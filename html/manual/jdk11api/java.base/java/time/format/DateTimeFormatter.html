<!doctype html>
<!-- NewPage -->
<html lang="en">
 <head> 
  <!-- Generated by javadoc --> 
  <title>DateTimeFormatter</title> 
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> 
  <meta name="keywords" content="java.time.format.DateTimeFormatter class"> 
  <meta name="keywords" content="ISO_LOCAL_DATE"> 
  <meta name="keywords" content="ISO_OFFSET_DATE"> 
  <meta name="keywords" content="ISO_DATE"> 
  <meta name="keywords" content="ISO_LOCAL_TIME"> 
  <meta name="keywords" content="ISO_OFFSET_TIME"> 
  <meta name="keywords" content="ISO_TIME"> 
  <meta name="keywords" content="ISO_LOCAL_DATE_TIME"> 
  <meta name="keywords" content="ISO_OFFSET_DATE_TIME"> 
  <meta name="keywords" content="ISO_ZONED_DATE_TIME"> 
  <meta name="keywords" content="ISO_DATE_TIME"> 
  <meta name="keywords" content="ISO_ORDINAL_DATE"> 
  <meta name="keywords" content="ISO_WEEK_DATE"> 
  <meta name="keywords" content="ISO_INSTANT"> 
  <meta name="keywords" content="BASIC_ISO_DATE"> 
  <meta name="keywords" content="RFC_1123_DATE_TIME"> 
  <meta name="keywords" content="ofPattern()"> 
  <meta name="keywords" content="ofLocalizedDate()"> 
  <meta name="keywords" content="ofLocalizedTime()"> 
  <meta name="keywords" content="ofLocalizedDateTime()"> 
  <meta name="keywords" content="parsedExcessDays()"> 
  <meta name="keywords" content="parsedLeapSecond()"> 
  <meta name="keywords" content="getLocale()"> 
  <meta name="keywords" content="withLocale()"> 
  <meta name="keywords" content="localizedBy()"> 
  <meta name="keywords" content="getDecimalStyle()"> 
  <meta name="keywords" content="withDecimalStyle()"> 
  <meta name="keywords" content="getChronology()"> 
  <meta name="keywords" content="withChronology()"> 
  <meta name="keywords" content="getZone()"> 
  <meta name="keywords" content="withZone()"> 
  <meta name="keywords" content="getResolverStyle()"> 
  <meta name="keywords" content="withResolverStyle()"> 
  <meta name="keywords" content="getResolverFields()"> 
  <meta name="keywords" content="withResolverFields()"> 
  <meta name="keywords" content="format()"> 
  <meta name="keywords" content="formatTo()"> 
  <meta name="keywords" content="parse()"> 
  <meta name="keywords" content="parseBest()"> 
  <meta name="keywords" content="parseUnresolved()"> 
  <meta name="keywords" content="toFormat()"> 
  <meta name="keywords" content="toString()"> 
  <link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style"> 
  <link rel="stylesheet" type="text/css" href="../../../../jquery/jquery-ui.css" title="Style"> 
  <script type="text/javascript" src="../../../../script.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jszip/dist/jszip.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script> 
  <!--[if IE]>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]--> 
  <script type="text/javascript" src="../../../../jquery/jquery-1.10.2.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jquery-migrate-1.2.1.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jquery-ui.js"></script> 
 </head> 
 <body> <SCRIPT LANGUAGE="JavaScript"><!-- Hide  
   function ResumeError() {     return true;}window.onerror = ResumeError;// --></SCRIPT>
  <script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="DateTimeFormatter (Java SE 11 & JDK 11 )";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":9,"i10":9,"i11":9,"i12":9,"i13":9,"i14":9,"i15":10,"i16":10,"i17":10,"i18":10,"i19":9,"i20":9,"i21":10,"i22":10,"i23":10,"i24":10,"i25":10,"i26":10,"i27":10,"i28":10,"i29":10,"i30":10,"i31":10};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script> 
  <noscript> 
   <div>
     JavaScript is disabled on your browser. 
   </div> 
  </noscript> 
  <header role="banner"> 
   <nav role="navigation"> 
    <div class="fixedNav"> 
     <!-- ========= START OF TOP NAVBAR ======= --> 
     <div class="topNav"> 
      <a id="navbar.top"> 
       <!--   --> </a> 
      <div class="skipNav"> 
       <a href="#skip.navbar.top" title="Skip navigation links">跳过导航</a> 
      </div> 
      <a id="navbar.top.firstrow"> 
       <!--   --> </a> 
      <ul class="navList" title="Navigation"> 
       <li><a href="../../../../index.html">概述</a></li> 
       <li><a href="../../../module-summary.html">模块</a></li> 
       <li><a href="package-summary.html">软件包</a></li> 
       <li class="navBarCell1Rev">类</li> 
       <li><a href="class-use/DateTimeFormatter.html">使用</a></li> 
       <li><a href="package-tree.html">树</a></li> 
       <li><a href="../../../../deprecated-list.html">已过时的</a></li> 
       <li><a href="../../../../index-files/index-1.html">索引</a></li> 
       <li><a href="../../../../help-doc.html">帮助</a></li> 
      </ul> 
      <div class="aboutLanguage"> 
       <div style="margin-top: 14px;"> 
        <strong>Java SE 11 &amp; JDK 11</strong> 
       </div> 
      </div> 
     </div> 
     <div class="subNav"> 
      <ul class="navList" id="allclasses_navbar_top"> 
       <li><a href="../../../../allclasses.html">所有类</a></li> 
      </ul> 
      <ul class="navListSearch"> 
       <li><label for="search">SEARCH:</label> <input type="text" id="search" value="search" disabled> <input type="reset" id="reset" value="reset" disabled> </li> 
      </ul> 
      <div> 
       <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
       <noscript> 
        <div>
          JavaScript is disabled on your browser. 
        </div> 
       </noscript> 
      </div> 
       <div class="fixedNav">
       <ul class="subNavList"> 
        <li>概要：&nbsp;</li> 
        <li>嵌套&nbsp;|&nbsp;</li> 
        <li><a href="#field.summary">字段</a>&nbsp;|&nbsp;</li> 
        <li>构造方法&nbsp;|&nbsp;</li> 
        <li><a href="#method.summary">方法</a></li> 
       </ul> 
       <ul class="subNavList"> 
        <li>详细信息：&nbsp;</li> 
        <li><a href="#field.detail">字段</a>&nbsp;|&nbsp;</li> 
        <li>构造方法&nbsp;|&nbsp;</li> 
        <li><a href="#method.detail">方法</a></li> 
       </ul> 
      </div> 
      <a id="skip.navbar.top"> 
       <!--   --> </a> 
     </div> 
     <!-- ========= END OF TOP NAVBAR ========= --> 
    </div> 
    <div class="navPadding">
      &nbsp; 
    </div> 
    <script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script> 
   </nav> 
  </header> 
  <!-- ======== START OF CLASS DATA ======== --> 
  <main role="main"> 
   <div class="header"> 
    <div class="subTitle"> 
     <span class="moduleLabelInType">模块</span>&nbsp; 
     <a href="../../../module-summary.html">java.base</a> 
    </div> 
    <div class="subTitle"> 
     <span class="packageLabelInType">软件包</span>&nbsp; 
     <a href="package-summary.html">java.time.format</a> 
    </div> 
    <h2 title="Class DateTimeFormatter" class="title">Class DateTimeFormatter</h2> 
   </div> 
   <div class="contentContainer"> 
    <ul class="inheritance"> 
     <li><a href="../../lang/Object.html" title="class in java.lang">java.lang.Object</a></li> 
     <li> 
      <ul class="inheritance"> 
       <li>java.time.format.DateTimeFormatter</li> 
      </ul> </li> 
    </ul> 
    <div class="description"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <hr> <pre>public final class <span class="typeNameLabel">DateTimeFormatter</span>
extends <a href="../../lang/Object.html" title="class in java.lang">Object</a></pre> 
       <div class="block"> 
        <span>用于打印和解析日期时间对象的格式化程序。</span> 
        <p> <span>此类提供打印和解析的主要应用程序入口点，并提供<code>DateTimeFormatter</code>常见实现：</span> </p> 
        <ul> 
         <li> <span>使用预定义常量，例如<a href="#ISO_LOCAL_DATE"><code>ISO_LOCAL_DATE</code></a></span> </li> 
         <li> <span>使用模式字母，例如<code>uuuu-MMM-dd</code></span> </li> 
         <li> <span>使用本地化样式，例如<code>long</code>或<code>medium</code></span> </li> 
        </ul> 
        <p> <span>更复杂的格式化器由<a href="DateTimeFormatterBuilder.html" title="java.time.format中的类"><code>DateTimeFormatterBuilder</code></a>提供。</span> </p> 
        <p> <span>主日期时间类提供两种方法 - 一种用于格式化， <code>format(DateTimeFormatter formatter)</code> ，一种用于解析， <code>parse(CharSequence text, DateTimeFormatter formatter)</code> 。</span> </p> 
        <p> <span>例如：</span> </p> 
        <blockquote> 
         <span><pre>
  LocalDate date = LocalDate.now();
  String text = date.format(formatter);
  LocalDate parsedDate = LocalDate.parse(text, formatter);
 </pre></span> 
        </blockquote> 
        <p> <span>除格式外，还可以使用所需的Locale，Chronology，ZoneId和DecimalStyle创建格式化程序。</span> </p> 
        <p> <span><a href="#withLocale(java.util.Locale)"><code>withLocale</code></a>方法返回一个覆盖语言环境的新格式化程序。</span> <span>语言环境影响格式化和解析的某些方面。</span> <span>例如， <a href="#ofLocalizedDate(java.time.format.FormatStyle)"><code>ofLocalizedDate</code></a>提供了使用特定于语言环境的日期格式的格式化程序。</span> </p> 
        <p> <span><a href="#withChronology(java.time.chrono.Chronology)"><code>withChronology</code></a>方法返回一个覆盖年表的新格式化程序。</span> <span>如果被覆盖，则在格式化之前将日期时间值转换为年表。</span> <span>在解析期间，日期时间值将在返回之前转换为年表。</span> </p> 
        <p> <span><a href="#withZone(java.time.ZoneId)"><code>withZone</code></a>方法返回一个覆盖该区域的新格式化程序。</span> <span>如果被覆盖，则在格式化之前将日期时间值转换为带有请求的ZoneId的ZonedDateTime。</span> <span>在解析期间，在返回值之前应用ZoneId。</span> </p> 
        <p> <span><a href="#withDecimalStyle(java.time.format.DecimalStyle)"><code>withDecimalStyle</code></a>方法返回一个覆盖<a href="DecimalStyle.html" title="java.time.format中的类"><code>DecimalStyle</code></a>的新格式化程序。</span> <span>DecimalStyle符号用于格式化和解析。</span> </p> 
        <p> <span>某些应用程序可能需要使用较旧的<a href="../../text/Format.html" title="java.text中的类"><code>java.text.Format</code></a>类进行格式化。</span> <span>该<a href="#toFormat()"><code>toFormat()</code></a>方法返回的实现<code>java.text.Format</code> 。</span> </p> 
        <h3 id="predefined"> <span>预定义的格式化程序</span> </h3> 
        <span> Predefined Formatters    Formatter Description Example     <a href="#ofLocalizedDate(java.time.format.FormatStyle)"><code>ofLocalizedDate(dateStyle)</code></a>   Formatter with date style from the locale   '2011-12-03'    <a href="#ofLocalizedTime(java.time.format.FormatStyle)"><code>ofLocalizedTime(timeStyle)</code></a>   Formatter with time style from the locale   '10:15:30'    <a href="#ofLocalizedDateTime(java.time.format.FormatStyle)"><code>ofLocalizedDateTime(dateTimeStyle)</code></a>   Formatter with a style for date and time from the locale  '3 Jun 2008 11:05:30'    <a href="#ofLocalizedDateTime(java.time.format.FormatStyle)"><code>ofLocalizedDateTime(dateStyle,timeStyle)</code></a>   Formatter with date and time styles from the locale   '3 Jun 2008 11:05'    <a href="#BASIC_ISO_DATE"><code>BASIC_ISO_DATE</code></a> Basic ISO date  '20111203'    <a href="#ISO_LOCAL_DATE"><code>ISO_LOCAL_DATE</code></a>  ISO Local Date  '2011-12-03'    <a href="#ISO_OFFSET_DATE"><code>ISO_OFFSET_DATE</code></a>  ISO Date with offset  '2011-12-03+01:00'    <a href="#ISO_DATE"><code>ISO_DATE</code></a>  ISO Date with or without offset   '2011-12-03+01:00'; '2011-12-03'    <a href="#ISO_LOCAL_TIME"><code>ISO_LOCAL_TIME</code></a>  Time without offset  '10:15:30'    <a href="#ISO_OFFSET_TIME"><code>ISO_OFFSET_TIME</code></a>  Time with offset  '10:15:30+01:00'    <a href="#ISO_TIME"><code>ISO_TIME</code></a>  Time with or without offset  '10:15:30+01:00'; '10:15:30'    <a href="#ISO_LOCAL_DATE_TIME"><code>ISO_LOCAL_DATE_TIME</code></a>  ISO Local Date and Time  '2011-12-03T10:15:30'    <a href="#ISO_OFFSET_DATE_TIME"><code>ISO_OFFSET_DATE_TIME</code></a>  Date Time with Offset  '2011-12-03T10:15:30+01:00'    <a href="#ISO_ZONED_DATE_TIME"><code>ISO_ZONED_DATE_TIME</code></a>  Zoned Date Time  '2011-12-03T10:15:30+01:00[Europe/Paris]'    <a href="#ISO_DATE_TIME"><code>ISO_DATE_TIME</code></a>  Date and time with ZoneId  '2011-12-03T10:15:30+01:00[Europe/Paris]'    <a href="#ISO_ORDINAL_DATE"><code>ISO_ORDINAL_DATE</code></a>  Year and day of year  '2012-337'    <a href="#ISO_WEEK_DATE"><code>ISO_WEEK_DATE</code></a>  Year and Week  '2012-W48-6'    <a href="#ISO_INSTANT"><code>ISO_INSTANT</code></a>  Date and Time of an Instant  '2011-12-03T10:15:30Z'     <a href="#RFC_1123_DATE_TIME"><code>RFC_1123_DATE_TIME</code></a>  RFC 1123 / RFC 822  'Tue, 3 Jun 2008 11:05:30 GMT'  </span> 
        <table class="striped" style="text-align:left"> 
        </table> 
        <h3 id="patterns"> <span>格式化和解析的模式</span> </h3> 
        <span>模式基于简单的字母和符号序列。</span> 
        <span>模式用于使用<a href="#ofPattern(java.lang.String)"><code>ofPattern(String)</code></a>和<a href="#ofPattern(java.lang.String,java.util.Locale)"><code>ofPattern(String, Locale)</code></a>方法创建Formatter。</span> 
        <span>例如， <code>"d MMM uuuu"</code>将2011-12-03格式化为“2011年12月3日”。</span> 
        <span>从模式创建的格式化程序可以根据需要多次使用，它是不可变的并且是线程安全的。</span> 
        <p> <span>例如：</span> </p> 
        <blockquote> 
         <span><pre>
  LocalDate date = LocalDate.now();
  DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy MM dd");
  String text = date.format(formatter);
  LocalDate parsedDate = LocalDate.parse(text, formatter);
 </pre></span> 
        </blockquote> 
        <p> <span>所有字母'A'到'Z'和'a'到'z'都保留为模式字母。</span> <span>定义了以下模式字母：</span> </p> 
        <span> Pattern Letters and Symbols    Symbol Meaning Presentation Examples     G era text AD; Anno Domini; A   u year year 2004; 04   y year-of-era year 2004; 04   D day-of-year number 189   M/L month-of-year number/text 7; 07; Jul; July; J   d day-of-month number 10   g modified-julian-day number 2451334   Q/q quarter-of-year number/text 3; 03; Q3; 3rd quarter   Y week-based-year year 1996; 96   w week-of-week-based-year number 27   W week-of-month number 4   E day-of-week text Tue; Tuesday; T   e/c localized day-of-week number/text 2; 02; Tue; Tuesday; T   F day-of-week-in-month number 3   a am-pm-of-day text PM   h clock-hour-of-am-pm (1-12) number 12   K hour-of-am-pm (0-11) number 0   k clock-hour-of-day (1-24) number 24   H hour-of-day (0-23) number 0   m minute-of-hour number 30   s second-of-minute number 55   S fraction-of-second fraction 978   A milli-of-day number 1234   n nano-of-second number 987654321   N nano-of-day number 1234000000   V time-zone ID zone-id America/Los_Angeles; Z; -08:30   v generic time-zone name zone-name Pacific Time; PT   z time-zone name zone-name Pacific Standard Time; PST   O localized zone-offset offset-O GMT+8; GMT+08:00; UTC-08:00   X zone-offset 'Z' for zero offset-X Z; -08; -0830; -08:30; -083015; -08:30:15   x zone-offset offset-x +0000; -08; -0830; -08:30; -083015; -08:30:15   Z zone-offset offset-Z +0000; -0800; -08:00   p pad next pad modifier 1   ' escape for text delimiter    '' single quote literal '   [ optional section start     ] optional section end     # reserved for future use     { reserved for future use     } reserved for future use    </span> 
        <table class="striped"> 
        </table> 
        <p> <span>模式字母的数量决定了格式。</span> </p> 
        <p> <span><b>文本</b> ：文本样式根据使用的模式字母数确定。</span> <span>少于4个模式字母将使用<a href="TextStyle.html#SHORT"><code>short form</code></a> 。</span> <span>正好4个模式字母将使用<a href="TextStyle.html#FULL"><code>full form</code></a> 。</span> <span>正好5个模式字母将使用<a href="TextStyle.html#NARROW"><code>narrow form</code></a> 。</span> <span>模式字母'L'，'c'和'q'指定文本样式的独立形式。</span> </p> 
        <p> <span><b>Number</b> ：如果字母数为1，则使用最小位数输出该值，不进行填充。</span> <span>否则，将使用位数作为输出字段的宽度，并根据需要将值填充为零。</span> <span>以下模式字母对字母数量有约束。</span> <span>只能指定一个'c'和'F'字母。</span> <span>最多可以指定两个字母“d”，“H”，“h”，“K”，“k”，“m”和“s”。</span> <span>最多可以指定三个字母'D'。</span> </p> 
        <p> <span><b>数字/文本</b> ：如果模式字母的数量为3或更大，请使用上面的文本规则。</span> <span>否则使用上面的数字规则。</span> </p> 
        <p> <span><b>分数</b> ：以秒为单位输出纳秒级字段。</span> <span>纳秒值具有九位数，因此模式字母的数量从1到9.如果小于9，则截断纳秒值，仅输出最高有效数字。</span> </p> 
        <p> <span><b>年份</b> ：字母数决定了使用填充的最小字段宽度。</span> <span>如果字母数为2，则使用<a href="DateTimeFormatterBuilder.html#appendValueReduced(java.time.temporal.TemporalField,int,int,int)"><code>reduced</code></a>两位数形式。</span> <span>对于打印，这将输出最右边的两位数字。</span> <span>对于解析，这将使用2000的基值进行解析，从而产生2000到2099（包括2000和2099）范围内的一年。</span> <span>如果字母数小于4（但不是2），则符号仅按负<a href="SignStyle.html#NORMAL"><code>SignStyle.NORMAL</code></a>输出。</span> <span>否则，如果超过焊盘宽度，则输出符号，如<a href="SignStyle.html#EXCEEDS_PAD"><code>SignStyle.EXCEEDS_PAD</code>所示</a> 。</span> </p> 
        <p> <span><b>ZoneId</b> ：输出时区ID，例如“Europe / Paris”。</span> <span>如果字母数为2，则输出时区ID。</span> <span>任何其他计数的字母抛出<code>IllegalArgumentException</code> 。</span> </p> 
        <p> <span><b>区域名称</b> ：输出时区ID的显示名称。</span> <span>如果模式字母为“z”，则输出为夏令时感知区域名称。</span> <span>如果没有足够的信息来确定是否适用DST，则将使用忽略夏令时的名称。</span> <span>如果字母数为一，二或三，则输出短名称。</span> <span>如果字母数为4，则输出全名。</span> <span>五个或更多的字母抛出<code>IllegalArgumentException</code> 。</span> </p> 
        <p> <span>如果模式字母为“v”，则输出提供区域名称，忽略夏令时。</span> <span>如果字母数为1，则输出短名称。</span> <span>如果字母数为4，则输出全名。</span> <span>两个，三个和五个或更多的字母抛出<code>IllegalArgumentException</code> 。</span> </p> 
        <p> <span><b>偏移X和x</b> ：根据模式字母的数量格式化偏移。</span> <span>一个字母仅输出小时，例如'+01'，除非分钟非零，在这种情况下分钟也输出，例如'+0130'。</span> <span>两个字母输出小时和分钟，没有冒号，例如'+0130'。</span> <span>三个字母输出小时和分钟，带有冒号，例如'+01：30'。</span> <span>四个字母输出小时和分钟以及可选秒，没有冒号，例如'+013015'。</span> <span>五个字母输出小时和分钟，可选秒输出冒号，例如'+01：30：15'。</span> <span>六个或更多的字母抛出<code>IllegalArgumentException</code> 。</span> <span>当要输出的偏移量为零时，模式字母“X”（大写）将输出“Z”，而模式字母“x”（小写）将输出“+00”，“+ 0000”或“+00” ：00' 。</span> </p> 
        <p> <span><b>偏移O</b> ：根据模式字母的数量格式化局部偏移。</span> <span>一个字母输出<a href="TextStyle.html#SHORT">short</a>形式的局部偏移，它是局部偏移文本，例如'GMT'，小时不带前导零，可选2位数分钟，第二个非零，和冒号，例如'GMT + 8 ”。</span> <span>四个字母输出<a href="TextStyle.html#FULL">full</a>表格，它是本地化的偏移文本，例如'GMT，具有2位小时和分钟字段，可选的第二字段（如果非零）和冒号，例如'GMT + 08:00'。</span> <span>任何其他计数的字母抛出<code>IllegalArgumentException</code> 。</span> </p> 
        <p> <span><b>偏移Z</b> ：根据模式字母的数量格式化偏移。</span> <span>一个，两个或三个字母输出小时和分钟，没有冒号，例如'+0130'。</span> <span>当偏移量为零时，输出将为“+0000”。</span> <span>四个字母输出<a href="TextStyle.html#FULL">full</a>形式的局部偏移，相当于Offset-O的四个字母。</span> <span>如果偏移为零，则输出将是相应的本地化偏移文本。</span> <span>五个字母输出小时，分钟，可选第二个，如果非零，则使用冒号。</span> <span>如果偏移量为零，则输出“Z”。</span> <span>六个或更多的字母抛出<code>IllegalArgumentException</code> 。</span> </p> 
        <p> <span><b>可选部分</b> ：可选部分标记的工作方式与调用<a href="DateTimeFormatterBuilder.html#optionalStart()"><code>DateTimeFormatterBuilder.optionalStart()</code></a>和<a href="DateTimeFormatterBuilder.html#optionalEnd()"><code>DateTimeFormatterBuilder.optionalEnd()</code>完全相同</a> 。</span> </p> 
        <p> <span><b>填充修饰符</b> ：修改紧跟其后用空格填充的模式。</span> <span>垫宽度由图案字母的数量决定。</span> <span>这与致电<a href="DateTimeFormatterBuilder.html#padNext(int)"><code>DateTimeFormatterBuilder.padNext(int)</code></a>相同。</span> </p> 
        <p> <span>例如，'ppH'输出左边填充的小时，空格宽度为2。</span> </p> 
        <p> <span>任何无法识别的字母都是错误的。</span> <span>任何非字母字符，除了'['，']'，'{'，'}'，'＃'和单引号都将直接输出。</span> <span>尽管如此，建议在要直接输出的所有字符周围使用单引号，以确保将来的更改不会破坏您的应用程序。</span> </p> 
        <h3 id="resolving"> <span>解决</span> </h3> 
        <span>解析实现为两阶段操作。</span> 
        <span>首先，使用格式化程序定义的布局解析文本，生成<code>Map</code>字段值， <code>ZoneId</code>和<code>Chronology</code> 。</span> 
        <span>其次，分析的数据<em>解析</em> ，通过验证，合并和简化了各领域到更多有用的。</span> 
        <p> <span>这个类提供了五种解析方法。</span> <span>其中四个执行解析和解析阶段。</span> <span>第五种方法<a href="#parseUnresolved(java.lang.CharSequence,java.text.ParsePosition)"><code>parseUnresolved(CharSequence, ParsePosition)</code></a>仅执行第一阶段，结果未解析。</span> <span>因此，它本质上是一种低级操作。</span> </p> 
        <p> <span>解析阶段由在此类上设置的两个参数控制。</span> </p> 
        <p> <span><a href="ResolverStyle.html" title="java.time.format中的枚举"><code>ResolverStyle</code></a>是一个枚举，提供三种不同的方法，严格，智能和宽松。</span> <span>智能选项是默认选项。</span> <span>可以使用<a href="#withResolverStyle(java.time.format.ResolverStyle)"><code>withResolverStyle(ResolverStyle)</code></a>进行设置。</span> </p> 
        <p> <span><a href="#withResolverFields(java.time.temporal.TemporalField...)"><code>withResolverFields(TemporalField...)</code></a>参数允许在解析启动之前过滤要解析的字段集。</span> <span>例如，如果格式化程序已经解析了年，月，日，年和日，则有两种方法可以解决日期:(年+月+日）和（年+天的年）。</span> <span>解析器字段允许选择两种方法中的一种。</span> <span>如果未设置解析器字段，则两种方法必须生成相同的日期。</span> </p> 
        <p> <span>解析单独的字段以形成完整的日期和时间是一个复杂的过程，其行为分布在许多类中。</span> <span>它遵循以下步骤：</span> </p> 
        <ol> 
         <li> <span>年表确定。</span> <span>结果的年表是要解析的年表，或者如果没有解析年表，则是在此类上设置的年表，或者如果为空，则为<code>IsoChronology</code> 。</span> </li> 
         <li> <span><code>ChronoField</code>日期字段已解决。</span> <span>这是使用<a href="../chrono/Chronology.html#resolveDate(java.util.Map,java.time.format.ResolverStyle)"><code>Chronology.resolveDate(Map, ResolverStyle)</code></a>实现的。</span> <span>有关字段解析的文档位于<code>Chronology</code>的实现中。</span> </li> 
         <li> <span><code>ChronoField</code>时间字段已解决。</span> <span>这记录在<a href="../temporal/ChronoField.html" title="java.time.temporal中的枚举"><code>ChronoField</code>上，</a>并且对于所有年表都是相同的。</span> </li> 
         <li> <span>处理不是<code>ChronoField</code>任何字段。</span> <span>这是使用<a href="../temporal/TemporalField.html#resolve(java.util.Map,java.time.temporal.TemporalAccessor,java.time.format.ResolverStyle)"><code>TemporalField.resolve(Map, TemporalAccessor, ResolverStyle)</code></a>实现的。</span> <span>有关字段解析的文档位于<code>TemporalField</code>的实现中。</span> </li> 
         <li> <span>将重新解析<code>ChronoField</code>日期和时间字段。</span> <span>这允许第四步中的字段生成<code>ChronoField</code>值，并将它们处理为日期和时间。</span> </li> 
         <li> <span>如果至少有一个小时的可用时间，则形成<code>LocalTime</code> 。</span> <span>这涉及提供分钟，秒和小数秒的默认值。</span> </li> 
         <li> <span>任何剩余的未解析字段将根据已解决的任何日期和/或时间进行交叉检查。</span> <span>因此，较早阶段将解决（年+月+日）到某个日期，此阶段将检查该星期几对该日期是否有效。</span> </li> 
         <li> <span>如果解析了<a href="#parsedExcessDays()">excess number of days</a> ，则在日期可用时将其添加到日期。</span> </li> 
         <li> <span>如果存在基于秒的字段，但未解析<code>LocalTime</code> ，则解析器确保可以使用毫秒，微秒和纳秒值来满足<a href="../temporal/ChronoField.html" title="java.time.temporal中的枚举"><code>ChronoField</code></a>的合同。</span> <span>如果遗漏，这些将被设置为零。</span> </li> 
         <li> <span>如果同时解析了日期和时间并且存在偏移或区域，则会创建字段<a href="../temporal/ChronoField.html#INSTANT_SECONDS"><code>ChronoField.INSTANT_SECONDS</code></a> 。</span> <span>如果解析了偏移量，则偏移量将与<code>LocalDateTime</code>组合以形成瞬间，忽略任何区域。</span> <span>如果<code>ZoneId</code>在没有偏移，则区分析将与合并<code>LocalDateTime</code>形成使用规则的即时<a href="../chrono/ChronoLocalDateTime.html#atZone(java.time.ZoneId)"><code>ChronoLocalDateTime.atZone(ZoneId)</code></a> 。</span> </li> 
        </ol> 
       </div> 
       <dl> 
        <dt> 
         <span class="simpleTagLabel">实现要求：</span> 
        </dt> 
        <dd>
          这个类是不可变的和线程安全的。 
        </dd> 
        <dt> 
         <span class="simpleTagLabel">从以下版本开始：</span> 
        </dt> 
        <dd>
          1.8 
        </dd> 
       </dl> </li> 
     </ul> 
    </div> 
    <div class="summary"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <!-- =========== FIELD SUMMARY =========== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="field.summary"> 
           <!--   --> </a> <h3>字段汇总</h3> 
          <table class="memberSummary"> 
           <caption> 
            <span>字段</span> 
            <span class="tabEnd">&nbsp;</span> 
           </caption> 
           <tbody> 
            <tr> 
             <th class="colFirst" scope="col">变量和类型</th> 
             <th class="colSecond" scope="col">字段</th> 
             <th class="colLast" scope="col">描述</th> 
            </tr> 
            <tr class="altColor"> 
             <td class="colFirst"><code>static <a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#BASIC_ISO_DATE">BASIC_ISO_DATE</a></span></code></th> 
             <td class="colLast"> 
              <div class="block">
                ISO日期格式化程序，用于格式化或解析没有偏移的日期，例如“20111203”。 
              </div> </td> 
            </tr> 
            <tr class="rowColor"> 
             <td class="colFirst"><code>static <a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ISO_DATE">ISO_DATE</a></span></code></th> 
             <td class="colLast"> 
              <div class="block">
                ISO日期格式化程序，使用偏移量格式化或解析日期（如“2011-12-03”或“2011-12-03 + 01:00”）。 
              </div> </td> 
            </tr> 
            <tr class="altColor"> 
             <td class="colFirst"><code>static <a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ISO_DATE_TIME">ISO_DATE_TIME</a></span></code></th> 
             <td class="colLast"> 
              <div class="block">
                类似ISO的日期时格式化程序，使用偏移量和区域（如果可用）格式化或解析日期时间，例如“2011-12-03T10：15：30”，“2011-12-03T10：15：30 + 01 ：00'或'2011-12-03T10：15：30 + 01:00 [欧洲/巴黎]'。 
              </div> </td> 
            </tr> 
            <tr class="rowColor"> 
             <td class="colFirst"><code>static <a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ISO_INSTANT">ISO_INSTANT</a></span></code></th> 
             <td class="colLast"> 
              <div class="block">
                ISO即时格式化程序，用于格式化或解析UTC中的瞬间，例如“2011-12-03T10：15：30Z”。 
              </div> </td> 
            </tr> 
            <tr class="altColor"> 
             <td class="colFirst"><code>static <a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ISO_LOCAL_DATE">ISO_LOCAL_DATE</a></span></code></th> 
             <td class="colLast"> 
              <div class="block">
                ISO日期格式化程序，用于格式化或解析没有偏移的日期，例如“2011-12-03”。 
              </div> </td> 
            </tr> 
            <tr class="rowColor"> 
             <td class="colFirst"><code>static <a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ISO_LOCAL_DATE_TIME">ISO_LOCAL_DATE_TIME</a></span></code></th> 
             <td class="colLast"> 
              <div class="block">
                ISO日期时格式化程序，用于格式化或解析没有偏移的日期时间，例如“2011-12-03T10：15：30”。 
              </div> </td> 
            </tr> 
            <tr class="altColor"> 
             <td class="colFirst"><code>static <a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ISO_LOCAL_TIME">ISO_LOCAL_TIME</a></span></code></th> 
             <td class="colLast"> 
              <div class="block">
                ISO时间格式化程序，用于格式化或解析没有偏移的时间，例如“10:15”或“10:15:30”。 
              </div> </td> 
            </tr> 
            <tr class="rowColor"> 
             <td class="colFirst"><code>static <a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ISO_OFFSET_DATE">ISO_OFFSET_DATE</a></span></code></th> 
             <td class="colLast"> 
              <div class="block">
                ISO日期格式化程序，用于格式化或解析具有偏移量的日期，例如“2011-12-03 + 01:00”。 
              </div> </td> 
            </tr> 
            <tr class="altColor"> 
             <td class="colFirst"><code>static <a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ISO_OFFSET_DATE_TIME">ISO_OFFSET_DATE_TIME</a></span></code></th> 
             <td class="colLast"> 
              <div class="block">
                ISO日期时格格式器，用于格式化或解析具有偏移的日期时间，例如“2011-12-03T10：15：30 + 01:00”。 
              </div> </td> 
            </tr> 
            <tr class="rowColor"> 
             <td class="colFirst"><code>static <a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ISO_OFFSET_TIME">ISO_OFFSET_TIME</a></span></code></th> 
             <td class="colLast"> 
              <div class="block">
                ISO时间格式化程序，使用偏移格式化或解析时间，例如'10：15 + 01:00'或'10：15：30 + 01:00'。 
              </div> </td> 
            </tr> 
            <tr class="altColor"> 
             <td class="colFirst"><code>static <a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ISO_ORDINAL_DATE">ISO_ORDINAL_DATE</a></span></code></th> 
             <td class="colLast"> 
              <div class="block">
                ISO日期格式化程序，用于格式化或解析没有偏移的序数日期，例如“2012-337”。 
              </div> </td> 
            </tr> 
            <tr class="rowColor"> 
             <td class="colFirst"><code>static <a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ISO_TIME">ISO_TIME</a></span></code></th> 
             <td class="colLast"> 
              <div class="block">
                ISO时间格式化程序，用于格式化或解析时间，如果可用，则为偏移量，例如“10:15”，“10：15：30”或“10:15:30 + 01:00”。 
              </div> </td> 
            </tr> 
            <tr class="altColor"> 
             <td class="colFirst"><code>static <a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ISO_WEEK_DATE">ISO_WEEK_DATE</a></span></code></th> 
             <td class="colLast"> 
              <div class="block">
                ISO日期格式化程序，用于格式化或解析没有偏移的基于周的日期，例如“2012-W48-6”。 
              </div> </td> 
            </tr> 
            <tr class="rowColor"> 
             <td class="colFirst"><code>static <a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ISO_ZONED_DATE_TIME">ISO_ZONED_DATE_TIME</a></span></code></th> 
             <td class="colLast"> 
              <div class="block">
                类似ISO的日期时格格式器，用于格式化或解析具有偏移和区域的日期时间，例如“2011-12-03T10：15：30 + 01:00 [欧洲/巴黎]”。 
              </div> </td> 
            </tr> 
            <tr class="altColor"> 
             <td class="colFirst"><code>static <a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#RFC_1123_DATE_TIME">RFC_1123_DATE_TIME</a></span></code></th> 
             <td class="colLast"> 
              <div class="block">
                RFC-1123日期时间格式化程序，例如'Tue，2008年6月3日11:05:30 GMT'。 
              </div> </td> 
            </tr> 
           </tbody> 
          </table> </li> 
        </ul> 
       </section> 
       <!-- ========== METHOD SUMMARY =========== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="method.summary"> 
           <!--   --> </a> <h3>方法摘要</h3> 
          <table class="memberSummary"> 
           <caption> 
           <span id="t0" class="activeTableTab"><span>所有方法</span><span class="tabEnd">&nbsp;</span>
            <span id="t1" class="tableTab"><span><a href="javascript:show(1);">静态方法</a></span><span class="tabEnd">&nbsp;</span></span> 
             <span id="t2" class="tableTab"><span><a href="javascript:show(2);">实例方法</a>  </span></span> 
            <span id="t4" class="tableTab"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd">&nbsp;</span></span> 
           </caption> 
           <tbody> 
            <tr> 
             <th class="colFirst" scope="col">变量和类型</th> 
             <th class="colSecond" scope="col">方法</th> 
             <th class="colLast" scope="col">描述</th> 
            </tr> 
            <tr id="i0" class="altColor"> 
             <td class="colFirst"><code><a href="../../lang/String.html" title="class in java.lang">String</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#format(java.time.temporal.TemporalAccessor)">format</a></span>​(<a href="../temporal/TemporalAccessor.html" title="interface in java.time.temporal">TemporalAccessor</a>&nbsp;temporal)</code></th> 
             <td class="colLast"> 
              <div class="block">
                使用此格式化程序格式化日期时间对象。 
              </div> </td> 
            </tr> 
            <tr id="i1" class="rowColor"> 
             <td class="colFirst"><code>void</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#formatTo(java.time.temporal.TemporalAccessor,java.lang.Appendable)">formatTo</a></span>​(<a href="../temporal/TemporalAccessor.html" title="interface in java.time.temporal">TemporalAccessor</a>&nbsp;temporal, <a href="../../lang/Appendable.html" title="interface in java.lang">Appendable</a>&nbsp;appendable)</code></th> 
             <td class="colLast"> 
              <div class="block">
                使用此格式化程序将日期时间对象格式化为 
               <code>Appendable</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i2" class="altColor"> 
             <td class="colFirst"><code><a href="../chrono/Chronology.html" title="interface in java.time.chrono">Chronology</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getChronology()">getChronology</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                获取格式化期间要使用的重写年代表。 
              </div> </td> 
            </tr> 
            <tr id="i3" class="rowColor"> 
             <td class="colFirst"><code><a href="DecimalStyle.html" title="class in java.time.format">DecimalStyle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getDecimalStyle()">getDecimalStyle</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                获取格式化期间要使用的DecimalStyle。 
              </div> </td> 
            </tr> 
            <tr id="i4" class="altColor"> 
             <td class="colFirst"><code><a href="../../util/Locale.html" title="class in java.util">Locale</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getLocale()">getLocale</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                获取格式化期间要使用的语言环境。 
              </div> </td> 
            </tr> 
            <tr id="i5" class="rowColor"> 
             <td class="colFirst"><code><a href="../../util/Set.html" title="interface in java.util">Set</a>&lt;<a href="../temporal/TemporalField.html" title="interface in java.time.temporal">TemporalField</a>&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getResolverFields()">getResolverFields</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                获取解析期间要使用的解析器字段。 
              </div> </td> 
            </tr> 
            <tr id="i6" class="altColor"> 
             <td class="colFirst"><code><a href="ResolverStyle.html" title="enum in java.time.format">ResolverStyle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getResolverStyle()">getResolverStyle</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                获取解析期间要使用的解析器样式。 
              </div> </td> 
            </tr> 
            <tr id="i7" class="rowColor"> 
             <td class="colFirst"><code><a href="../ZoneId.html" title="class in java.time">ZoneId</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getZone()">getZone</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                获取格式化期间要使用的覆盖区域。 
              </div> </td> 
            </tr> 
            <tr id="i8" class="altColor"> 
             <td class="colFirst"><code><a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#localizedBy(java.util.Locale)">localizedBy</a></span>​(<a href="../../util/Locale.html" title="class in java.util">Locale</a>&nbsp;locale)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回此格式化程序的副本，其中包含区域设置，日历，区域，小数样式和/或时区的本地化值，它们取代此格式化程序中的值。 
              </div> </td> 
            </tr> 
            <tr id="i9" class="rowColor"> 
             <td class="colFirst"><code>static <a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ofLocalizedDate(java.time.format.FormatStyle)">ofLocalizedDate</a></span>​(<a href="FormatStyle.html" title="enum in java.time.format">FormatStyle</a>&nbsp;dateStyle)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回ISO年表的特定于语言环境的日期格式。 
              </div> </td> 
            </tr> 
            <tr id="i10" class="altColor"> 
             <td class="colFirst"><code>static <a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ofLocalizedDateTime(java.time.format.FormatStyle)">ofLocalizedDateTime</a></span>​(<a href="FormatStyle.html" title="enum in java.time.format">FormatStyle</a>&nbsp;dateTimeStyle)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回ISO年表的特定于语言环境的日期时间格式化程序。 
              </div> </td> 
            </tr> 
            <tr id="i11" class="rowColor"> 
             <td class="colFirst"><code>static <a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ofLocalizedDateTime(java.time.format.FormatStyle,java.time.format.FormatStyle)">ofLocalizedDateTime</a></span>​(<a href="FormatStyle.html" title="enum in java.time.format">FormatStyle</a>&nbsp;dateStyle, <a href="FormatStyle.html" title="enum in java.time.format">FormatStyle</a>&nbsp;timeStyle)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回ISO年表的特定于语言环境的日期和时间格式。 
              </div> </td> 
            </tr> 
            <tr id="i12" class="altColor"> 
             <td class="colFirst"><code>static <a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ofLocalizedTime(java.time.format.FormatStyle)">ofLocalizedTime</a></span>​(<a href="FormatStyle.html" title="enum in java.time.format">FormatStyle</a>&nbsp;timeStyle)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回ISO年表的特定于语言环境的时间格式。 
              </div> </td> 
            </tr> 
            <tr id="i13" class="rowColor"> 
             <td class="colFirst"><code>static <a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ofPattern(java.lang.String)">ofPattern</a></span>​(<a href="../../lang/String.html" title="class in java.lang">String</a>&nbsp;pattern)</code></th> 
             <td class="colLast"> 
              <div class="block">
                使用指定的模式创建格式化程序。 
              </div> </td> 
            </tr> 
            <tr id="i14" class="altColor"> 
             <td class="colFirst"><code>static <a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ofPattern(java.lang.String,java.util.Locale)">ofPattern</a></span>​(<a href="../../lang/String.html" title="class in java.lang">String</a>&nbsp;pattern, <a href="../../util/Locale.html" title="class in java.util">Locale</a>&nbsp;locale)</code></th> 
             <td class="colLast"> 
              <div class="block">
                使用指定的模式和语言环境创建格式化程序。 
              </div> </td> 
            </tr> 
            <tr id="i15" class="rowColor"> 
             <td class="colFirst"><code><a href="../temporal/TemporalAccessor.html" title="interface in java.time.temporal">TemporalAccessor</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#parse(java.lang.CharSequence)">parse</a></span>​(<a href="../../lang/CharSequence.html" title="interface in java.lang">CharSequence</a>&nbsp;text)</code></th> 
             <td class="colLast"> 
              <div class="block">
                完全解析生成临时对象的文本。 
              </div> </td> 
            </tr> 
            <tr id="i16" class="altColor"> 
             <td class="colFirst"><code><a href="../temporal/TemporalAccessor.html" title="interface in java.time.temporal">TemporalAccessor</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#parse(java.lang.CharSequence,java.text.ParsePosition)">parse</a></span>​(<a href="../../lang/CharSequence.html" title="interface in java.lang">CharSequence</a>&nbsp;text, <a href="../../text/ParsePosition.html" title="class in java.text">ParsePosition</a>&nbsp;position)</code></th> 
             <td class="colLast"> 
              <div class="block">
                使用此格式化程序解析文本，提供对文本位置的控制。 
              </div> </td> 
            </tr> 
            <tr id="i17" class="rowColor"> 
             <td class="colFirst"><code>&lt;T&gt;&nbsp;T</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#parse(java.lang.CharSequence,java.time.temporal.TemporalQuery)">parse</a></span>​(<a href="../../lang/CharSequence.html" title="interface in java.lang">CharSequence</a>&nbsp;text, <a href="../temporal/TemporalQuery.html" title="interface in java.time.temporal">TemporalQuery</a>&lt;T&gt;&nbsp;query)</code></th> 
             <td class="colLast"> 
              <div class="block">
                完全解析生成指定类型对象的文本。 
              </div> </td> 
            </tr> 
            <tr id="i18" class="altColor"> 
             <td class="colFirst"><code><a href="../temporal/TemporalAccessor.html" title="interface in java.time.temporal">TemporalAccessor</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#parseBest(java.lang.CharSequence,java.time.temporal.TemporalQuery...)">parseBest</a></span>​(<a href="../../lang/CharSequence.html" title="interface in java.lang">CharSequence</a>&nbsp;text, <a href="../temporal/TemporalQuery.html" title="interface in java.time.temporal">TemporalQuery</a>&lt;?&gt;...&nbsp;queries)</code></th> 
             <td class="colLast"> 
              <div class="block">
                完全解析生成指定类型之一的对象的文本。 
              </div> </td> 
            </tr> 
            <tr id="i19" class="rowColor"> 
             <td class="colFirst"><code>static <a href="../temporal/TemporalQuery.html" title="interface in java.time.temporal">TemporalQuery</a>&lt;<a href="../Period.html" title="class in java.time">Period</a>&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#parsedExcessDays()">parsedExcessDays</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                一个查询，提供对已解析的超出天数的访问权限。 
              </div> </td> 
            </tr> 
            <tr id="i20" class="altColor"> 
             <td class="colFirst"><code>static <a href="../temporal/TemporalQuery.html" title="interface in java.time.temporal">TemporalQuery</a>&lt;<a href="../../lang/Boolean.html" title="class in java.lang">Boolean</a>&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#parsedLeapSecond()">parsedLeapSecond</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                提供对是否解析闰秒的访问的查询。 
              </div> </td> 
            </tr> 
            <tr id="i21" class="rowColor"> 
             <td class="colFirst"><code><a href="../temporal/TemporalAccessor.html" title="interface in java.time.temporal">TemporalAccessor</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#parseUnresolved(java.lang.CharSequence,java.text.ParsePosition)">parseUnresolved</a></span>​(<a href="../../lang/CharSequence.html" title="interface in java.lang">CharSequence</a>&nbsp;text, <a href="../../text/ParsePosition.html" title="class in java.text">ParsePosition</a>&nbsp;position)</code></th> 
             <td class="colLast"> 
              <div class="block">
                使用此格式化程序解析文本，而不解析结果，用于高级用例。 
              </div> </td> 
            </tr> 
            <tr id="i22" class="altColor"> 
             <td class="colFirst"><code><a href="../../text/Format.html" title="class in java.text">Format</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toFormat()">toFormat</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                将此格式化程序作为 
               <code>java.text.Format</code>实例返回。 
              </div> </td> 
            </tr> 
            <tr id="i23" class="rowColor"> 
             <td class="colFirst"><code><a href="../../text/Format.html" title="class in java.text">Format</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toFormat(java.time.temporal.TemporalQuery)">toFormat</a></span>​(<a href="../temporal/TemporalQuery.html" title="interface in java.time.temporal">TemporalQuery</a>&lt;?&gt;&nbsp;parseQuery)</code></th> 
             <td class="colLast"> 
              <div class="block">
                将此格式化程序作为将使用指定查询进行分析的 
               <code>java.text.Format</code>实例返回。 
              </div> </td> 
            </tr> 
            <tr id="i24" class="altColor"> 
             <td class="colFirst"><code><a href="../../lang/String.html" title="class in java.lang">String</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toString()">toString</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回底层格式化程序的描述。 
              </div> </td> 
            </tr> 
            <tr id="i25" class="rowColor"> 
             <td class="colFirst"><code><a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#withChronology(java.time.chrono.Chronology)">withChronology</a></span>​(<a href="../chrono/Chronology.html" title="interface in java.time.chrono">Chronology</a>&nbsp;chrono)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回此格式化程序的副本，其中包含新的覆盖时间顺序。 
              </div> </td> 
            </tr> 
            <tr id="i26" class="altColor"> 
             <td class="colFirst"><code><a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#withDecimalStyle(java.time.format.DecimalStyle)">withDecimalStyle</a></span>​(<a href="DecimalStyle.html" title="class in java.time.format">DecimalStyle</a>&nbsp;decimalStyle)</code></th> 
             <td class="colLast"> 
              <div class="block">
                使用新的DecimalStyle返回此formatter的副本。 
              </div> </td> 
            </tr> 
            <tr id="i27" class="rowColor"> 
             <td class="colFirst"><code><a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#withLocale(java.util.Locale)">withLocale</a></span>​(<a href="../../util/Locale.html" title="class in java.util">Locale</a>&nbsp;locale)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回具有新语言环境的此formatter的副本。 
              </div> </td> 
            </tr> 
            <tr id="i28" class="altColor"> 
             <td class="colFirst"><code><a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#withResolverFields(java.time.temporal.TemporalField...)">withResolverFields</a></span>​(<a href="../temporal/TemporalField.html" title="interface in java.time.temporal">TemporalField</a>...&nbsp;resolverFields)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回此格式化程序的副本，其中包含一组新的解析程序字段。 
              </div> </td> 
            </tr> 
            <tr id="i29" class="rowColor"> 
             <td class="colFirst"><code><a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#withResolverFields(java.util.Set)">withResolverFields</a></span>​(<a href="../../util/Set.html" title="interface in java.util">Set</a>&lt;<a href="../temporal/TemporalField.html" title="interface in java.time.temporal">TemporalField</a>&gt;&nbsp;resolverFields)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回此格式化程序的副本，其中包含一组新的解析程序字段。 
              </div> </td> 
            </tr> 
            <tr id="i30" class="altColor"> 
             <td class="colFirst"><code><a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#withResolverStyle(java.time.format.ResolverStyle)">withResolverStyle</a></span>​(<a href="ResolverStyle.html" title="enum in java.time.format">ResolverStyle</a>&nbsp;resolverStyle)</code></th> 
             <td class="colLast"> 
              <div class="block">
                使用新的解析程序样式返回此formatter的副本。 
              </div> </td> 
            </tr> 
            <tr id="i31" class="rowColor"> 
             <td class="colFirst"><code><a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#withZone(java.time.ZoneId)">withZone</a></span>​(<a href="../ZoneId.html" title="class in java.time">ZoneId</a>&nbsp;zone)</code></th> 
             <td class="colLast"> 
              <div class="block">
                使用新的覆盖区域返回此格式化程序的副本。 
              </div> </td> 
            </tr> 
           </tbody> 
          </table> 
          <ul class="blockList"> 
           <li class="blockList"><a id="methods.inherited.from.class.java.lang.Object"> 
             <!--   --> </a> <h3>声明方法的类&nbsp;java.lang.<a href="../../lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../lang/Object.html#clone()">clone</a>, <a href="../../lang/Object.html#equals(java.lang.Object)">equals</a>, <a href="../../lang/Object.html#finalize()">finalize</a>, <a href="../../lang/Object.html#getClass()">getClass</a>, <a href="../../lang/Object.html#hashCode()">hashCode</a>, <a href="../../lang/Object.html#notify()">notify</a>, <a href="../../lang/Object.html#notifyAll()">notifyAll</a>, <a href="../../lang/Object.html#wait()">wait</a>, <a href="../../lang/Object.html#wait(long)">wait</a>, <a href="../../lang/Object.html#wait(long,int)">wait</a></code></li> 
          </ul> </li> 
        </ul> 
       </section> </li> 
     </ul> 
    </div> 
    <div class="details"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <!-- ============ FIELD DETAIL =========== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="field.detail"> 
           <!--   --> </a> <h3>字段详细信息</h3> <a id="ISO_LOCAL_DATE"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>ISO_LOCAL_DATE</h4> <pre>public static final&nbsp;<a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> ISO_LOCAL_DATE</pre> 
            <div class="block"> 
             <span>ISO日期格式化程序，用于格式化或解析没有偏移的日期，例如“2011-12-03”。</span> 
             <p> <span>这将返回一个不可变格式化程序，它能够格式化和解析ISO-8601扩展本地日期格式。</span> <span>格式包括：</span> </p> 
             <ul> 
              <li> <span><a href="../temporal/ChronoField.html#YEAR"><code>year</code>的</a>四位数或更多位数。</span> <span>0000到9999范围内的年份将预先填充为零，以确保四位数。</span> <span>超出该范围的年份将具有带前缀的正面或负面符号。</span> </li> 
              <li> <span>破折号</span> </li> 
              <li> <span>两位数为<a href="../temporal/ChronoField.html#MONTH_OF_YEAR"><code>month-of-year</code></a> 。</span> <span>这是预先填充零以确保两位数。</span> </li> 
              <li> <span>破折号</span> </li> 
              <li> <span><a href="../temporal/ChronoField.html#DAY_OF_MONTH"><code>day-of-month</code>的</a>两位数字。</span> <span>这是预先填充零以确保两位数。</span> </li> 
             </ul> 
             <p> <span>返回的格式化程序具有ISO设置的年表，以确保正确转换其他日历系统中的日期。</span> <span>它没有覆盖区域并使用<a href="ResolverStyle.html#STRICT"><code>STRICT</code></a>解析器样式。</span> </p> 
            </div> </li> 
          </ul> <a id="ISO_OFFSET_DATE"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>ISO_OFFSET_DATE</h4> <pre>public static final&nbsp;<a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> ISO_OFFSET_DATE</pre> 
            <div class="block"> 
             <span>ISO日期格式化程序，用于格式化或解析具有偏移量的日期，例如“2011-12-03 + 01:00”。</span> 
             <p> <span>这将返回一个不可变格式化程序，它能够格式化和解析ISO-8601扩展偏移日期格式。</span> <span>格式包括：</span> </p> 
             <ul> 
              <li> <span><a href="#ISO_LOCAL_DATE"><code>ISO_LOCAL_DATE</code></a></span> </li> 
              <li> <span><a href="../ZoneOffset.html#getId()"><code>offset ID</code></a> 。</span> <span>如果偏移量为秒，则即使这不是ISO-8601标准的一部分，也会处理它们。</span> <span>解析不区分大小写。</span> </li> 
             </ul> 
             <p> <span>返回的格式化程序具有ISO设置的年表，以确保正确转换其他日历系统中的日期。</span> <span>它没有覆盖区域并使用<a href="ResolverStyle.html#STRICT"><code>STRICT</code></a>解析器样式。</span> </p> 
            </div> </li> 
          </ul> <a id="ISO_DATE"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>ISO_DATE</h4> <pre>public static final&nbsp;<a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> ISO_DATE</pre> 
            <div class="block"> 
             <span>ISO日期格式化程序，使用偏移量格式化或解析日期（如“2011-12-03”或“2011-12-03 + 01:00”）。</span> 
             <p> <span>这将返回一个能够格式化和解析ISO-8601扩展日期格式的不可变格式化程序。</span> <span>格式包括：</span> </p> 
             <ul> 
              <li> <span><a href="#ISO_LOCAL_DATE"><code>ISO_LOCAL_DATE</code></a></span> </li> 
              <li> <span>如果偏移量不可用，则格式完成。</span> </li> 
              <li> <span><a href="../ZoneOffset.html#getId()"><code>offset ID</code></a> 。</span> <span>如果偏移量为秒，则即使这不是ISO-8601标准的一部分，也会处理它们。</span> <span>解析不区分大小写。</span> </li> 
             </ul> 
             <p> <span>由于此格式化程序具有可选元素，因此可能需要使用<a href="#parseBest(java.lang.CharSequence,java.time.temporal.TemporalQuery...)"><code>parseBest(java.lang.CharSequence, java.time.temporal.TemporalQuery&lt;?&gt;...)</code></a>进行解析。</span> </p> 
             <p> <span>返回的格式化程序具有ISO设置的年表，以确保正确转换其他日历系统中的日期。</span> <span>它没有覆盖区域并使用<a href="ResolverStyle.html#STRICT"><code>STRICT</code></a>解析器样式。</span> </p> 
            </div> </li> 
          </ul> <a id="ISO_LOCAL_TIME"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>ISO_LOCAL_TIME</h4> <pre>public static final&nbsp;<a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> ISO_LOCAL_TIME</pre> 
            <div class="block"> 
             <span>ISO时间格式化程序，用于格式化或解析没有偏移的时间，例如“10:15”或“10:15:30”。</span> 
             <p> <span>这将返回一个不可变格式化程序，它能够格式化和解析ISO-8601扩展本地时间格式。</span> <span>格式包括：</span> </p> 
             <ul> 
              <li> <span>两位数为<a href="../temporal/ChronoField.html#HOUR_OF_DAY"><code>hour-of-day</code></a> 。</span> <span>这是预先填充零以确保两位数。</span> </li> 
              <li> <span>结肠</span> </li> 
              <li> <span>两位数为<a href="../temporal/ChronoField.html#MINUTE_OF_HOUR"><code>minute-of-hour</code></a> 。</span> <span>这是预先填充零以确保两位数。</span> </li> 
              <li> <span>如果第二分钟不可用，则格式完成。</span> </li> 
              <li> <span>结肠</span> </li> 
              <li> <span>两位数为<a href="../temporal/ChronoField.html#SECOND_OF_MINUTE"><code>second-of-minute</code></a> 。</span> <span>这是预先填充零以确保两位数。</span> </li> 
              <li> <span>如果纳秒为零或不可用，则格式完成。</span> </li> 
              <li> <span>小数点</span> </li> 
              <li> <span><a href="../temporal/ChronoField.html#NANO_OF_SECOND"><code>nano-of-second</code>的</a>一到九位数字。</span> <span>根据需要输出许多数字。</span> </li> 
             </ul> 
             <p> <span>返回的格式化程序没有覆盖年表或区域。</span> <span>它使用了<a href="ResolverStyle.html#STRICT"><code>STRICT</code></a>解析器样式。</span> </p> 
            </div> </li> 
          </ul> <a id="ISO_OFFSET_TIME"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>ISO_OFFSET_TIME</h4> <pre>public static final&nbsp;<a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> ISO_OFFSET_TIME</pre> 
            <div class="block"> 
             <span>ISO时间格式化程序，使用偏移格式化或解析时间，例如'10：15 + 01:00'或'10：15：30 + 01:00'。</span> 
             <p> <span>这将返回一个不可变格式化程序，能够格式化和解析ISO-8601扩展偏移时间格式。</span> <span>格式包括：</span> </p> 
             <ul> 
              <li> <span><a href="#ISO_LOCAL_TIME"><code>ISO_LOCAL_TIME</code></a></span> </li> 
              <li> <span><a href="../ZoneOffset.html#getId()"><code>offset ID</code></a> 。</span> <span>如果偏移量为秒，则即使这不是ISO-8601标准的一部分，也会处理它们。</span> <span>解析不区分大小写。</span> </li> 
             </ul> 
             <p> <span>返回的格式化程序没有覆盖年表或区域。</span> <span>它使用<a href="ResolverStyle.html#STRICT"><code>STRICT</code></a>解析器样式。</span> </p> 
            </div> </li> 
          </ul> <a id="ISO_TIME"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>ISO_TIME</h4> <pre>public static final&nbsp;<a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> ISO_TIME</pre> 
            <div class="block"> 
             <span>ISO时间格式化程序，用于格式化或解析时间，如果可用，则为偏移量，例如“10:15”，“10：15：30”或“10:15:30 + 01:00”。</span> 
             <p> <span>这将返回一个不可变格式化程序，能够格式化和解析ISO-8601扩展偏移时间格式。</span> <span>格式包括：</span> </p> 
             <ul> 
              <li> <span><a href="#ISO_LOCAL_TIME"><code>ISO_LOCAL_TIME</code></a></span> </li> 
              <li> <span>如果偏移量不可用，则格式完成。</span> </li> 
              <li> <span><a href="../ZoneOffset.html#getId()"><code>offset ID</code></a> 。</span> <span>如果偏移量为秒，则即使这不是ISO-8601标准的一部分，也会处理它们。</span> <span>解析不区分大小写。</span> </li> 
             </ul> 
             <p> <span>由于此格式化程序具有可选元素，因此可能需要使用<a href="#parseBest(java.lang.CharSequence,java.time.temporal.TemporalQuery...)"><code>parseBest(java.lang.CharSequence, java.time.temporal.TemporalQuery&lt;?&gt;...)</code></a>进行解析。</span> </p> 
             <p> <span>返回的格式化程序没有覆盖年表或区域。</span> <span>它使用<a href="ResolverStyle.html#STRICT"><code>STRICT</code></a>解析器样式。</span> </p> 
            </div> </li> 
          </ul> <a id="ISO_LOCAL_DATE_TIME"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>ISO_LOCAL_DATE_TIME</h4> <pre>public static final&nbsp;<a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> ISO_LOCAL_DATE_TIME</pre> 
            <div class="block"> 
             <span>ISO日期时格式化程序，用于格式化或解析没有偏移的日期时间，例如“2011-12-03T10：15：30”。</span> 
             <p> <span>这将返回一个不可变格式化程序，它能够格式化和解析ISO-8601扩展偏移日期时间格式。</span> <span>格式包括：</span> </p> 
             <ul> 
              <li> <span><a href="#ISO_LOCAL_DATE"><code>ISO_LOCAL_DATE</code></a></span> </li> 
              <li> <span>字母'T'。</span> <span>解析不区分大小写。</span> </li> 
              <li> <span><a href="#ISO_LOCAL_TIME"><code>ISO_LOCAL_TIME</code></a></span> </li> 
             </ul> 
             <p> <span>返回的格式化程序具有ISO设置的年表，以确保正确转换其他日历系统中的日期。</span> <span>它没有覆盖区域并使用<a href="ResolverStyle.html#STRICT"><code>STRICT</code></a>解析器样式。</span> </p> 
            </div> </li> 
          </ul> <a id="ISO_OFFSET_DATE_TIME"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>ISO_OFFSET_DATE_TIME</h4> <pre>public static final&nbsp;<a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> ISO_OFFSET_DATE_TIME</pre> 
            <div class="block"> 
             <span>ISO日期时格格式器，用于格式化或解析具有偏移的日期时间，例如“2011-12-03T10：15：30 + 01:00”。</span> 
             <p> <span>这将返回一个不可变格式化程序，它能够格式化和解析ISO-8601扩展偏移日期时间格式。</span> <span>格式包括：</span> </p> 
             <ul> 
              <li> <span><a href="#ISO_LOCAL_DATE_TIME"><code>ISO_LOCAL_DATE_TIME</code></a></span> </li> 
              <li> <span><a href="../ZoneOffset.html#getId()"><code>offset ID</code></a> 。</span> <span>如果偏移量为秒，则即使这不是ISO-8601标准的一部分，也会处理它们。</span> <span>偏移解析是宽松的，这允许分钟和秒是可选的。</span> <span>解析不区分大小写。</span> </li> 
             </ul> 
             <p> <span>返回的格式化程序具有ISO设置的年表，以确保正确转换其他日历系统中的日期。</span> <span>它没有覆盖区域并使用<a href="ResolverStyle.html#STRICT"><code>STRICT</code></a>解析器样式。</span> </p> 
            </div> </li> 
          </ul> <a id="ISO_ZONED_DATE_TIME"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>ISO_ZONED_DATE_TIME</h4> <pre>public static final&nbsp;<a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> ISO_ZONED_DATE_TIME</pre> 
            <div class="block"> 
             <span>类似ISO的日期时格格式器，用于格式化或解析具有偏移和区域的日期时间，例如“2011-12-03T10：15：30 + 01:00 [欧洲/巴黎]”。</span> 
             <p> <span>这将返回一个不可变格式化程序，它能够格式化和解析扩展ISO-8601扩展偏移日期时间格式的格式以添加时区。</span> <span>方括号中的部分不是ISO-8601标准的一部分。</span> <span>格式包括：</span> </p> 
             <ul> 
              <li> <span><a href="#ISO_OFFSET_DATE_TIME"><code>ISO_OFFSET_DATE_TIME</code></a></span> </li> 
              <li> <span>如果区域ID不可用或者是<code>ZoneOffset</code>则格式完成。</span> </li> 
              <li> <span>一个开放的方括号'['。</span> </li> 
              <li> <span><a href="../ZoneId.html#getId()"><code>zone ID</code></a> 。</span> <span>这不是ISO-8601标准的一部分。</span> <span>解析区分大小写。</span> </li> 
              <li> <span>一个紧密的方括号']'。</span> </li> 
             </ul> 
             <p> <span>返回的格式化程序具有ISO设置的年表，以确保正确转换其他日历系统中的日期。</span> <span>它没有覆盖区域并使用<a href="ResolverStyle.html#STRICT"><code>STRICT</code></a>解析器样式。</span> </p> 
            </div> </li> 
          </ul> <a id="ISO_DATE_TIME"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>ISO_DATE_TIME</h4> <pre>public static final&nbsp;<a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> ISO_DATE_TIME</pre> 
            <div class="block"> 
             <span>类似ISO的日期时格式化程序，使用偏移量和区域（如果可用）格式化或解析日期时间，例如“2011-12-03T10：15：30”，“2011-12-03T10：15：30 + 01 ：00'或'2011-12-03T10：15：30 + 01:00 [欧洲/巴黎]'。</span> 
             <p> <span>这将返回一个不可变格式化程序，它能够格式化和解析ISO-8601扩展本地或偏移日期时间格式，以及指定时区的扩展非ISO格式。</span> <span>格式包括：</span> </p> 
             <ul> 
              <li> <span><a href="#ISO_LOCAL_DATE_TIME"><code>ISO_LOCAL_DATE_TIME</code></a></span> </li> 
              <li> <span>如果无法格式化或解析偏移量，则格式完成。</span> </li> 
              <li> <span><a href="../ZoneOffset.html#getId()"><code>offset ID</code></a> 。</span> <span>如果偏移量为秒，则即使这不是ISO-8601标准的一部分，也会处理它们。</span> </li> 
              <li> <span>如果区域ID不可用或者是<code>ZoneOffset</code>则格式完成。</span> </li> 
              <li> <span>一个开放的方括号'['。</span> </li> 
              <li> <span><a href="../ZoneId.html#getId()"><code>zone ID</code></a> 。</span> <span>这不是ISO-8601标准的一部分。</span> <span>解析区分大小写。</span> </li> 
              <li> <span>一个紧密的方括号']'。</span> </li> 
             </ul> 
             <p> <span>由于此格式化程序具有可选元素，因此可能需要使用<a href="#parseBest(java.lang.CharSequence,java.time.temporal.TemporalQuery...)"><code>parseBest(java.lang.CharSequence, java.time.temporal.TemporalQuery&lt;?&gt;...)</code></a>进行解析。</span> </p> 
             <p> <span>返回的格式化程序具有ISO设置的年表，以确保正确转换其他日历系统中的日期。</span> <span>它没有覆盖区域并使用<a href="ResolverStyle.html#STRICT"><code>STRICT</code></a>解析器样式。</span> </p> 
            </div> </li> 
          </ul> <a id="ISO_ORDINAL_DATE"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>ISO_ORDINAL_DATE</h4> <pre>public static final&nbsp;<a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> ISO_ORDINAL_DATE</pre> 
            <div class="block"> 
             <span>ISO日期格式化程序，用于格式化或解析没有偏移的序数日期，例如“2012-337”。</span> 
             <p> <span>这将返回一个不可变格式化程序，它能够格式化和解析ISO-8601扩展序数日期格式。</span> <span>格式包括：</span> </p> 
             <ul> 
              <li> <span><a href="../temporal/ChronoField.html#YEAR"><code>year</code>的</a>四位数或更多位数。</span> <span>0000到9999范围内的年份将预先填充为零，以确保四位数。</span> <span>超出该范围的年份将具有带前缀的正面或负面符号。</span> </li> 
              <li> <span>破折号</span> </li> 
              <li> <span><a href="../temporal/ChronoField.html#DAY_OF_YEAR"><code>day-of-year</code>的</a>三位数字。</span> <span>这是预先填充零以确保三位数。</span> </li> 
              <li> <span>如果无法格式化或解析偏移量，则格式完成。</span> </li> 
              <li> <span><a href="../ZoneOffset.html#getId()"><code>offset ID</code></a> 。</span> <span>如果偏移量为秒，则即使这不是ISO-8601标准的一部分，也会处理它们。</span> <span>解析不区分大小写。</span> </li> 
             </ul> 
             <p> <span>由于此格式化程序具有可选元素，因此可能需要使用<a href="#parseBest(java.lang.CharSequence,java.time.temporal.TemporalQuery...)"><code>parseBest(java.lang.CharSequence, java.time.temporal.TemporalQuery&lt;?&gt;...)</code></a>进行解析。</span> </p> 
             <p> <span>返回的格式化程序具有ISO设置的年表，以确保正确转换其他日历系统中的日期。</span> <span>它没有覆盖区域并使用<a href="ResolverStyle.html#STRICT"><code>STRICT</code></a>解析器样式。</span> </p> 
            </div> </li> 
          </ul> <a id="ISO_WEEK_DATE"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>ISO_WEEK_DATE</h4> <pre>public static final&nbsp;<a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> ISO_WEEK_DATE</pre> 
            <div class="block"> 
             <span>ISO日期格式化程序，用于格式化或解析没有偏移的基于周的日期，例如“2012-W48-6”。</span> 
             <p> <span>这将返回一个不可变的格式化程序，它能够格式化和解析ISO-8601扩展的基于周的日期格式。</span> <span>格式包括：</span> </p> 
             <ul> 
              <li> <span><a href="../temporal/IsoFields.html#WEEK_BASED_YEAR"><code>week-based-year</code>的</a>四位数或更多位数。</span> <span>0000到9999范围内的年份将预先填充为零，以确保四位数。</span> <span>超出该范围的年份将具有带前缀的正面或负面符号。</span> </li> 
              <li> <span>破折号</span> </li> 
              <li> <span>字母'W'。</span> <span>解析不区分大小写。</span> </li> 
              <li> <span>两位数为<a href="../temporal/IsoFields.html#WEEK_OF_WEEK_BASED_YEAR"><code>week-of-week-based-year</code></a> 。</span> <span>这是预先填充零以确保三位数。</span> </li> 
              <li> <span>破折号</span> </li> 
              <li> <span><a href="../temporal/ChronoField.html#DAY_OF_WEEK"><code>day-of-week</code>的</a>一位数字。</span> <span>该值从星期一（1）到星期日（7）。</span> </li> 
              <li> <span>如果无法格式化或解析偏移量，则格式完成。</span> </li> 
              <li> <span><a href="../ZoneOffset.html#getId()"><code>offset ID</code></a> 。</span> <span>如果偏移量为秒，则即使这不是ISO-8601标准的一部分，也会处理它们。</span> <span>解析不区分大小写。</span> </li> 
             </ul> 
             <p> <span>由于此格式化程序具有可选元素，因此可能需要使用<a href="#parseBest(java.lang.CharSequence,java.time.temporal.TemporalQuery...)"><code>parseBest(java.lang.CharSequence, java.time.temporal.TemporalQuery&lt;?&gt;...)</code></a>进行解析。</span> </p> 
             <p> <span>返回的格式化程序具有ISO设置的年表，以确保正确转换其他日历系统中的日期。</span> <span>它没有覆盖区域并使用<a href="ResolverStyle.html#STRICT"><code>STRICT</code></a>解析器样式。</span> </p> 
            </div> </li> 
          </ul> <a id="ISO_INSTANT"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>ISO_INSTANT</h4> <pre>public static final&nbsp;<a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> ISO_INSTANT</pre> 
            <div class="block"> 
             <span>ISO即时格式化程序，用于格式化或解析UTC中的瞬间，例如“2011-12-03T10：15：30Z”。</span> 
             <p> <span>这将返回一个能够格式化和解析ISO-8601即时格式的不可变格式化程序。</span> <span>格式化时，始终输出秒的分钟。</span> <span>毫秒秒根据需要输出零，三，六或九位数。</span> <span>解析时，至少需要秒时间字段。</span> <span>解析从零到九的小数秒。</span> <span>未使用本地化的十进制样式。</span> </p> 
             <p> <span>这是一种特殊情况格式化程序，旨在允许<a href="../Instant.html" title="java.time中的类"><code>Instant</code></a>的人类可读形式。</span> <span><code>Instant</code>类仅用于表示某个时间点，并在内部存储一个以纳秒为单位的值，该值为1970-01-01Z的固定时期。</span> <span>因此，如果没有提供某种形式的时区，则无法将<code>Instant</code>格式化为日期或时间。</span> <span>此格式化允许<code>Instant</code>到通过提供一种使用合适的转化被格式化， <code>ZoneOffset.UTC</code> 。</span> </p> 
             <p> <span>格式包括：</span> </p> 
             <ul> 
              <li> <span><a href="#ISO_OFFSET_DATE_TIME"><code>ISO_OFFSET_DATE_TIME</code></a>其中，即时转换为<a href="../temporal/ChronoField.html#INSTANT_SECONDS"><code>ChronoField.INSTANT_SECONDS</code></a>和<a href="../temporal/ChronoField.html#NANO_OF_SECOND"><code>ChronoField.NANO_OF_SECOND</code>，</a>使用<code>UTC</code>偏移量。</span> <span>解析不区分大小写。</span> </li> 
             </ul> 
             <p> <span>返回的格式化程序没有覆盖年表或区域。</span> <span>它使用<a href="ResolverStyle.html#STRICT"><code>STRICT</code></a>解析器样式。</span> </p> 
            </div> </li> 
          </ul> <a id="BASIC_ISO_DATE"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>BASIC_ISO_DATE</h4> <pre>public static final&nbsp;<a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> BASIC_ISO_DATE</pre> 
            <div class="block"> 
             <span>ISO日期格式化程序，用于格式化或解析没有偏移的日期，例如“20111203”。</span> 
             <p> <span>这将返回一个不可变格式化程序，它能够格式化和解析ISO-8601基本本地日期格式。</span> <span>格式包括：</span> </p> 
             <ul> 
              <li> <span>四位数为<a href="../temporal/ChronoField.html#YEAR"><code>year</code></a> 。</span> <span>仅支持0000至9999范围内的年份。</span> </li> 
              <li> <span>两位数为<a href="../temporal/ChronoField.html#MONTH_OF_YEAR"><code>month-of-year</code></a> 。</span> <span>这是预先填充零以确保两位数。</span> </li> 
              <li> <span>两位数为<a href="../temporal/ChronoField.html#DAY_OF_MONTH"><code>day-of-month</code></a> 。</span> <span>这是预先填充零以确保两位数。</span> </li> 
              <li> <span>如果无法格式化或解析偏移量，则格式完成。</span> </li> 
              <li> <span><a href="../ZoneOffset.html#getId()"><code>offset ID</code></a>没有冒号。</span> <span>如果偏移量为秒，则即使这不是ISO-8601标准的一部分，也会处理它们。</span> <span>偏移解析是宽松的，这允许分钟和秒是可选的。</span> <span>解析不区分大小写。</span> </li> 
             </ul> 
             <p> <span>由于此格式化程序具有可选元素，因此可能需要使用<a href="#parseBest(java.lang.CharSequence,java.time.temporal.TemporalQuery...)"><code>parseBest(java.lang.CharSequence, java.time.temporal.TemporalQuery&lt;?&gt;...)</code></a>进行解析。</span> </p> 
             <p> <span>返回的格式化程序具有ISO设置的年表，以确保正确转换其他日历系统中的日期。</span> <span>它没有覆盖区域并使用<a href="ResolverStyle.html#STRICT"><code>STRICT</code></a>解析器样式。</span> </p> 
            </div> </li> 
          </ul> <a id="RFC_1123_DATE_TIME"> 
           <!--   --> </a> 
          <ul class="blockListLast"> 
           <li class="blockList"> <h4>RFC_1123_DATE_TIME</h4> <pre>public static final&nbsp;<a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a> RFC_1123_DATE_TIME</pre> 
            <div class="block"> 
             <span>RFC-1123日期时间格式化程序，例如'Tue，2008年6月3日11:05:30 GMT'。</span> 
             <p> <span>这将返回一个不可变的格式化程序，能够格式化和解析大多数RFC-1123格式。</span> <span>RFC-1123更新RFC-822将年份从两位数改为四位。</span> <span>此实施需要四位数年份。</span> <span>此实施也不处理北美或军区名称，仅处理'GMT'和抵消金额。</span> </p> 
             <p> <span>格式包括：</span> </p> 
             <ul> 
              <li> <span>如果星期几无法格式化或解析，则跳转到日期。</span> </li> 
              <li> <span>三个字母<a href="../temporal/ChronoField.html#DAY_OF_WEEK"><code>day-of-week</code></a>英文。</span> </li> 
              <li> <span>一个逗号</span> </li> 
              <li> <span>空间</span> </li> 
              <li> <span><a href="../temporal/ChronoField.html#DAY_OF_MONTH"><code>day-of-month</code>的</a>一位或两位数字。</span> </li> 
              <li> <span>空间</span> </li> 
              <li> <span>三个字母<a href="../temporal/ChronoField.html#MONTH_OF_YEAR"><code>month-of-year</code></a>英文。</span> </li> 
              <li> <span>空间</span> </li> 
              <li> <span>四位数为<a href="../temporal/ChronoField.html#YEAR"><code>year</code></a> 。</span> <span>仅支持0000至9999范围内的年份。</span> </li> 
              <li> <span>空间</span> </li> 
              <li> <span>两位数为<a href="../temporal/ChronoField.html#HOUR_OF_DAY"><code>hour-of-day</code></a> 。</span> <span>这是预先填充零以确保两位数。</span> </li> 
              <li> <span>结肠</span> </li> 
              <li> <span>两位数为<a href="../temporal/ChronoField.html#MINUTE_OF_HOUR"><code>minute-of-hour</code></a> 。</span> <span>这是预先填充零以确保两位数。</span> </li> 
              <li> <span>如果第二分钟不可用，则跳转到下一个空格。</span> </li> 
              <li> <span>结肠</span> </li> 
              <li> <span>两位数为<a href="../temporal/ChronoField.html#SECOND_OF_MINUTE"><code>second-of-minute</code></a> 。</span> <span>这是预先填充零以确保两位数。</span> </li> 
              <li> <span>空间</span> </li> 
              <li> <span><a href="../ZoneOffset.html#getId()"><code>offset ID</code></a>没有冒号或秒。</span> <span>零偏移使用“GMT”。</span> <span>不处理北美地区名称和军事区域名称。</span> </li> 
             </ul> 
             <p> <span>解析不区分大小写。</span> </p> 
             <p> <span>返回的格式化程序具有ISO设置的年表，以确保正确转换其他日历系统中的日期。</span> <span>它没有覆盖区域并使用<a href="ResolverStyle.html#SMART"><code>SMART</code></a>解析器样式。</span> </p> 
            </div> </li> 
          </ul> </li> 
        </ul> 
       </section> 
       <!-- ============ METHOD DETAIL ========== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="method.detail"> 
           <!--   --> </a> <h3>方法详细信息</h3> <a id="ofPattern(java.lang.String)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>ofPattern</h4> <pre class="methodSignature">public static&nbsp;<a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a>&nbsp;ofPattern​(<a href="../../lang/String.html" title="class in java.lang">String</a>&nbsp;pattern)</pre> 
            <div class="block"> 
             <span>使用指定的模式创建格式化程序。</span> 
             <p> <span>此方法将基于类文档中描述的简单<a href="#patterns">pattern of letters and symbols</a>创建格式化程序。</span> <span>例如， <code>d MMM uuuu</code>将2011-12-03格式化为“2011年12月3日”。</span> </p> 
             <p> <span>格式化程序将使用<a href="../../util/Locale.html#getDefault(java.util.Locale.Category)"><code>default FORMAT locale</code></a> 。</span> <span>这可以使用返回的格式化程序上的<a href="#withLocale(java.util.Locale)"><code>withLocale(Locale)</code></a>进行更改。</span> <span>或者，使用此方法的<a href="#ofPattern(java.lang.String,java.util.Locale)"><code>ofPattern(String, Locale)</code></a>变体。</span> </p> 
             <p> <span>返回的格式化程序没有覆盖年表或区域。</span> <span>它使用<a href="ResolverStyle.html#SMART"><code>SMART</code></a>旋转变压器样式。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>pattern</code> - 要使用的模式，而不是null 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               基于模式的格式化程序，不是null 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果模式无效 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="DateTimeFormatterBuilder.html#appendPattern(java.lang.String)"><code>DateTimeFormatterBuilder.appendPattern(String)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="ofPattern(java.lang.String,java.util.Locale)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>ofPattern</h4> <pre class="methodSignature">public static&nbsp;<a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a>&nbsp;ofPattern​(<a href="../../lang/String.html" title="class in java.lang">String</a>&nbsp;pattern,
                                          <a href="../../util/Locale.html" title="class in java.util">Locale</a>&nbsp;locale)</pre> 
            <div class="block"> 
             <span>使用指定的模式和语言环境创建格式化程序。</span> 
             <p> <span>此方法将基于类文档中描述的简单<a href="#patterns">pattern of letters and symbols</a>创建格式化程序。</span> <span>例如， <code>d MMM uuuu</code>将2011-12-03格式化为“2011年12月3日”。</span> </p> 
             <p> <span>格式化程序将使用指定的语言环境。</span> <span>这可以使用返回的格式化程序上的<a href="#withLocale(java.util.Locale)"><code>withLocale(Locale)</code></a>进行更改。</span> </p> 
             <p> <span>返回的格式化程序没有覆盖年表或区域。</span> <span>它使用<a href="ResolverStyle.html#SMART"><code>SMART</code></a>解析器样式。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>pattern</code> - 要使用的模式，而不是null 
             </dd> 
             <dd> 
              <code>locale</code> - 要使用的语言环境，而不是null 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               基于模式的格式化程序，不是null 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果模式无效 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="DateTimeFormatterBuilder.html#appendPattern(java.lang.String)"><code>DateTimeFormatterBuilder.appendPattern(String)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="ofLocalizedDate(java.time.format.FormatStyle)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>ofLocalizedDate</h4> <pre class="methodSignature">public static&nbsp;<a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a>&nbsp;ofLocalizedDate​(<a href="FormatStyle.html" title="enum in java.time.format">FormatStyle</a>&nbsp;dateStyle)</pre> 
            <div class="block"> 
             <span>返回ISO年表的特定于语言环境的日期格式。</span> 
             <p> <span>这将返回格式化程序，该格式化程序将格式化或解析日期。</span> <span>使用的确切格式模式因区域设置而异。</span> </p> 
             <p> <span>语言环境由格式化程序确定。</span> <span>通过此方法直接返回的格式化程序将使用<a href="../../util/Locale.html#getDefault(java.util.Locale.Category)"><code>default FORMAT locale</code></a> 。</span> <span>可以使用<a href="#withLocale(java.util.Locale)"><code>withLocale(Locale)</code></a>在此方法的结果上控制区域设置。</span> </p> 
             <p> <span>请注意，本地化模式是懒惰地查找的。</span> <span>此<code>DateTimeFormatter</code>包含所需的样式和区域设置，查找所需的模式。</span> </p> 
             <p> <span>返回的格式化程序具有ISO设置的年表，以确保正确转换其他日历系统中的日期。</span> <span>它没有覆盖区域并使用<a href="ResolverStyle.html#SMART"><code>SMART</code></a>解析器样式。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>dateStyle</code> - 要获取的格式化程序样式，而不是null 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               日期格式化程序，不是null 
             </dd> 
            </dl> </li> 
          </ul> <a id="ofLocalizedTime(java.time.format.FormatStyle)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>ofLocalizedTime</h4> <pre class="methodSignature">public static&nbsp;<a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a>&nbsp;ofLocalizedTime​(<a href="FormatStyle.html" title="enum in java.time.format">FormatStyle</a>&nbsp;timeStyle)</pre> 
            <div class="block"> 
             <span>返回ISO年表的特定于语言环境的时间格式。</span> 
             <p> <span>这将返回格式化程序，该格式化程序将格式化或解析时间。</span> <span>使用的确切格式模式因区域设置而异。</span> </p> 
             <p> <span>语言环境由格式化程序确定。</span> <span>直接通过此方法返回的格式化程序将使用<a href="../../util/Locale.html#getDefault(java.util.Locale.Category)"><code>default FORMAT locale</code></a> 。</span> <span>可以使用<a href="#withLocale(java.util.Locale)"><code>withLocale(Locale)</code></a>对此方法的结果控制区域设置。</span> </p> 
             <p> <span>请注意，本地化模式是懒惰地查找的。</span> <span>这个<code>DateTimeFormatter</code>拥有所需的样式和区域设置，查找所需的模式。</span> </p> 
             <p> <span>返回的格式化程序具有ISO设置的年表，以确保正确转换其他日历系统中的日期。</span> <span>它没有覆盖区域并使用<a href="ResolverStyle.html#SMART"><code>SMART</code></a>解析器样式。</span> <span><code>FULL</code>和<code>LONG</code>样式通常需要时区。</span> <span>当使用这些风格格式化，一<code>ZoneId</code>必须是可用的，无论是使用<code>ZonedDateTime</code>或<a href="#withZone(java.time.ZoneId)"><code>withZone(java.time.ZoneId)</code></a> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>timeStyle</code> - 要获取的格式化程序样式，而不是null 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               时间格式化程序，不是null 
             </dd> 
            </dl> </li> 
          </ul> <a id="ofLocalizedDateTime(java.time.format.FormatStyle)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>ofLocalizedDateTime</h4> <pre class="methodSignature">public static&nbsp;<a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a>&nbsp;ofLocalizedDateTime​(<a href="FormatStyle.html" title="enum in java.time.format">FormatStyle</a>&nbsp;dateTimeStyle)</pre> 
            <div class="block"> 
             <span>返回ISO年表的特定于语言环境的日期时间格式化程序。</span> 
             <p> <span>这将返回格式化程序，该格式化程序将格式化或解析日期时间。</span> <span>使用的确切格式模式因区域设置而异。</span> </p> 
             <p> <span>语言环境由格式化程序确定。</span> <span>通过此方法直接返回的格式化程序将使用<a href="../../util/Locale.html#getDefault(java.util.Locale.Category)"><code>default FORMAT locale</code></a> 。</span> <span>可以使用<a href="#withLocale(java.util.Locale)"><code>withLocale(Locale)</code></a>在此方法的结果上控制区域设置。</span> </p> 
             <p> <span>请注意，本地化模式是懒惰地查找的。</span> <span>此<code>DateTimeFormatter</code>包含所需的样式和区域设置，查找所需的模式。</span> </p> 
             <p> <span>返回的格式化程序具有ISO设置的年表，以确保正确转换其他日历系统中的日期。</span> <span>它没有覆盖区域并使用<a href="ResolverStyle.html#SMART"><code>SMART</code></a>解析器样式。</span> <span><code>FULL</code>和<code>LONG</code>样式通常需要时区。</span> <span>当使用这些风格格式化，一<code>ZoneId</code>必须是可用的，无论是使用<code>ZonedDateTime</code>或<a href="#withZone(java.time.ZoneId)"><code>withZone(java.time.ZoneId)</code></a> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>dateTimeStyle</code> - 要获取的格式化程序样式，而不是null 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               日期时格格式器，不是null 
             </dd> 
            </dl> </li> 
          </ul> <a id="ofLocalizedDateTime(java.time.format.FormatStyle,java.time.format.FormatStyle)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>ofLocalizedDateTime</h4> <pre class="methodSignature">public static&nbsp;<a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a>&nbsp;ofLocalizedDateTime​(<a href="FormatStyle.html" title="enum in java.time.format">FormatStyle</a>&nbsp;dateStyle,
                                                    <a href="FormatStyle.html" title="enum in java.time.format">FormatStyle</a>&nbsp;timeStyle)</pre> 
            <div class="block"> 
             <span>返回ISO年表的特定于语言环境的日期和时间格式。</span> 
             <p> <span>这将返回格式化程序，该格式化程序将格式化或解析日期时间。</span> <span>使用的确切格式模式因区域设置而异。</span> </p> 
             <p> <span>语言环境由格式化程序确定。</span> <span>通过此方法直接返回的格式化程序将使用<a href="../../util/Locale.html#getDefault()"><code>default FORMAT locale</code></a> 。</span> <span>可以使用此方法的结果使用<a href="#withLocale(java.util.Locale)"><code>withLocale(Locale)</code></a>控制区域设置。</span> </p> 
             <p> <span>请注意，本地化模式是懒惰地查找的。</span> <span>此<code>DateTimeFormatter</code>包含所需的样式和区域设置，查找所需的模式。</span> </p> 
             <p> <span>返回的格式化程序具有ISO设置的年表，以确保正确转换其他日历系统中的日期。</span> <span>它没有覆盖区域并使用<a href="ResolverStyle.html#SMART"><code>SMART</code></a>解析器样式。</span> <span><code>FULL</code>和<code>LONG</code>样式通常需要时区。</span> <span>当使用这些风格格式化，一<code>ZoneId</code>必须是可用的，无论是使用<code>ZonedDateTime</code>或<a href="#withZone(java.time.ZoneId)"><code>withZone(java.time.ZoneId)</code></a> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>dateStyle</code> - 要获取的日期格式化程序样式，而不是null 
             </dd> 
             <dd> 
              <code>timeStyle</code> - 要获取的时间格式器样式，而不是null 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               日期，时间或日期时间格式化程序，不为空 
             </dd> 
            </dl> </li> 
          </ul> <a id="parsedExcessDays()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>parsedExcessDays</h4> <pre class="methodSignature">public static final&nbsp;<a href="../temporal/TemporalQuery.html" title="interface in java.time.temporal">TemporalQuery</a>&lt;<a href="../Period.html" title="class in java.time">Period</a>&gt;&nbsp;parsedExcessDays()</pre> 
            <div class="block"> 
             <span>一个查询，提供对已解析的超出天数的访问权限。</span> 
             <p> <span>这将返回单例<a href="../temporal/TemporalQuery.html" title="java.time.temporal中的接口">query</a> ，该单元提供对解析中的其他信息的访问。</span> <span>查询始终返回非null周期，返回零周期而不是null。</span> </p> 
             <p> <span>有两种情况，此查询可能返回非零周期。</span> </p> 
             <ul> 
              <li> <span>如果<code>ResolverStyle</code>是<code>LENIENT</code>并且解析时间没有日期，那么解析的完整结果包括<code>LocalTime</code>和超过<code>Period</code>天。</span> </li> 
              <li> <span>如果<code>ResolverStyle</code>是<code>SMART</code>并且解析时间没有时间为24:00:00的日期，那么解析的完整结果包括<code>LocalTime</code>的00:00:00和超过<code>Period</code>的一天。</span> </li> 
             </ul> 
             <p> <span>在这两种情况下，如果解析完整的<code>ChronoLocalDateTime</code>或<code>Instant</code> ，则将多余的天数添加到日期部分。</span> <span>因此，此查询将返回零周期。</span> </p> 
             <p> <span><code>SMART</code>行为处理常见的“一天结束”24:00值。</span> <span><code>LENIENT</code>模式下的处理也会产生相同的结果：</span> </p> 
             <pre>  <span>Text to parse        Parsed object                         Excess days
  "2012-12-03T00:00"   LocalDateTime.of(2012, 12, 3, 0, 0)   ZERO
  "2012-12-03T24:00"   LocalDateTime.of(2012, 12, 4, 0, 0)   ZERO
  "00:00"              LocalTime.of(0, 0)                    ZERO
  "24:00"              LocalTime.of(0, 0)                    Period.ofDays(1)</span> </pre> 
             <span>查询可以使用如下：</span> 
             <pre>  <span>TemporalAccessor parsed = formatter.parse(str);
  LocalTime time = parsed.query(LocalTime::from);
  Period extraDays = parsed.query(DateTimeFormatter.parsedExcessDays());</span> </pre> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个查询，提供对已解析的超出天数的访问权限 
             </dd> 
            </dl> </li> 
          </ul> <a id="parsedLeapSecond()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>parsedLeapSecond</h4> <pre class="methodSignature">public static final&nbsp;<a href="../temporal/TemporalQuery.html" title="interface in java.time.temporal">TemporalQuery</a>&lt;<a href="../../lang/Boolean.html" title="class in java.lang">Boolean</a>&gt;&nbsp;parsedLeapSecond()</pre> 
            <div class="block"> 
             <span>提供对是否解析闰秒的访问的查询。</span> 
             <p> <span>这将返回一个单例<a href="../temporal/TemporalQuery.html" title="java.time.temporal中的接口">query</a> ，它可以从解析中访问其他信息。</span> <span>查询始终返回非null布尔值，如果解析看到闰秒，则返回true，否则返回false。</span> </p> 
             <p> <span>即时解析处理'23：59：60'的特殊“闰秒”时间。</span> <span>闰秒发生在UTC时区的“23:59:60”，但是在不同时区的其他本地时间。</span> <span>为避免这种潜在的歧义，闰秒的处理仅限于<a href="DateTimeFormatterBuilder.html#appendInstant()"><code>DateTimeFormatterBuilder.appendInstant()</code></a> ，因为该方法始终使用UTC区域偏移量解析瞬间。</span> </p> 
             <p> <span>如果收到时间'23：59：60'，则应用简单转换，用59替换60分钟的第二分钟。可以在解析结果上使用此查询来确定闰秒调整是否为制作。</span> <span>该查询将返回<code>true</code> ，如果它没有调整去除闰秒，而<code>false</code>如果不是。</span> <span>请注意，应用闰秒平滑机制（如UTC-SLS）是应用程序的责任，如下所示：</span> </p> 
             <pre>  <span>TemporalAccessor parsed = formatter.parse(str);
  Instant instant = parsed.query(Instant::from);
  if (parsed.query(DateTimeFormatter.parsedLeapSecond())) {
    // validate leap-second is correct and apply correct smoothing
  }</span> </pre> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个查询，提供对是否解析闰秒的访问权限 
             </dd> 
            </dl> </li> 
          </ul> <a id="getLocale()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getLocale</h4> <pre class="methodSignature">public&nbsp;<a href="../../util/Locale.html" title="class in java.util">Locale</a>&nbsp;getLocale()</pre> 
            <div class="block"> 
             <span>获取格式化期间要使用的语言环境。</span> 
             <p> <span>这用于查找需要特定本地化的格式化程序的任何部分，例如文本或本地化模式。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此格式化程序的语言环境，不为null 
             </dd> 
            </dl> </li> 
          </ul> <a id="withLocale(java.util.Locale)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>withLocale</h4> <pre class="methodSignature">public&nbsp;<a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a>&nbsp;withLocale​(<a href="../../util/Locale.html" title="class in java.util">Locale</a>&nbsp;locale)</pre> 
            <div class="block"> 
             <span>返回具有新语言环境的此formatter的副本。</span> 
             <p> <span>这用于查找需要特定本地化的格式化程序的任何部分，例如文本或本地化模式。</span> </p> 
             <p> <span>语言环境存储为传入，无需进一步处理。</span> <span>如果语言环境具有<a href="../../util/Locale.html#def_locale_extension">Unicode extensions</a> ，则稍后可以在文本处理中使用它们。</span> <span>要从unicode扩展设置年表，时区和小数形式，请参阅<a href="#localizedBy(java.util.Locale)"><code>localizedBy()</code></a> 。</span> </p> 
             <p> <span>此实例是不可变的，不受此方法调用的影响。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>locale</code> - 新的语言环境，不为null 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               基于此格式化程序的格式化程序，具有请求的语言环境，而不是null 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#localizedBy(java.util.Locale)"><code>localizedBy(Locale)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="localizedBy(java.util.Locale)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>localizedBy</h4> <pre class="methodSignature">public&nbsp;<a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a>&nbsp;localizedBy​(<a href="../../util/Locale.html" title="class in java.util">Locale</a>&nbsp;locale)</pre> 
            <div class="block"> 
             <span>返回此格式化程序的副本，其中包含区域设置，日历，区域，小数样式和/或时区的本地化值，它们取代此格式化程序中的值。</span> 
             <p> <span>这用于查找需要特定本地化的格式化程序的任何部分，例如文本或本地化模式。</span> <span>如果区域设置包含“ca”（日历），“nu”（编号系统），“rg”（区域覆盖）和/或“tz”（时区） <a href="../../util/Locale.html#def_locale_extension">Unicode extensions</a> ，则年表，编号系统和/或区域为覆盖。</span> <span>如果同时指定了“ca”和“rg”，则来自“ca”扩展名的时间顺序将取代“rg”扩展名中的隐式值。</span> <span>“nu”扩展也是如此。</span> </p> 
             <p> <span>与<a href="#withLocale(java.util.Locale)"><code>withLocale</code></a>方法不同， <a href="#withLocale(java.util.Locale)">对此</a>方法的调用可能会产生不同的格式化程序，具体取决于与其他withXXXX（）方法链接的方法的顺序。</span> </p> 
             <p> <span>此实例是不可变的，不受此方法调用的影响。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>locale</code> - 语言环境，不为null 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               基于此格式化程序的格式化程序，具有日历，小数形式和/或时区的本地化值，取代此格式化程序中的值。 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               10 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#withLocale(java.util.Locale)"><code>withLocale(Locale)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getDecimalStyle()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getDecimalStyle</h4> <pre class="methodSignature">public&nbsp;<a href="DecimalStyle.html" title="class in java.time.format">DecimalStyle</a>&nbsp;getDecimalStyle()</pre> 
            <div class="block">
              获取格式化期间要使用的DecimalStyle。 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此格式化程序的语言环境，不为null 
             </dd> 
            </dl> </li> 
          </ul> <a id="withDecimalStyle(java.time.format.DecimalStyle)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>withDecimalStyle</h4> <pre class="methodSignature">public&nbsp;<a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a>&nbsp;withDecimalStyle​(<a href="DecimalStyle.html" title="class in java.time.format">DecimalStyle</a>&nbsp;decimalStyle)</pre> 
            <div class="block"> 
             <span>使用新的DecimalStyle返回此formatter的副本。</span> 
             <p> <span>此实例是不可变的，不受此方法调用的影响。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>decimalStyle</code> - 新的DecimalStyle，不为null 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               基于此格式化程序的格式化程序，具有请求的DecimalStyle，而不是null 
             </dd> 
            </dl> </li> 
          </ul> <a id="getChronology()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getChronology</h4> <pre class="methodSignature">public&nbsp;<a href="../chrono/Chronology.html" title="interface in java.time.chrono">Chronology</a>&nbsp;getChronology()</pre> 
            <div class="block"> 
             <span>获取格式化期间要使用的重写年代表。</span> 
             <p> <span>这将返回覆盖年表，用于转换日期。</span> <span>默认情况下，格式化程序没有覆盖时间顺序，返回null。</span> <span>有关<a href="#withChronology(java.time.chrono.Chronology)">覆盖</a>的更多详细信息，请参见<a href="#withChronology(java.time.chrono.Chronology)"><code>withChronology(Chronology)</code></a> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此格式化程序的重写时间顺序，如果没有重写，则返回null 
             </dd> 
            </dl> </li> 
          </ul> <a id="withChronology(java.time.chrono.Chronology)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>withChronology</h4> <pre class="methodSignature">public&nbsp;<a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a>&nbsp;withChronology​(<a href="../chrono/Chronology.html" title="interface in java.time.chrono">Chronology</a>&nbsp;chrono)</pre> 
            <div class="block"> 
             <span>返回此格式化程序的副本，其中包含新的覆盖时间顺序。</span> 
             <p> <span>这将返回一个格式化程序，该格式化程序具有与此格式化程序类似的状态，但设置了覆盖时间顺</span> <span>默认情况下，格式化程序没有覆盖时间顺序，返回null。</span> </p> 
             <p> <span>如果添加了覆盖，则格式化或解析的任何日期都将受到影响。</span> </p> 
             <p> <span>格式化时，如果时态对象包含日期，则它将转换为覆盖年表中的日期。</span> <span>是否包含日期是通过查询<a href="../temporal/ChronoField.html#EPOCH_DAY"><code>EPOCH_DAY</code></a>字段来确定的。</span> <span>除非被覆盖，否则任何时间或区域都将保持不变。</span> </p> 
             <p> <span>如果临时对象不包含日期，但包含一个或多个<code>ChronoField</code>日期字段，则抛出<code>DateTimeException</code> 。</span> <span>在所有其他情况下，覆盖年表被添加到时间，替换任何先前的年表，但不更改日期/时间。</span> </p> 
             <p> <span>解析时，需要考虑两种不同的情况。</span> <span>如果直接从文本中解析了年表，可能是因为使用了<a href="DateTimeFormatterBuilder.html#appendChronologyId()"><code>DateTimeFormatterBuilder.appendChronologyId()</code></a> ，那么这个覆盖年表没有任何效果。</span> <span>如果未解析任何区域，则将使用此覆盖年表按照年表的日期解析规则将<code>ChronoField</code>值解释为日期。</span> </p> 
             <p> <span>此实例是不可变的，不受此方法调用的影响。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>chrono</code> - 新的年表，如果没有覆盖则为null 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               基于此格式化程序的格式化程序，具有请求的覆盖时间顺序，而不是null 
             </dd> 
            </dl> </li> 
          </ul> <a id="getZone()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getZone</h4> <pre class="methodSignature">public&nbsp;<a href="../ZoneId.html" title="class in java.time">ZoneId</a>&nbsp;getZone()</pre> 
            <div class="block"> 
             <span>获取格式化期间要使用的覆盖区域。</span> 
             <p> <span>这将返回覆盖区域，用于转换瞬间。</span> <span>默认情况下，格式化程序没有覆盖区域，返回null。</span> <span>有关<a href="#withZone(java.time.ZoneId)">覆盖</a>的更多详细信息，请参见<a href="#withZone(java.time.ZoneId)"><code>withZone(ZoneId)</code></a> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此格式化程序的覆盖区域，如果没有覆盖，则返回null 
             </dd> 
            </dl> </li> 
          </ul> <a id="withZone(java.time.ZoneId)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>withZone</h4> <pre class="methodSignature">public&nbsp;<a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a>&nbsp;withZone​(<a href="../ZoneId.html" title="class in java.time">ZoneId</a>&nbsp;zone)</pre> 
            <div class="block"> 
             <span>使用新的覆盖区域返回此格式化程序的副本。</span> 
             <p> <span>这将返回一个格式化程序，其状态与此格式化程序类似，但设置了覆盖区域。</span> <span>默认情况下，格式化程序没有覆盖区域，返回null。</span> </p> 
             <p> <span>如果添加了覆盖，则任何格式化或解析的瞬间都将受到影响。</span> </p> 
             <p> <span>格式化时，如果临时对象包含瞬间，则使用覆盖区域将其转换为分区日期时间。</span> <span>是否瞬时是通过查询<a href="../temporal/ChronoField.html#INSTANT_SECONDS"><code>INSTANT_SECONDS</code></a>字段来确定的。</span> <span>如果输入具有时间顺序，那么除非被覆盖，否则它将被保留。</span> <span>如果输入没有年表，例如<code>Instant</code> ，那么将使用ISO年表。</span> </p> 
             <p> <span>如果临时对象不包含瞬间，但确实包含偏移量，则进行额外检查。</span> <span>如果规范化的覆盖区域是与时间偏移不同的偏移，则抛出<code>DateTimeException</code> 。</span> <span>在所有其他情况下，覆盖区域将添加到时间，替换任何以前的区域，但不更改日期/时间。</span> </p> 
             <p> <span>解析时，需要考虑两种不同的情况。</span> <span>如果区域已直接从文本中解析，可能是因为使用了<a href="DateTimeFormatterBuilder.html#appendZoneId()"><code>DateTimeFormatterBuilder.appendZoneId()</code></a> ，则此覆盖区域无效。</span> <span>如果没有解析区域，则此覆盖区域将包含在解析结果中，可用于构建时刻和日期时间。</span> </p> 
             <p> <span>此实例是不可变的，不受此方法调用的影响。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>zone</code> - 新的覆盖区域，如果没有覆盖，则为null 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               基于此格式化程序的格式化程序，具有请求的覆盖区域，而不是null 
             </dd> 
            </dl> </li> 
          </ul> <a id="getResolverStyle()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getResolverStyle</h4> <pre class="methodSignature">public&nbsp;<a href="ResolverStyle.html" title="enum in java.time.format">ResolverStyle</a>&nbsp;getResolverStyle()</pre> 
            <div class="block"> 
             <span>获取解析期间要使用的解析器样式。</span> 
             <p> <span>这将返回解析器样式，在解析第二阶段时将字段解析为日期和时间。</span> <span>默认情况下，格式化程序具有<a href="ResolverStyle.html#SMART"><code>SMART</code></a>解析程序样式。</span> <span>有关详细信息，请参见<a href="#withResolverStyle(java.time.format.ResolverStyle)"><code>withResolverStyle(ResolverStyle)</code></a> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此格式化程序的解析器样式，不为null 
             </dd> 
            </dl> </li> 
          </ul> <a id="withResolverStyle(java.time.format.ResolverStyle)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>withResolverStyle</h4> <pre class="methodSignature">public&nbsp;<a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a>&nbsp;withResolverStyle​(<a href="ResolverStyle.html" title="enum in java.time.format">ResolverStyle</a>&nbsp;resolverStyle)</pre> 
            <div class="block"> 
             <span>使用新的解析程序样式返回此formatter的副本。</span> 
             <p> <span>这将返回一个格式化程序，其状态与此格式化程序类似，但设置了解析程序样式。</span> <span>默认情况下，格式化程序具有<a href="ResolverStyle.html#SMART"><code>SMART</code></a>解析程序样式。</span> </p> 
             <p> <span>更改解析程序样式仅在解析期间有效。</span> <span>解析文本字符串分两个阶段进行。</span> <span>阶段1是根据添加到构建器的字段的基本文本解析。</span> <span>阶段2将解析的字段 - 值对解析为日期和/或时间对象。</span> <span>解析器样式用于控制阶段2解析的发生方式。</span> <span>有关可用选项的更多信息，请参见<code>ResolverStyle</code> 。</span> </p> 
             <p> <span>此实例是不可变的，不受此方法调用的影响。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>resolverStyle</code> - 新的解析器样式，不为null 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               基于此格式化程序的格式化程序，具有请求的解析程序样式，而不是null 
             </dd> 
            </dl> </li> 
          </ul> <a id="getResolverFields()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getResolverFields</h4> <pre class="methodSignature">public&nbsp;<a href="../../util/Set.html" title="interface in java.util">Set</a>&lt;<a href="../temporal/TemporalField.html" title="interface in java.time.temporal">TemporalField</a>&gt;&nbsp;getResolverFields()</pre> 
            <div class="block"> 
             <span>获取解析期间要使用的解析器字段。</span> 
             <p> <span>这将返回解析器字段，在解析第二阶段时将字段解析为日期和时间。</span> <span>默认情况下，格式化程序没有解析器字段，因此返回null。</span> <span>有关详细信息，请参见<a href="#withResolverFields(java.util.Set)"><code>withResolverFields(Set)</code></a> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此格式化程序的不可变的解析程序字段集，如果没有字段则为null 
             </dd> 
            </dl> </li> 
          </ul> <a id="withResolverFields(java.time.temporal.TemporalField...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>withResolverFields</h4> <pre class="methodSignature">public&nbsp;<a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a>&nbsp;withResolverFields​(<a href="../temporal/TemporalField.html" title="interface in java.time.temporal">TemporalField</a>...&nbsp;resolverFields)</pre> 
            <div class="block"> 
             <span>返回此格式化程序的副本，其中包含一组新的解析程序字段。</span> 
             <p> <span>这将返回一个格式化程序，其状态与此格式化程序类似，但设置了解析程序字段。</span> <span>默认情况下，格式化程序没有解析程序字段。</span> </p> 
             <p> <span>更改解析程序字段仅在解析期间有效。</span> <span>解析文本字符串分两个阶段进行。</span> <span>阶段1是根据添加到构建器的字段的基本文本解析。</span> <span>阶段2将解析的字段 - 值对解析为日期和/或时间对象。</span> <span>解析器字段用于过滤阶段1和阶段2之间的字段 - 值对。</span> </p> 
             <p> <span>这可用于在两种或更多种方式之间进行选择，以便解决日期或时间。</span> <span>例如，如果格式化程序包含年，月，日，日和年，则有两种方法可以解决日期问题。</span> <span>使用参数<a href="../temporal/ChronoField.html#YEAR"><code>YEAR</code></a>和<a href="../temporal/ChronoField.html#DAY_OF_YEAR"><code>DAY_OF_YEAR</code></a>调用此方法将确保使用年份和日期解析日期，这实际上意味着在解决阶段忽略月份和日期。</span> </p> 
             <p> <span>以类似的方式，该方法可用于忽略否则将被交叉检查的辅助字段。</span> <span>例如，如果格式化程序包含年，月，日，星期和星期几，那么只有一种方法可以解决日期，但是星期几的解析值将被交叉检查反对解决的日期。</span> <span>调用此方法与参数<a href="../temporal/ChronoField.html#YEAR"><code>YEAR</code></a> ， <a href="../temporal/ChronoField.html#MONTH_OF_YEAR"><code>MONTH_OF_YEAR</code></a>和<a href="../temporal/ChronoField.html#DAY_OF_MONTH"><code>DAY_OF_MONTH</code></a>将确保日期是正确解决，但没有任何交叉检查的某一天的一周。</span> </p> 
             <p> <span>在实现方面，该方法表现如下。</span> <span>解析阶段的结果可以被认为是字段到值的映射。</span> <span>此方法的行为是使该映射在阶段1和阶段2之间进行过滤，删除除指定为此方法的参数之外的所有字段。</span> </p> 
             <p> <span>此实例是不可变的，不受此方法调用的影响。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>resolverFields</code> - 新的解析程序字段集，如果没有字段，则为null 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               基于此格式化程序的格式化程序，具有请求的解析程序样式，而不是null 
             </dd> 
            </dl> </li> 
          </ul> <a id="withResolverFields(java.util.Set)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>withResolverFields</h4> <pre class="methodSignature">public&nbsp;<a href="DateTimeFormatter.html" title="class in java.time.format">DateTimeFormatter</a>&nbsp;withResolverFields​(<a href="../../util/Set.html" title="interface in java.util">Set</a>&lt;<a href="../temporal/TemporalField.html" title="interface in java.time.temporal">TemporalField</a>&gt;&nbsp;resolverFields)</pre> 
            <div class="block"> 
             <span>返回此格式化程序的副本，其中包含一组新的解析程序字段。</span> 
             <p> <span>这将返回一个格式化程序，其状态与此格式化程序类似，但设置了解析程序字段。</span> <span>默认情况下，格式化程序没有解析程序字段。</span> </p> 
             <p> <span>更改解析程序字段仅在解析期间有效。</span> <span>解析文本字符串分两个阶段进行。</span> <span>阶段1是根据添加到构建器的字段的基本文本解析。</span> <span>阶段2将解析的字段 - 值对解析为日期和/或时间对象。</span> <span>解析器字段用于过滤阶段1和阶段2之间的字段 - 值对。</span> </p> 
             <p> <span>这可用于在两种或更多种方式之间进行选择，以便解决日期或时间。</span> <span>例如，如果格式化程序包含年，月，日，日和年，则有两种方法可以解决日期问题。</span> <span>使用参数<a href="../temporal/ChronoField.html#YEAR"><code>YEAR</code></a>和<a href="../temporal/ChronoField.html#DAY_OF_YEAR"><code>DAY_OF_YEAR</code></a>调用此方法将确保使用年份和年份解析日期，这实际上意味着在解析阶段忽略月份和日期。</span> </p> 
             <p> <span>以类似的方式，该方法可用于忽略否则将被交叉检查的辅助字段。</span> <span>例如，如果格式化程序包含年，月，日，星期和星期几，那么只有一种方法可以解决日期，但是星期几的解析值将被交叉检查反对解决的日期。</span> <span>调用此方法与参数<a href="../temporal/ChronoField.html#YEAR"><code>YEAR</code></a> ， <a href="../temporal/ChronoField.html#MONTH_OF_YEAR"><code>MONTH_OF_YEAR</code></a>和<a href="../temporal/ChronoField.html#DAY_OF_MONTH"><code>DAY_OF_MONTH</code></a>将确保日期是正确解决，但没有任何交叉检查的某一天的一周。</span> </p> 
             <p> <span>在实现方面，该方法表现如下。</span> <span>解析阶段的结果可以被认为是字段到值的映射。</span> <span>此方法的行为是使该映射在阶段1和阶段2之间进行过滤，删除除指定为此方法的参数之外的所有字段。</span> </p> 
             <p> <span>此实例是不可变的，不受此方法调用的影响。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>resolverFields</code> - 新的解析器字段集，如果没有字段，则为null 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               基于此格式化程序的格式化程序，具有请求的解析程序样式，而不是null 
             </dd> 
            </dl> </li> 
          </ul> <a id="format(java.time.temporal.TemporalAccessor)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>format</h4> <pre class="methodSignature">public&nbsp;<a href="../../lang/String.html" title="class in java.lang">String</a>&nbsp;format​(<a href="../temporal/TemporalAccessor.html" title="interface in java.time.temporal">TemporalAccessor</a>&nbsp;temporal)</pre> 
            <div class="block"> 
             <span>使用此格式化程序格式化日期时间对象。</span> 
             <p> <span>这使用格式化程序的规则将日期时间格式化为String。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>temporal</code> - 要格式化的时态对象，而不是null 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               格式化的字符串，不是null 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../DateTimeException.html" title="class in java.time">DateTimeException</a></code> - 如果格式化期间发生错误 
             </dd> 
            </dl> </li> 
          </ul> <a id="formatTo(java.time.temporal.TemporalAccessor,java.lang.Appendable)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>formatTo</h4> <pre class="methodSignature">public&nbsp;void&nbsp;formatTo​(<a href="../temporal/TemporalAccessor.html" title="interface in java.time.temporal">TemporalAccessor</a>&nbsp;temporal,
                     <a href="../../lang/Appendable.html" title="interface in java.lang">Appendable</a>&nbsp;appendable)</pre> 
            <div class="block"> 
             <span>使用此格式化程序将日期时间对象格式化为<code>Appendable</code> 。</span> 
             <p> <span>这会将格式化的日期时间输出到指定的目的地。</span> <span><a href="../../lang/Appendable.html" title="java.lang中的接口"><code>Appendable</code></a>是受所有键字符输出类别，包括实现一个通用接口<code>StringBuffer</code> ， <code>StringBuilder</code> ， <code>PrintStream</code>和<code>Writer</code> 。</span> </p> 
             <p> <span>虽然<code>Appendable</code>方法抛出<code>IOException</code> ，但这种方法没有。</span> <span>相反，任何<code>IOException</code>都包含在运行时异常中。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>temporal</code> - 要格式化的时态对象，而不是null 
             </dd> 
             <dd> 
              <code>appendable</code> - 可以格式化为，不为null 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../DateTimeException.html" title="class in java.time">DateTimeException</a></code> - 如果格式化期间发生错误 
             </dd> 
            </dl> </li> 
          </ul> <a id="parse(java.lang.CharSequence)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>parse</h4> <pre class="methodSignature">public&nbsp;<a href="../temporal/TemporalAccessor.html" title="interface in java.time.temporal">TemporalAccessor</a>&nbsp;parse​(<a href="../../lang/CharSequence.html" title="interface in java.lang">CharSequence</a>&nbsp;text)</pre> 
            <div class="block"> 
             <span>完全解析生成临时对象的文本。</span> 
             <p> <span>这会解析生成临时对象的整个文本。</span> <span>使用<a href="#parse(java.lang.CharSequence,java.time.temporal.TemporalQuery)"><code>parse(CharSequence, TemporalQuery)</code></a>通常更有用。</span> <span>此方法的结果是<code>TemporalAccessor</code>已经解决，应用基本验证检查以帮助确保有效的日期时间。</span> </p> 
             <p> <span>如果解析完成而没有读取文本的整个长度，或者在解析或合并期间出现问题，则抛出异常。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>text</code> - 要解析的文本，而不是null 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               解析的时态对象，而不是null 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="DateTimeParseException.html" title="class in java.time.format">DateTimeParseException</a></code> - 如果无法解析请求的结果 
             </dd> 
            </dl> </li> 
          </ul> <a id="parse(java.lang.CharSequence,java.text.ParsePosition)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>parse</h4> <pre class="methodSignature">public&nbsp;<a href="../temporal/TemporalAccessor.html" title="interface in java.time.temporal">TemporalAccessor</a>&nbsp;parse​(<a href="../../lang/CharSequence.html" title="interface in java.lang">CharSequence</a>&nbsp;text,
                              <a href="../../text/ParsePosition.html" title="class in java.text">ParsePosition</a>&nbsp;position)</pre> 
            <div class="block"> 
             <span>使用此格式化程序解析文本，提供对文本位置的控制。</span> 
             <p> <span>这解析文本而不要求解析从字符串的开头开始或在结束时完成。</span> <span>此方法的结果是<code>TemporalAccessor</code>已经解决，应用基本验证检查以帮助确保有效的日期时间。</span> </p> 
             <p> <span>该文本将从指定的开始<code>ParsePosition</code>解析。</span> <span>无需解析文本的整个长度， <code>ParsePosition</code>将在解析结束时使用索引进行更新。</span> </p> 
             <p> <span>该方法的操作与在<code>java.text.Format</code>上使用<code>ParsePosition</code>类似方法略有不同。</span> <span>该类将使用<code>ParsePosition</code>上的错误索引返回错误。</span> <span>相反，如果发生错误，此方法将抛出<a href="DateTimeParseException.html" title="java.time.format中的类"><code>DateTimeParseException</code></a> ，异常包含错误索引。</span> <span>由于此API中解析和解析日期/时间的复杂性增加，因此这种行为更改是必要的。</span> </p> 
             <p> <span>如果格式化程序使用不同的值多次解析同一字段，则结果将是错误。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>text</code> - 要解析的文本，而不是null 
             </dd> 
             <dd> 
              <code>position</code> - 要解析的位置，使用已解析的长度和任何错误的索引进行更新，而不是null 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               解析的时态对象，而不是null 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="DateTimeParseException.html" title="class in java.time.format">DateTimeParseException</a></code> - 如果无法解析请求的结果 
             </dd> 
             <dd> 
              <code><a href="../../lang/IndexOutOfBoundsException.html" title="class in java.lang">IndexOutOfBoundsException</a></code> - 如果头寸无效 
             </dd> 
            </dl> </li> 
          </ul> <a id="parse(java.lang.CharSequence,java.time.temporal.TemporalQuery)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>parse</h4> <pre class="methodSignature">public&nbsp;&lt;T&gt;&nbsp;T&nbsp;parse​(<a href="../../lang/CharSequence.html" title="interface in java.lang">CharSequence</a>&nbsp;text,
                   <a href="../temporal/TemporalQuery.html" title="interface in java.time.temporal">TemporalQuery</a>&lt;T&gt;&nbsp;query)</pre> 
            <div class="block"> 
             <span>完全解析生成指定类型对象的文本。</span> 
             <p> <span>大多数应用程序应该使用此方法进行解析。</span> <span>它解析整个文本以生成所需的日期时间。</span> <span>该查询通常是对<code>from(TemporalAccessor)</code>方法的方法引用。</span> <span>例如：</span> </p> 
             <pre>  <span>LocalDateTime dt = parser.parse(str, LocalDateTime::from);</span> </pre> 
             <span>如果解析完成而没有读取文本的整个长度，或者在解析或合并期间出现问题，则抛出异常。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 已解析日期时间的类型 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>text</code> - 要解析的文本，而不是null 
             </dd> 
             <dd> 
              <code>query</code> - 定义要解析的类型的查询，而不是null 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               解析的日期时间，而不是null 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="DateTimeParseException.html" title="class in java.time.format">DateTimeParseException</a></code> - 如果无法解析请求的结果 
             </dd> 
            </dl> </li> 
          </ul> <a id="parseBest(java.lang.CharSequence,java.time.temporal.TemporalQuery...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>parseBest</h4> <pre class="methodSignature">public&nbsp;<a href="../temporal/TemporalAccessor.html" title="interface in java.time.temporal">TemporalAccessor</a>&nbsp;parseBest​(<a href="../../lang/CharSequence.html" title="interface in java.lang">CharSequence</a>&nbsp;text,
                                  <a href="../temporal/TemporalQuery.html" title="interface in java.time.temporal">TemporalQuery</a>&lt;?&gt;...&nbsp;queries)</pre> 
            <div class="block"> 
             <span>完全解析生成指定类型之一的对象的文本。</span> 
             <p> <span>当解析器可以处理可选元素时，此解析方法很方便使用。</span> <span>例如，'uuuu-MM-dd HH.mm [VV]'的模式可以完全解析为<code>ZonedDateTime</code> ，或部分解析为<code>LocalDateTime</code> 。</span> <span>必须按顺序指定查询，从最佳匹配的完全解析选项开始，以最差匹配的最小解析选项结束。</span> <span>该查询通常是对<code>from(TemporalAccessor)</code>方法的方法引用。</span> </p> 
             <p> <span>结果与成功解析的第一个类型相关联。</span> <span>通常，应用程序将使用<code>instanceof</code>来检查结果。</span> <span>例如：</span> </p> 
             <pre>  <span>TemporalAccessor dt = parser.parseBest(str, ZonedDateTime::from, LocalDateTime::from);
  if (dt instanceof ZonedDateTime) {
   ...
  } else {
   ...
  }</span> </pre> 
             <span>如果解析完成而没有读取文本的整个长度，或者在解析或合并期间出现问题，则抛出异常。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>text</code> - 要解析的文本，而不是null 
             </dd> 
             <dd> 
              <code>queries</code> - 定义要尝试解析的类型的查询，必须实现 
              <code>TemporalAccessor</code> ，而不是null 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               解析的日期时间，而不是null 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果指定的类型少于2种 
             </dd> 
             <dd> 
              <code><a href="DateTimeParseException.html" title="class in java.time.format">DateTimeParseException</a></code> - 如果无法解析请求的结果 
             </dd> 
            </dl> </li> 
          </ul> <a id="parseUnresolved(java.lang.CharSequence,java.text.ParsePosition)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>parseUnresolved</h4> <pre class="methodSignature">public&nbsp;<a href="../temporal/TemporalAccessor.html" title="interface in java.time.temporal">TemporalAccessor</a>&nbsp;parseUnresolved​(<a href="../../lang/CharSequence.html" title="interface in java.lang">CharSequence</a>&nbsp;text,
                                        <a href="../../text/ParsePosition.html" title="class in java.text">ParsePosition</a>&nbsp;position)</pre> 
            <div class="block"> 
             <span>使用此格式化程序解析文本，而不解析结果，用于高级用例。</span> 
             <p> <span>解析实现为两阶段操作。</span> <span>首先，使用格式化程序定义的布局解析文本，生成<code>Map</code>字段值， <code>ZoneId</code>和<code>Chronology</code> 。</span> <span>其次，分析的数据<em>解析</em> ，通过验证，合并和简化了各领域到更多有用的。</span> <span>此方法执行解析阶段但不执行解析阶段。</span> </p> 
             <p> <span>该方法的结果是<code>TemporalAccessor</code> ，它表示输入中看到的数据。</span> <span>未验证值，因此解析日期字符串'2012-00-65'将导致具有三个字段的时间 - '2012'年，'0'月和'65'月日。</span> </p> 
             <p> <span>该文本将从指定的开始<code>ParsePosition</code>解析。</span> <span>无需解析文本的整个长度， <code>ParsePosition</code>将在解析结束时使用索引进行更新。</span> </p> 
             <p> <span>使用<code>ParsePosition</code>的错误索引字段而不是<code>DateTimeParseException</code>返回错误。</span> <span>返回的错误索引将设置为指示错误的索引。</span> <span>在使用结果之前，呼叫者必须检查错误。</span> </p> 
             <p> <span>如果格式化程序使用不同的值多次解析同一字段，则结果将是错误。</span> </p> 
             <p> <span>此方法适用于在解析期间需要访问内部状态的高级用例。</span> <span>典型的应用程序代码应使用<a href="#parse(java.lang.CharSequence,java.time.temporal.TemporalQuery)"><code>parse(CharSequence, TemporalQuery)</code></a>或目标类型的解析方法。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>text</code> - 要解析的文本，而不是null 
             </dd> 
             <dd> 
              <code>position</code> - 要解析的位置，使用已解析的长度和任何错误的索引进行更新，而不是null 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               解析后的文本，如果解析导致错误，则返回null 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../DateTimeException.html" title="class in java.time">DateTimeException</a></code> - 如果在解析过程中出现问题 
             </dd> 
             <dd> 
              <code><a href="../../lang/IndexOutOfBoundsException.html" title="class in java.lang">IndexOutOfBoundsException</a></code> - 如果头寸无效 
             </dd> 
            </dl> </li> 
          </ul> <a id="toFormat()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>toFormat</h4> <pre class="methodSignature">public&nbsp;<a href="../../text/Format.html" title="class in java.text">Format</a>&nbsp;toFormat()</pre> 
            <div class="block"> 
             <span>将此格式化程序作为<code>java.text.Format</code>实例返回。</span> 
             <p> <span>返回的<a href="../../text/Format.html" title="java.text中的类"><code>Format</code></a>实例将格式化任何<a href="../temporal/TemporalAccessor.html" title="java.time.temporal中的接口"><code>TemporalAccessor</code></a>并解析为已解析的<a href="../temporal/TemporalAccessor.html" title="java.time.temporal中的接口"><code>TemporalAccessor</code></a> 。</span> </p> 
             <p> <span>例外情况将遵循<code>Format</code>的定义，有关<code>IllegalArgumentException</code>期间<code>ParseException</code>和<code>ParseException</code>详细信息，请参阅这些方法，或者在解析期间<code>ParseException</code> null。</span> <span>格式不支持归属返回的格式字符串。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此格式化程序作为经典格式实例，不为null 
             </dd> 
            </dl> </li> 
          </ul> <a id="toFormat(java.time.temporal.TemporalQuery)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>toFormat</h4> <pre class="methodSignature">public&nbsp;<a href="../../text/Format.html" title="class in java.text">Format</a>&nbsp;toFormat​(<a href="../temporal/TemporalQuery.html" title="interface in java.time.temporal">TemporalQuery</a>&lt;?&gt;&nbsp;parseQuery)</pre> 
            <div class="block"> 
             <span>将此格式化程序作为将使用指定查询进行分析的<code>java.text.Format</code>实例返回。</span> 
             <p> <span>返回的<a href="../../text/Format.html" title="java.text中的类"><code>Format</code></a>实例将格式化任何<a href="../temporal/TemporalAccessor.html" title="java.time.temporal中的接口"><code>TemporalAccessor</code></a>并解析为指定的类型。</span> <span>该类型必须是<a href="#parse(java.lang.CharSequence)"><code>parse(java.lang.CharSequence)</code></a>支持的<a href="#parse(java.lang.CharSequence)">类型</a> 。</span> </p> 
             <p> <span>例外将遵循<code>Format</code>的定义，有关<code>IllegalArgumentException</code>期间<code>ParseException</code>和<code>ParseException</code>详细信息，请参阅这些方法，或者在解析期间<code>ParseException</code> null。</span> <span>格式不支持归属返回的格式字符串。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>parseQuery</code> - 定义要解析的类型的查询，而不是null 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此格式化程序作为经典格式实例，不为null 
             </dd> 
            </dl> </li> 
          </ul> <a id="toString()"> 
           <!--   --> </a> 
          <ul class="blockListLast"> 
           <li class="blockList"> <h4>toString</h4> <pre class="methodSignature">public&nbsp;<a href="../../lang/String.html" title="class in java.lang">String</a>&nbsp;toString()</pre> 
            <div class="block">
              返回底层格式化程序的描述。 
            </div> 
            <dl> 
             <dt> 
              <span class="overrideSpecifyLabel">重写：</span> 
             </dt> 
             <dd> 
              <code><a href="../../lang/Object.html#toString()">toString</a></code> ，课程 
              <code><a href="../../lang/Object.html" title="class in java.lang">Object</a></code> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此格式化程序的描述，不为null 
             </dd> 
            </dl> </li> 
          </ul> </li> 
        </ul> 
       </section> </li> 
     </ul> 
    </div> 
   </div> 
  </main> 
  <!-- ========= END OF CLASS DATA ========= --> 
  <footer role="contentinfo"> 
   <nav role="navigation"> 
    <!-- ======= START OF BOTTOM NAVBAR ====== --> 
    <div class="bottomNav"> 
     <a id="navbar.bottom"> 
      <!--   --> </a> 
     <div class="skipNav"> 
      <a href="#skip.navbar.bottom" title="Skip navigation links">跳过导航</a> 
     </div> 
     <a id="navbar.bottom.firstrow"> 
      <!--   --> </a> 
     <ul class="navList" title="Navigation"> 
      <li><a href="../../../../index.html">概述</a></li> 
      <li><a href="../../../module-summary.html">模块</a></li> 
      <li><a href="package-summary.html">软件包</a></li> 
      <li class="navBarCell1Rev">类</li> 
      <li><a href="class-use/DateTimeFormatter.html">使用</a></li> 
      <li><a href="package-tree.html">树</a></li> 
      <li><a href="../../../../deprecated-list.html">已过时的</a></li> 
      <li><a href="../../../../index-files/index-1.html">索引</a></li> 
      <li><a href="../../../../help-doc.html">帮助</a></li> 
     </ul> 
     <div class="aboutLanguage"> 
      <div style="margin-top: 14px;"> 
       <strong>Java SE 11 &amp; JDK 11</strong> 
      </div> 
     </div> 
    </div> 
    <div class="subNav"> 
     <ul class="navList" id="allclasses_navbar_bottom"> 
      <li><a href="../../../../allclasses.html">所有类</a></li> 
     </ul> 
     <div> 
      <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
      <noscript> 
       <div>
         JavaScript is disabled on your browser. 
       </div> 
      </noscript> 
     </div> 
     <div> 
      <ul class="subNavList"> 
       <li>概要：&nbsp;</li> 
       <li>嵌套&nbsp;|&nbsp;</li> 
       <li><a href="#field.summary">字段</a>&nbsp;|&nbsp;</li> 
       <li>构造方法&nbsp;|&nbsp;</li> 
       <li><a href="#method.summary">方法</a></li> 
      </ul> 
      <ul class="subNavList"> 
       <li>详细信息：&nbsp;</li> 
       <li><a href="#field.detail">字段</a>&nbsp;|&nbsp;</li> 
       <li>构造方法&nbsp;|&nbsp;</li> 
       <li><a href="#method.detail">方法</a></li> 
      </ul> 
     </div> 
     <a id="skip.navbar.bottom"> 
      <!--   --> </a> 
    </div> 
    <!-- ======== END OF BOTTOM NAVBAR ======= --> 
   </nav> 
   <p class="legalCopy"><small><a href="http://bugreport.java.com/bugreport/">Report a bug or suggest an enhancement</a><br> For further API reference and developer documentation see the <a href="http://www.oracle.com/pls/topic/lookup?ctx=javase11.0.1&amp;id=homepage" target="_blank">Java SE Documentation</a>, which contains more detailed, developer-targeted descriptions with conceptual overviews, definitions of terms, workarounds, and working code examples.<br> Java is a trademark or registered trademark of Oracle and/or its affiliates in the US and other countries.<br> <a href="../../../../../legal/copyright.html">Copyright</a> © 1993, 2018, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.<br>All rights reserved. Use is subject to <a href="http://www.oracle.com/technetwork/java/javase/terms/license/java11.0.1speclicense.html">license terms</a> and the <a href="http://www.oracle.com/technetwork/java/redist-137594.html">documentation redistribution policy</a>. 
     <!-- Version 11.0.1+13-LTS --></small></p> 
  </footer>  
 </body>
</html>