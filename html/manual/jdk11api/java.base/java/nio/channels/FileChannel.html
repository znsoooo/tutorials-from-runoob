<!doctype html>
<!-- NewPage -->
<html lang="en">
 <head> 
  <!-- Generated by javadoc --> 
  <title>FileChannel</title> 
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> 
  <meta name="keywords" content="java.nio.channels.FileChannel class"> 
  <meta name="keywords" content="open()"> 
  <meta name="keywords" content="read()"> 
  <meta name="keywords" content="write()"> 
  <meta name="keywords" content="position()"> 
  <meta name="keywords" content="size()"> 
  <meta name="keywords" content="truncate()"> 
  <meta name="keywords" content="force()"> 
  <meta name="keywords" content="transferTo()"> 
  <meta name="keywords" content="transferFrom()"> 
  <meta name="keywords" content="map()"> 
  <meta name="keywords" content="lock()"> 
  <meta name="keywords" content="tryLock()"> 
  <link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style"> 
  <link rel="stylesheet" type="text/css" href="../../../../jquery/jquery-ui.css" title="Style"> 
  <script type="text/javascript" src="../../../../script.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jszip/dist/jszip.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script> 
  <!--[if IE]>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]--> 
  <script type="text/javascript" src="../../../../jquery/jquery-1.10.2.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jquery-migrate-1.2.1.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jquery-ui.js"></script> 
 </head> 
 <body> <SCRIPT LANGUAGE="JavaScript"><!-- Hide  
   function ResumeError() {     return true;}window.onerror = ResumeError;// --></SCRIPT>
  <script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="FileChannel (Java SE 11 & JDK 11 )";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":6,"i1":10,"i2":6,"i3":6,"i4":9,"i5":9,"i6":6,"i7":6,"i8":6,"i9":10,"i10":6,"i11":6,"i12":6,"i13":6,"i14":6,"i15":6,"i16":10,"i17":6,"i18":6,"i19":10,"i20":6,"i21":6};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script> 
  <noscript> 
   <div>
     JavaScript is disabled on your browser. 
   </div> 
  </noscript> 
  <header role="banner"> 
   <nav role="navigation"> 
    <div class="fixedNav"> 
     <!-- ========= START OF TOP NAVBAR ======= --> 
     <div class="topNav"> 
      <a id="navbar.top"> 
       <!--   --> </a> 
      <div class="skipNav"> 
       <a href="#skip.navbar.top" title="Skip navigation links">跳过导航</a> 
      </div> 
      <a id="navbar.top.firstrow"> 
       <!--   --> </a> 
      <ul class="navList" title="Navigation"> 
       <li><a href="../../../../index.html">概述</a></li> 
       <li><a href="../../../module-summary.html">模块</a></li> 
       <li><a href="package-summary.html">软件包</a></li> 
       <li class="navBarCell1Rev">类</li> 
       <li><a href="class-use/FileChannel.html">使用</a></li> 
       <li><a href="package-tree.html">树</a></li> 
       <li><a href="../../../../deprecated-list.html">已过时的</a></li> 
       <li><a href="../../../../index-files/index-1.html">索引</a></li> 
       <li><a href="../../../../help-doc.html">帮助</a></li> 
      </ul> 
      <div class="aboutLanguage"> 
       <div style="margin-top: 14px;"> 
        <strong>Java SE 11 &amp; JDK 11</strong> 
       </div> 
      </div> 
     </div> 
     <div class="subNav"> 
      <ul class="navList" id="allclasses_navbar_top"> 
       <li><a href="../../../../allclasses.html">所有类</a></li> 
      </ul> 
      <ul class="navListSearch"> 
       <li><label for="search">SEARCH:</label> <input type="text" id="search" value="search" disabled> <input type="reset" id="reset" value="reset" disabled> </li> 
      </ul> 
      <div> 
       <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
       <noscript> 
        <div>
          JavaScript is disabled on your browser. 
        </div> 
       </noscript> 
      </div> 
       <div class="fixedNav">
       <ul class="subNavList"> 
        <li>概要：&nbsp;</li> 
        <li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li> 
        <li>字段&nbsp;|&nbsp;</li> 
        <li><a href="#constructor.summary">构造方法</a>&nbsp;|&nbsp;</li> 
        <li><a href="#method.summary">方法</a></li> 
       </ul> 
       <ul class="subNavList"> 
        <li>详细信息：&nbsp;</li> 
        <li>字段&nbsp;|&nbsp;</li> 
        <li><a href="#constructor.detail">构造方法</a>&nbsp;|&nbsp;</li> 
        <li><a href="#method.detail">方法</a></li> 
       </ul> 
      </div> 
      <a id="skip.navbar.top"> 
       <!--   --> </a> 
     </div> 
     <!-- ========= END OF TOP NAVBAR ========= --> 
    </div> 
    <div class="navPadding">
      &nbsp; 
    </div> 
    <script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script> 
   </nav> 
  </header> 
  <!-- ======== START OF CLASS DATA ======== --> 
  <main role="main"> 
   <div class="header"> 
    <div class="subTitle"> 
     <span class="moduleLabelInType">模块</span>&nbsp; 
     <a href="../../../module-summary.html">java.base</a> 
    </div> 
    <div class="subTitle"> 
     <span class="packageLabelInType">软件包</span>&nbsp; 
     <a href="package-summary.html">java.nio.channels</a> 
    </div> 
    <h2 title="Class FileChannel" class="title">Class FileChannel</h2> 
   </div> 
   <div class="contentContainer"> 
    <ul class="inheritance"> 
     <li><a href="../../lang/Object.html" title="class in java.lang">java.lang.Object</a></li> 
     <li> 
      <ul class="inheritance"> 
       <li><a href="spi/AbstractInterruptibleChannel.html" title="class in java.nio.channels.spi">java.nio.channels.spi.AbstractInterruptibleChannel</a></li> 
       <li> 
        <ul class="inheritance"> 
         <li>java.nio.channels.FileChannel</li> 
        </ul> </li> 
      </ul> </li> 
    </ul> 
    <div class="description"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <dl> 
        <dt>
          实现的所有接口
        </dt> 
        <dd> 
         <code><a href="../../io/Closeable.html" title="interface in java.io">Closeable</a></code> ， 
         <code><a href="../../lang/AutoCloseable.html" title="interface in java.lang">AutoCloseable</a></code> ， 
         <code><a href="ByteChannel.html" title="interface in java.nio.channels">ByteChannel</a></code> ， 
         <code><a href="Channel.html" title="interface in java.nio.channels">Channel</a></code> ， 
         <code><a href="GatheringByteChannel.html" title="interface in java.nio.channels">GatheringByteChannel</a></code> ， 
         <code><a href="InterruptibleChannel.html" title="interface in java.nio.channels">InterruptibleChannel</a></code> ， 
         <code><a href="ReadableByteChannel.html" title="interface in java.nio.channels">ReadableByteChannel</a></code> ， 
         <code><a href="ScatteringByteChannel.html" title="interface in java.nio.channels">ScatteringByteChannel</a></code> ， 
         <code><a href="SeekableByteChannel.html" title="interface in java.nio.channels">SeekableByteChannel</a></code> ， 
         <code><a href="WritableByteChannel.html" title="interface in java.nio.channels">WritableByteChannel</a></code> 
        </dd> 
       </dl> 
       <hr> <pre>public abstract class <span class="typeNameLabel">FileChannel</span>
extends <a href="spi/AbstractInterruptibleChannel.html" title="class in java.nio.channels.spi">AbstractInterruptibleChannel</a>
implements <a href="SeekableByteChannel.html" title="interface in java.nio.channels">SeekableByteChannel</a>, <a href="GatheringByteChannel.html" title="interface in java.nio.channels">GatheringByteChannel</a>, <a href="ScatteringByteChannel.html" title="interface in java.nio.channels">ScatteringByteChannel</a></pre> 
       <div class="block"> 
        <span>用于读取，写入，映射和操作文件的通道。</span> 
        <p> <span>文件通道是连接到文件的<a href="SeekableByteChannel.html" title="java.nio.channels中的接口"><code>SeekableByteChannel</code></a> 。</span> <span>它的文件中有一个当前<i>位置</i> ，可以是<a href="#position()"><code><i>queried</i></code></a>和<a href="#position(long)"><code><i>modified</i></code></a> 。</span> <span>该文件本身包含一个可变长度的字节序列，可以读取和写入，并且可以查询其当前的<a href="#size()"><code><i>size</i></code></a> 。</span> <span>当字节写入超出其当前大小时，文件的大小会增加;</span> <span>当文件大小为<a href="#truncate(long)"><code><i>truncated</i></code></a>时，文件的大小会减小。</span> <span>该文件还可以具有一些关联的<i>元数据，</i>例如访问权限，内容类型和最后修改时间;</span> <span>此类未定义元数据访问的方法。</span> </p> 
        <p> <span>除了熟悉的字节通道的读，写和关闭操作外，该类还定义了以下特定于文件的操作：</span> </p> 
        <ul> 
         <li><p> <span>字节中的字节可以是<a href="#read(java.nio.ByteBuffer,long)"><code>read</code></a>或<a href="#write(java.nio.ByteBuffer,long)"><code><i>written</i></code></a> ，其方式不会影响通道的当前位置。</span> </p></li> 
         <li><p> <span>文件的一个区域可以直接进入内存<a href="#map(java.nio.channels.FileChannel.MapMode,long,long)"><code><i>mapped</i></code></a> ;</span> <span>对于大文件，这通常比调用通常的<code>read</code>或<code>write</code>方法更有效。</span> </p></li> 
         <li><p> <span>对文件所做的更新可能是<a href="#force(boolean)"><code><i>forced out</i></code></a>到底层存储设备，确保在系统崩溃时数据不会丢失。</span> </p></li> 
         <li><p> <span>字节可以从文件<a href="#transferTo(long,long,java.nio.channels.WritableByteChannel)"><code><i>to some other channel</i></code></a>和<a href="#transferFrom(java.nio.channels.ReadableByteChannel,long,long)"><code><i>vice versa</i></code>传输</a> ，其方式可以由许多操作系统优化为直接<a href="#transferFrom(java.nio.channels.ReadableByteChannel,long,long)">进出</a>文件系统高速缓存的非常快速的传输。</span> </p></li> 
         <li><p> <span>文件的某个区域可能是<a href="FileLock.html" title="java.nio.channels中的类"><code><i>locked</i></code>，</a>以防其他程序访问。</span> </p></li> 
        </ul> 
        <p> <span>文件通道可供多个并发线程使用。</span> <span>可以随时调用<a href="Channel.html#close()"><code>close</code></a>方法，如<a href="Channel.html" title="java.nio.channels中的接口"><code>Channel</code></a>接口所指定。</span> <span>在任何给定时间，只有一个涉及通道位置或可以更改其文件大小的操作可能正在进行中;</span> <span>在第一个操作仍在进行时尝试启动第二个此类操作将阻塞，直到第一个操作完成。</span> <span>其他操作，特别是那些采取明确立场的操作，可以同时进行;</span> <span>他们实际上是否这样做取决于基本的实施，因此没有具体说明。</span> </p> 
        <p> <span>由此类实例提供的文件视图保证与同一程序中其他实例提供的同一文件的其他视图一致。</span> <span>然而，由于底层操作系统执行的高速缓存和网络文件系统协议引起的延迟，该类实例提供的视图可能会也可能不会与其他同时运行的程序所看到的视图一致。</span> <span>无论编写这些其他程序的语言是什么，以及它们是在同一台机器上运行还是在其他机器上运行，都是如此。</span> <span>任何此类不一致的确切性质都取决于系统，因此未指定。</span> </p> 
        <p> <span>通过调用<a href="#open(java.nio.file.Path,java.util.Set,java.nio.file.attribute.FileAttribute...)">此类</a>定义的<a href="#open(java.nio.file.Path,java.util.Set,java.nio.file.attribute.FileAttribute...)"><code>open</code></a>方法之一来创建文件通道。</span> <span>的文件信道也可以从现有的获得<a href="../../io/FileInputStream.html#getChannel()"><code>FileInputStream</code></a> ， <a href="../../io/FileOutputStream.html#getChannel()"><code>FileOutputStream</code></a> ，或<a href="../../io/RandomAccessFile.html#getChannel()"><code>RandomAccessFile</code></a>对象通过调用该对象的<code>getChannel</code>方法，它返回被连接到相同的基本文件的文件信道。</span> <span>在从现有流或随机访问文件获得文件通道的情况下，文件通道的状态与其<code>getChannel</code>方法返回通道的对象的状态紧密相关。</span> <span>无论是显式地还是通过读取或写入字节来改变通道的位置，都将改变原始对象的文件位置，反之亦然。</span> <span>通过文件通道更改文件的长度将改变通过原始对象看到的长度，反之亦然。</span> <span>通过写入字节来更改文件的内容将更改原始对象看到的内容，反之亦然。</span> <span><a id="open-mode"></a></span> </p> 
        <p> <span>在不同的点上，该类指定需要“打开以供阅读”，“打开以进行写入”或“打开以进行读写”的实例。</span> <span>通过<a href="../../io/FileInputStream.html" title="java.io中的类"><code>FileInputStream</code></a>实例的<a href="../../io/FileInputStream.html#getChannel()"><code>getChannel</code></a>方法获得的通道将打开以供阅读。</span> <span>通过<a href="../../io/FileOutputStream.html" title="java.io中的类"><code>FileOutputStream</code></a>实例的<a href="../../io/FileOutputStream.html#getChannel()"><code>getChannel</code></a>方法获得的通道将打开以进行写入。</span> <span>最后，通过所获得的信道<a href="../../io/RandomAccessFile.html#getChannel()"><code>getChannel</code></a>一个的方法<a href="../../io/RandomAccessFile.html" title="java.io中的类"><code>RandomAccessFile</code></a>实例将是开放的，如果该实例用模式下创建阅读<code>"r"</code>和将开放阅读和如果该实例用模式下创建的写<code>"rw"</code> 。</span> <span><a id="append-mode"></a></span> </p> 
        <p> <span>打开以进行写入的文件通道可能处于<i>追加模式</i> ，例如，如果它是从通过调用<a href="../../io/FileOutputStream.html#%3Cinit%3E(java.io.File,boolean)"><code>FileOutputStream(File,boolean)</code></a>构造函数创建的文件输出流中<a href="../../io/FileOutputStream.html#%3Cinit%3E(java.io.File,boolean)">获取</a>并为第二个参数传递<code>true</code> 。</span> <span>在此模式下，相对写入操作的每次调用首先将位置前进到文件的末尾，然后写入所请求的数据。</span> <span>位置的提升和数据的写入是在单个原子操作中完成的是系统相关的，因此是未指定的。</span> </p> 
       </div> 
       <dl> 
        <dt> 
         <span class="simpleTagLabel">从以下版本开始：</span> 
        </dt> 
        <dd>
          1.4 
        </dd> 
        <dt> 
         <span class="seeLabel">另请参见：</span> 
        </dt> 
        <dd> 
         <a href="../../io/FileInputStream.html#getChannel()"><code>FileInputStream.getChannel()</code></a> ， 
         <a href="../../io/FileOutputStream.html#getChannel()"><code>FileOutputStream.getChannel()</code></a> ， 
         <a href="../../io/RandomAccessFile.html#getChannel()"><code>RandomAccessFile.getChannel()</code></a> 
        </dd> 
       </dl> </li> 
     </ul> 
    </div> 
    <div class="summary"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <!-- ======== NESTED CLASS SUMMARY ======== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="nested.class.summary"> 
           <!--   --> </a> <h3>嵌套类汇总</h3> 
          <table class="memberSummary"> 
           <caption> 
            <span>嵌套类</span> 
            <span class="tabEnd">&nbsp;</span> 
           </caption> 
           <tbody> 
            <tr> 
             <th class="colFirst" scope="col">变量和类型</th> 
             <th class="colSecond" scope="col">类</th> 
             <th class="colLast" scope="col">描述</th> 
            </tr> 
            <tr class="altColor"> 
             <td class="colFirst"><code>static class&nbsp;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="FileChannel.MapMode.html" title="class in java.nio.channels">FileChannel.MapMode</a></span></code></th> 
             <td class="colLast"> 
              <div class="block">
                文件映射模式的类型安全枚举。 
              </div> </td> 
            </tr> 
           </tbody> 
          </table> </li> 
        </ul> 
       </section> 
       <!-- ======== CONSTRUCTOR SUMMARY ======== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="constructor.summary"> 
           <!--   --> </a> <h3>构造方法摘要</h3> 
          <table class="memberSummary"> 
           <caption> 
            <span>构造方法</span> 
            <span class="tabEnd">&nbsp;</span> 
           </caption> 
           <tbody> 
            <tr> 
             <th class="colFirst" scope="col">变量</th> 
             <th class="colSecond" scope="col">构造器</th> 
             <th class="colLast" scope="col">描述</th> 
            </tr> 
            <tr class="altColor"> 
             <td class="colFirst"><code>protected </code></td> 
             <th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E()">FileChannel</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                初始化此类的新实例。 
              </div> </td> 
            </tr> 
           </tbody> 
          </table> </li> 
        </ul> 
       </section> 
       <!-- ========== METHOD SUMMARY =========== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="method.summary"> 
           <!--   --> </a> <h3>方法摘要</h3> 
          <table class="memberSummary"> 
           <caption> 
           <span id="t0" class="activeTableTab"><span>所有方法</span><span class="tabEnd">&nbsp;</span>
            <span id="t1" class="tableTab"><span><a href="javascript:show(1);">静态方法</a></span><span class="tabEnd">&nbsp;</span></span> 
             <span id="t2" class="tableTab"><span><a href="javascript:show(2);">实例方法</a>  </span></span> 
            <span id="t3" class="tableTab"><span><a href="javascript:show(4);">抽象方法</a></span><span class="tabEnd">&nbsp;</span></span> 
            <span id="t4" class="tableTab"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd">&nbsp;</span></span> 
           </caption> 
           <tbody> 
            <tr> 
             <th class="colFirst" scope="col">变量和类型</th> 
             <th class="colSecond" scope="col">方法</th> 
             <th class="colLast" scope="col">描述</th> 
            </tr> 
            <tr id="i0" class="altColor"> 
             <td class="colFirst"><code>abstract void</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#force(boolean)">force</a></span>​(boolean&nbsp;metaData)</code></th> 
             <td class="colLast"> 
              <div class="block">
                强制将此通道文件的任何更新写入包含它的存储设备。 
              </div> </td> 
            </tr> 
            <tr id="i1" class="rowColor"> 
             <td class="colFirst"><code><a href="FileLock.html" title="class in java.nio.channels">FileLock</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#lock()">lock</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                获取此频道文件的独占锁定。 
              </div> </td> 
            </tr> 
            <tr id="i2" class="altColor"> 
             <td class="colFirst"><code>abstract <a href="FileLock.html" title="class in java.nio.channels">FileLock</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#lock(long,long,boolean)">lock</a></span>​(long&nbsp;position, long&nbsp;size, boolean&nbsp;shared)</code></th> 
             <td class="colLast"> 
              <div class="block">
                获取此通道文件的给定区域的锁定。 
              </div> </td> 
            </tr> 
            <tr id="i3" class="rowColor"> 
             <td class="colFirst"><code>abstract <a href="../MappedByteBuffer.html" title="class in java.nio">MappedByteBuffer</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#map(java.nio.channels.FileChannel.MapMode,long,long)">map</a></span>​(<a href="FileChannel.MapMode.html" title="class in java.nio.channels">FileChannel.MapMode</a>&nbsp;mode, long&nbsp;position, long&nbsp;size)</code></th> 
             <td class="colLast"> 
              <div class="block">
                将此频道文件的某个区域直接映射到内存中。 
              </div> </td> 
            </tr> 
            <tr id="i4" class="altColor"> 
             <td class="colFirst"><code>static <a href="FileChannel.html" title="class in java.nio.channels">FileChannel</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#open(java.nio.file.Path,java.nio.file.OpenOption...)">open</a></span>​(<a href="../file/Path.html" title="interface in java.nio.file">Path</a>&nbsp;path, <a href="../file/OpenOption.html" title="interface in java.nio.file">OpenOption</a>...&nbsp;options)</code></th> 
             <td class="colLast"> 
              <div class="block">
                打开或创建文件，返回文件通道以访问该文件。 
              </div> </td> 
            </tr> 
            <tr id="i5" class="rowColor"> 
             <td class="colFirst"><code>static <a href="FileChannel.html" title="class in java.nio.channels">FileChannel</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#open(java.nio.file.Path,java.util.Set,java.nio.file.attribute.FileAttribute...)">open</a></span>​(<a href="../file/Path.html" title="interface in java.nio.file">Path</a>&nbsp;path, <a href="../../util/Set.html" title="interface in java.util">Set</a>&lt;? extends <a href="../file/OpenOption.html" title="interface in java.nio.file">OpenOption</a>&gt;&nbsp;options, <a href="../file/attribute/FileAttribute.html" title="interface in java.nio.file.attribute">FileAttribute</a>&lt;?&gt;...&nbsp;attrs)</code></th> 
             <td class="colLast"> 
              <div class="block">
                打开或创建文件，返回文件通道以访问该文件。 
              </div> </td> 
            </tr> 
            <tr id="i6" class="altColor"> 
             <td class="colFirst"><code>abstract long</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#position()">position</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回此通道的文件位置。 
              </div> </td> 
            </tr> 
            <tr id="i7" class="rowColor"> 
             <td class="colFirst"><code>abstract <a href="FileChannel.html" title="class in java.nio.channels">FileChannel</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#position(long)">position</a></span>​(long&nbsp;newPosition)</code></th> 
             <td class="colLast"> 
              <div class="block">
                设置此通道的文件位置。 
              </div> </td> 
            </tr> 
            <tr id="i8" class="altColor"> 
             <td class="colFirst"><code>abstract int</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#read(java.nio.ByteBuffer)">read</a></span>​(<a href="../ByteBuffer.html" title="class in java.nio">ByteBuffer</a>&nbsp;dst)</code></th> 
             <td class="colLast"> 
              <div class="block">
                从该通道读取一个字节序列到给定的缓冲区。 
              </div> </td> 
            </tr> 
            <tr id="i9" class="rowColor"> 
             <td class="colFirst"><code>long</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#read(java.nio.ByteBuffer%5B%5D)">read</a></span>​(<a href="../ByteBuffer.html" title="class in java.nio">ByteBuffer</a>[]&nbsp;dsts)</code></th> 
             <td class="colLast"> 
              <div class="block">
                从该通道读取一系列字节到给定的缓冲区。 
              </div> </td> 
            </tr> 
            <tr id="i10" class="altColor"> 
             <td class="colFirst"><code>abstract long</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#read(java.nio.ByteBuffer%5B%5D,int,int)">read</a></span>​(<a href="../ByteBuffer.html" title="class in java.nio">ByteBuffer</a>[]&nbsp;dsts, int&nbsp;offset, int&nbsp;length)</code></th> 
             <td class="colLast"> 
              <div class="block">
                从该通道读取一系列字节到给定缓冲区的子序列。 
              </div> </td> 
            </tr> 
            <tr id="i11" class="rowColor"> 
             <td class="colFirst"><code>abstract int</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#read(java.nio.ByteBuffer,long)">read</a></span>​(<a href="../ByteBuffer.html" title="class in java.nio">ByteBuffer</a>&nbsp;dst, long&nbsp;position)</code></th> 
             <td class="colLast"> 
              <div class="block">
                从给定文件位置开始，从该通道读取一个字节序列到给定缓冲区。 
              </div> </td> 
            </tr> 
            <tr id="i12" class="altColor"> 
             <td class="colFirst"><code>abstract long</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#size()">size</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回此通道文件的当前大小。 
              </div> </td> 
            </tr> 
            <tr id="i13" class="rowColor"> 
             <td class="colFirst"><code>abstract long</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#transferFrom(java.nio.channels.ReadableByteChannel,long,long)">transferFrom</a></span>​(<a href="ReadableByteChannel.html" title="interface in java.nio.channels">ReadableByteChannel</a>&nbsp;src, long&nbsp;position, long&nbsp;count)</code></th> 
             <td class="colLast"> 
              <div class="block">
                从给定的可读字节通道将字节传输到此通道的文件中。 
              </div> </td> 
            </tr> 
            <tr id="i14" class="altColor"> 
             <td class="colFirst"><code>abstract long</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#transferTo(long,long,java.nio.channels.WritableByteChannel)">transferTo</a></span>​(long&nbsp;position, long&nbsp;count, <a href="WritableByteChannel.html" title="interface in java.nio.channels">WritableByteChannel</a>&nbsp;target)</code></th> 
             <td class="colLast"> 
              <div class="block">
                将字节从此通道的文件传输到给定的可写字节通道。 
              </div> </td> 
            </tr> 
            <tr id="i15" class="rowColor"> 
             <td class="colFirst"><code>abstract <a href="FileChannel.html" title="class in java.nio.channels">FileChannel</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#truncate(long)">truncate</a></span>​(long&nbsp;size)</code></th> 
             <td class="colLast"> 
              <div class="block">
                将此频道的文件截断为给定大小。 
              </div> </td> 
            </tr> 
            <tr id="i16" class="altColor"> 
             <td class="colFirst"><code><a href="FileLock.html" title="class in java.nio.channels">FileLock</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#tryLock()">tryLock</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                尝试获取此频道文件的独占锁定。 
              </div> </td> 
            </tr> 
            <tr id="i17" class="rowColor"> 
             <td class="colFirst"><code>abstract <a href="FileLock.html" title="class in java.nio.channels">FileLock</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#tryLock(long,long,boolean)">tryLock</a></span>​(long&nbsp;position, long&nbsp;size, boolean&nbsp;shared)</code></th> 
             <td class="colLast"> 
              <div class="block">
                尝试获取此频道文件的给定区域的锁定。 
              </div> </td> 
            </tr> 
            <tr id="i18" class="altColor"> 
             <td class="colFirst"><code>abstract int</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#write(java.nio.ByteBuffer)">write</a></span>​(<a href="../ByteBuffer.html" title="class in java.nio">ByteBuffer</a>&nbsp;src)</code></th> 
             <td class="colLast"> 
              <div class="block">
                从给定缓冲区向该通道写入一个字节序列。 
              </div> </td> 
            </tr> 
            <tr id="i19" class="rowColor"> 
             <td class="colFirst"><code>long</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#write(java.nio.ByteBuffer%5B%5D)">write</a></span>​(<a href="../ByteBuffer.html" title="class in java.nio">ByteBuffer</a>[]&nbsp;srcs)</code></th> 
             <td class="colLast"> 
              <div class="block">
                从给定的缓冲区向该通道写入一个字节序列。 
              </div> </td> 
            </tr> 
            <tr id="i20" class="altColor"> 
             <td class="colFirst"><code>abstract long</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#write(java.nio.ByteBuffer%5B%5D,int,int)">write</a></span>​(<a href="../ByteBuffer.html" title="class in java.nio">ByteBuffer</a>[]&nbsp;srcs, int&nbsp;offset, int&nbsp;length)</code></th> 
             <td class="colLast"> 
              <div class="block">
                从给定缓冲区的子序列向该通道写入一个字节序列。 
              </div> </td> 
            </tr> 
            <tr id="i21" class="rowColor"> 
             <td class="colFirst"><code>abstract int</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#write(java.nio.ByteBuffer,long)">write</a></span>​(<a href="../ByteBuffer.html" title="class in java.nio">ByteBuffer</a>&nbsp;src, long&nbsp;position)</code></th> 
             <td class="colLast"> 
              <div class="block">
                从给定的缓冲区向该通道写入一个字节序列，从给定的文件位置开始。 
              </div> </td> 
            </tr> 
           </tbody> 
          </table> 
          <ul class="blockList"> 
           <li class="blockList"><a id="methods.inherited.from.class.java.nio.channels.spi.AbstractInterruptibleChannel"> 
             <!--   --> </a> <h3>声明方法的类&nbsp;java.nio.channels.spi.<a href="spi/AbstractInterruptibleChannel.html" title="class in java.nio.channels.spi">AbstractInterruptibleChannel</a></h3> <code><a href="spi/AbstractInterruptibleChannel.html#begin()">begin</a>, <a href="spi/AbstractInterruptibleChannel.html#close()">close</a>, <a href="spi/AbstractInterruptibleChannel.html#end(boolean)">end</a>, <a href="spi/AbstractInterruptibleChannel.html#implCloseChannel()">implCloseChannel</a></code></li> 
          </ul> 
          <ul class="blockList"> 
           <li class="blockList"><a id="methods.inherited.from.class.java.lang.Object"> 
             <!--   --> </a> <h3>声明方法的类&nbsp;java.lang.<a href="../../lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../lang/Object.html#clone()">clone</a>, <a href="../../lang/Object.html#equals(java.lang.Object)">equals</a>, <a href="../../lang/Object.html#finalize()">finalize</a>, <a href="../../lang/Object.html#getClass()">getClass</a>, <a href="../../lang/Object.html#hashCode()">hashCode</a>, <a href="../../lang/Object.html#notify()">notify</a>, <a href="../../lang/Object.html#notifyAll()">notifyAll</a>, <a href="../../lang/Object.html#toString()">toString</a>, <a href="../../lang/Object.html#wait()">wait</a>, <a href="../../lang/Object.html#wait(long)">wait</a>, <a href="../../lang/Object.html#wait(long,int)">wait</a></code></li> 
          </ul> 
          <ul class="blockList"> 
           <li class="blockList"><a id="methods.inherited.from.class.java.nio.channels.Channel"> 
             <!--   --> </a> <h3>声明方法的接口&nbsp;java.nio.channels.<a href="Channel.html" title="interface in java.nio.channels">Channel</a></h3> <code><a href="Channel.html#isOpen()">isOpen</a></code></li> 
          </ul> </li> 
        </ul> 
       </section> </li> 
     </ul> 
    </div> 
    <div class="details"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <!-- ========= CONSTRUCTOR DETAIL ======== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="constructor.detail"> 
           <!--   --> </a> <h3>构造方法详细信息</h3> <a id="<init>()"> 
           <!--   --> </a> 
          <ul class="blockListLast"> 
           <li class="blockList"> <h4>FileChannel</h4> <pre>protected&nbsp;FileChannel()</pre> 
            <div class="block">
              初始化此类的新实例。 
            </div> </li> 
          </ul> </li> 
        </ul> 
       </section> 
       <!-- ============ METHOD DETAIL ========== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="method.detail"> 
           <!--   --> </a> <h3>方法详细信息</h3> <a id="open(java.nio.file.Path,java.util.Set,java.nio.file.attribute.FileAttribute...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>open</h4> <pre class="methodSignature">public static&nbsp;<a href="FileChannel.html" title="class in java.nio.channels">FileChannel</a>&nbsp;open​(<a href="../file/Path.html" title="interface in java.nio.file">Path</a>&nbsp;path,
                               <a href="../../util/Set.html" title="interface in java.util">Set</a>&lt;? extends <a href="../file/OpenOption.html" title="interface in java.nio.file">OpenOption</a>&gt;&nbsp;options,
                               <a href="../file/attribute/FileAttribute.html" title="interface in java.nio.file.attribute">FileAttribute</a>&lt;?&gt;...&nbsp;attrs)
                        throws <a href="../../io/IOException.html" title="class in java.io">IOException</a></pre> 
            <div class="block"> 
             <span>打开或创建文件，返回文件通道以访问该文件。</span> 
             <p> <span><code>options</code>参数确定文件的打开方式。</span> <span><a href="../file/StandardOpenOption.html#READ"><code>READ</code></a>和<a href="../file/StandardOpenOption.html#WRITE"><code>WRITE</code></a>选项确定是否应打开文件以进行读取和/或写入。</span> <span>如果数组中都没有包含任何选项（或<a href="../file/StandardOpenOption.html#APPEND"><code>APPEND</code></a>选项），则打开文件进行读取。</span> <span>默认情况下，在文件开头处开始读取或写入。</span> </p> 
             <p> <span>除了<code>READ</code>和<code>WRITE</code> ，还可能出现以下选项：</span> </p> 
             <span> additional options    Option Description      <a href="../file/StandardOpenOption.html#APPEND"><code>APPEND</code></a>   If this option is present then the file is opened for writing and each invocation of the channel's <code>write</code> method first advances the position to the end of the file and then writes the requested data. Whether the advancement of the position and the writing of the data are done in a single atomic operation is system-dependent and therefore unspecified. This option may not be used in conjunction with the <code>READ</code> or <code>TRUNCATE_EXISTING</code> options.     <a href="../file/StandardOpenOption.html#TRUNCATE_EXISTING"><code>TRUNCATE_EXISTING</code></a>   If this option is present then the existing file is truncated to a size of 0 bytes. This option is ignored when the file is opened only for reading.     <a href="../file/StandardOpenOption.html#CREATE_NEW"><code>CREATE_NEW</code></a>   If this option is present then a new file is created, failing if the file already exists. When creating a file the check for the existence of the file and the creation of the file if it does not exist is atomic with respect to other file system operations. This option is ignored when the file is opened only for reading.     <a href="../file/StandardOpenOption.html#CREATE"><code>CREATE</code></a>   If this option is present then an existing file is opened if it exists, otherwise a new file is created. When creating a file the check for the existence of the file and the creation of the file if it does not exist is atomic with respect to other file system operations. This option is ignored if the <code>CREATE_NEW</code> option is also present or the file is opened only for reading.     <a href="../file/StandardOpenOption.html#DELETE_ON_CLOSE"><code>DELETE_ON_CLOSE</code></a>   When this option is present then the implementation makes a <em>best effort</em> attempt to delete the file when closed by the <a href="spi/AbstractInterruptibleChannel.html#close()"><code>close</code></a> method. If the <code>close</code> method is not invoked then a <em>best effort</em> attempt is made to delete the file when the Java virtual machine terminates.    <a href="../file/StandardOpenOption.html#SPARSE"><code>SPARSE</code></a>   When creating a new file this option is a <em>hint</em> that the new file will be sparse. This option is ignored when not creating a new file.     <a href="../file/StandardOpenOption.html#SYNC"><code>SYNC</code></a>   Requires that every update to the file's content or metadata be written synchronously to the underlying storage device. (see <a href="../file/package-summary.html#integrity"> Synchronized I/O file integrity</a>).     <a href="../file/StandardOpenOption.html#DSYNC"><code>DSYNC</code></a>   Requires that every update to the file's content be written synchronously to the underlying storage device. (see <a href="../file/package-summary.html#integrity"> Synchronized I/O file integrity</a>).   </span> 
             <table class="striped"> 
             </table> 
             <p> <span>实现还可以支持其他选项。</span> </p> 
             <p> <span><code>attrs</code>参数是文件<a href="../file/attribute/FileAttribute.html" title="java.nio.file.attribute中的接口"><code>file-attributes</code></a>的可选数组，用于在创建文件时以原子方式设置。</span> </p> 
             <p> <span>新的信道是通过调用创建<a href="../file/spi/FileSystemProvider.html#newFileChannel(java.nio.file.Path,java.util.Set,java.nio.file.attribute.FileAttribute...)"><code>newFileChannel</code></a>上创建该提供商方法<code>Path</code> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>path</code> - 要打开或创建的文件的路径 
             </dd> 
             <dd> 
              <code>options</code> - 指定文件打开方式的选项 
             </dd> 
             <dd> 
              <code>attrs</code> - 创建文件时要自动设置的文件属性的可选列表 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个新的文件通道 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果集合包含无效的选项组合 
             </dd> 
             <dd> 
              <code><a href="../../lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果 
              <code>path</code>与不支持创建文件通道的提供程序关联，或者指定了不支持的打开选项，或者该数组包含在创建文件时无法原子设置的属性 
             </dd> 
             <dd> 
              <code><a href="../../io/IOException.html" title="class in java.io">IOException</a></code> - 如果发生I / O错误 
             </dd> 
             <dd> 
              <span><code><a href="../../lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果安装了安全管理器，它将拒绝实现所需的未指定权限。</span> 
              <span>对于默认提供程序，如果打开文件进行读取，则调用<a href="../../lang/SecurityManager.html#checkRead(java.lang.String)"><code>SecurityManager.checkRead(String)</code></a>方法来检查读取访问权限。</span> 
              <span>如果打开文件进行写入，则调用<a href="../../lang/SecurityManager.html#checkWrite(java.lang.String)"><code>SecurityManager.checkWrite(String)</code></a>方法来检查写访问</span> 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.7 
             </dd> 
            </dl> </li> 
          </ul> <a id="open(java.nio.file.Path,java.nio.file.OpenOption...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>open</h4> <pre class="methodSignature">public static&nbsp;<a href="FileChannel.html" title="class in java.nio.channels">FileChannel</a>&nbsp;open​(<a href="../file/Path.html" title="interface in java.nio.file">Path</a>&nbsp;path,
                               <a href="../file/OpenOption.html" title="interface in java.nio.file">OpenOption</a>...&nbsp;options)
                        throws <a href="../../io/IOException.html" title="class in java.io">IOException</a></pre> 
            <div class="block"> 
             <span>打开或创建文件，返回文件通道以访问该文件。</span> 
             <p> <span>调用此方法的行为与调用完全相同</span> </p> 
             <pre>  <span>fc.<a href="#open(java.nio.file.Path,java.util.Set,java.nio.file.attribute.FileAttribute...)"><code>open</code></a>(file, opts, new FileAttribute&lt;?&gt;[0]);</span> </pre> 
             <span>其中<code>opts</code>是<code>options</code>数组中指定的一组选项。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>path</code> - 要打开或创建的文件的路径 
             </dd> 
             <dd> 
              <code>options</code> - 指定文件打开方式的选项 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个新的文件通道 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果集合包含无效的选项组合 
             </dd> 
             <dd> 
              <code><a href="../../lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果 
              <code>path</code>与不支持创建文件通道的提供程序关联，或者指定了不支持的打开选项 
             </dd> 
             <dd> 
              <code><a href="../../io/IOException.html" title="class in java.io">IOException</a></code> - 如果发生I / O错误 
             </dd> 
             <dd> 
              <span><code><a href="../../lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果安装了安全管理器，它将拒绝实现所需的未指定权限。</span> 
              <span>对于默认提供程序，如果打开文件进行读取，则调用<a href="../../lang/SecurityManager.html#checkRead(java.lang.String)"><code>SecurityManager.checkRead(String)</code></a>方法来检查读取访问权限。</span> 
              <span>如果打开文件进行写入，则调用<a href="../../lang/SecurityManager.html#checkWrite(java.lang.String)"><code>SecurityManager.checkWrite(String)</code></a>方法来检查写访问</span> 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.7 
             </dd> 
            </dl> </li> 
          </ul> <a id="read(java.nio.ByteBuffer)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>read</h4> <pre class="methodSignature">public abstract&nbsp;int&nbsp;read​(<a href="../ByteBuffer.html" title="class in java.nio">ByteBuffer</a>&nbsp;dst)
                  throws <a href="../../io/IOException.html" title="class in java.io">IOException</a></pre> 
            <div class="block"> 
             <span>从该通道读取一个字节序列到给定的缓冲区。</span> 
             <p> <span>从该通道的当前文件位置开始读取字节，然后使用实际读取的字节数更新文件位置。</span> <span>否则，此方法的行为与<a href="ReadableByteChannel.html" title="java.nio.channels中的接口"><code>ReadableByteChannel</code></a>接口中指定的<a href="ReadableByteChannel.html" title="java.nio.channels中的接口">完全相同</a> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="overrideSpecifyLabel">Specified by:</span> 
             </dt> 
             <dd> 
              <code><a href="ReadableByteChannel.html#read(java.nio.ByteBuffer)">read</a></code>在接口 
              <code><a href="ReadableByteChannel.html" title="interface in java.nio.channels">ReadableByteChannel</a></code> 
             </dd> 
             <dt> 
              <span class="overrideSpecifyLabel">Specified by:</span> 
             </dt> 
             <dd> 
              <code><a href="SeekableByteChannel.html#read(java.nio.ByteBuffer)">read</a></code>在界面 
              <code><a href="SeekableByteChannel.html" title="interface in java.nio.channels">SeekableByteChannel</a></code> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>dst</code> - 要传输字节的缓冲区 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               如果通道已到达流末尾，则读取的字节数（可能为零）或 
              <code>-1</code> 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="ClosedChannelException.html" title="class in java.nio.channels">ClosedChannelException</a></code> - 如果此渠道已关闭 
             </dd> 
             <dd> 
              <code><a href="AsynchronousCloseException.html" title="class in java.nio.channels">AsynchronousCloseException</a></code> - 如果另一个线程在读取操作正在进行时关闭此通道 
             </dd> 
             <dd> 
              <code><a href="ClosedByInterruptException.html" title="class in java.nio.channels">ClosedByInterruptException</a></code> - 如果另一个线程在读操作正在进行时中断当前线程，从而关闭通道并设置当前线程的中断状态 
             </dd> 
             <dd> 
              <code><a href="../../io/IOException.html" title="class in java.io">IOException</a></code> - 如果发生其他一些I / O错误 
             </dd> 
            </dl> </li> 
          </ul> <a id="read(java.nio.ByteBuffer[],int,int)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>read</h4> <pre class="methodSignature">public abstract&nbsp;long&nbsp;read​(<a href="../ByteBuffer.html" title="class in java.nio">ByteBuffer</a>[]&nbsp;dsts,
                          int&nbsp;offset,
                          int&nbsp;length)
                   throws <a href="../../io/IOException.html" title="class in java.io">IOException</a></pre> 
            <div class="block"> 
             <span>从该通道读取一系列字节到给定缓冲区的子序列。</span> 
             <p> <span>从该通道的当前文件位置开始读取字节，然后使用实际读取的字节数更新文件位置。</span> <span>否则，此方法的行为与<a href="ScatteringByteChannel.html" title="java.nio.channels中的接口"><code>ScatteringByteChannel</code></a>接口中指定的<a href="ScatteringByteChannel.html" title="java.nio.channels中的接口">完全相同</a> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="overrideSpecifyLabel">Specified by:</span> 
             </dt> 
             <dd> 
              <code><a href="ScatteringByteChannel.html#read(java.nio.ByteBuffer%5B%5D,int,int)">read</a></code>在接口 
              <code><a href="ScatteringByteChannel.html" title="interface in java.nio.channels">ScatteringByteChannel</a></code> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>dsts</code> - 要传输字节的缓冲区 
             </dd> 
             <dd> 
              <span><code>offset</code> - 要传输字节的第一个缓冲区的缓冲区数组内的偏移量;</span> 
              <span>必须是非负数且不大于<code>dsts.length</code></span> 
             </dd> 
             <dd> 
              <span><code>length</code> - 要访问的最大缓冲区数;</span> 
              <span>必须是非负数且不大于<code>dsts.length</code> - <code>offset</code></span> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               如果通道已到达流末尾，则读取的字节数（可能为零）或 
              <code>-1</code> 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="ClosedChannelException.html" title="class in java.nio.channels">ClosedChannelException</a></code> - 如果此渠道已关闭 
             </dd> 
             <dd> 
              <code><a href="AsynchronousCloseException.html" title="class in java.nio.channels">AsynchronousCloseException</a></code> - 如果另一个线程在读取操作正在进行时关闭此通道 
             </dd> 
             <dd> 
              <code><a href="ClosedByInterruptException.html" title="class in java.nio.channels">ClosedByInterruptException</a></code> - 如果另一个线程在读操作正在进行时中断当前线程，从而关闭通道并设置当前线程的中断状态 
             </dd> 
             <dd> 
              <code><a href="../../io/IOException.html" title="class in java.io">IOException</a></code> - 如果发生其他一些I / O错误 
             </dd> 
            </dl> </li> 
          </ul> <a id="read(java.nio.ByteBuffer[])"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>read</h4> <pre class="methodSignature">public final&nbsp;long&nbsp;read​(<a href="../ByteBuffer.html" title="class in java.nio">ByteBuffer</a>[]&nbsp;dsts)
                throws <a href="../../io/IOException.html" title="class in java.io">IOException</a></pre> 
            <div class="block"> 
             <span>从该通道读取一系列字节到给定的缓冲区。</span> 
             <p> <span>从该通道的当前文件位置开始读取字节，然后使用实际读取的字节数更新文件位置。</span> <span>否则，此方法的行为与<a href="ScatteringByteChannel.html" title="java.nio.channels中的接口"><code>ScatteringByteChannel</code></a>接口中指定的<a href="ScatteringByteChannel.html" title="java.nio.channels中的接口">完全相同</a> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="overrideSpecifyLabel">Specified by:</span> 
             </dt> 
             <dd> 
              <code><a href="ScatteringByteChannel.html#read(java.nio.ByteBuffer%5B%5D)">read</a></code>在接口 
              <code><a href="ScatteringByteChannel.html" title="interface in java.nio.channels">ScatteringByteChannel</a></code> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>dsts</code> - 要传输字节的缓冲区 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               如果通道已到达流末尾，则读取的字节数（可能为零）或 
              <code>-1</code> 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="ClosedChannelException.html" title="class in java.nio.channels">ClosedChannelException</a></code> - 如果此渠道已关闭 
             </dd> 
             <dd> 
              <code><a href="AsynchronousCloseException.html" title="class in java.nio.channels">AsynchronousCloseException</a></code> - 如果另一个线程在读取操作正在进行时关闭此通道 
             </dd> 
             <dd> 
              <code><a href="ClosedByInterruptException.html" title="class in java.nio.channels">ClosedByInterruptException</a></code> - 如果另一个线程在读操作正在进行时中断当前线程，从而关闭通道并设置当前线程的中断状态 
             </dd> 
             <dd> 
              <code><a href="../../io/IOException.html" title="class in java.io">IOException</a></code> - 如果发生其他一些I / O错误 
             </dd> 
            </dl> </li> 
          </ul> <a id="write(java.nio.ByteBuffer)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>write</h4> <pre class="methodSignature">public abstract&nbsp;int&nbsp;write​(<a href="../ByteBuffer.html" title="class in java.nio">ByteBuffer</a>&nbsp;src)
                   throws <a href="../../io/IOException.html" title="class in java.io">IOException</a></pre> 
            <div class="block"> 
             <span>从给定缓冲区向该通道写入一个字节序列。</span> 
             <p> <span>除非通道处于附加模式，否则从该通道的当前文件位置开始写入字节，在这种情况下，位置首先前进到文件的末尾。</span> <span>如有必要，文件将生长以容纳写入的字节，然后使用实际写入的字节数更新文件位置。</span> <span>否则，此方法的行为与<a href="WritableByteChannel.html" title="java.nio.channels中的接口"><code>WritableByteChannel</code></a>接口指定的<a href="WritableByteChannel.html" title="java.nio.channels中的接口">完全相同</a> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="overrideSpecifyLabel">Specified by:</span> 
             </dt> 
             <dd> 
              <code><a href="SeekableByteChannel.html#write(java.nio.ByteBuffer)">write</a></code>在接口 
              <code><a href="SeekableByteChannel.html" title="interface in java.nio.channels">SeekableByteChannel</a></code> 
             </dd> 
             <dt> 
              <span class="overrideSpecifyLabel">Specified by:</span> 
             </dt> 
             <dd> 
              <code><a href="WritableByteChannel.html#write(java.nio.ByteBuffer)">write</a></code> ，界面 
              <code><a href="WritableByteChannel.html" title="interface in java.nio.channels">WritableByteChannel</a></code> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>src</code> - 要从中检索字节的缓冲区 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               写入的字节数，可能为零 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="ClosedChannelException.html" title="class in java.nio.channels">ClosedChannelException</a></code> - 如果此渠道已关闭 
             </dd> 
             <dd> 
              <code><a href="AsynchronousCloseException.html" title="class in java.nio.channels">AsynchronousCloseException</a></code> - 如果另一个线程在写操作正在进行时关闭此通道 
             </dd> 
             <dd> 
              <code><a href="ClosedByInterruptException.html" title="class in java.nio.channels">ClosedByInterruptException</a></code> - 如果另一个线程在写操作正在进行时中断当前线程，从而关闭通道并设置当前线程的中断状态 
             </dd> 
             <dd> 
              <code><a href="../../io/IOException.html" title="class in java.io">IOException</a></code> - 如果发生其他一些I / O错误 
             </dd> 
            </dl> </li> 
          </ul> <a id="write(java.nio.ByteBuffer[],int,int)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>write</h4> <pre class="methodSignature">public abstract&nbsp;long&nbsp;write​(<a href="../ByteBuffer.html" title="class in java.nio">ByteBuffer</a>[]&nbsp;srcs,
                           int&nbsp;offset,
                           int&nbsp;length)
                    throws <a href="../../io/IOException.html" title="class in java.io">IOException</a></pre> 
            <div class="block"> 
             <span>从给定缓冲区的子序列向该通道写入一个字节序列。</span> 
             <p> <span>除非通道处于附加模式，否则从该通道的当前文件位置开始写入字节，在这种情况下，位置首先前进到文件的末尾。</span> <span>如有必要，文件将生长以容纳写入的字节，然后使用实际写入的字节数更新文件位置。</span> <span>否则，此方法的行为与<a href="GatheringByteChannel.html" title="java.nio.channels中的接口"><code>GatheringByteChannel</code></a>接口中指定的<a href="GatheringByteChannel.html" title="java.nio.channels中的接口">完全相同</a> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="overrideSpecifyLabel">Specified by:</span> 
             </dt> 
             <dd> 
              <code><a href="GatheringByteChannel.html#write(java.nio.ByteBuffer%5B%5D,int,int)">write</a></code>在界面 
              <code><a href="GatheringByteChannel.html" title="interface in java.nio.channels">GatheringByteChannel</a></code> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>srcs</code> - 要从中检索字节的缓冲区 
             </dd> 
             <dd> 
              <span><code>offset</code> - 要从中检索字节的第一个缓冲区的缓冲区数组中的偏移量;</span> 
              <span>必须是非负数且不大于<code>srcs.length</code></span> 
             </dd> 
             <dd> 
              <span><code>length</code> - 要访问的最大缓冲区数;</span> 
              <span>必须是非负数且不大于<code>srcs.length</code> - <code>offset</code></span> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               写入的字节数，可能为零 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="ClosedChannelException.html" title="class in java.nio.channels">ClosedChannelException</a></code> - 如果此渠道已关闭 
             </dd> 
             <dd> 
              <code><a href="AsynchronousCloseException.html" title="class in java.nio.channels">AsynchronousCloseException</a></code> - 如果另一个线程在写入操作正在进行时关闭此通道 
             </dd> 
             <dd> 
              <code><a href="ClosedByInterruptException.html" title="class in java.nio.channels">ClosedByInterruptException</a></code> - 如果另一个线程在写操作正在进行时中断当前线程，从而关闭通道并设置当前线程的中断状态 
             </dd> 
             <dd> 
              <code><a href="../../io/IOException.html" title="class in java.io">IOException</a></code> - 如果发生其他一些I / O错误 
             </dd> 
            </dl> </li> 
          </ul> <a id="write(java.nio.ByteBuffer[])"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>write</h4> <pre class="methodSignature">public final&nbsp;long&nbsp;write​(<a href="../ByteBuffer.html" title="class in java.nio">ByteBuffer</a>[]&nbsp;srcs)
                 throws <a href="../../io/IOException.html" title="class in java.io">IOException</a></pre> 
            <div class="block"> 
             <span>从给定的缓冲区向该通道写入一个字节序列。</span> 
             <p> <span>除非通道处于附加模式，否则从该通道的当前文件位置开始写入字节，在这种情况下，位置首先前进到文件的末尾。</span> <span>如有必要，文件将生长以容纳写入的字节，然后使用实际写入的字节数更新文件位置。</span> <span>否则，此方法的行为与<a href="GatheringByteChannel.html" title="java.nio.channels中的接口"><code>GatheringByteChannel</code></a>接口中指定的<a href="GatheringByteChannel.html" title="java.nio.channels中的接口">完全相同</a> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="overrideSpecifyLabel">Specified by:</span> 
             </dt> 
             <dd> 
              <code><a href="GatheringByteChannel.html#write(java.nio.ByteBuffer%5B%5D)">write</a></code>在接口 
              <code><a href="GatheringByteChannel.html" title="interface in java.nio.channels">GatheringByteChannel</a></code> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>srcs</code> - 要从中检索字节的缓冲区 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               写入的字节数，可能为零 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="ClosedChannelException.html" title="class in java.nio.channels">ClosedChannelException</a></code> - 如果此渠道已关闭 
             </dd> 
             <dd> 
              <code><a href="AsynchronousCloseException.html" title="class in java.nio.channels">AsynchronousCloseException</a></code> - 如果另一个线程在写操作正在进行时关闭此通道 
             </dd> 
             <dd> 
              <code><a href="ClosedByInterruptException.html" title="class in java.nio.channels">ClosedByInterruptException</a></code> - 如果另一个线程在写操作正在进行时中断当前线程，从而关闭通道并设置当前线程的中断状态 
             </dd> 
             <dd> 
              <code><a href="../../io/IOException.html" title="class in java.io">IOException</a></code> - 如果发生其他一些I / O错误 
             </dd> 
            </dl> </li> 
          </ul> <a id="position()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>position</h4> <pre class="methodSignature">public abstract&nbsp;long&nbsp;position()
                       throws <a href="../../io/IOException.html" title="class in java.io">IOException</a></pre> 
            <div class="block">
              返回此通道的文件位置。 
            </div> 
            <dl> 
             <dt> 
              <span class="overrideSpecifyLabel">Specified by:</span> 
             </dt> 
             <dd> 
              <code><a href="SeekableByteChannel.html#position()">position</a></code> ，界面 
              <code><a href="SeekableByteChannel.html" title="interface in java.nio.channels">SeekableByteChannel</a></code> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此通道的文件位置，一个非负整数，计算从文件开头到当前位置的字节数 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="ClosedChannelException.html" title="class in java.nio.channels">ClosedChannelException</a></code> - 如果此渠道已关闭 
             </dd> 
             <dd> 
              <code><a href="../../io/IOException.html" title="class in java.io">IOException</a></code> - 如果发生其他一些I / O错误 
             </dd> 
            </dl> </li> 
          </ul> <a id="position(long)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>position</h4> <pre class="methodSignature">public abstract&nbsp;<a href="FileChannel.html" title="class in java.nio.channels">FileChannel</a>&nbsp;position​(long&nbsp;newPosition)
                              throws <a href="../../io/IOException.html" title="class in java.io">IOException</a></pre> 
            <div class="block"> 
             <span>设置此通道的文件位置。</span> 
             <p> <span>将位置设置为大于文件当前大小的值是合法的，但不会更改文件的大小。</span> <span>稍后尝试在这样的位置读取字节将立即返回文件结束指示。</span> <span>稍后尝试在这样的位置写入字节将导致文件增长以容纳新字节;</span> <span>未指定前一个文件结尾和新写入字节之间的任何字节的值。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="overrideSpecifyLabel">Specified by:</span> 
             </dt> 
             <dd> 
              <code><a href="SeekableByteChannel.html#position(long)">position</a></code> ，界面 
              <code><a href="SeekableByteChannel.html" title="interface in java.nio.channels">SeekableByteChannel</a></code> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>newPosition</code> - 新位置，一个非负整数，用于计算文件开头的字节数 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               这个文件频道 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="ClosedChannelException.html" title="class in java.nio.channels">ClosedChannelException</a></code> - 如果此渠道已关闭 
             </dd> 
             <dd> 
              <code><a href="../../lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果新头寸为负数 
             </dd> 
             <dd> 
              <code><a href="../../io/IOException.html" title="class in java.io">IOException</a></code> - 如果发生其他一些I / O错误 
             </dd> 
            </dl> </li> 
          </ul> <a id="size()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>size</h4> <pre class="methodSignature">public abstract&nbsp;long&nbsp;size()
                   throws <a href="../../io/IOException.html" title="class in java.io">IOException</a></pre> 
            <div class="block">
              返回此通道文件的当前大小。 
            </div> 
            <dl> 
             <dt> 
              <span class="overrideSpecifyLabel">Specified by:</span> 
             </dt> 
             <dd> 
              <code><a href="SeekableByteChannel.html#size()">size</a></code>在界面 
              <code><a href="SeekableByteChannel.html" title="interface in java.nio.channels">SeekableByteChannel</a></code> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此通道文件的当前大小，以字节为单位 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="ClosedChannelException.html" title="class in java.nio.channels">ClosedChannelException</a></code> - 如果此渠道已关闭 
             </dd> 
             <dd> 
              <code><a href="../../io/IOException.html" title="class in java.io">IOException</a></code> - 如果发生其他一些I / O错误 
             </dd> 
            </dl> </li> 
          </ul> <a id="truncate(long)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>truncate</h4> <pre class="methodSignature">public abstract&nbsp;<a href="FileChannel.html" title="class in java.nio.channels">FileChannel</a>&nbsp;truncate​(long&nbsp;size)
                              throws <a href="../../io/IOException.html" title="class in java.io">IOException</a></pre> 
            <div class="block"> 
             <span>将此频道的文件截断为给定大小。</span> 
             <p> <span>如果给定大小小于文件的当前大小，则文件将被截断，丢弃文件新端之外的任何字节。</span> <span>如果给定大小大于或等于文件的当前大小，则不修改该文件。</span> <span>在任何一种情况下，如果此通道的文件位置大于给定大小，则将其设置为该大小。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="overrideSpecifyLabel">Specified by:</span> 
             </dt> 
             <dd> 
              <code><a href="SeekableByteChannel.html#truncate(long)">truncate</a></code>在接口 
              <code><a href="SeekableByteChannel.html" title="interface in java.nio.channels">SeekableByteChannel</a></code> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>size</code> - 新大小，非负字节数 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               这个文件频道 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="NonWritableChannelException.html" title="class in java.nio.channels">NonWritableChannelException</a></code> - 如果未打开此频道进行写入 
             </dd> 
             <dd> 
              <code><a href="ClosedChannelException.html" title="class in java.nio.channels">ClosedChannelException</a></code> - 如果此渠道已关闭 
             </dd> 
             <dd> 
              <code><a href="../../lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果新大小为负数 
             </dd> 
             <dd> 
              <code><a href="../../io/IOException.html" title="class in java.io">IOException</a></code> - 如果发生其他一些I / O错误 
             </dd> 
            </dl> </li> 
          </ul> <a id="force(boolean)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>force</h4> <pre class="methodSignature">public abstract&nbsp;void&nbsp;force​(boolean&nbsp;metaData)
                    throws <a href="../../io/IOException.html" title="class in java.io">IOException</a></pre> 
            <div class="block"> 
             <span>强制将此通道文件的任何更新写入包含它的存储设备。</span> 
             <p> <span>如果此通道的文件驻留在本地存储设备上，则当此方法返回时，保证自创建此通道以来对文件所做的所有更改，或者自上次调用此方法以来，该文件都将写入该设备。</span> <span>这对于确保在系统崩溃时不会丢失关键信息非常有用。</span> </p> 
             <p> <span>如果文件不驻留在本地设备上，则不会进行此类保证。</span> </p> 
             <p> <span><code>metaData</code>参数可用于限制此方法需要执行的I / O操作数。</span> <span>为此参数传递<code>false</code>表示只需要将文件内容的更新写入存储;</span> <span>传递<code>true</code>表示必须写入文件内容和元数据的更新，这通常需要至少一次I / O操作。</span> <span>此参数是否实际具有任何效果取决于底层操作系统，因此未指定。</span> </p> 
             <p> <span>即使仅打开通道进行读取，调用此方法也可能导致I / O操作发生。</span> <span>例如，某些操作系统将最后访问时间作为文件元数据的一部分进行维护，并且每次读取文件时都会更新此时间。</span> <span>这是否实际完成是依赖于系统的，因此未指定。</span> </p> 
             <p> <span>此方法仅保证强制通过此类中定义的方法对此通道的文件进行更改。</span> <span>它可能会也可能不会强制通过修改通过调用<a href="#map(java.nio.channels.FileChannel.MapMode,long,long)"><code>map</code></a>方法获得的<a href="../MappedByteBuffer.html" title="java.nio中的类"><code><i>mapped byte buffer</i></code></a>的内容进行<a href="#map(java.nio.channels.FileChannel.MapMode,long,long)">更改</a> 。</span> <span>调用映射字节缓冲区的<a href="../MappedByteBuffer.html#force()"><code>force</code></a>方法将强制写入对缓冲区内容的更改。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <span><code>metaData</code> - 如果是<code>true</code>则需要使用此方法强制更改文件的内容和要写入存储的元数据;</span> 
              <span>否则，只需强制内容更改即可写入</span> 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="ClosedChannelException.html" title="class in java.nio.channels">ClosedChannelException</a></code> - 如果此渠道已关闭 
             </dd> 
             <dd> 
              <code><a href="../../io/IOException.html" title="class in java.io">IOException</a></code> - 如果发生其他一些I / O错误 
             </dd> 
            </dl> </li> 
          </ul> <a id="transferTo(long,long,java.nio.channels.WritableByteChannel)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>transferTo</h4> <pre class="methodSignature">public abstract&nbsp;long&nbsp;transferTo​(long&nbsp;position,
                                long&nbsp;count,
                                <a href="WritableByteChannel.html" title="interface in java.nio.channels">WritableByteChannel</a>&nbsp;target)
                         throws <a href="../../io/IOException.html" title="class in java.io">IOException</a></pre> 
            <div class="block"> 
             <span>将字节从此通道的文件传输到给定的可写字节通道。</span> 
             <p> <span>尝试从该通道文件中的给定<code>position</code>开始读取最多<code>count</code>个字节，并将它们写入目标通道。</span> <span>调用此方法可能会也可能不会传输所有请求的字节;</span> <span>是否这样做取决于渠道的性质和状态。</span> <span>如果此通道的文件包含从给定的<code>position</code>开始的少于<code>count</code>字节，或者目标通道是非阻塞且其输出缓冲区中的<code>count</code>字节少于<code>position</code> ，则传输的字节数少于所请求的字节数。</span> </p> 
             <p> <span>此方法不会修改此通道的位置。</span> <span>如果给定位置大于文件的当前大小，则不传输任何字节。</span> <span>如果目标通道有一个位置，则从该位置开始写入字节，然后该位置按写入的字节数递增。</span> </p> 
             <p> <span>此方法可能比从此通道读取并写入目标通道的简单循环更有效。</span> <span>许多操作系统可以直接从文件系统缓存向目标通道传输字节，而无需实际复制它们。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <span><code>position</code> - 文件在转移开始时的位置;</span> 
              <span>必须是非负面的</span> 
             </dd> 
             <dd> 
              <span><code>count</code> - 要传输的最大字节数;</span> 
              <span>必须是非负面的</span> 
             </dd> 
             <dd> 
              <code>target</code> - 目标通道 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               实际传输的字节数，可能为零 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果参数的前提条件不成立 
             </dd> 
             <dd> 
              <code><a href="NonReadableChannelException.html" title="class in java.nio.channels">NonReadableChannelException</a></code> - 如果未打开此频道进行阅读 
             </dd> 
             <dd> 
              <code><a href="NonWritableChannelException.html" title="class in java.nio.channels">NonWritableChannelException</a></code> - 如果未打开目标通道进行写入 
             </dd> 
             <dd> 
              <code><a href="ClosedChannelException.html" title="class in java.nio.channels">ClosedChannelException</a></code> - 如果此通道或目标通道关闭 
             </dd> 
             <dd> 
              <code><a href="AsynchronousCloseException.html" title="class in java.nio.channels">AsynchronousCloseException</a></code> - 如果另一个线程在传输过程中关闭了任一通道 
             </dd> 
             <dd> 
              <code><a href="ClosedByInterruptException.html" title="class in java.nio.channels">ClosedByInterruptException</a></code> - 如果另一个线程在传输过程中中断当前线程，从而关闭两个通道并设置当前线程的中断状态 
             </dd> 
             <dd> 
              <code><a href="../../io/IOException.html" title="class in java.io">IOException</a></code> - 如果发生其他一些I / O错误 
             </dd> 
            </dl> </li> 
          </ul> <a id="transferFrom(java.nio.channels.ReadableByteChannel,long,long)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>transferFrom</h4> <pre class="methodSignature">public abstract&nbsp;long&nbsp;transferFrom​(<a href="ReadableByteChannel.html" title="interface in java.nio.channels">ReadableByteChannel</a>&nbsp;src,
                                  long&nbsp;position,
                                  long&nbsp;count)
                           throws <a href="../../io/IOException.html" title="class in java.io">IOException</a></pre> 
            <div class="block"> 
             <span>从给定的可读字节通道将字节传输到此通道的文件中。</span> 
             <p> <span>尝试从源通道读取最多<code>count</code>个字节，并从给定的<code>position</code>开始将它们写入此通道的文件。</span> <span>调用此方法可能会也可能不会传输所有请求的字节;</span> <span>是否这样做取决于渠道的性质和状态。</span> <span>如果源通道剩余少于<code>count</code>个字节，或者源通道非阻塞且输入缓冲区中立即可用的字节数少于<code>count</code>少于<code>count</code>字节数。</span> </p> 
             <p> <span>此方法不会修改此通道的位置。</span> <span>如果给定位置大于文件的当前大小，则不传输任何字节。</span> <span>如果源通道有一个位置，则从该位置开始读取字节，然后将位置增加读取的字节数。</span> </p> 
             <p> <span>此方法可能比从源通道读取并写入此通道的简单循环更有效。</span> <span>许多操作系统可以直接从源通道将字节传输到文件系统缓存中，而无需实际复制它们。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>src</code> - 源通道 
             </dd> 
             <dd> 
              <span><code>position</code> - 文件在转移开始时的位置;</span> 
              <span>必须是非负面的</span> 
             </dd> 
             <dd> 
              <span><code>count</code> - 要传输的最大字节数;</span> 
              <span>必须是非负面的</span> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               实际传输的字节数，可能为零 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果参数的前提条件不成立 
             </dd> 
             <dd> 
              <code><a href="NonReadableChannelException.html" title="class in java.nio.channels">NonReadableChannelException</a></code> - 如果未打开源通道进行读取 
             </dd> 
             <dd> 
              <code><a href="NonWritableChannelException.html" title="class in java.nio.channels">NonWritableChannelException</a></code> - 如果未打开此频道进行写入 
             </dd> 
             <dd> 
              <code><a href="ClosedChannelException.html" title="class in java.nio.channels">ClosedChannelException</a></code> - 如果此通道或源通道关闭 
             </dd> 
             <dd> 
              <code><a href="AsynchronousCloseException.html" title="class in java.nio.channels">AsynchronousCloseException</a></code> - 如果另一个线程在传输过程中关闭了任一通道 
             </dd> 
             <dd> 
              <code><a href="ClosedByInterruptException.html" title="class in java.nio.channels">ClosedByInterruptException</a></code> - 如果另一个线程在传输过程中中断当前线程，从而关闭两个通道并设置当前线程的中断状态 
             </dd> 
             <dd> 
              <code><a href="../../io/IOException.html" title="class in java.io">IOException</a></code> - 如果发生其他一些I / O错误 
             </dd> 
            </dl> </li> 
          </ul> <a id="read(java.nio.ByteBuffer,long)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>read</h4> <pre class="methodSignature">public abstract&nbsp;int&nbsp;read​(<a href="../ByteBuffer.html" title="class in java.nio">ByteBuffer</a>&nbsp;dst,
                         long&nbsp;position)
                  throws <a href="../../io/IOException.html" title="class in java.io">IOException</a></pre> 
            <div class="block"> 
             <span>从给定文件位置开始，从该通道读取一个字节序列到给定缓冲区。</span> 
             <p> <span>此方法的工作方式与<a href="#read(java.nio.ByteBuffer)"><code>read(ByteBuffer)</code></a>方法相同，不同之处在于从给定文件位置开始而不是在通道的当前位置读取字节。</span> <span>此方法不会修改此通道的位置。</span> <span>如果给定位置大于文件的当前大小，则不读取任何字节。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>dst</code> - 要传输字节的缓冲区 
             </dd> 
             <dd> 
              <span><code>position</code> - 要开始传输的文件位置;</span> 
              <span>必须是非负面的</span> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               如果给定位置大于或等于文件的当前大小，则读取的字节数（可能为零）或 
              <code>-1</code> 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果头寸为负数 
             </dd> 
             <dd> 
              <code><a href="NonReadableChannelException.html" title="class in java.nio.channels">NonReadableChannelException</a></code> - 如果未打开此频道进行阅读 
             </dd> 
             <dd> 
              <code><a href="ClosedChannelException.html" title="class in java.nio.channels">ClosedChannelException</a></code> - 如果此渠道已关闭 
             </dd> 
             <dd> 
              <code><a href="AsynchronousCloseException.html" title="class in java.nio.channels">AsynchronousCloseException</a></code> - 如果另一个线程在读操作正在进行时关闭此通道 
             </dd> 
             <dd> 
              <code><a href="ClosedByInterruptException.html" title="class in java.nio.channels">ClosedByInterruptException</a></code> - 如果另一个线程在读操作正在进行时中断当前线程，从而关闭通道并设置当前线程的中断状态 
             </dd> 
             <dd> 
              <code><a href="../../io/IOException.html" title="class in java.io">IOException</a></code> - 如果发生其他一些I / O错误 
             </dd> 
            </dl> </li> 
          </ul> <a id="write(java.nio.ByteBuffer,long)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>write</h4> <pre class="methodSignature">public abstract&nbsp;int&nbsp;write​(<a href="../ByteBuffer.html" title="class in java.nio">ByteBuffer</a>&nbsp;src,
                          long&nbsp;position)
                   throws <a href="../../io/IOException.html" title="class in java.io">IOException</a></pre> 
            <div class="block"> 
             <span>从给定的缓冲区向该通道写入一个字节序列，从给定的文件位置开始。</span> 
             <p> <span>此方法的工作方式与<a href="#write(java.nio.ByteBuffer)"><code>write(ByteBuffer)</code></a>方法相同，不同之处在于从给定文件位置开始而不是在通道的当前位置开始写入字节。</span> <span>此方法不会修改此通道的位置。</span> <span>如果给定位置大于文件的当前大小，则文件将增长以容纳新字节;</span> <span>未指定前一个文件结尾和新写入字节之间的任何字节的值。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>src</code> - 要从中传输字节的缓冲区 
             </dd> 
             <dd> 
              <span><code>position</code> - 传输开始的文件位置;</span> 
              <span>必须是非负面的</span> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               写入的字节数，可能为零 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果头寸为负数 
             </dd> 
             <dd> 
              <code><a href="NonWritableChannelException.html" title="class in java.nio.channels">NonWritableChannelException</a></code> - 如果未打开此频道进行写入 
             </dd> 
             <dd> 
              <code><a href="ClosedChannelException.html" title="class in java.nio.channels">ClosedChannelException</a></code> - 如果此渠道已关闭 
             </dd> 
             <dd> 
              <code><a href="AsynchronousCloseException.html" title="class in java.nio.channels">AsynchronousCloseException</a></code> - 如果另一个线程在写操作正在进行时关闭此通道 
             </dd> 
             <dd> 
              <code><a href="ClosedByInterruptException.html" title="class in java.nio.channels">ClosedByInterruptException</a></code> - 如果另一个线程在写操作正在进行时中断当前线程，从而关闭通道并设置当前线程的中断状态 
             </dd> 
             <dd> 
              <code><a href="../../io/IOException.html" title="class in java.io">IOException</a></code> - 如果发生其他一些I / O错误 
             </dd> 
            </dl> </li> 
          </ul> <a id="map(java.nio.channels.FileChannel.MapMode,long,long)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>map</h4> <pre class="methodSignature">public abstract&nbsp;<a href="../MappedByteBuffer.html" title="class in java.nio">MappedByteBuffer</a>&nbsp;map​(<a href="FileChannel.MapMode.html" title="class in java.nio.channels">FileChannel.MapMode</a>&nbsp;mode,
                                     long&nbsp;position,
                                     long&nbsp;size)
                              throws <a href="../../io/IOException.html" title="class in java.io">IOException</a></pre> 
            <div class="block"> 
             <span>将此频道文件的某个区域直接映射到内存中。</span> 
             <p> <span>文件的区域可以以三种模式之一映射到存储器中：</span> </p> 
             <ul> 
              <li><p> <span><i>只读：</i>任何修改结果缓冲区的尝试都将导致抛出<a href="../ReadOnlyBufferException.html" title="java.nio中的类"><code>ReadOnlyBufferException</code></a> 。</span> <span>（ <a href="FileChannel.MapMode.html#READ_ONLY"><code>MapMode.READ_ONLY</code></a> ）</span> </p></li> 
              <li><p> <span><i>读/写：</i>对结果缓冲区所做的更改最终会传播到文件中;</span> <span>它们可能会或可能不会被映射到同一文件的其他程序看到。</span> <span>（ <a href="FileChannel.MapMode.html#READ_WRITE"><code>MapMode.READ_WRITE</code></a> ）</span> </p></li> 
              <li><p> <span><i>专用：</i>对生成的缓冲区所做的更改不会传播到文件，也不会对映射了同一文件的其他程序可见;</span> <span>相反，它们将导致创建缓冲区的修改部分的私有副本。</span> <span>（ <a href="FileChannel.MapMode.html#PRIVATE"><code>MapMode.PRIVATE</code></a> ）</span> </p></li> 
             </ul> 
             <p> <span>对于只读映射，必须打开此通道才能读取;</span> <span>对于读/写或私有映射，必须已打开此通道以进行读取和写入。</span> </p> 
             <p> <span>此方法返回的<a href="../MappedByteBuffer.html" title="java.nio中的类"><code><i>mapped byte buffer</i></code></a>的位置为零，限制和容量为<code>size</code> ;</span> <span>它的标记将是不确定的。</span> <span>缓冲区及其表示的映射将保持有效，直到缓冲区本身被垃圾收集。</span> </p> 
             <p> <span>映射一旦建立，就不依赖于用于创建映射的文件通道。</span> <span>特别是，关闭通道对映射的有效性没有影响。</span> </p> 
             <p> <span>内存映射文件的许多细节本质上依赖于底层操作系统，因此未指定。</span> <span>未指定请求的区域未完全包含在此通道的文件中时此方法的行为。</span> <span>是否通过此程序或其他程序对基础文件的内容或大小所做的更改传播到缓冲区是未指定的。</span> <span>未指定缓冲区更改传播到文件的速率。</span> </p> 
             <p> <span>对于大多数操作系统，将文件映射到内存比通过通常的<a href="#read(java.nio.ByteBuffer)"><code>read</code></a>和<a href="#write(java.nio.ByteBuffer)"><code>write</code></a>方法读取或写入几十千字节的数据更昂贵。</span> <span>从性能的角度来看，通常只需要将相对较大的文件映射到内存中。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <span><code>mode</code> -一个常数的<a href="FileChannel.MapMode.html#READ_ONLY"><code>READ_ONLY</code></a> ， <a href="FileChannel.MapMode.html#READ_WRITE"><code>READ_WRITE</code></a> ，或<a href="FileChannel.MapMode.html#PRIVATE"><code>PRIVATE</code></a>在所定义<a href="FileChannel.MapMode.html" title="java.nio.channels中的类"><code>FileChannel.MapMode</code></a>类，根据该文件是否是要被映射的只读，读/写，或私人（写入时复制），分别</span> 
             </dd> 
             <dd> 
              <span><code>position</code> - 文件中映射区域开始的位置;</span> 
              <span>必须是非负面的</span> 
             </dd> 
             <dd> 
              <span><code>size</code> - 要映射的区域的大小;</span> 
              <span>必须是非负数且不大于<a href="../../lang/Integer.html#MAX_VALUE"><code>Integer.MAX_VALUE</code></a></span> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               映射的字节缓冲区 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="NonReadableChannelException.html" title="class in java.nio.channels">NonReadableChannelException</a></code> - 如果 
              <code>mode</code>是 
              <a href="FileChannel.MapMode.html#READ_ONLY"><code>READ_ONLY</code></a>但此频道未打开以进行阅读 
             </dd> 
             <dd> 
              <code><a href="NonWritableChannelException.html" title="class in java.nio.channels">NonWritableChannelException</a></code> - 如果 
              <code>mode</code>是 
              <a href="FileChannel.MapMode.html#READ_WRITE"><code>READ_WRITE</code></a>或 
              <a href="FileChannel.MapMode.html#PRIVATE"><code>PRIVATE</code></a>但此信道未打开以进行读写 
             </dd> 
             <dd> 
              <code><a href="../../lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果参数的前提条件不成立 
             </dd> 
             <dd> 
              <code><a href="../../io/IOException.html" title="class in java.io">IOException</a></code> - 如果发生其他一些I / O错误 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <span><a href="FileChannel.MapMode.html" title="java.nio.channels中的类"><code>FileChannel.MapMode</code></a> ， <a href="../MappedByteBuffer.html" title="java.nio中的类"><code>MappedByteBuffer</code></a></span> 
             </dd> 
            </dl> </li> 
          </ul> <a id="lock(long,long,boolean)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>lock</h4> <pre class="methodSignature">public abstract&nbsp;<a href="FileLock.html" title="class in java.nio.channels">FileLock</a>&nbsp;lock​(long&nbsp;position,
                              long&nbsp;size,
                              boolean&nbsp;shared)
                       throws <a href="../../io/IOException.html" title="class in java.io">IOException</a></pre> 
            <div class="block"> 
             <span>获取此通道文件的给定区域的锁定。</span> 
             <p> <span>调用此方法将阻塞，直到可以锁定该区域，关闭此通道，或者中断调用线程，以先到者为准。</span> </p> 
             <p> <span>如果在调用此方法期间此通道被另一个线程关闭，则将抛出<a href="AsynchronousCloseException.html" title="java.nio.channels中的类"><code>AsynchronousCloseException</code></a> 。</span> </p> 
             <p> <span>如果在等待获取锁定时调用线程被中断，则将设置其中断状态并抛出<a href="FileLockInterruptionException.html" title="java.nio.channels中的类"><code>FileLockInterruptionException</code></a> 。</span> <span>如果在调用此方法时设置了调用程序的中断状态，则会立即抛出该异常;</span> <span>线程的中断状态不会改变。</span> </p> 
             <p> <span>由<code>position</code>和<code>size</code>参数指定的区域不需要包含在实际底层文件中，甚至不要包含在实际底层文件中。</span> <span>锁定区域的大小是固定的;</span> <span>如果锁定区域最初包含文件的末尾并且文件超出该区域，那么该文件的新部分将不会被锁定。</span> <span>如果预计文件的大小会增加并且需要锁定整个文件，则应锁定从零开始并且不小于文件的预期最大大小的区域。</span> <span>零参数<a href="#lock()"><code>lock()</code></a>方法只是锁定一个大小为<a href="../../lang/Long.html#MAX_VALUE"><code>Long.MAX_VALUE</code></a>的区域。</span> </p> 
             <p> <span>某些操作系统不支持共享锁，在这种情况下，对共享锁的请求会自动转换为独占锁的请求。</span> <span>可以通过调用生成的锁对象的<a href="FileLock.html#isShared()"><code>isShared</code></a>方法来测试新获取的锁是共享的还是独占的。</span> </p> 
             <p> <span>文件锁代表整个Java虚拟机。</span> <span>它们不适合控制同一虚拟机中多个线程对文件的访问。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <span><code>position</code> - 锁定区域开始的位置;</span> 
              <span>必须是非负面的</span> 
             </dd> 
             <dd> 
              <span><code>size</code> - 锁定区域的大小;</span> 
              <span>必须为非负数，且总和<code>position</code> + <code>size</code>必须为非负数</span> 
             </dd> 
             <dd> 
              <span><code>shared</code> - <code>true</code>请求共享锁，在这种情况下，此通道必须打开才能读取（并可能写入）;</span> 
              <span><code>false</code>请求独占锁定，在这种情况下，此通道必须打开才能写入（并可能读取）</span> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               表示新获取的锁的锁对象 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果参数的前提条件不成立 
             </dd> 
             <dd> 
              <code><a href="ClosedChannelException.html" title="class in java.nio.channels">ClosedChannelException</a></code> - 如果此渠道已关闭 
             </dd> 
             <dd> 
              <code><a href="AsynchronousCloseException.html" title="class in java.nio.channels">AsynchronousCloseException</a></code> - 如果在此方法中阻止调用线程，则另一个线程关闭此通道 
             </dd> 
             <dd> 
              <code><a href="FileLockInterruptionException.html" title="class in java.nio.channels">FileLockInterruptionException</a></code> - 如果在此方法中阻止调用线程被中断 
             </dd> 
             <dd> 
              <code><a href="OverlappingFileLockException.html" title="class in java.nio.channels">OverlappingFileLockException</a></code> - 如果此Java虚拟机已经拥有与所请求区域重叠的锁，或者此方法中已阻止另一个线程并且正在尝试锁定重叠区域 
             </dd> 
             <dd> 
              <code><a href="NonReadableChannelException.html" title="class in java.nio.channels">NonReadableChannelException</a></code> - 如果 
              <code>shared</code>是 
              <code>true</code>这个频道没有打开阅读 
             </dd> 
             <dd> 
              <code><a href="NonWritableChannelException.html" title="class in java.nio.channels">NonWritableChannelException</a></code> - 如果 
              <code>shared</code>是 
              <code>false</code>但此信道未开通以进行写入 
             </dd> 
             <dd> 
              <code><a href="../../io/IOException.html" title="class in java.io">IOException</a></code> - 如果发生其他一些I / O错误 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#lock()"><code>lock()</code></a> ， 
              <a href="#tryLock()"><code>tryLock()</code></a> ， 
              <a href="#tryLock(long,long,boolean)"><code>tryLock(long,long,boolean)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="lock()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>lock</h4> <pre class="methodSignature">public final&nbsp;<a href="FileLock.html" title="class in java.nio.channels">FileLock</a>&nbsp;lock()
                    throws <a href="../../io/IOException.html" title="class in java.io">IOException</a></pre> 
            <div class="block"> 
             <span>获取此频道文件的独占锁定。</span> 
             <p> <span>调用<code>fc.lock()</code>形式的此方法的行为与调用的方式完全相同</span> </p> 
             <pre>  <span>fc.<a href="#lock(long,long,boolean)"><code>lock</code></a>(0L, Long.MAX_VALUE, false)</span> </pre> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               表示新获取的锁的锁对象 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="ClosedChannelException.html" title="class in java.nio.channels">ClosedChannelException</a></code> - 如果此渠道已关闭 
             </dd> 
             <dd> 
              <code><a href="AsynchronousCloseException.html" title="class in java.nio.channels">AsynchronousCloseException</a></code> - 如果在此方法中阻止调用线程，则另一个线程关闭此通道 
             </dd> 
             <dd> 
              <code><a href="FileLockInterruptionException.html" title="class in java.nio.channels">FileLockInterruptionException</a></code> - 如果在此方法中阻止调用线程被中断 
             </dd> 
             <dd> 
              <code><a href="OverlappingFileLockException.html" title="class in java.nio.channels">OverlappingFileLockException</a></code> - 如果此Java虚拟机已经拥有与所请求区域重叠的锁，或者此方法中已阻止另一个线程并且正在尝试锁定同一文件的重叠区域 
             </dd> 
             <dd> 
              <code><a href="NonWritableChannelException.html" title="class in java.nio.channels">NonWritableChannelException</a></code> - 如果未打开此频道进行写入 
             </dd> 
             <dd> 
              <code><a href="../../io/IOException.html" title="class in java.io">IOException</a></code> - 如果发生其他一些I / O错误 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#lock(long,long,boolean)"><code>lock(long,long,boolean)</code></a> ， 
              <a href="#tryLock()"><code>tryLock()</code></a> ， 
              <a href="#tryLock(long,long,boolean)"><code>tryLock(long,long,boolean)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="tryLock(long,long,boolean)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>tryLock</h4> <pre class="methodSignature">public abstract&nbsp;<a href="FileLock.html" title="class in java.nio.channels">FileLock</a>&nbsp;tryLock​(long&nbsp;position,
                                 long&nbsp;size,
                                 boolean&nbsp;shared)
                          throws <a href="../../io/IOException.html" title="class in java.io">IOException</a></pre> 
            <div class="block"> 
             <span>尝试获取此频道文件的给定区域的锁定。</span> 
             <p> <span>此方法不会阻止。</span> <span>调用始终立即返回，要么已获取所请求区域的锁定，要么未能执行此操作。</span> <span>如果由于另一个程序持有重叠锁而无法获取锁定，则返回<code>null</code> 。</span> <span>如果由于任何其他原因而无法获取锁定，则会抛出相应的异常。</span> </p> 
             <p> <span>由<code>position</code>和<code>size</code>参数指定的区域不需要包含在实际底层文件中，甚至不要包含在实际底层文件中。</span> <span>锁定区域的大小是固定的;</span> <span>如果锁定区域最初包含文件的末尾并且文件超出该区域，那么该文件的新部分将不会被锁定。</span> <span>如果预计文件的大小会增加并且需要锁定整个文件，则应锁定从零开始并且不小于文件的预期最大大小的区域。</span> <span>零参数<a href="#tryLock()"><code>tryLock()</code></a>方法只是锁定大小为<a href="../../lang/Long.html#MAX_VALUE"><code>Long.MAX_VALUE</code></a>的区域。</span> </p> 
             <p> <span>某些操作系统不支持共享锁，在这种情况下，对共享锁的请求会自动转换为独占锁的请求。</span> <span>可以通过调用生成的锁定对象的<a href="FileLock.html#isShared()"><code>isShared</code></a>方法来测试新获取的锁是共享的还是独占的。</span> </p> 
             <p> <span>文件锁代表整个Java虚拟机。</span> <span>它们不适合控制同一虚拟机中多个线程对文件的访问。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <span><code>position</code> - 锁定区域开始的位置;</span> 
              <span>必须是非负面的</span> 
             </dd> 
             <dd> 
              <span><code>size</code> - 锁定区域的大小;</span> 
              <span>必须为非负数，且总和<code>position</code> + <code>size</code>必须为非负数</span> 
             </dd> 
             <dd> 
              <code>shared</code> - 
              <code>true</code>请求共享锁， 
              <code>false</code>请求独占锁 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               表示新获取的锁的锁对象，如果由于另一个程序持有重叠锁而无法获取锁， 
              <code>null</code> 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果参数的前提条件不成立 
             </dd> 
             <dd> 
              <code><a href="ClosedChannelException.html" title="class in java.nio.channels">ClosedChannelException</a></code> - 如果此渠道已关闭 
             </dd> 
             <dd> 
              <code><a href="OverlappingFileLockException.html" title="class in java.nio.channels">OverlappingFileLockException</a></code> - 如果此Java虚拟机已拥有与所请求区域重叠的锁，或者此方法中已阻止另一个线程并且正在尝试锁定同一文件的重叠区域 
             </dd> 
             <dd> 
              <code><a href="../../io/IOException.html" title="class in java.io">IOException</a></code> - 如果发生其他一些I / O错误 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#lock()"><code>lock()</code></a> ， 
              <a href="#lock(long,long,boolean)"><code>lock(long,long,boolean)</code></a> ， 
              <a href="#tryLock()"><code>tryLock()</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="tryLock()"> 
           <!--   --> </a> 
          <ul class="blockListLast"> 
           <li class="blockList"> <h4>tryLock</h4> <pre class="methodSignature">public final&nbsp;<a href="FileLock.html" title="class in java.nio.channels">FileLock</a>&nbsp;tryLock()
                       throws <a href="../../io/IOException.html" title="class in java.io">IOException</a></pre> 
            <div class="block"> 
             <span>尝试获取此频道文件的独占锁定。</span> 
             <p> <span>调用<code>fc.tryLock()</code>形式的此方法的行为与调用的方式完全相同</span> </p> 
             <pre>  <span>fc.<a href="#tryLock(long,long,boolean)"><code>tryLock</code></a>(0L, Long.MAX_VALUE, false)</span> </pre> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               表示新获取的锁的锁对象，如果由于另一个程序持有重叠锁而无法获取锁， 
              <code>null</code> 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="ClosedChannelException.html" title="class in java.nio.channels">ClosedChannelException</a></code> - 如果此渠道已关闭 
             </dd> 
             <dd> 
              <code><a href="OverlappingFileLockException.html" title="class in java.nio.channels">OverlappingFileLockException</a></code> - 如果此Java虚拟机已经拥有与所请求区域重叠的锁，或者此方法中已阻止另一个线程并且正在尝试锁定重叠区域 
             </dd> 
             <dd> 
              <code><a href="../../io/IOException.html" title="class in java.io">IOException</a></code> - 如果发生其他一些I / O错误 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#lock()"><code>lock()</code></a> ， 
              <a href="#lock(long,long,boolean)"><code>lock(long,long,boolean)</code></a> ， 
              <a href="#tryLock(long,long,boolean)"><code>tryLock(long,long,boolean)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> </li> 
        </ul> 
       </section> </li> 
     </ul> 
    </div> 
   </div> 
  </main> 
  <!-- ========= END OF CLASS DATA ========= --> 
  <footer role="contentinfo"> 
   <nav role="navigation"> 
    <!-- ======= START OF BOTTOM NAVBAR ====== --> 
    <div class="bottomNav"> 
     <a id="navbar.bottom"> 
      <!--   --> </a> 
     <div class="skipNav"> 
      <a href="#skip.navbar.bottom" title="Skip navigation links">跳过导航</a> 
     </div> 
     <a id="navbar.bottom.firstrow"> 
      <!--   --> </a> 
     <ul class="navList" title="Navigation"> 
      <li><a href="../../../../index.html">概述</a></li> 
      <li><a href="../../../module-summary.html">模块</a></li> 
      <li><a href="package-summary.html">软件包</a></li> 
      <li class="navBarCell1Rev">类</li> 
      <li><a href="class-use/FileChannel.html">使用</a></li> 
      <li><a href="package-tree.html">树</a></li> 
      <li><a href="../../../../deprecated-list.html">已过时的</a></li> 
      <li><a href="../../../../index-files/index-1.html">索引</a></li> 
      <li><a href="../../../../help-doc.html">帮助</a></li> 
     </ul> 
     <div class="aboutLanguage"> 
      <div style="margin-top: 14px;"> 
       <strong>Java SE 11 &amp; JDK 11</strong> 
      </div> 
     </div> 
    </div> 
    <div class="subNav"> 
     <ul class="navList" id="allclasses_navbar_bottom"> 
      <li><a href="../../../../allclasses.html">所有类</a></li> 
     </ul> 
     <div> 
      <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
      <noscript> 
       <div>
         JavaScript is disabled on your browser. 
       </div> 
      </noscript> 
     </div> 
     <div> 
      <ul class="subNavList"> 
       <li>概要：&nbsp;</li> 
       <li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li> 
       <li>字段&nbsp;|&nbsp;</li> 
       <li><a href="#constructor.summary">构造方法</a>&nbsp;|&nbsp;</li> 
       <li><a href="#method.summary">方法</a></li> 
      </ul> 
      <ul class="subNavList"> 
       <li>详细信息：&nbsp;</li> 
       <li>字段&nbsp;|&nbsp;</li> 
       <li><a href="#constructor.detail">构造方法</a>&nbsp;|&nbsp;</li> 
       <li><a href="#method.detail">方法</a></li> 
      </ul> 
     </div> 
     <a id="skip.navbar.bottom"> 
      <!--   --> </a> 
    </div> 
    <!-- ======== END OF BOTTOM NAVBAR ======= --> 
   </nav> 
   <p class="legalCopy"><small><a href="http://bugreport.java.com/bugreport/">Report a bug or suggest an enhancement</a><br> For further API reference and developer documentation see the <a href="http://www.oracle.com/pls/topic/lookup?ctx=javase11.0.1&amp;id=homepage" target="_blank">Java SE Documentation</a>, which contains more detailed, developer-targeted descriptions with conceptual overviews, definitions of terms, workarounds, and working code examples.<br> Java is a trademark or registered trademark of Oracle and/or its affiliates in the US and other countries.<br> <a href="../../../../../legal/copyright.html">Copyright</a> © 1993, 2018, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.<br>All rights reserved. Use is subject to <a href="http://www.oracle.com/technetwork/java/javase/terms/license/java11.0.1speclicense.html">license terms</a> and the <a href="http://www.oracle.com/technetwork/java/redist-137594.html">documentation redistribution policy</a>. 
     <!-- Version 11.0.1+13-LTS --></small></p> 
  </footer>  
 </body>
</html>