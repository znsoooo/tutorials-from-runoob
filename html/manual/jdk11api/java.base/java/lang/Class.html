<!doctype html>
<!-- NewPage -->
<html lang="en">
 <head> 
  <!-- Generated by javadoc --> 
  <title>Class</title> 
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> 
  <meta name="keywords" content="java.lang.Class class"> 
  <meta name="keywords" content="toString()"> 
  <meta name="keywords" content="toGenericString()"> 
  <meta name="keywords" content="forName()"> 
  <meta name="keywords" content="newInstance()"> 
  <meta name="keywords" content="isInstance()"> 
  <meta name="keywords" content="isAssignableFrom()"> 
  <meta name="keywords" content="isInterface()"> 
  <meta name="keywords" content="isArray()"> 
  <meta name="keywords" content="isPrimitive()"> 
  <meta name="keywords" content="isAnnotation()"> 
  <meta name="keywords" content="isSynthetic()"> 
  <meta name="keywords" content="getName()"> 
  <meta name="keywords" content="getClassLoader()"> 
  <meta name="keywords" content="getModule()"> 
  <meta name="keywords" content="getTypeParameters()"> 
  <meta name="keywords" content="getSuperclass()"> 
  <meta name="keywords" content="getGenericSuperclass()"> 
  <meta name="keywords" content="getPackage()"> 
  <meta name="keywords" content="getPackageName()"> 
  <meta name="keywords" content="getInterfaces()"> 
  <meta name="keywords" content="getGenericInterfaces()"> 
  <meta name="keywords" content="getComponentType()"> 
  <meta name="keywords" content="getModifiers()"> 
  <meta name="keywords" content="getSigners()"> 
  <meta name="keywords" content="getEnclosingMethod()"> 
  <meta name="keywords" content="getEnclosingConstructor()"> 
  <meta name="keywords" content="getDeclaringClass()"> 
  <meta name="keywords" content="getEnclosingClass()"> 
  <meta name="keywords" content="getSimpleName()"> 
  <meta name="keywords" content="getTypeName()"> 
  <meta name="keywords" content="getCanonicalName()"> 
  <meta name="keywords" content="isAnonymousClass()"> 
  <meta name="keywords" content="isLocalClass()"> 
  <meta name="keywords" content="isMemberClass()"> 
  <meta name="keywords" content="getClasses()"> 
  <meta name="keywords" content="getFields()"> 
  <meta name="keywords" content="getMethods()"> 
  <meta name="keywords" content="getConstructors()"> 
  <meta name="keywords" content="getField()"> 
  <meta name="keywords" content="getMethod()"> 
  <meta name="keywords" content="getConstructor()"> 
  <meta name="keywords" content="getDeclaredClasses()"> 
  <meta name="keywords" content="getDeclaredFields()"> 
  <meta name="keywords" content="getDeclaredMethods()"> 
  <meta name="keywords" content="getDeclaredConstructors()"> 
  <meta name="keywords" content="getDeclaredField()"> 
  <meta name="keywords" content="getDeclaredMethod()"> 
  <meta name="keywords" content="getDeclaredConstructor()"> 
  <meta name="keywords" content="getResourceAsStream()"> 
  <meta name="keywords" content="getResource()"> 
  <meta name="keywords" content="getProtectionDomain()"> 
  <meta name="keywords" content="desiredAssertionStatus()"> 
  <meta name="keywords" content="isEnum()"> 
  <meta name="keywords" content="getEnumConstants()"> 
  <meta name="keywords" content="cast()"> 
  <meta name="keywords" content="asSubclass()"> 
  <meta name="keywords" content="getAnnotation()"> 
  <meta name="keywords" content="isAnnotationPresent()"> 
  <meta name="keywords" content="getAnnotationsByType()"> 
  <meta name="keywords" content="getAnnotations()"> 
  <meta name="keywords" content="getDeclaredAnnotation()"> 
  <meta name="keywords" content="getDeclaredAnnotationsByType()"> 
  <meta name="keywords" content="getDeclaredAnnotations()"> 
  <meta name="keywords" content="getAnnotatedSuperclass()"> 
  <meta name="keywords" content="getAnnotatedInterfaces()"> 
  <meta name="keywords" content="getNestHost()"> 
  <meta name="keywords" content="isNestmateOf()"> 
  <meta name="keywords" content="getNestMembers()"> 
  <link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style"> 
  <link rel="stylesheet" type="text/css" href="../../../jquery/jquery-ui.css" title="Style"> 
  <script type="text/javascript" src="../../../script.js"></script> 
  <script type="text/javascript" src="../../../jquery/jszip/dist/jszip.js"></script> 
  <script type="text/javascript" src="../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script> 
  <!--[if IE]>
<script type="text/javascript" src="../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]--> 
  <script type="text/javascript" src="../../../jquery/jquery-1.10.2.js"></script> 
  <script type="text/javascript" src="../../../jquery/jquery-migrate-1.2.1.js"></script> 
  <script type="text/javascript" src="../../../jquery/jquery-ui.js"></script> 
 </head> 
 <body> <SCRIPT LANGUAGE="JavaScript"><!-- Hide  
   function ResumeError() {     return true;}window.onerror = ResumeError;// --></SCRIPT>
  <script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Class (Java SE 11 & JDK 11 )";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":10,"i1":10,"i2":10,"i3":9,"i4":9,"i5":9,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10,"i24":10,"i25":10,"i26":10,"i27":10,"i28":10,"i29":10,"i30":10,"i31":10,"i32":10,"i33":10,"i34":10,"i35":10,"i36":10,"i37":10,"i38":10,"i39":10,"i40":10,"i41":10,"i42":10,"i43":10,"i44":10,"i45":10,"i46":10,"i47":10,"i48":10,"i49":10,"i50":10,"i51":10,"i52":10,"i53":10,"i54":10,"i55":10,"i56":10,"i57":10,"i58":10,"i59":10,"i60":10,"i61":10,"i62":10,"i63":10,"i64":10,"i65":10,"i66":10,"i67":42,"i68":10,"i69":10};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"],32:["t6","Deprecated Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script> 
  <noscript> 
   <div>
     JavaScript is disabled on your browser. 
   </div> 
  </noscript> 
  <header role="banner"> 
   <nav role="navigation"> 
    <div class="fixedNav"> 
     <!-- ========= START OF TOP NAVBAR ======= --> 
     <div class="topNav"> 
      <a id="navbar.top"> 
       <!--   --> </a> 
      <div class="skipNav"> 
       <a href="#skip.navbar.top" title="Skip navigation links">跳过导航</a> 
      </div> 
      <a id="navbar.top.firstrow"> 
       <!--   --> </a> 
      <ul class="navList" title="Navigation"> 
       <li><a href="../../../index.html">概述</a></li> 
       <li><a href="../../module-summary.html">模块</a></li> 
       <li><a href="package-summary.html">软件包</a></li> 
       <li class="navBarCell1Rev">类</li> 
       <li><a href="class-use/Class.html">使用</a></li> 
       <li><a href="package-tree.html">树</a></li> 
       <li><a href="../../../deprecated-list.html">已过时的</a></li> 
       <li><a href="../../../index-files/index-1.html">索引</a></li> 
       <li><a href="../../../help-doc.html">帮助</a></li> 
      </ul> 
      <div class="aboutLanguage"> 
       <div style="margin-top: 14px;"> 
        <strong>Java SE 11 &amp; JDK 11</strong> 
       </div> 
      </div> 
     </div> 
     <div class="subNav"> 
      <ul class="navList" id="allclasses_navbar_top"> 
       <li><a href="../../../allclasses.html">所有类</a></li> 
      </ul> 
      <ul class="navListSearch"> 
       <li><label for="search">SEARCH:</label> <input type="text" id="search" value="search" disabled> <input type="reset" id="reset" value="reset" disabled> </li> 
      </ul> 
      <div> 
       <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
       <noscript> 
        <div>
          JavaScript is disabled on your browser. 
        </div> 
       </noscript> 
      </div> 
       <div class="fixedNav">
       <ul class="subNavList"> 
        <li>概要：&nbsp;</li> 
        <li>嵌套&nbsp;|&nbsp;</li> 
        <li>字段&nbsp;|&nbsp;</li> 
        <li>构造方法&nbsp;|&nbsp;</li> 
        <li><a href="#method.summary">方法</a></li> 
       </ul> 
       <ul class="subNavList"> 
        <li>详细信息：&nbsp;</li> 
        <li>字段&nbsp;|&nbsp;</li> 
        <li>构造方法&nbsp;|&nbsp;</li> 
        <li><a href="#method.detail">方法</a></li> 
       </ul> 
      </div> 
      <a id="skip.navbar.top"> 
       <!--   --> </a> 
     </div> 
     <!-- ========= END OF TOP NAVBAR ========= --> 
    </div> 
    <div class="navPadding">
      &nbsp; 
    </div> 
    <script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script> 
   </nav> 
  </header> 
  <!-- ======== START OF CLASS DATA ======== --> 
  <main role="main"> 
   <div class="header"> 
    <div class="subTitle"> 
     <span class="moduleLabelInType">模块</span>&nbsp; 
     <a href="../../module-summary.html">java.base</a> 
    </div> 
    <div class="subTitle"> 
     <span class="packageLabelInType">软件包</span>&nbsp; 
     <a href="package-summary.html">java.lang</a> 
    </div> 
    <h2 title="Class Class" class="title">Class Class&lt;T&gt;</h2> 
   </div> 
   <div class="contentContainer"> 
    <ul class="inheritance"> 
     <li><a href="Object.html" title="class in java.lang">java.lang.Object</a></li> 
     <li> 
      <ul class="inheritance"> 
       <li>java.lang.Class&lt;T&gt;</li> 
      </ul> </li> 
    </ul> 
    <div class="description"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <dl> 
        <dt> 
         <span class="paramLabel">参数类型</span> 
        </dt> 
        <dd> 
         <span><code>T</code> - 此<code>类</code>对象建模的类的类型。</span> 
         <span>例如， <code>String.class</code>的类型是<code>Class&lt;String&gt;</code> 。</span> 
         <span>如果正在建模的类未知，请使用<code>Class&lt;?&gt;</code> 。</span> 
        </dd> 
       </dl> 
       <dl> 
        <dt>
          实现的所有接口
        </dt> 
        <dd> 
         <code><a href="../io/Serializable.html" title="interface in java.io">Serializable</a></code> ， 
         <code><a href="reflect/AnnotatedElement.html" title="interface in java.lang.reflect">AnnotatedElement</a></code> ， 
         <code><a href="reflect/GenericDeclaration.html" title="interface in java.lang.reflect">GenericDeclaration</a></code> ， 
         <code><a href="reflect/Type.html" title="interface in java.lang.reflect">Type</a></code> 
        </dd> 
       </dl> 
       <hr> <pre>public final class <span class="typeNameLabel">Class&lt;T&gt;</span>
extends <a href="Object.html" title="class in java.lang">Object</a>
implements <a href="../io/Serializable.html" title="interface in java.io">Serializable</a>, <a href="reflect/GenericDeclaration.html" title="interface in java.lang.reflect">GenericDeclaration</a>, <a href="reflect/Type.html" title="interface in java.lang.reflect">Type</a>, <a href="reflect/AnnotatedElement.html" title="interface in java.lang.reflect">AnnotatedElement</a></pre> 
       <div class="block"> 
        <span>类<code>类</code>实例表示正在运行的Java应用程序中的类和接口。</span> 
        <span>枚举类型是一种类，注释类型是一种接口。</span> 
        <span>每个数组也属于一个类，该类反映为<code>类</code>对象，由具有相同元素类型和维数的所有数组共享。</span> 
        <span>原始Java类型（ <code>boolean</code> ， <code>byte</code> ， <code>char</code> ， <code>short</code> ， <code>int</code> ， <code>long</code> ， <code>float</code> ，和<code>double</code> ），以及关键字<code>void</code>也表示为<code>类</code>对象。</span> 
        <p> <span><code>类</code>没有公共构造函数。</span> <span>而是当类加载器调用<a href="ClassLoader.html#defineClass(java.lang.String,byte%5B%5D,int,int)"><code>defineClass</code></a>方法之一并传递<code>class</code>文件的字节时，Java虚拟机会自动构造<code>类</code>对象。</span> </p> 
        <p> <span>类<code>类</code>的方法暴露了类或接口的许多特征。</span> <span>大多数特性派生自类加载器传递给Java虚拟机的<code>class</code>文件。</span> <span>一些特性由运行时的类加载环境决定，例如<a href="#getModule()"><code>getModule()</code></a>返回的模块。</span> </p> 
        <p> <span>类<code>类</code>某些方法公开Java源代码中的类或接口的声明是否<em>包含</em>在另一个声明中。</span> <span>其他方法描述了类或接口如何位于<em>嵌套中</em> 。</span> <span><a id="nest">nest</a>是一组类和接口，在同一运行时包中，允许相互访问其<code>private</code>成员。</span> <span>类和接口称为<em>nestmates</em> 。</span> <span>一个巢穴充当<em>巢主</em> ，并列举属于巢的其他巢穴;</span> <span>它们中的每一个又将其记录为嵌套主机。</span> <span>属于嵌套的类（包括其主机）的类和接口是在生成<code>class</code>文件时确定的，例如，Java编译器通常会将顶级类记录为嵌套的主机，其中其他成员是类，声明包含在顶级类声明中的接口。</span> </p> 
        <p> <span>以下示例使用<code>类</code>对象来打印对象的类名：</span> </p> 
        <blockquote> 
         <span><pre>
     void printClassName(Object obj) {
         System.out.println("The class of " + obj +
                            " is " + obj.getClass().getName());
     }
 </pre></span> 
        </blockquote> 
        <p> <span>也可以使用类文字为指定类型（或void）获取<code>类</code>对象。</span> <span>参见<cite>The Java™ Language Specification的</cite>第15.8.2节。</span> <span>例如：</span> </p> 
        <blockquote> 
         <span><code>System.out.println("The name of class Foo is: "+Foo.class.getName());</code></span> 
        </blockquote> 
       </div> 
       <dl> 
        <dt> 
         <span class="simpleTagLabel">从以下版本开始：</span> 
        </dt> 
        <dd>
          1.0 
        </dd> 
        <dt> 
         <span class="seeLabel">另请参见：</span> 
        </dt> 
        <dd> 
         <a href="ClassLoader.html#defineClass(byte%5B%5D,int,int)"><code>ClassLoader.defineClass(byte[], int, int)</code></a> ， 
         <a href="../../../serialized-form.html#java.lang.Class">Serialized Form</a> 
        </dd> 
       </dl> </li> 
     </ul> 
    </div> 
    <div class="summary"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <!-- ========== METHOD SUMMARY =========== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="method.summary"> 
           <!--   --> </a> <h3>方法摘要</h3> 
          <table class="memberSummary"> 
           <caption> 
           <span id="t0" class="activeTableTab"><span>所有方法</span><span class="tabEnd">&nbsp;</span>
            <span id="t1" class="tableTab"><span><a href="javascript:show(1);">静态方法</a></span><span class="tabEnd">&nbsp;</span></span> 
             <span id="t2" class="tableTab"><span><a href="javascript:show(2);">实例方法</a>  </span></span> 
            <span id="t4" class="tableTab"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd">&nbsp;</span></span> 
            <span id="t6" class="tableTab"><span><a href="javascript:show(32);">弃用的方法</a></span><span class="tabEnd">&nbsp;</span></span> 
           </caption> 
           <tbody> 
            <tr> 
             <th class="colFirst" scope="col">变量和类型</th> 
             <th class="colSecond" scope="col">方法</th> 
             <th class="colLast" scope="col">描述</th> 
            </tr> 
            <tr id="i0" class="altColor"> 
             <td class="colFirst"><code>&lt;U&gt;&nbsp;<a href="Class.html" title="class in java.lang">类</a>&lt;? extends U&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#asSubclass(java.lang.Class)">asSubclass</a></span>​(<a href="Class.html" title="class in java.lang">类</a>&lt;U&gt;&nbsp;clazz)</code></th> 
             <td class="colLast"> 
              <div class="block">
                转换此 
               <code>类</code>对象以表示由指定的类对象表示的类的子类。 
              </div> </td> 
            </tr> 
            <tr id="i1" class="rowColor"> 
             <td class="colFirst"><code><a href="Class.html" title="type parameter in Class">T</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#cast(java.lang.Object)">cast</a></span>​(<a href="Object.html" title="class in java.lang">Object</a>&nbsp;obj)</code></th> 
             <td class="colLast"> 
              <div class="block">
                将对象 
               <code>类</code>为此 
               <code>类</code>对象表示的类或接口。 
              </div> </td> 
            </tr> 
            <tr id="i2" class="altColor"> 
             <td class="colFirst"><code>boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#desiredAssertionStatus()">desiredAssertionStatus</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                如果要在调用此方法时初始化，则返回将分配给此类的断言状态。 
              </div> </td> 
            </tr> 
            <tr id="i3" class="rowColor"> 
             <td class="colFirst"><code>static <a href="Class.html" title="class in java.lang">类</a>&lt;?&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#forName(java.lang.Module,java.lang.String)">forName</a></span>​(<a href="Module.html" title="class in java.lang">模块</a>&nbsp;module, <a href="String.html" title="class in java.lang">String</a>&nbsp;name)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>类</code>给定 
               <a href="ClassLoader.html#name">binary name</a>给定的模块中。 
              </div> </td> 
            </tr> 
            <tr id="i4" class="altColor"> 
             <td class="colFirst"><code>static <a href="Class.html" title="class in java.lang">类</a>&lt;?&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#forName(java.lang.String)">forName</a></span>​(<a href="String.html" title="class in java.lang">String</a>&nbsp;className)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回与具有给定字符串名称的类或接口关联的 
               <code>类</code>对象。 
              </div> </td> 
            </tr> 
            <tr id="i5" class="rowColor"> 
             <td class="colFirst"><code>static <a href="Class.html" title="class in java.lang">类</a>&lt;?&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#forName(java.lang.String,boolean,java.lang.ClassLoader)">forName</a></span>​(<a href="String.html" title="class in java.lang">String</a>&nbsp;name, boolean&nbsp;initialize, <a href="ClassLoader.html" title="class in java.lang">ClassLoader</a>&nbsp;loader)</code></th> 
             <td class="colLast"> 
              <div class="block">
                使用给定的类加载器返回与具有给定字符串名称的类或接口关联的 
               <code>类</code>对象。 
              </div> </td> 
            </tr> 
            <tr id="i6" class="altColor"> 
             <td class="colFirst"><code><a href="reflect/AnnotatedType.html" title="interface in java.lang.reflect">AnnotatedType</a>[]</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getAnnotatedInterfaces()">getAnnotatedInterfaces</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>AnnotatedType</code>对象的数组， 
               <code>AnnotatedType</code>对象表示使用类型来指定此 
               <code>类</code>对象所表示的实体的超 
               <code>类</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i7" class="rowColor"> 
             <td class="colFirst"><code><a href="reflect/AnnotatedType.html" title="interface in java.lang.reflect">AnnotatedType</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getAnnotatedSuperclass()">getAnnotatedSuperclass</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回一个 
               <code>AnnotatedType</code>对象，该对象表示使用类型来指定此 
               <code>类</code>对象所表示的实体的超类。 
              </div> </td> 
            </tr> 
            <tr id="i8" class="altColor"> 
             <td class="colFirst"><code>&lt;A extends <a href="annotation/Annotation.html" title="interface in java.lang.annotation">Annotation</a>&gt;<br>A</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getAnnotation(java.lang.Class)">getAnnotation</a></span>​(<a href="Class.html" title="class in java.lang">类</a>&lt;A&gt;&nbsp;annotationClass)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回该元素的，如果这样的注释 
               <em>，</em>否则返回null指定类型的注释。 
              </div> </td> 
            </tr> 
            <tr id="i9" class="rowColor"> 
             <td class="colFirst"><code><a href="annotation/Annotation.html" title="interface in java.lang.annotation">Annotation</a>[]</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getAnnotations()">getAnnotations</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回此元素上 
               <em>存在的</em>注释。 
              </div> </td> 
            </tr> 
            <tr id="i10" class="altColor"> 
             <td class="colFirst"><code>&lt;A extends <a href="annotation/Annotation.html" title="interface in java.lang.annotation">Annotation</a>&gt;<br>A[]</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getAnnotationsByType(java.lang.Class)">getAnnotationsByType</a></span>​(<a href="Class.html" title="class in java.lang">类</a>&lt;A&gt;&nbsp;annotationClass)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回与此元素 
               <em>关联的</em>注释。 
              </div> </td> 
            </tr> 
            <tr id="i11" class="rowColor"> 
             <td class="colFirst"><code><a href="String.html" title="class in java.lang">String</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getCanonicalName()">getCanonicalName</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回Java语言规范定义的基础类的规范名称。 
              </div> </td> 
            </tr> 
            <tr id="i12" class="altColor"> 
             <td class="colFirst"><code><a href="Class.html" title="class in java.lang">类</a>&lt;?&gt;[]</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getClasses()">getClasses</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回一个包含 
               <code>类</code>对象的数组， 
               <code>类</code>对象表示作为此 
               <code>类</code>对象所表示的类的成员的所有公共类和接口。 
              </div> </td> 
            </tr> 
            <tr id="i13" class="rowColor"> 
             <td class="colFirst"><code><a href="ClassLoader.html" title="class in java.lang">ClassLoader</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getClassLoader()">getClassLoader</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回类的类加载器。 
              </div> </td> 
            </tr> 
            <tr id="i14" class="altColor"> 
             <td class="colFirst"><code><a href="Class.html" title="class in java.lang">类</a>&lt;?&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getComponentType()">getComponentType</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回表示数组的组件类型的 
               <code>类</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i15" class="rowColor"> 
             <td class="colFirst"><code><a href="reflect/Constructor.html" title="class in java.lang.reflect">构造器</a>&lt;<a href="Class.html" title="type parameter in Class">T</a>&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getConstructor(java.lang.Class...)">getConstructor</a></span>​(<a href="Class.html" title="class in java.lang">类</a>&lt;?&gt;...&nbsp;parameterTypes)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回一个 
               <code>构造器</code>对象，该对象反映此 
               <code>类</code>对象所表示的类的指定公共构造函数。 
              </div> </td> 
            </tr> 
            <tr id="i16" class="altColor"> 
             <td class="colFirst"><code><a href="reflect/Constructor.html" title="class in java.lang.reflect">构造器</a>&lt;?&gt;[]</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getConstructors()">getConstructors</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回一个包含 
               <code>构造器</code>对象的数组， 
               <code>构造器</code>对象反映了此 
               <code>类</code>对象所表示的类的所有公共构造函数。 
              </div> </td> 
            </tr> 
            <tr id="i17" class="rowColor"> 
             <td class="colFirst"><code>&lt;A extends <a href="annotation/Annotation.html" title="interface in java.lang.annotation">Annotation</a>&gt;<br>A</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getDeclaredAnnotation(java.lang.Class)">getDeclaredAnnotation</a></span>​(<a href="Class.html" title="class in java.lang">类</a>&lt;A&gt;&nbsp;annotationClass)</code></th> 
             <td class="colLast"> 
              <div class="block">
                如果 
               <em>直接存在</em>这样的注释，则返回指定类型的此元素的注释，否则返回null。 
              </div> </td> 
            </tr> 
            <tr id="i18" class="altColor"> 
             <td class="colFirst"><code><a href="annotation/Annotation.html" title="interface in java.lang.annotation">Annotation</a>[]</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getDeclaredAnnotations()">getDeclaredAnnotations</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <em>直接出现</em>在此元素上的注释。 
              </div> </td> 
            </tr> 
            <tr id="i19" class="rowColor"> 
             <td class="colFirst"><code>&lt;A extends <a href="annotation/Annotation.html" title="interface in java.lang.annotation">Annotation</a>&gt;<br>A[]</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getDeclaredAnnotationsByType(java.lang.Class)">getDeclaredAnnotationsByType</a></span>​(<a href="Class.html" title="class in java.lang">类</a>&lt;A&gt;&nbsp;annotationClass)</code></th> 
             <td class="colLast"> 
              <div class="block">
                如果此类注释 
               <em>直接存在</em>或 
               <em>间接存在</em> ，则返回指定类型的此元素的注释。 
              </div> </td> 
            </tr> 
            <tr id="i20" class="altColor"> 
             <td class="colFirst"><code><a href="Class.html" title="class in java.lang">类</a>&lt;?&gt;[]</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getDeclaredClasses()">getDeclaredClasses</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>类</code>对象的数组， 
               <code>类</code>对象反映声明为此 
               <code>类</code>对象所表示的类的成员的所有类和接口。 
              </div> </td> 
            </tr> 
            <tr id="i21" class="rowColor"> 
             <td class="colFirst"><code><a href="reflect/Constructor.html" title="class in java.lang.reflect">构造器</a>&lt;<a href="Class.html" title="type parameter in Class">T</a>&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getDeclaredConstructor(java.lang.Class...)">getDeclaredConstructor</a></span>​(<a href="Class.html" title="class in java.lang">类</a>&lt;?&gt;...&nbsp;parameterTypes)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回一个 
               <code>构造器</code>对象，该对象反映此 
               <code>类</code>对象所表示的类或接口的指定构造函数。 
              </div> </td> 
            </tr> 
            <tr id="i22" class="altColor"> 
             <td class="colFirst"><code><a href="reflect/Constructor.html" title="class in java.lang.reflect">构造器</a>&lt;?&gt;[]</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getDeclaredConstructors()">getDeclaredConstructors</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>构造器</code>对象的数组， 
               <code>构造器</code>对象反映由此 
               <code>类</code>对象表示的类声明的所有构造函数。 
              </div> </td> 
            </tr> 
            <tr id="i23" class="rowColor"> 
             <td class="colFirst"><code><a href="reflect/Field.html" title="class in java.lang.reflect">字段</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getDeclaredField(java.lang.String)">getDeclaredField</a></span>​(<a href="String.html" title="class in java.lang">String</a>&nbsp;name)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>字段</code>对象，该对象反映此 
               <code>类</code>对象表示的类或接口的指定声明字段。 
              </div> </td> 
            </tr> 
            <tr id="i24" class="altColor"> 
             <td class="colFirst"><code><a href="reflect/Field.html" title="class in java.lang.reflect">字段</a>[]</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getDeclaredFields()">getDeclaredFields</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>字段</code>对象的数组， 
               <code>字段</code>对象反映由此 
               <code>类</code>对象表示的类或接口声明的所有字段。 
              </div> </td> 
            </tr> 
            <tr id="i25" class="rowColor"> 
             <td class="colFirst"><code><a href="reflect/Method.html" title="class in java.lang.reflect">方法</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getDeclaredMethod(java.lang.String,java.lang.Class...)">getDeclaredMethod</a></span>​(<a href="String.html" title="class in java.lang">String</a>&nbsp;name, <a href="Class.html" title="class in java.lang">类</a>&lt;?&gt;...&nbsp;parameterTypes)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>方法</code>对象，该对象反映此 
               <code>类</code>对象表示的类或接口的指定声明方法。 
              </div> </td> 
            </tr> 
            <tr id="i26" class="altColor"> 
             <td class="colFirst"><code><a href="reflect/Method.html" title="class in java.lang.reflect">方法</a>[]</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getDeclaredMethods()">getDeclaredMethods</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回一个包含 
               <code>方法</code>对象的数组， 
               <code>方法</code>对象反映此 
               <code>类</code>对象表示的类或接口的所有已声明方法，包括public，protected，default（package）访问和私有方法，但不包括继承的方法。 
              </div> </td> 
            </tr> 
            <tr id="i27" class="rowColor"> 
             <td class="colFirst"><code><a href="Class.html" title="class in java.lang">类</a>&lt;?&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getDeclaringClass()">getDeclaringClass</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                如果此 
               <code>类</code>对象表示的类或接口是另一个类的成员，则返回表示声明它的类的 
               <code>类</code>对象。 
              </div> </td> 
            </tr> 
            <tr id="i28" class="altColor"> 
             <td class="colFirst"><code><a href="Class.html" title="class in java.lang">类</a>&lt;?&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getEnclosingClass()">getEnclosingClass</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回基础类的直接封闭类。 
              </div> </td> 
            </tr> 
            <tr id="i29" class="rowColor"> 
             <td class="colFirst"><code><a href="reflect/Constructor.html" title="class in java.lang.reflect">构造器</a>&lt;?&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getEnclosingConstructor()">getEnclosingConstructor</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block"> 
               <span>如果此<code>类</code>对象表示构造函数中的本地或匿名类，则返回表示基础类的直接封闭构造函数的<a href="reflect/Constructor.html" title="java.lang.reflect中的类"><code>构造器</code></a>对象。</span> 
              </div> </td> 
            </tr> 
            <tr id="i30" class="altColor"> 
             <td class="colFirst"><code><a href="reflect/Method.html" title="class in java.lang.reflect">方法</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getEnclosingMethod()">getEnclosingMethod</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block"> 
               <span>如果此<code>类</code>对象表示方法中的本地或匿名类，则返回<a href="reflect/Method.html" title="java.lang.reflect中的类"><code>方法</code></a>对象，该对象表示基础类的直接封闭方法。</span> 
              </div> </td> 
            </tr> 
            <tr id="i31" class="rowColor"> 
             <td class="colFirst"><code><a href="Class.html" title="type parameter in Class">T</a>[]</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getEnumConstants()">getEnumConstants</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回此枚举类的元素，如果此Class对象不表示枚举类型，则返回null。 
              </div> </td> 
            </tr> 
            <tr id="i32" class="altColor"> 
             <td class="colFirst"><code><a href="reflect/Field.html" title="class in java.lang.reflect">字段</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getField(java.lang.String)">getField</a></span>​(<a href="String.html" title="class in java.lang">String</a>&nbsp;name)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>字段</code>对象，该对象反映此 
               <code>类</code>对象表示的类或接口的指定公共成员字段。 
              </div> </td> 
            </tr> 
            <tr id="i33" class="rowColor"> 
             <td class="colFirst"><code><a href="reflect/Field.html" title="class in java.lang.reflect">字段</a>[]</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getFields()">getFields</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回一个包含 
               <code>字段</code>对象的数组， 
               <code>字段</code>对象反映此 
               <code>类</code>对象所表示的类或接口的所有可访问公共字段。 
              </div> </td> 
            </tr> 
            <tr id="i34" class="altColor"> 
             <td class="colFirst"><code><a href="reflect/Type.html" title="interface in java.lang.reflect">Type</a>[]</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getGenericInterfaces()">getGenericInterfaces</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回表示由此对象表示的类或接口直接实现的接口的 
               <code>Type</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i35" class="rowColor"> 
             <td class="colFirst"><code><a href="reflect/Type.html" title="interface in java.lang.reflect">Type</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getGenericSuperclass()">getGenericSuperclass</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>Type</code>表示此所表示的实体（类，接口，基本类型或void）的直接超类 
               <code>类</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i36" class="altColor"> 
             <td class="colFirst"><code><a href="Class.html" title="class in java.lang">类</a>&lt;?&gt;[]</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getInterfaces()">getInterfaces</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回由此对象表示的类或接口直接实现的接口。 
              </div> </td> 
            </tr> 
            <tr id="i37" class="rowColor"> 
             <td class="colFirst"><code><a href="reflect/Method.html" title="class in java.lang.reflect">方法</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getMethod(java.lang.String,java.lang.Class...)">getMethod</a></span>​(<a href="String.html" title="class in java.lang">String</a>&nbsp;name, <a href="Class.html" title="class in java.lang">类</a>&lt;?&gt;...&nbsp;parameterTypes)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>方法</code>对象，该对象反映此 
               <code>类</code>对象表示的类或接口的指定公共成员方法。 
              </div> </td> 
            </tr> 
            <tr id="i38" class="altColor"> 
             <td class="colFirst"><code><a href="reflect/Method.html" title="class in java.lang.reflect">方法</a>[]</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getMethods()">getMethods</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回一个包含 
               <code>方法</code>对象的数组， 
               <code>方法</code>对象反映此 
               <code>类</code>对象所表示的类或接口的所有公共方法，包括由类或接口声明的那些以及从超类和超接口继承的那些。 
              </div> </td> 
            </tr> 
            <tr id="i39" class="rowColor"> 
             <td class="colFirst"><code>int</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getModifiers()">getModifiers</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回此类或接口的Java语言修饰符，以整数编码。 
              </div> </td> 
            </tr> 
            <tr id="i40" class="altColor"> 
             <td class="colFirst"><code><a href="Module.html" title="class in java.lang">模块</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getModule()">getModule</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回此类或接口所属的模块。 
              </div> </td> 
            </tr> 
            <tr id="i41" class="rowColor"> 
             <td class="colFirst"><code><a href="String.html" title="class in java.lang">String</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getName()">getName</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回此 
               <code>类</code>对象表示的实体名称（类，接口，数组类，基本类型或void），作为 
               <code>String</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i42" class="altColor"> 
             <td class="colFirst"><code><a href="Class.html" title="class in java.lang">类</a>&lt;?&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getNestHost()">getNestHost</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>类</code>对象所代表的类或接口所属的 
               <a href="#nest">nest</a>的嵌套主机。 
              </div> </td> 
            </tr> 
            <tr id="i43" class="rowColor"> 
             <td class="colFirst"><code><a href="Class.html" title="class in java.lang">类</a>&lt;?&gt;[]</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getNestMembers()">getNestMembers</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回一个包含 
               <code>类</code>对象的数组， 
               <code>类</code>对象表示作为此 
               <code>类</code>对象所代表的类或接口所属的嵌套成员的所有类和接口。 
              </div> </td> 
            </tr> 
            <tr id="i44" class="altColor"> 
             <td class="colFirst"><code><a href="Package.html" title="class in java.lang">软件包</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getPackage()">getPackage</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                获取此类的包。 
              </div> </td> 
            </tr> 
            <tr id="i45" class="rowColor"> 
             <td class="colFirst"><code><a href="String.html" title="class in java.lang">String</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getPackageName()">getPackageName</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回完全限定的包名称。 
              </div> </td> 
            </tr> 
            <tr id="i46" class="altColor"> 
             <td class="colFirst"><code><a href="../security/ProtectionDomain.html" title="class in java.security">ProtectionDomain</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getProtectionDomain()">getProtectionDomain</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>ProtectionDomain</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i47" class="rowColor"> 
             <td class="colFirst"><code><a href="../net/URL.html" title="class in java.net">URL</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getResource(java.lang.String)">getResource</a></span>​(<a href="String.html" title="class in java.lang">String</a>&nbsp;name)</code></th> 
             <td class="colLast"> 
              <div class="block">
                查找具有给定名称的资源。 
              </div> </td> 
            </tr> 
            <tr id="i48" class="altColor"> 
             <td class="colFirst"><code><a href="../io/InputStream.html" title="class in java.io">InputStream</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getResourceAsStream(java.lang.String)">getResourceAsStream</a></span>​(<a href="String.html" title="class in java.lang">String</a>&nbsp;name)</code></th> 
             <td class="colLast"> 
              <div class="block">
                查找具有给定名称的资源。 
              </div> </td> 
            </tr> 
            <tr id="i49" class="rowColor"> 
             <td class="colFirst"><code><a href="Object.html" title="class in java.lang">Object</a>[]</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getSigners()">getSigners</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                获取此类的签名者。 
              </div> </td> 
            </tr> 
            <tr id="i50" class="altColor"> 
             <td class="colFirst"><code><a href="String.html" title="class in java.lang">String</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getSimpleName()">getSimpleName</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回源代码中给出的基础类的简单名称。 
              </div> </td> 
            </tr> 
            <tr id="i51" class="rowColor"> 
             <td class="colFirst"><code><a href="Class.html" title="class in java.lang">类</a>&lt;? super <a href="Class.html" title="type parameter in Class">T</a>&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getSuperclass()">getSuperclass</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>类</code>表示此所表示的实体（类，接口，基本类型或void）的直接超类 
               <code>类</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i52" class="altColor"> 
             <td class="colFirst"><code><a href="String.html" title="class in java.lang">String</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getTypeName()">getTypeName</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回此类型名称的信息字符串。 
              </div> </td> 
            </tr> 
            <tr id="i53" class="rowColor"> 
             <td class="colFirst"><code><a href="reflect/TypeVariable.html" title="interface in java.lang.reflect">TypeVariable</a>&lt;<a href="Class.html" title="class in java.lang">类</a>&lt;<a href="Class.html" title="type parameter in Class">T</a>&gt;&gt;[]</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getTypeParameters()">getTypeParameters</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回的数组 
               <code>TypeVariable</code>对象表示通过此表示的一般声明声明的类型变量 
               <code>GenericDeclaration</code>目的，在声明的顺序。 
              </div> </td> 
            </tr> 
            <tr id="i54" class="altColor"> 
             <td class="colFirst"><code>boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isAnnotation()">isAnnotation</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                如果此 
               <code>类</code>对象表示注释类型，则返回true。 
              </div> </td> 
            </tr> 
            <tr id="i55" class="rowColor"> 
             <td class="colFirst"><code>boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isAnnotationPresent(java.lang.Class)">isAnnotationPresent</a></span>​(<a href="Class.html" title="class in java.lang">类</a>&lt;? extends <a href="annotation/Annotation.html" title="interface in java.lang.annotation">Annotation</a>&gt;&nbsp;annotationClass)</code></th> 
             <td class="colLast"> 
              <div class="block">
                如果此元素上 
               <em>存在</em>指定类型的注释，则返回true，否则返回false。 
              </div> </td> 
            </tr> 
            <tr id="i56" class="altColor"> 
             <td class="colFirst"><code>boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isAnonymousClass()">isAnonymousClass</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                当且仅当基础类是匿名类时，返回 
               <code>true</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i57" class="rowColor"> 
             <td class="colFirst"><code>boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isArray()">isArray</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                确定此 
               <code>类</code>对象是否表示数组类。 
              </div> </td> 
            </tr> 
            <tr id="i58" class="altColor"> 
             <td class="colFirst"><code>boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isAssignableFrom(java.lang.Class)">isAssignableFrom</a></span>​(<a href="Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;cls)</code></th> 
             <td class="colLast"> 
              <div class="block">
                确定此 
               <code>类</code>对象表示的类或接口是否与指定的 
               <code>类</code>参数表示的类或接口相同，或者是它的超类或超接口。 
              </div> </td> 
            </tr> 
            <tr id="i59" class="rowColor"> 
             <td class="colFirst"><code>boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isEnum()">isEnum</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                当且仅当此类在源代码中声明为枚举时返回true。 
              </div> </td> 
            </tr> 
            <tr id="i60" class="altColor"> 
             <td class="colFirst"><code>boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isInstance(java.lang.Object)">isInstance</a></span>​(<a href="Object.html" title="class in java.lang">Object</a>&nbsp;obj)</code></th> 
             <td class="colLast"> 
              <div class="block">
                确定指定的 
               <code>Object</code>是否与此 
               <code>类</code>表示的对象分配兼容。 
              </div> </td> 
            </tr> 
            <tr id="i61" class="rowColor"> 
             <td class="colFirst"><code>boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isInterface()">isInterface</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                确定指定的 
               <code>类</code>对象是否表示接口类型。 
              </div> </td> 
            </tr> 
            <tr id="i62" class="altColor"> 
             <td class="colFirst"><code>boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isLocalClass()">isLocalClass</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                当且仅当底层类是本地类时，返回 
               <code>true</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i63" class="rowColor"> 
             <td class="colFirst"><code>boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isMemberClass()">isMemberClass</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                当且仅当基础类是成员类时，返回 
               <code>true</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i64" class="altColor"> 
             <td class="colFirst"><code>boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isNestmateOf(java.lang.Class)">isNestmateOf</a></span>​(<a href="Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;c)</code></th> 
             <td class="colLast"> 
              <div class="block">
                确定给定的 
               <code>类</code>是否是此 
               <code>类</code>对象所表示的类或接口的 
               <code>类</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i65" class="rowColor"> 
             <td class="colFirst"><code>boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isPrimitive()">isPrimitive</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                确定指定的 
               <code>类</code>对象是否表示基本类型。 
              </div> </td> 
            </tr> 
            <tr id="i66" class="altColor"> 
             <td class="colFirst"><code>boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isSynthetic()">isSynthetic</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block"> 
               <span>如果此类是合成类，则返回<code>true</code> ;</span> 
               <span>否则返回<code>false</code> 。</span> 
              </div> </td> 
            </tr> 
            <tr id="i67" class="rowColor"> 
             <td class="colFirst"><code><a href="Class.html" title="type parameter in Class">T</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#newInstance()">newInstance</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block"> 
               <span><span class="deprecatedLabel">已过时。</span></span> 
               <div class="deprecationComment"> 
                <span>此方法传播由Nullary构造函数抛出的任何异常，包括已检查的异常。</span> 
               </div> 
              </div> </td> 
            </tr> 
            <tr id="i68" class="altColor"> 
             <td class="colFirst"><code><a href="String.html" title="class in java.lang">String</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toGenericString()">toGenericString</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回描述此 
               <code>类</code>的字符串，包括有关修饰符和类型参数的信息。 
              </div> </td> 
            </tr> 
            <tr id="i69" class="rowColor"> 
             <td class="colFirst"><code><a href="String.html" title="class in java.lang">String</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toString()">toString</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                将对象转换为字符串。 
              </div> </td> 
            </tr> 
           </tbody> 
          </table> 
          <ul class="blockList"> 
           <li class="blockList"><a id="methods.inherited.from.class.java.lang.Object"> 
             <!--   --> </a> <h3>声明方法的类&nbsp;java.lang.<a href="Object.html" title="class in java.lang">Object</a></h3> <code><a href="Object.html#clone()">clone</a>, <a href="Object.html#equals(java.lang.Object)">equals</a>, <a href="Object.html#finalize()">finalize</a>, <a href="Object.html#getClass()">getClass</a>, <a href="Object.html#hashCode()">hashCode</a>, <a href="Object.html#notify()">notify</a>, <a href="Object.html#notifyAll()">notifyAll</a>, <a href="Object.html#wait()">wait</a>, <a href="Object.html#wait(long)">wait</a>, <a href="Object.html#wait(long,int)">wait</a></code></li> 
          </ul> </li> 
        </ul> 
       </section> </li> 
     </ul> 
    </div> 
    <div class="details"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <!-- ============ METHOD DETAIL ========== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="method.detail"> 
           <!--   --> </a> <h3>方法详细信息</h3> <a id="toString()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>toString</h4> <pre class="methodSignature">public&nbsp;<a href="String.html" title="class in java.lang">String</a>&nbsp;toString()</pre> 
            <div class="block"> 
             <span>将对象转换为字符串。</span> 
             <span>字符串表示形式是字符串“class”或“interface”，后跟一个空格，然后是<code>getName</code>返回的格式的类的完全限定名。</span> 
             <span>如果此<code>类</code>对象表示基本类型，则此方法返回基本类型的名称。</span> 
             <span>如果此<code>类</code>对象表示void，则此方法返回“void”。</span> 
             <span>如果此<code>类</code>对象表示数组类型，则此方法返回“class”，后跟<code>getName</code> 。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="overrideSpecifyLabel">重写：</span> 
             </dt> 
             <dd> 
              <code><a href="Object.html#toString()">toString</a></code>在 
              <code><a href="Object.html" title="class in java.lang">Object</a></code>类 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此类对象的字符串表示形式。 
             </dd> 
            </dl> </li> 
          </ul> <a id="toGenericString()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>toGenericString</h4> <pre class="methodSignature">public&nbsp;<a href="String.html" title="class in java.lang">String</a>&nbsp;toGenericString()</pre> 
            <div class="block"> 
             <span>返回描述此<code>类</code>的字符串，包括有关修饰符和类型参数的信息。</span> 
             <span>该字符串格式类型修饰符列表，如果有的话，后面的那种类型（基本类型和空字符串<code>class</code> ， <code>枚举</code> ， <code>interface</code> ，或<code>@</code> <code>interface</code> ，如适用），其次是类型的名称，然后是angle-bracketed逗号分隔的类型类型参数列表（如果有）。</span> 
             <span>空格用于将修饰符彼此分开，并将任何修饰符与类型类型分开。</span> 
             <span>修饰符以规范顺序出现。</span> 
             <span>如果没有类型参数，则省略类型参数列表。</span> 
             <span>对于数组类型，字符串以类型名称开头，后跟以角度括起来的逗号分隔的类型参数列表（如果有），后跟<code>[]</code>字符序列，每个数组维度一组括号。</span> 
             <p> <span>注意，由于正在生成关于类型的运行时表示的信息，因此可能存在不在源代码上存在或在源代码上非法的修饰符。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               描述此 
              <code>类</code>的字符串，包括有关修饰符和类型参数的信息 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.8 
             </dd> 
            </dl> </li> 
          </ul> <a id="forName(java.lang.String)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>forName</h4> <pre class="methodSignature">public static&nbsp;<a href="Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;forName​(<a href="String.html" title="class in java.lang">String</a>&nbsp;className)
                        throws <a href="ClassNotFoundException.html" title="class in java.lang">ClassNotFoundException</a></pre> 
            <div class="block"> 
             <span>返回与具有给定字符串名称的类或接口关联的<code>类</code>对象。</span> 
             <span>调用此方法相当于：</span> 
             <blockquote> 
              <span><code>Class.forName(className, true, currentLoader)</code></span> 
             </blockquote> 
             <span>其中<code>currentLoader</code>表示当前类的定义类加载器。</span> 
             <p> <span>例如，以下代码片段返回名为<code>java.lang.Thread</code>的类的运行时<code>类</code>描述符：</span> </p> 
             <blockquote> 
              <span><code>Class t = Class.forName("java.lang.Thread")</code></span> 
             </blockquote> 
             <p> <span>调用<code>forName("X")</code>会导致名为<code>X</code>的类被初始化。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>className</code> - 所需类的完全限定名称。 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               具有指定名称的类的 
              <code>类</code>对象。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="LinkageError.html" title="class in java.lang">LinkageError</a></code> - 如果链接失败 
             </dd> 
             <dd> 
              <code><a href="ExceptionInInitializerError.html" title="class in java.lang">ExceptionInInitializerError</a></code> - 如果此方法引发的初始化失败 
             </dd> 
             <dd> 
              <code><a href="ClassNotFoundException.html" title="class in java.lang">ClassNotFoundException</a></code> - 如果无法找到班级 
             </dd> 
            </dl> </li> 
          </ul> <a id="forName(java.lang.String,boolean,java.lang.ClassLoader)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>forName</h4> <pre class="methodSignature">public static&nbsp;<a href="Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;forName​(<a href="String.html" title="class in java.lang">String</a>&nbsp;name,
                               boolean&nbsp;initialize,
                               <a href="ClassLoader.html" title="class in java.lang">ClassLoader</a>&nbsp;loader)
                        throws <a href="ClassNotFoundException.html" title="class in java.lang">ClassNotFoundException</a></pre> 
            <div class="block"> 
             <span>使用给定的类加载器返回与具有给定字符串名称的类或接口关联的<code>类</code>对象。</span> 
             <span>给定类或接口的完全限定名称（采用<code>getName</code>返回的相同格式），此方法尝试查找，加载和链接类或接口。</span> 
             <span>指定的类加载器用于加载类或接口。</span> 
             <span>如果参数<code>loader</code>为null，则通过引导类加载器加载该类。</span> 
             <span>仅当<code>initialize</code>参数为<code>true</code>并且之前尚未初始化时，才会初始化<code>true</code> 。</span> 
             <p> <span>如果<code>name</code>表示基本类型或void，则将尝试在未命名的包中找到用户定义的类，其名称为<code>name</code> 。</span> <span>因此，此方法不能用于获取表示基本类型或void的任何<code>类</code>对象。</span> </p> 
             <p> <span>如果<code>name</code>表示数组类，则加载数组类的组件类型但不进行初始化。</span> </p> 
             <p> <span>例如，在实例方法中，表达式为：</span> </p> 
             <blockquote> 
              <span><code>Class.forName("Foo")</code></span> 
             </blockquote> 
             <span>相当于：</span> 
             <blockquote> 
              <span><code>Class.forName("Foo", true, this.getClass().getClassLoader())</code></span> 
             </blockquote> 
             <span>请注意，此方法会抛出与<em>Java语言规范的</em>第12.2节，第12.3节和第12.4节中指定的加载，链接或初始化相关的错误。</span> 
             <span>请注意，此方法不会检查其调用者是否可以访问所请求的类。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>name</code> - 所需类的完全限定名称 
             </dd> 
             <dd> 
              <span><code>initialize</code> - 如果<code>true</code>该类将被初始化。</span> 
              <span>请参见<em>Java语言规范的</em>第12.4节。</span> 
             </dd> 
             <dd> 
              <code>loader</code> - 必须从中加载类的类加载器 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               表示所需类的类对象 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="LinkageError.html" title="class in java.lang">LinkageError</a></code> - 如果链接失败 
             </dd> 
             <dd> 
              <code><a href="ExceptionInInitializerError.html" title="class in java.lang">ExceptionInInitializerError</a></code> - 如果此方法引发的初始化失败 
             </dd> 
             <dd> 
              <code><a href="ClassNotFoundException.html" title="class in java.lang">ClassNotFoundException</a></code> - 如果指定的类加载器无法找到该类 
             </dd> 
             <dd> 
              <span><code><a href="SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理器，并且<code>loader</code>是<code>null</code> ，并且调用者的类加载器不是<code>null</code> ，并且调用者没有<a href="RuntimePermission.html" title="java.lang中的类"><code>RuntimePermission</code></a> <code>("getClassLoader")</code></span> 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.2 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <span><a href="#forName(java.lang.String)"><code>forName(String)</code></a> ， <a href="ClassLoader.html" title="java.lang中的类"><code>ClassLoader</code></a></span> 
             </dd> 
            </dl> </li> 
          </ul> <a id="forName(java.lang.Module,java.lang.String)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>forName</h4> <pre class="methodSignature">public static&nbsp;<a href="Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;forName​(<a href="Module.html" title="class in java.lang">模块</a>&nbsp;module,
                               <a href="String.html" title="class in java.lang">String</a>&nbsp;name)</pre> 
            <div class="block"> 
             <span>返回<code>类</code>给定<a href="ClassLoader.html#name">binary name</a>给定的模块中。</span> 
             <p> <span>此方法尝试定位，加载和链接类或接口。</span> <span>它不运行类初始化程序。</span> <span>如果找不到该类，则此方法返回<code>null</code> 。</span> </p> 
             <p> <span>如果给定模块的类加载器定义了其他模块，并且给定名称是在不同模块中定义的类，则此方法在加载类后返回<code>null</code> 。</span> </p> 
             <p> <span>此方法不检查其调用者是否可以访问所请求的类。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>此方法在失败时返回<code>null</code>而不是抛出<a href="ClassNotFoundException.html" title="java.lang中的类"><code>ClassNotFoundException</code></a> ，如<a href="#forName(java.lang.String,boolean,java.lang.ClassLoader)"><code>forName(String, boolean, ClassLoader)</code></a>方法所做的<a href="#forName(java.lang.String,boolean,java.lang.ClassLoader)">那样</a> 。</span> 
              <span>如果调用者在另一个模块中加载一个类，则安全检查是基于堆栈的权限检查。</span> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>模块</code> - 模块 
             </dd> 
             <dd> 
              <code>name</code> - 该 
              <a href="ClassLoader.html#name">课程的binary name</a> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <span><code>类</code>给定模块中定义的给定名称的对象;</span> 
              <span><code>null</code>如果找不到。</span> 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果给定的模块或名称是 
              <code>null</code> 
             </dd> 
             <dd> 
              <code><a href="LinkageError.html" title="class in java.lang">LinkageError</a></code> - 如果链接失败 
             </dd> 
             <dd> 
              <span><code><a href="SecurityException.html" title="class in java.lang">SecurityException</a></code> -</span> 
              <ul> 
               <li> <span>如果调用者不是指定的模块，则拒绝<code>RuntimePermission("getClassLoader")</code>权限;</span> <span>要么</span> </li> 
               <li> <span>访问模块内容被拒绝。</span> <span>例如，当类加载器调用<a href="module/ModuleReader.html#open(java.lang.String)"><code>ModuleReader.open(String)</code></a>以读取模块中类文件的字节时，将执行权限检查。</span> </li> 
              </ul> 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
            </dl> </li> 
          </ul> <a id="newInstance()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>newInstance</h4> <pre class="methodSignature"><a href="Deprecated.html" title="annotation in java.lang">@Deprecated</a>(<a href="Deprecated.html#since()">since</a>="9")
public&nbsp;<a href="Class.html" title="type parameter in Class">T</a>&nbsp;newInstance()
              throws <a href="InstantiationException.html" title="class in java.lang">InstantiationException</a>,
                     <a href="IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre> 
            <div class="deprecationBlock"> 
             <span class="deprecatedLabel">Deprecated.</span> 
             <div class="deprecationComment">
               This method propagates any exception thrown by the nullary constructor, including a checked exception. Use of this method effectively bypasses the compile-time exception checking that would otherwise be performed by the compiler. The 
              <a href="reflect/Constructor.html#newInstance(java.lang.Object...)"><code>Constructor.newInstance</code></a> method avoids this problem by wrapping any exception thrown by the constructor in a (checked) 
              <a href="reflect/InvocationTargetException.html" title="class in java.lang.reflect"><code>InvocationTargetException</code></a>. 
              <p>The call </p> 
              <pre><code>
 clazz.newInstance()
 </code></pre> can be replaced by 
              <pre><code>
 clazz.getDeclaredConstructor().newInstance()
 </code></pre> The latter sequence of calls is inferred to be able to throw the additional exception types 
              <a href="reflect/InvocationTargetException.html" title="class in java.lang.reflect"><code>InvocationTargetException</code></a> and 
              <a href="NoSuchMethodException.html" title="class in java.lang"><code>NoSuchMethodException</code></a>. Both of these exception types are subclasses of 
              <a href="ReflectiveOperationException.html" title="class in java.lang"><code>ReflectiveOperationException</code></a>. 
             </div> 
            </div> 
            <div class="block"> 
             <span>创建此<code>类</code>对象表示的类的新实例。</span> 
             <span>该类实例化为<code>new</code>带有空参数列表的表达式。</span> 
             <span>如果尚未初始化，则初始化该类。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               由此对象表示的类的新分配实例。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code> - 如果无法访问该类或其无效构造函数。 
             </dd> 
             <dd> 
              <span><code><a href="InstantiationException.html" title="class in java.lang">InstantiationException</a></code> - 如果此<code>类</code>表示抽象类，接口，数组类，基元类型或void;</span> 
              <span>或者如果该类没有无效的构造函数;</span> 
              <span>或者如果实例化由于其他原因而失败。</span> 
             </dd> 
             <dd> 
              <code><a href="ExceptionInInitializerError.html" title="class in java.lang">ExceptionInInitializerError</a></code> - 如果此方法引发的初始化失败。 
             </dd> 
             <dd> 
              <code><a href="SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理器 
              <i>s</i> ，并且调用者的类加载器与当前类的类加载器不同或是其祖先，则调用 
              <a href="SecurityManager.html#checkPackageAccess(java.lang.String)"><code>s.checkPackageAccess()</code>将</a>拒绝访问此类的包。 
             </dd> 
            </dl> </li> 
          </ul> <a id="isInstance(java.lang.Object)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>isInstance</h4> <pre class="methodSignature">public&nbsp;boolean&nbsp;isInstance​(<a href="Object.html" title="class in java.lang">Object</a>&nbsp;obj)</pre> 
            <div class="block"> 
             <span>确定指定的<code>Object</code>是否与此<code>类</code>表示的对象分配兼容。</span> 
             <span>此方法是Java语言<code>instanceof</code>运算符的动态等效项。</span> 
             <span>该方法返回<code>true</code>如果指定<code>Object</code>参数为非空并且可以转换为通过此表示的引用类型<code>类</code>对象不提高一个<code>ClassCastException.</code>它返回<code>false</code>否则。</span> 
             <p> <span>具体来说，如果此<code>类</code>对象表示声明的类，如果指定的<code>Object</code>参数是所表示的类（或其任何子类）的实例，则此方法返回<code>true</code> ;</span> <span>否则返回<code>false</code> 。</span> <span>如果此<code>类</code>对象表示数组类，如果指定的<code>Object</code>参数可以通过标识转换或扩展引用转换转换为数组类的对象，则此方法返回<code>true</code> ;</span> <span>否则返回<code>false</code> 。</span> <span>如果此<code>类</code>对象表示接口，则如果指定的<code>Object</code>参数的类或任何超类实现此接口，则此方法返回<code>true</code> ;</span> <span>否则返回<code>false</code> 。</span> <span>如果此<code>类</code>对象表示基本类型，则此方法返回<code>false</code> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>obj</code> - 要检查的对象 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               如果 
              <code>obj</code>是 
              <code>obj</code>的实例， 
              <code>obj</code> true 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.1 
             </dd> 
            </dl> </li> 
          </ul> <a id="isAssignableFrom(java.lang.Class)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>isAssignableFrom</h4> <pre class="methodSignature">public&nbsp;boolean&nbsp;isAssignableFrom​(<a href="Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;cls)</pre> 
            <div class="block"> 
             <span>确定此<code>类</code>对象表示的类或接口是否与指定的<code>类</code>参数表示的类或接口相同，或者是它的超类或超接口。</span> 
             <span>如果是这样，它返回<code>true</code> ;</span> 
             <span>否则返回<code>false</code> 。</span> 
             <span>如果此<code>类</code>对象表示基本类型，如果指定的<code>类</code>参数恰好是此<code>类</code>对象，则此方法返回<code>true</code> ;</span> 
             <span>否则返回<code>false</code> 。</span> 
             <p> <span>具体来说，此方法测试是否可以通过标识转换或扩展引用转换将指定的<code>类</code>参数表示的类型转换为此<code>类</code>对象表示的类型。</span> <span>有关<em>详细信息</em> ，请参阅<em>Java语言规范</em> ，第5.1.1和5.1.4节。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>cls</code> - 要检查的 
              <code>类</code>对象 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>boolean</code>值，指示是否可以将类型为 
              <code>cls</code>对象分配给此类的对象 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果指定的Class参数为null。 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.1 
             </dd> 
            </dl> </li> 
          </ul> <a id="isInterface()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>isInterface</h4> <pre class="methodSignature">public&nbsp;boolean&nbsp;isInterface()</pre> 
            <div class="block">
              确定指定的 
             <code>类</code>对象是否表示接口类型。 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <span><code>true</code>如果此对象表示接口;</span> 
              <span>否则为<code>false</code> 。</span> 
             </dd> 
            </dl> </li> 
          </ul> <a id="isArray()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>isArray</h4> <pre class="methodSignature">public&nbsp;boolean&nbsp;isArray()</pre> 
            <div class="block">
              确定此 
             <code>类</code>对象是否表示数组类。 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <span><code>true</code>如果此对象表示数组类;</span> 
              <span>否则为<code>false</code> 。</span> 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.1 
             </dd> 
            </dl> </li> 
          </ul> <a id="isPrimitive()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>isPrimitive</h4> <pre class="methodSignature">public&nbsp;boolean&nbsp;isPrimitive()</pre> 
            <div class="block"> 
             <span>确定指定的<code>类</code>对象是否表示基本类型。</span> 
             <p> <span>有九个预定义的<code>类</code>对象来表示八种基本类型和void。</span> <span>这些是由Java虚拟机创建，并且具有相同的名称为他们所代表的基本类型，即<code>boolean</code> ， <code>byte</code> ， <code>char</code> ， <code>short</code> ， <code>int</code> ， <code>long</code> ， <code>float</code>和<code>double</code> 。</span> </p> 
             <p> <span>这些对象只能通过以下公共静态最终变量访问，并且是此方法返回<code>true</code>的唯一<code>类</code>对象。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               当且仅当此类表示基本类型时才返回true 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.1 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="Boolean.html#TYPE"><code>Boolean.TYPE</code></a> ， 
              <a href="Character.html#TYPE"><code>Character.TYPE</code></a> ， 
              <a href="Byte.html#TYPE"><code>Byte.TYPE</code></a> ， 
              <a href="Short.html#TYPE"><code>Short.TYPE</code></a> ， 
              <a href="Integer.html#TYPE"><code>Integer.TYPE</code></a> ， 
              <a href="Long.html#TYPE"><code>Long.TYPE</code></a> ， 
              <a href="Float.html#TYPE"><code>Float.TYPE</code></a> ， 
              <a href="Double.html#TYPE"><code>Double.TYPE</code></a> ， 
              <a href="Void.html#TYPE"><code>Void.TYPE</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="isAnnotation()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>isAnnotation</h4> <pre class="methodSignature">public&nbsp;boolean&nbsp;isAnnotation()</pre> 
            <div class="block"> 
             <span>如果此<code>类</code>对象表示注释类型，则返回true。</span> 
             <span>请注意，如果此方法返回true，则<a href="#isInterface()"><code>isInterface()</code></a>也将返回true，因为所有注释类型也是接口。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <span><code>true</code>如果此类对象表示注释类型;</span> 
              <span>否则为<code>false</code></span> 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.5 
             </dd> 
            </dl> </li> 
          </ul> <a id="isSynthetic()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>isSynthetic</h4> <pre class="methodSignature">public&nbsp;boolean&nbsp;isSynthetic()</pre> 
            <div class="block"> 
             <span>如果此类是合成类，则返回<code>true</code> ;</span> 
             <span>否则返回<code>false</code> 。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>true</code>当且仅当此类是Java语言规范定义的合成类时。 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.5 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">See <cite>The Java™ Language Specification</cite>:</span> 
             </dt> 
             <dd>
               13.1二进制形式 
             </dd> 
            </dl> </li> 
          </ul> <a id="getName()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getName</h4> <pre class="methodSignature">public&nbsp;<a href="String.html" title="class in java.lang">String</a>&nbsp;getName()</pre> 
            <div class="block"> 
             <span>返回此<code>类</code>对象表示的实体名称（类，接口，数组类，基本类型或void），作为<code>String</code> 。</span> 
             <p> <span>如果此类对象表示不是数组类型的引用类型，则返回该类的二进制名称，如<cite>The Java™ Language Specification</cite>所指定。</span> </p> 
             <p> <span>如果此类对象表示基本类型或void，则返回的名称是<code>String</code>等于与基本类型或void对应的Java语言关键字。</span> </p> 
             <p> <span>如果此类对象表示一个数组类，则该名称的内部形式由元素类型的名称组成，前面是一个或多个表示数组嵌套深度的“ <code>[</code> ”字符。</span> <span>元素类型名称的编码如下：</span> </p> 
             <blockquote> 
              <span>
               <table class="striped"> 
                <caption style="display:none">
                  Element types and encodings 
                </caption> 
                <thead> 
                 <tr> 
                  <th scope="col"> Element Type </th> 
                  <th scope="col"> Encoding </th> 
                 </tr> 
                </thead> 
                <tbody style="text-align:left"> 
                 <tr> 
                  <th scope="row"> boolean </th> 
                  <td style="text-align:center"> Z </td> 
                 </tr> 
                 <tr> 
                  <th scope="row"> byte </th> 
                  <td style="text-align:center"> B </td> 
                 </tr> 
                 <tr> 
                  <th scope="row"> char </th> 
                  <td style="text-align:center"> C </td> 
                 </tr> 
                 <tr> 
                  <th scope="row"> class or interface </th> 
                  <td style="text-align:center"> L<i>classname</i>; </td> 
                 </tr> 
                 <tr> 
                  <th scope="row"> double </th> 
                  <td style="text-align:center"> D </td> 
                 </tr> 
                 <tr> 
                  <th scope="row"> float </th> 
                  <td style="text-align:center"> F </td> 
                 </tr> 
                 <tr> 
                  <th scope="row"> int </th> 
                  <td style="text-align:center"> I </td> 
                 </tr> 
                 <tr> 
                  <th scope="row"> long </th> 
                  <td style="text-align:center"> J </td> 
                 </tr> 
                 <tr> 
                  <th scope="row"> short </th> 
                  <td style="text-align:center"> S </td> 
                 </tr> 
                </tbody> 
               </table></span> 
             </blockquote> 
             <p> <span>类或接口名称<i>classname</i>是上面指定的类的二进制名称。</span> </p> 
             <p> <span>例子：</span> </p> 
             <blockquote> 
              <span><pre>
 String.class.getName()
     returns "java.lang.String"
 byte.class.getName()
     returns "byte"
 (new Object[3]).getClass().getName()
     returns "[Ljava.lang.Object;"
 (new int[3][4][5][6][7][8][9]).getClass().getName()
     returns "[[[[[[[I"
 </pre></span> 
             </blockquote> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此对象表示的类或接口的名称。 
             </dd> 
            </dl> </li> 
          </ul> <a id="getClassLoader()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getClassLoader</h4> <pre class="methodSignature">public&nbsp;<a href="ClassLoader.html" title="class in java.lang">ClassLoader</a>&nbsp;getClassLoader()</pre> 
            <div class="block"> 
             <span>返回类的类加载器。</span> 
             <span>某些实现可能使用null来表示引导类加载器。</span> 
             <span>如果此类由引导类加载器加载，则此方法将在此类实现中返回null。</span> 
             <p> <span>如果此对象表示基本类型或void，则返回null。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               加载此对象表示的类或接口的类加载器。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <span><code><a href="SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理器，并且调用者的类加载器不是<code>null</code> ，并且与请求类加载器的类的类加载器的祖先不同，并且调用者没有<a href="RuntimePermission.html" title="java.lang中的类"><code>RuntimePermission</code></a> <code>("getClassLoader")</code></span> 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <span><a href="ClassLoader.html" title="java.lang中的类"><code>ClassLoader</code></a> ， <a href="SecurityManager.html#checkPermission(java.security.Permission)"><code>SecurityManager.checkPermission(java.security.Permission)</code></a> ， <a href="RuntimePermission.html" title="java.lang中的类"><code>RuntimePermission</code></a></span> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getModule()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getModule</h4> <pre class="methodSignature">public&nbsp;<a href="Module.html" title="class in java.lang">模块</a>&nbsp;getModule()</pre> 
            <div class="block"> 
             <span>返回此类或接口所属的模块。</span> 
             <span>如果此类表示数组类型，则此方法返回元素类型的<code>模块</code> 。</span> 
             <span>如果此类表示基本类型或void，则返回<code>java.base</code>模块的<code>模块</code>对象。</span> 
             <span>如果此类位于未命名的模块中，则<a href="ClassLoader.html#getUnnamedModule()">返回</a> <code>模块</code>的类加载器的<a href="ClassLoader.html#getUnnamedModule()">unnamed</a> <code>模块</code> 。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此类或接口所属的模块 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
            </dl> </li> 
          </ul> <a id="getTypeParameters()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getTypeParameters</h4> <pre class="methodSignature">public&nbsp;<a href="reflect/TypeVariable.html" title="interface in java.lang.reflect">TypeVariable</a>&lt;<a href="Class.html" title="class in java.lang">类</a>&lt;<a href="Class.html" title="type parameter in Class">T</a>&gt;&gt;[]&nbsp;getTypeParameters()</pre> 
            <div class="block"> 
             <span>返回的数组<code>TypeVariable</code>对象表示通过此表示的一般声明声明的类型变量<code>GenericDeclaration</code>目的，在声明的顺序。</span> 
             <span>如果基础泛型声明未声明类型变量，则返回长度为0的数组。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="overrideSpecifyLabel">Specified by:</span> 
             </dt> 
             <dd> 
              <code><a href="reflect/GenericDeclaration.html#getTypeParameters()">getTypeParameters</a></code>在接口 
              <code><a href="reflect/GenericDeclaration.html" title="interface in java.lang.reflect">GenericDeclaration</a></code> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个 
              <code>TypeVariable</code>对象的数组，表示此泛型声明声明的类型变量 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="reflect/GenericSignatureFormatError.html" title="class in java.lang.reflect">GenericSignatureFormatError</a></code> - 如果此通用声明的通用签名不符合 
              <cite>The Java™ Virtual Machine Specification中</cite>指定的格式 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.5 
             </dd> 
            </dl> </li> 
          </ul> <a id="getSuperclass()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getSuperclass</h4> <pre class="methodSignature">public&nbsp;<a href="Class.html" title="class in java.lang">类</a>&lt;? super <a href="Class.html" title="type parameter in Class">T</a>&gt;&nbsp;getSuperclass()</pre> 
            <div class="block"> 
             <span>返回表示此<code>类</code>表示的实体的直接超类（类，接口，基本类型或void）的<code>类</code> 。</span> 
             <span>如果此<code>类</code>表示<code>Object</code>类，接口，基本类型或void，则返回null。</span> 
             <span>如果此对象表示数组类，则返回表示<code>Object</code>类的<code>类</code>对象。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此对象表示的类的直接超类 
             </dd> 
            </dl> </li> 
          </ul> <a id="getGenericSuperclass()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getGenericSuperclass</h4> <pre class="methodSignature">public&nbsp;<a href="reflect/Type.html" title="interface in java.lang.reflect">Type</a>&nbsp;getGenericSuperclass()</pre> 
            <div class="block"> 
             <span>返回<code>Type</code>表示此所表示的实体（类，接口，基本类型或void）的直接超类<code>类</code> 。</span> 
             <p> <span>如果超类是参数化类型，则返回的<code>Type</code>对象必须准确反映源代码中使用的实际类型参数。</span> <span>如果之前尚未创建超类，则创建表示超类的参数化类型。</span> <span>有关参数化类型的创建过程的语义，请参阅<a href="reflect/ParameterizedType.html" title="java.lang.reflect中的接口"><code>ParameterizedType</code></a>的声明。</span> <span>如果此<code>类</code>表示<code>Object</code>类，接口，基本类型或void，则返回null。</span> <span>如果此对象表示数组类，则返回表示<code>Object</code>类的<code>类</code>对象。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此对象表示的类的直接超类 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="reflect/GenericSignatureFormatError.html" title="class in java.lang.reflect">GenericSignatureFormatError</a></code> - 如果泛型类签名不符合 
              <cite>The Java™ Virtual Machine Specification中</cite>指定的格式 
             </dd> 
             <dd> 
              <code><a href="TypeNotPresentException.html" title="class in java.lang">TypeNotPresentException</a></code> - 如果泛型超类引用不存在的类型声明 
             </dd> 
             <dd> 
              <code><a href="reflect/MalformedParameterizedTypeException.html" title="class in java.lang.reflect">MalformedParameterizedTypeException</a></code> - 如果泛型超类引用无法以任何原因实例化的参数化类型 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.5 
             </dd> 
            </dl> </li> 
          </ul> <a id="getPackage()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getPackage</h4> <pre class="methodSignature">public&nbsp;<a href="Package.html" title="class in java.lang">软件包</a>&nbsp;getPackage()</pre> 
            <div class="block"> 
             <span>获取此类的包。</span> 
             <p> <span>如果此类表示数组类型，基本类型或void，则此方法返回<code>null</code> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               这个类的包。 
             </dd> 
            </dl> </li> 
          </ul> <a id="getPackageName()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getPackageName</h4> <pre class="methodSignature">public&nbsp;<a href="String.html" title="class in java.lang">String</a>&nbsp;getPackageName()</pre> 
            <div class="block"> 
             <span>返回完全限定的包名称。</span> 
             <p> <span>如果此类是顶级类，则此方法返回该类所属的包的完全限定名称，如果该类位于未命名的包中，则返回空字符串。</span> </p> 
             <p> <span>如果该类是一个成员的类，则此方法等效于调用<code>getPackageName()</code>上<a href="#getEnclosingClass()">enclosing class</a> 。</span> </p> 
             <p> <span>如果该类是<a href="#isLocalClass()">local class</a>或<a href="#isAnonymousClass()">anonymous class</a> ，则此方法等效于调用<code>getPackageName()</code>上<a href="#getDeclaringClass()">declaring class</a>的的<a href="#getEnclosingMethod()">enclosing method</a>或<a href="#getEnclosingConstructor()">enclosing constructor</a> 。</span> </p> 
             <p> <span>如果此类表示数组类型，则此方法返回元素类型的包名称。</span> <span>如果此类表示基本类型或void，则返回包名“ <code>java.lang</code> ”。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               完全限定的包名称 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">See <cite>The Java™ Language Specification</cite>:</span> 
             </dt> 
             <dd>
               6.7完全合格的名称 
             </dd> 
            </dl> </li> 
          </ul> <a id="getInterfaces()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getInterfaces</h4> <pre class="methodSignature">public&nbsp;<a href="Class.html" title="class in java.lang">类</a>&lt;?&gt;[]&nbsp;getInterfaces()</pre> 
            <div class="block"> 
             <span>返回由此对象表示的类或接口直接实现的接口。</span> 
             <p> <span>如果此对象表示类，则返回值是一个数组，其中包含表示该类直接实现的所有接口的对象。</span> <span>数组中接口对象的顺序对应于此对象所表示的类的声明的<code>implements</code>子句中的接口名称的顺序。</span> <span>例如，鉴于声明：</span> </p> 
             <blockquote> 
              <span><code>class Shimmer implements FloorWax, DessertTopping { ... }</code></span> 
             </blockquote> 
             <span>假设的值<code>s</code>是实例<code>Shimmer</code> ;</span> 
             <span>表达式的值：</span> 
             <blockquote> 
              <span><code>s.getClass().getInterfaces()[0]</code></span> 
             </blockquote> 
             <span>是<code>类</code>对象，表示接口<code>FloorWax</code> ;</span> 
             <span>和价值：</span> 
             <blockquote> 
              <span><code>s.getClass().getInterfaces()[1]</code></span> 
             </blockquote> 
             <span>是<code>类</code>对象，表示接口<code>DessertTopping</code> 。</span> 
             <p> <span>如果此对象表示接口，则该数组包含表示由接口直接扩展的所有接口的对象。</span> <span>数组中接口对象的顺序对应于此对象表示的接口声明的<code>extends</code>子句中接口名称的顺序。</span> </p> 
             <p> <span>如果此对象表示不实现接口的类或接口，则该方法返回长度为0的数组。</span> </p> 
             <p> <span>如果此对象表示基本类型或void，则该方法返回长度为0的数组。</span> </p> 
             <p> <span>如果此<code>类</code>对象表示阵列类型， <code>Cloneable</code>顺序返回接口<code>Cloneable</code>和<code>java.io.Serializable</code> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               由此类直接实现的接口数组 
             </dd> 
            </dl> </li> 
          </ul> <a id="getGenericInterfaces()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getGenericInterfaces</h4> <pre class="methodSignature">public&nbsp;<a href="reflect/Type.html" title="interface in java.lang.reflect">Type</a>[]&nbsp;getGenericInterfaces()</pre> 
            <div class="block"> 
             <span>返回表示由此对象表示的类或接口直接实现的接口的<code>Type</code> 。</span> 
             <p> <span>如果超接口是参数化类型，则<code>Type</code>返回的<code>Type</code>对象必须准确反映源代码中使用的实际类型参数。</span> <span>如果之前尚未创建，则创建表示每个超级接口的参数化类型。</span> <span>有关参数化类型的创建过程的语义，请参阅<a href="reflect/ParameterizedType.html" title="java.lang.reflect中的接口"><code>ParameterizedType</code></a>的声明。</span> </p> 
             <p> <span>如果此对象表示类，则返回值是一个数组，其中包含表示该类直接实现的所有接口的对象。</span> <span>数组中接口对象的顺序对应于此对象所表示的类的声明的<code>implements</code>子句中的接口名称的顺序。</span> </p> 
             <p> <span>如果此对象表示接口，则该数组包含表示由接口直接扩展的所有接口的对象。</span> <span>数组中接口对象的顺序对应于此对象表示的接口声明的<code>extends</code>子句中接口名称的顺序。</span> </p> 
             <p> <span>如果此对象表示不实现接口的类或接口，则该方法返回长度为0的数组。</span> </p> 
             <p> <span>如果此对象表示基本类型或void，则该方法返回长度为0的数组。</span> </p> 
             <p> <span>如果此<code>类</code>对象表示阵列类型， <code>Cloneable</code>顺序返回接口<code>Cloneable</code>和<code>java.io.Serializable</code> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               由此类直接实现的接口数组 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="reflect/GenericSignatureFormatError.html" title="class in java.lang.reflect">GenericSignatureFormatError</a></code> - 如果泛型类签名不符合 
              <cite>The Java™ Virtual Machine Specification中</cite>指定的格式 
             </dd> 
             <dd> 
              <code><a href="TypeNotPresentException.html" title="class in java.lang">TypeNotPresentException</a></code> - 如果任何通用超接口引用了不存在的类型声明 
             </dd> 
             <dd> 
              <code><a href="reflect/MalformedParameterizedTypeException.html" title="class in java.lang.reflect">MalformedParameterizedTypeException</a></code> - 如果任何通用超接口引用无法以任何原因实例化的参数化类型 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.5 
             </dd> 
            </dl> </li> 
          </ul> <a id="getComponentType()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getComponentType</h4> <pre class="methodSignature">public&nbsp;<a href="Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;getComponentType()</pre> 
            <div class="block"> 
             <span>返回表示数组的组件类型的<code>类</code> 。</span> 
             <span>如果此类不表示数组类，则此方法返回null。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>类</code>表示 
              <code>类</code>的组件类型（如果此类是数组） 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.1 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <span><a href="reflect/Array.html" title="java.lang.reflect中的类"><code>Array</code></a></span> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getModifiers()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getModifiers</h4> <pre class="methodSignature">public&nbsp;int&nbsp;getModifiers()</pre> 
            <div class="block"> 
             <span>返回此类或接口的Java语言修饰符，以整数编码。</span> 
             <span>修饰符由Java虚拟机的常数为<code>public</code> ， <code>protected</code> ， <code>private</code> ， <code>final</code> ， <code>static</code> ， <code>abstract</code>和<code>interface</code> ;</span> 
             <span>它们应该使用<code>Modifier</code>类的方法解码。</span> 
             <p> <span>如果底层类是一个数组类，则其<code>public</code> ， <code>private</code>和<code>protected</code>改性剂是相同的组分的类型。</span> <span>如果此<code>类</code>表示基本类型或void，则其<code>public</code>修饰符始终为<code>true</code> ，其<code>protected</code>和<code>private</code>修饰符始终为<code>false</code> 。</span> <span>如果此对象表示数组类，基本类型或void，则其<code>final</code>修饰符始终为<code>true</code> ，其界面修饰符始终为<code>false</code> 。</span> <span>其他修饰符的值不是由本规范确定的。</span> </p> 
             <p> <span>修饰符编码在<em>Java虚拟机规范</em>表4.1中定义。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>int</code>表示 
              <code>int</code>的修饰符 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.1 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <span><a href="reflect/Modifier.html" title="java.lang.reflect中的类"><code>Modifier</code></a></span> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getSigners()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getSigners</h4> <pre class="methodSignature">public&nbsp;<a href="Object.html" title="class in java.lang">Object</a>[]&nbsp;getSigners()</pre> 
            <div class="block">
              获取此类的签名者。 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <span>此类的签名者，如果没有签名者则为null。</span> 
              <span>特别是，如果此对象表示基本类型或void，则此方法返回null。</span> 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.1 
             </dd> 
            </dl> </li> 
          </ul> <a id="getEnclosingMethod()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getEnclosingMethod</h4> <pre class="methodSignature">public&nbsp;<a href="reflect/Method.html" title="class in java.lang.reflect">方法</a>&nbsp;getEnclosingMethod()
                          throws <a href="SecurityException.html" title="class in java.lang">SecurityException</a></pre> 
            <div class="block"> 
             <span>如果此<code>类</code>对象表示方法中的本地或匿名类，则返回<a href="reflect/Method.html" title="java.lang.reflect中的类"><code>方法</code></a>对象，该对象表示基础类的直接封闭方法。</span> 
             <span>否则返回<code>null</code> 。</span> 
             <span>特别是，如果基础类是由类型声明，实例初始化程序或静态初始化程序直接包含的本地或匿名类，则此方法返回<code>null</code> 。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <span>如果该类是本地或匿名类，则为基础类的直接封闭方法;</span> 
              <span>否则<code>null</code> 。</span> 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <span><code><a href="SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理器<i>s</i>且满足以下任一条件：</span> 
              <ul> 
               <li> <span>调用者的类加载器与封闭类的类加载器不同，并且调用<a href="SecurityManager.html#checkPermission(java.security.Permission)"><code>s.checkPermission</code></a>方法和<code>RuntimePermission("accessDeclaredMembers")</code>拒绝访问封闭类中的方法</span> </li> 
               <li> <span>调用者的类加载器与封闭类的类加载器不同或是祖先，并且<a href="SecurityManager.html#checkPackageAccess(java.lang.String)"><code>s.checkPackageAccess()</code>的</a>调用拒绝访问封闭类的包</span> </li> 
              </ul> 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.5 
             </dd> 
            </dl> </li> 
          </ul> <a id="getEnclosingConstructor()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getEnclosingConstructor</h4> <pre class="methodSignature">public&nbsp;<a href="reflect/Constructor.html" title="class in java.lang.reflect">构造器</a>&lt;?&gt;&nbsp;getEnclosingConstructor()
                                       throws <a href="SecurityException.html" title="class in java.lang">SecurityException</a></pre> 
            <div class="block"> 
             <span>如果此<code>类</code>对象表示构造函数中的本地或匿名类，则返回<a href="reflect/Constructor.html" title="java.lang.reflect中的类"><code>构造器</code></a>对象，该对象表示基础类的直接封闭构造函数。</span> 
             <span>否则返回<code>null</code> 。</span> 
             <span>特别是，如果基础类是由类型声明，实例初始化程序或静态初始化程序直接包含的本地或匿名类，则此方法返回<code>null</code> 。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <span>如果该类是本地或匿名类，则为基础类的直接封闭构造函数;</span> 
              <span>否则<code>null</code> 。</span> 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <span><code><a href="SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理器<i>s</i>且满足以下任一条件：</span> 
              <ul> 
               <li> <span>调用者的类加载器与封闭类的类加载器不同，并且调用<a href="SecurityManager.html#checkPermission(java.security.Permission)"><code>s.checkPermission</code></a>方法， <code>RuntimePermission("accessDeclaredMembers")</code>拒绝访问封闭类中的构造函数</span> </li> 
               <li> <span>调用者的类加载器与封闭类的类加载器不同或是祖先，并且<a href="SecurityManager.html#checkPackageAccess(java.lang.String)"><code>s.checkPackageAccess()</code>的</a>调用拒绝访问封闭类的包</span> </li> 
              </ul> 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.5 
             </dd> 
            </dl> </li> 
          </ul> <a id="getDeclaringClass()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getDeclaringClass</h4> <pre class="methodSignature">public&nbsp;<a href="Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;getDeclaringClass()
                           throws <a href="SecurityException.html" title="class in java.lang">SecurityException</a></pre> 
            <div class="block"> 
             <span>如果此<code>类</code>对象表示的类或接口是另一个类的成员，则返回表示声明它的类的<code>类</code>对象。</span> 
             <span>如果此类或接口不是任何其他类的成员，则此方法返回null。</span> 
             <span>如果此<code>类</code>对象表示数组类，基本类型或void，则此方法返回null。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               这个类的声明类 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理器 
              <i>s</i> ，并且调用者的类加载器与声明类的类加载器不同或者是祖先，并且 
              <a href="SecurityManager.html#checkPackageAccess(java.lang.String)"><code>s.checkPackageAccess()</code>的</a>调用拒绝访问声明类的包 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.1 
             </dd> 
            </dl> </li> 
          </ul> <a id="getEnclosingClass()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getEnclosingClass</h4> <pre class="methodSignature">public&nbsp;<a href="Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;getEnclosingClass()
                           throws <a href="SecurityException.html" title="class in java.lang">SecurityException</a></pre> 
            <div class="block"> 
             <span>返回基础类的直接封闭类。</span> 
             <span>如果底层类是顶级类，则此方法返回<code>null</code> 。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               基础类的直接封闭类 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理器 
              <i>s</i> ，并且调用者的类加载器与封闭类的类加载器不同或者是祖先，并且调用 
              <a href="SecurityManager.html#checkPackageAccess(java.lang.String)"><code>s.checkPackageAccess()</code></a>拒绝访问封闭类的包 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.5 
             </dd> 
            </dl> </li> 
          </ul> <a id="getSimpleName()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getSimpleName</h4> <pre class="methodSignature">public&nbsp;<a href="String.html" title="class in java.lang">String</a>&nbsp;getSimpleName()</pre> 
            <div class="block"> 
             <span>返回源代码中给出的基础类的简单名称。</span> 
             <span>如果基础类是匿名的，则返回空字符串。</span> 
             <p> <span>数组的简单名称是附加了“[]”的组件类型的简单名称。</span> <span>特别是组件类型为匿名的数组的简单名称是“[]”。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               底层类的简单名称 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.5 
             </dd> 
            </dl> </li> 
          </ul> <a id="getTypeName()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getTypeName</h4> <pre class="methodSignature">public&nbsp;<a href="String.html" title="class in java.lang">String</a>&nbsp;getTypeName()</pre> 
            <div class="block">
              返回此类型名称的信息字符串。 
            </div> 
            <dl> 
             <dt> 
              <span class="overrideSpecifyLabel">Specified by:</span> 
             </dt> 
             <dd> 
              <code><a href="reflect/Type.html#getTypeName()">getTypeName</a></code>在接口 
              <code><a href="reflect/Type.html" title="interface in java.lang.reflect">Type</a></code> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               这种类型名称的信息字符串 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.8 
             </dd> 
            </dl> </li> 
          </ul> <a id="getCanonicalName()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getCanonicalName</h4> <pre class="methodSignature">public&nbsp;<a href="String.html" title="class in java.lang">String</a>&nbsp;getCanonicalName()</pre> 
            <div class="block"> 
             <span>返回Java语言规范定义的基础类的规范名称。</span> 
             <span>如果基础类没有规范名称（即，如果它是本地或匿名类或其组件类型没有规范名称的数组），则返回null。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               基础类的规范名称（如果存在），否则为 
              <code>null</code> 。 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.5 
             </dd> 
            </dl> </li> 
          </ul> <a id="isAnonymousClass()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>isAnonymousClass</h4> <pre class="methodSignature">public&nbsp;boolean&nbsp;isAnonymousClass()</pre> 
            <div class="block">
              当且仅当基础类是匿名类时，返回 
             <code>true</code> 。 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>true</code>当且仅当此类是匿名类时。 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.5 
             </dd> 
            </dl> </li> 
          </ul> <a id="isLocalClass()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>isLocalClass</h4> <pre class="methodSignature">public&nbsp;boolean&nbsp;isLocalClass()</pre> 
            <div class="block">
              当且仅当基础类是本地类时，返回 
             <code>true</code> 。 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>true</code>当且仅当此类是本地类时。 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.5 
             </dd> 
            </dl> </li> 
          </ul> <a id="isMemberClass()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>isMemberClass</h4> <pre class="methodSignature">public&nbsp;boolean&nbsp;isMemberClass()</pre> 
            <div class="block">
              当且仅当基础类是成员类时，返回 
             <code>true</code> 。 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>true</code>当且仅当此类是成员类时。 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.5 
             </dd> 
            </dl> </li> 
          </ul> <a id="getClasses()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getClasses</h4> <pre class="methodSignature">public&nbsp;<a href="Class.html" title="class in java.lang">类</a>&lt;?&gt;[]&nbsp;getClasses()</pre> 
            <div class="block"> 
             <span>返回一个数组，其中包含<code>类</code>对象，这些对象表示作为此<code>类</code>对象所表示的类的成员的所有公共类和接口。</span> 
             <span>这包括从超类继承的公共类和接口成员，以及由类声明的公共类和接口成员。</span> 
             <span>如果此<code>类</code>对象没有公共成员类或接口，则此方法返回长度为0的数组。</span> 
             <span>如果此<code>类</code>对象表示基本类型，数组类或void，则此方法还返回长度为0的数组。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>类</code>对象的数组，表示 
              <code>类</code>的公共成员 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理器 
              <i>s</i> ，并且调用者的类加载器与当前类的类加载器不同或是其祖先，则调用 
              <a href="SecurityManager.html#checkPackageAccess(java.lang.String)"><code>s.checkPackageAccess()</code>将</a>拒绝访问此类的包。 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.1 
             </dd> 
            </dl> </li> 
          </ul> <a id="getFields()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getFields</h4> <pre class="methodSignature">public&nbsp;<a href="reflect/Field.html" title="class in java.lang.reflect">字段</a>[]&nbsp;getFields()
                  throws <a href="SecurityException.html" title="class in java.lang">SecurityException</a></pre> 
            <div class="block"> 
             <span>返回一个包含<code>字段</code>对象的数组， <code>字段</code>对象反映此<code>类</code>对象所表示的类或接口的所有可访问公共字段。</span> 
             <p> <span>如果此<code>类</code>对象表示没有可访问的公共字段的类或接口，则此方法返回长度为0的数组。</span> </p> 
             <p> <span>如果此<code>类</code>对象表示一个类，则此方法返回该类及其所有超类和超接口的公共字段。</span> </p> 
             <p> <span>如果此<code>类</code>对象表示接口，则此方法返回接口及其所有超接口的字段。</span> </p> 
             <p> <span>如果此<code>类</code>对象表示数组类型，基本类型或void，则此方法返回长度为0的数组。</span> </p> 
             <p> <span>返回数组中的元素未排序，并且不按任何特定顺序排列。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               表示公共字段的 
              <code>字段</code>对象的数组 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理器 
              <i>s</i> ，并且调用者的类加载器与当前类的类加载器不同或是其祖先，则调用 
              <a href="SecurityManager.html#checkPackageAccess(java.lang.String)"><code>s.checkPackageAccess()</code>将</a>拒绝访问此类的包。 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.1 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">See <cite>The Java™ Language Specification</cite>:</span> 
             </dt> 
             <dd>
               8.2集体成员，8.3现场声明 
             </dd> 
            </dl> </li> 
          </ul> <a id="getMethods()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getMethods</h4> <pre class="methodSignature">public&nbsp;<a href="reflect/Method.html" title="class in java.lang.reflect">方法</a>[]&nbsp;getMethods()
                    throws <a href="SecurityException.html" title="class in java.lang">SecurityException</a></pre> 
            <div class="block"> 
             <span>返回一个包含<code>方法</code>对象的数组， <code>方法</code>对象反映此<code>类</code>对象所表示的类或接口的所有公共方法，包括由类或接口声明的那些以及从超类和超接口继承的那些。</span> 
             <p> <span>如果此<code>类</code>对象表示一个数组类型，则返回的阵列具有<code>方法</code>对于每个由阵列类型从继承的公共方法对象<code>Object</code> 。</span> <span>它不包含<code>方法</code>对象为<code>clone()</code> 。</span> </p> 
             <p> <span>如果此<code>类</code>对象表示接口，则返回的数组不包含<code>Object</code>任何隐式声明的方法。</span> <span>因此，如果在此接口或其任何超接口中未显式声明任何方法，则返回的数组的长度为0.（请注意，表示类的<code>类</code>对象始终具有公共方法，继承自<code>Object</code> ）</span> </p> 
             <p> <span>返回的数组永远不包含名称为“ <code>&lt;init&gt;</code> ”或“ <code>&lt;clinit&gt;</code> ”的方法。</span> </p> 
             <p> <span>返回数组中的元素未排序，并且不按任何特定顺序排列。</span> </p> 
             <p> <span>通常，结果按照以下4步算法计算。</span> <span>设C是此<code>类</code>对象表示的类或接口：</span> </p> 
             <ol> 
              <li> <span>方法联合包括：</span> 
               <ol type="a"> 
                <li> <span>C声明了<a href="#getDeclaredMethods()"><code>getDeclaredMethods()</code></a>返回的公共实例和静态方法，并过滤为仅包含公共方法。</span> </li> 
                <li> <span>如果C是<code>Object</code>以外的类，则包括在C的超类上递归调用此算法的结果。</span> </li> 
                <li> <span>包括在C的所有直接超接口上递归调用此算法的结果，但仅包括实例方法。</span> </li> 
               </ol></li> 
              <li> <span>来自步骤1的联合被划分为具有相同签名（名称，参数类型）和返回类型的方法的子集。</span> </li> 
              <li> <span>在每个这样的子集内，仅选择最具体的方法。</span> <span>设方法M是来自具有相同签名和返回类型的一组方法的方法。</span> <span>如果在同一组中没有这样的方法N！= M，则M是最具体的，使得N比M更具特异性.N如果出现以下情况，则N比M更具体：</span> 
               <ol type="a"> 
                <li> <span>N由类声明，M由接口声明;</span> <span>要么</span> </li> 
                <li> <span>N和M都是由类或两者通过接口声明的，并且N的声明类型与M的声明类型相同或者是M的声明类型的子类型（显然，如果M和N的声明类型是相同类型，则M和N是相同的方法） 。</span> </li> 
               </ol></li> 
              <li> <span>该算法的结果是来自步骤3的所有选定方法的并集。</span> </li> 
             </ol> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>在类中可能有多个具有特定名称和参数类型的方法，因为虽然Java语言禁止类声明具有相同签名但返回类型不同的多个方法，但Java虚拟机却没有。</span> 
              <span>虚拟机中增加的灵活性可用于实现各种语言功能。</span> 
              <span>例如，协变返回可以用<a href="reflect/Method.html#isBridge()">bridge methods</a>实现;</span> 
              <span>桥接方法和重写方法将具有相同的签名但返回类型不同。</span> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>方法</code>对象的数组，表示 
              <code>方法</code>的公共方法 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理器 
              <i>s</i> ，并且调用者的类加载器与当前类的类加载器不同或是其祖先，则调用 
              <a href="SecurityManager.html#checkPackageAccess(java.lang.String)"><code>s.checkPackageAccess()</code>将</a>拒绝访问此类的包。 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.1 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">See <cite>The Java™ Language Specification</cite>:</span> 
             </dt> 
             <dd>
               8.2类成员，8.4方法声明 
             </dd> 
            </dl> </li> 
          </ul> <a id="getConstructors()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getConstructors</h4> <pre class="methodSignature">public&nbsp;<a href="reflect/Constructor.html" title="class in java.lang.reflect">构造器</a>&lt;?&gt;[]&nbsp;getConstructors()
                                 throws <a href="SecurityException.html" title="class in java.lang">SecurityException</a></pre> 
            <div class="block"> 
             <span>返回一个包含<code>构造器</code>对象的数组， <code>构造器</code>对象反映了此<code>类</code>对象所表示的类的所有公共构造函数。</span> 
             <span>如果类没有公共构造函数，或者类是数组类，或者类反映了基本类型或void，则返回长度为0的数组。</span> 
             <span>请注意，虽然此方法返回<code>Constructor&lt;T&gt;</code>对象的数组（此类中的构造函数数组），但此方法的返回类型为<code>Constructor&lt;?&gt;[]</code>而<em>不是</em>预期的<code>Constructor&lt;T&gt;[]</code> 。</span> 
             <span>这个信息量较少的返回类型是必要的，因为从此方法返回后，可以修改数组以保存不同类的<code>构造器</code>对象，这将违反<code>Constructor&lt;T&gt;[]</code>的类型保证。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>构造器</code>对象的数组，表示 
              <code>构造器</code>的公共构造函数 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理器 
              <i>s</i> ，并且调用者的类加载器与当前类的类加载器不同或是其祖先，则调用 
              <a href="SecurityManager.html#checkPackageAccess(java.lang.String)"><code>s.checkPackageAccess()</code>将</a>拒绝访问此类的包。 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.1 
             </dd> 
            </dl> </li> 
          </ul> <a id="getField(java.lang.String)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getField</h4> <pre class="methodSignature">public&nbsp;<a href="reflect/Field.html" title="class in java.lang.reflect">字段</a>&nbsp;getField​(<a href="String.html" title="class in java.lang">String</a>&nbsp;name)
               throws <a href="NoSuchFieldException.html" title="class in java.lang">NoSuchFieldException</a>,
                      <a href="SecurityException.html" title="class in java.lang">SecurityException</a></pre> 
            <div class="block"> 
             <span>返回<code>字段</code>对象，该对象反映此<code>类</code>对象表示的类或接口的指定公共成员字段。</span> 
             <span><code>name</code>参数是<code>String</code>指定所需字段的简单名称。</span> 
             <p> <span>要反映的字段由下面的算法确定。</span> <span>设C为此对象表示的类或接口：</span> </p> 
             <ol> 
              <li> <span>如果C声明一个具有指定名称的公共字段，那就是要反映的字段。</span> </li> 
              <li> <span>如果在上面的步骤1中没有找到字段，则该算法递归地应用于C的每个直接超接口。直接超接口按它们被声明的顺序搜索。</span> </li> 
              <li> <span>如果在上面的步骤1和2中没有找到字段，并且C具有超类S，则在S上递归调用该算法。如果C没有超类，则抛出<code>NoSuchFieldException</code> 。</span> </li> 
             </ol> 
             <p> <span>如果此<code>类</code>对象表示数组类型，则此方法找不到数组类型的<code>length</code>字段。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>name</code> - 字段名称 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               由 
              <code>name</code>指定的 
              <code>name</code>的 
              <code>字段</code>对象 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="NoSuchFieldException.html" title="class in java.lang">NoSuchFieldException</a></code> - 如果找不到具有指定名称的字段。 
             </dd> 
             <dd> 
              <code><a href="NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
              <code>name</code>是 
              <code>null</code> 
             </dd> 
             <dd> 
              <code><a href="SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理器 
              <i>s</i> ，并且调用者的类加载器与当前类的类加载器不同或是其祖先，则调用 
              <a href="SecurityManager.html#checkPackageAccess(java.lang.String)"><code>s.checkPackageAccess()</code>将</a>拒绝访问此类的包。 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.1 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">See <cite>The Java™ Language Specification</cite>:</span> 
             </dt> 
             <dd>
               8.2集体成员，8.3现场声明 
             </dd> 
            </dl> </li> 
          </ul> <a id="getMethod(java.lang.String,java.lang.Class...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getMethod</h4> <pre class="methodSignature">public&nbsp;<a href="reflect/Method.html" title="class in java.lang.reflect">方法</a>&nbsp;getMethod​(<a href="String.html" title="class in java.lang">String</a>&nbsp;name,
                        <a href="Class.html" title="class in java.lang">类</a>&lt;?&gt;...&nbsp;parameterTypes)
                 throws <a href="NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a>,
                        <a href="SecurityException.html" title="class in java.lang">SecurityException</a></pre> 
            <div class="block"> 
             <span>返回一个<code>方法</code>对象，该对象反映此<code>类</code>对象所表示的类或接口的指定公共成员方法。</span> 
             <span><code>name</code>参数是<code>String</code>指定所需方法的简单名称。</span> 
             <span><code>parameterTypes</code>参数是一个<code>类</code>对象的数组，以声明的顺序标识方法的形式参数类型。</span> 
             <span>如果<code>parameterTypes</code>是<code>null</code> ，则将其视为空数组。</span> 
             <p> <span>如果此<code>类</code>对象表示数组类型，则该方法找到以阵列型从继承的任何公有方法<code>Object</code>除了方法<code>clone()</code> 。</span> </p> 
             <p> <span>如果此<code>类</code>对象表示接口，则此方法未找到<code>Object</code>任何隐式声明的方法。</span> <span>因此，如果在此接口或其任何超接口中未显式声明任何方法，则此方法找不到任何方法。</span> </p> 
             <p> <span>此方法未找到名称为“ <code>&lt;init&gt;</code> ”或“ <code>&lt;clinit&gt;</code> ”的任何方法。</span> </p> 
             <p> <span>通常，要反映的方法由随后的4步算法确定。</span> <span>设C为此<code>类</code>对象表示的类或接口：</span> </p> 
             <ol> 
              <li> <span>方法联合包括：</span> 
               <ol type="a"> 
                <li> <span>C声明了<a href="#getDeclaredMethods()"><code>getDeclaredMethods()</code></a>返回的公共实例和静态方法，并过滤为仅包含与给定<code>name</code>和<code>parameterTypes</code>匹配的公共方法</span> </li> 
                <li> <span>如果C是<code>Object</code>以外的类，则包括在C的超类上递归调用此算法的结果。</span> </li> 
                <li> <span>包括在C的所有直接超接口上递归调用此算法的结果，但仅包括实例方法。</span> </li> 
               </ol></li> 
              <li> <span>此联合被分区为具有相同返回类型的方法子集（步骤1中的方法选择也保证它们具有相同的方法名称和参数类型）。</span> </li> 
              <li> <span>在每个这样的子集内，仅选择最具体的方法。</span> <span>设方法M是来自具有相同VM签名（返回类型，名称，参数类型）的一组方法的方法。</span> <span>如果在同一组中没有这样的方法N！= M，则M是最具体的，使得N比M更具特异性.N如果出现以下情况，则N比M更具体：</span> 
               <ol type="a"> 
                <li> <span>N由类声明，M由接口声明;</span> <span>要么</span> </li> 
                <li> <span>N和M都是由类或两者通过接口声明的，并且N的声明类型与M的声明类型相同或者是M的声明类型的子类型（显然，如果M和N的声明类型是相同类型，则M和N是相同的方法） 。</span> </li> 
               </ol></li> 
              <li> <span>该算法的结果是从步骤3中所有选定方法中具有最特定返回类型的方法中任意选择的。设R是来自步骤3中所有选定方法的集合的方法M的返回类型.M是一种方法最具体的返回类型，如果没有这样的方法N！= M来自同一组，具有返回类型S！= R，使得S是由R.class确定的R的子类型。</span> <span><a href="#isAssignableFrom(java.lang.Class)"><code>isAssignableFrom(java.lang.Class&lt;?&gt;)</code></a> （S.class）。</span> </li> 
             </ol> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>在类中可能有多个匹配名称和参数类型的方法，因为虽然Java语言禁止类声明具有相同签名但返回类型不同的多个方法，但Java虚拟机却没有。</span> 
              <span>虚拟机中增加的灵活性可用于实现各种语言功能。</span> 
              <span>例如，协变返回可以用<a href="reflect/Method.html#isBridge()">bridge methods</a>实现;</span> 
              <span>桥接方法和重写方法将具有相同的签名但返回类型不同。</span> 
              <span>此方法将返回覆盖方法，因为它具有更具体的返回类型。</span> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>name</code> - 方法的名称 
             </dd> 
             <dd> 
              <code>parameterTypes</code> - 参数列表 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               与指定的 
              <code>name</code>和 
              <code>parameterTypes</code>匹配的 
              <code>方法</code>对象 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a></code> - 如果未找到匹配方法或名称为“&lt;init&gt;”或“&lt;clinit&gt;”。 
             </dd> 
             <dd> 
              <code><a href="NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
              <code>name</code>是 
              <code>null</code> 
             </dd> 
             <dd> 
              <code><a href="SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理器 
              <i>s</i> ，并且调用者的类加载器与当前类的类加载器不同或是其祖先，则调用 
              <a href="SecurityManager.html#checkPackageAccess(java.lang.String)"><code>s.checkPackageAccess()</code>将</a>拒绝访问此类的包。 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.1 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">See <cite>The Java™ Language Specification</cite>:</span> 
             </dt> 
             <dd>
               8.2类成员，8.4方法声明 
             </dd> 
            </dl> </li> 
          </ul> <a id="getConstructor(java.lang.Class...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getConstructor</h4> <pre class="methodSignature">public&nbsp;<a href="reflect/Constructor.html" title="class in java.lang.reflect">构造器</a>&lt;<a href="Class.html" title="type parameter in Class">T</a>&gt;&nbsp;getConstructor​(<a href="Class.html" title="class in java.lang">类</a>&lt;?&gt;...&nbsp;parameterTypes)
                              throws <a href="NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a>,
                                     <a href="SecurityException.html" title="class in java.lang">SecurityException</a></pre> 
            <div class="block"> 
             <span>返回一个<code>构造器</code>对象，该对象反映此<code>类</code>对象所表示的类的指定公共构造函数。</span> 
             <span><code>parameterTypes</code>参数是一个<code>类</code>对象的数组，它按声明的顺序标识构造函数的形式参数类型。</span> 
             <span>如果此<code>类</code>对象表示在非静态上下文中声明的内部类，则形式参数类型包括显式封闭实例作为第一个参数。</span> 
             <p> <span>要反映的构造函数是此<code>类</code>对象所表示的类的公共构造函数，其形式参数类型与<code>parameterTypes</code>指定的类型相匹配。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>parameterTypes</code> - 参数数组 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               与指定的 
              <code>parameterTypes</code>匹配的公共构造函数的 
              <code>构造器</code>对象 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a></code> - 如果找不到匹配的方法。 
             </dd> 
             <dd> 
              <code><a href="SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理器 
              <i>s</i>且调用者的类加载器与当前类的类加载器的不同或类型的祖先相同，则调用 
              <a href="SecurityManager.html#checkPackageAccess(java.lang.String)"><code>s.checkPackageAccess()</code>将</a>拒绝访问此类的包。 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.1 
             </dd> 
            </dl> </li> 
          </ul> <a id="getDeclaredClasses()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getDeclaredClasses</h4> <pre class="methodSignature">public&nbsp;<a href="Class.html" title="class in java.lang">类</a>&lt;?&gt;[]&nbsp;getDeclaredClasses()
                              throws <a href="SecurityException.html" title="class in java.lang">SecurityException</a></pre> 
            <div class="block"> 
             <span>返回<code>类</code>对象的数组， <code>类</code>对象反映声明为此<code>类</code>对象所表示的类的成员的所有类和接口。</span> 
             <span>这包括公共，受保护，默认（包）访问以及类声明的私有类和接口，但不包括继承的类和接口。</span> 
             <span>如果类声明没有类或接口作为成员，或者此<code>类</code>对象表示基本类型，数组类或void，则此方法返回长度为0的数组。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>类</code>对象的数组，表示 
              <code>类</code>所有已声明成员 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <span><code><a href="SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理器<i>s</i>且满足以下任一条件：</span> 
              <ul> 
               <li> <span>调用者的类加载器与此类的类加载器不同，并且调用<a href="SecurityManager.html#checkPermission(java.security.Permission)"><code>s.checkPermission</code></a>方法和<code>RuntimePermission("accessDeclaredMembers")</code>拒绝访问<code>RuntimePermission("accessDeclaredMembers")</code>中的声明类</span> </li> 
               <li> <span>调用者的类加载器与当前类的类加载器不同或是祖先，并且<a href="SecurityManager.html#checkPackageAccess(java.lang.String)"><code>s.checkPackageAccess()</code>的</a>调用拒绝访问此类的包</span> </li> 
              </ul> 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.1 
             </dd> 
            </dl> </li> 
          </ul> <a id="getDeclaredFields()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getDeclaredFields</h4> <pre class="methodSignature">public&nbsp;<a href="reflect/Field.html" title="class in java.lang.reflect">字段</a>[]&nbsp;getDeclaredFields()
                          throws <a href="SecurityException.html" title="class in java.lang">SecurityException</a></pre> 
            <div class="block"> 
             <span>返回<code>字段</code>对象的数组， <code>字段</code>对象反映由此<code>类</code>对象表示的类或接口声明的所有字段。</span> 
             <span>这包括公共，受保护，默认（包）访问和私有字段，但不包括继承的字段。</span> 
             <p> <span>如果此<code>类</code>对象表示没有声明字段的类或接口，则此方法返回长度为0的数组。</span> </p> 
             <p> <span>如果此<code>类</code>对象表示数组类型，基本类型或void，则此方法返回长度为0的数组。</span> </p> 
             <p> <span>返回数组中的元素未排序，并且不按任何特定顺序排列。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>字段</code>对象的数组，表示 
              <code>字段</code>所有声明字段 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <span><code><a href="SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理器<i>s</i>且满足以下任一条件：</span> 
              <ul> 
               <li> <span>调用者的类加载器与此类的类加载器不同，并且调用<a href="SecurityManager.html#checkPermission(java.security.Permission)"><code>s.checkPermission</code></a>方法和<code>RuntimePermission("accessDeclaredMembers")</code>拒绝访问<code>RuntimePermission("accessDeclaredMembers")</code>中的声明字段</span> </li> 
               <li> <span>调用者的类加载器与当前类的类加载器不同或是祖先，并且<a href="SecurityManager.html#checkPackageAccess(java.lang.String)"><code>s.checkPackageAccess()</code>的</a>调用拒绝访问此类的包</span> </li> 
              </ul> 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.1 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">See <cite>The Java™ Language Specification</cite>:</span> 
             </dt> 
             <dd>
               8.2集体成员，8.3现场声明 
             </dd> 
            </dl> </li> 
          </ul> <a id="getDeclaredMethods()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getDeclaredMethods</h4> <pre class="methodSignature">public&nbsp;<a href="reflect/Method.html" title="class in java.lang.reflect">方法</a>[]&nbsp;getDeclaredMethods()
                            throws <a href="SecurityException.html" title="class in java.lang">SecurityException</a></pre> 
            <div class="block"> 
             <span>返回一个包含<code>方法</code>对象的数组， <code>方法</code>对象反映此<code>类</code>对象表示的类或接口的所有已声明方法，包括公共，受保护，默认（包）访问和私有方法，但不包括继承的方法。</span> 
             <p> <span>如果此<code>类</code>对象表示具有多个具有相同名称和参数类型但返回类型不同的声明方法的类型，则返回的数组对于每个此类方法都有一个<code>方法</code>对象。</span> </p> 
             <p> <span>如果此<code>类</code>对象表示具有类初始化方法的类型<code>&lt;clinit&gt;</code> ，则返回的阵列<em>不</em>具有相应的<code>方法</code>对象。</span> </p> 
             <p> <span>如果此<code>类</code>对象表示没有声明方法的类或接口，则返回的数组的长度为0。</span> </p> 
             <p> <span>如果此<code>类</code>对象表示数组类型，基本类型或void，则返回的数组的长度为0。</span> </p> 
             <p> <span>返回数组中的元素未排序，并且不按任何特定顺序排列。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>方法</code>对象的数组，表示 
              <code>方法</code>所有已声明方法 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <span><code><a href="SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理器<i>s</i>且满足以下任一条件：</span> 
              <ul> 
               <li> <span>调用者的类加载器与此类的类加载器不同，并且调用<a href="SecurityManager.html#checkPermission(java.security.Permission)"><code>s.checkPermission</code></a>方法， <code>RuntimePermission("accessDeclaredMembers")</code>拒绝访问<code>RuntimePermission("accessDeclaredMembers")</code>中的声明方法</span> </li> 
               <li> <span>调用者的类加载器与当前类的类加载器的不同或者是祖先，并且<a href="SecurityManager.html#checkPackageAccess(java.lang.String)"><code>s.checkPackageAccess()</code>的</a>调用拒绝访问此类的包</span> </li> 
              </ul> 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.1 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">See <cite>The Java™ Language Specification</cite>:</span> 
             </dt> 
             <dd>
               8.2类成员，8.4方法声明 
             </dd> 
            </dl> </li> 
          </ul> <a id="getDeclaredConstructors()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getDeclaredConstructors</h4> <pre class="methodSignature">public&nbsp;<a href="reflect/Constructor.html" title="class in java.lang.reflect">构造器</a>&lt;?&gt;[]&nbsp;getDeclaredConstructors()
                                         throws <a href="SecurityException.html" title="class in java.lang">SecurityException</a></pre> 
            <div class="block"> 
             <span>返回<code>构造器</code>对象的数组， <code>构造器</code>对象反映由此<code>类</code>对象表示的类声明的所有构造函数。</span> 
             <span>这些是公共，受保护，默认（包）访问和私有构造函数。</span> 
             <span>返回的数组中的元素没有排序，也没有任何特定的顺序。</span> 
             <span>如果类具有默认构造函数，则它包含在返回的数组中。</span> 
             <span>如果此<code>类</code>对象表示接口，基本类型，数组类或void，则此方法返回长度为0的数组。</span> 
             <p> <span>请参阅<em>Java语言规范</em> ，第8.2节。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>构造器</code>对象的数组，表示 
              <code>构造器</code>所有声明的构造函数 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <span><code><a href="SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理器<i>s</i>且满足以下任一条件：</span> 
              <ul> 
               <li> <span>调用者的类加载器与此类的类加载器不同，并且调用<a href="SecurityManager.html#checkPermission(java.security.Permission)"><code>s.checkPermission</code></a>方法和<code>RuntimePermission("accessDeclaredMembers")</code>拒绝访问<code>RuntimePermission("accessDeclaredMembers")</code>中的已声明构造函数</span> </li> 
               <li> <span>调用者的类加载器与当前类的类加载器或祖先不同，并且调用<a href="SecurityManager.html#checkPackageAccess(java.lang.String)"><code>s.checkPackageAccess()</code></a>拒绝访问此类的包</span> </li> 
              </ul> 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.1 
             </dd> 
            </dl> </li> 
          </ul> <a id="getDeclaredField(java.lang.String)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getDeclaredField</h4> <pre class="methodSignature">public&nbsp;<a href="reflect/Field.html" title="class in java.lang.reflect">字段</a>&nbsp;getDeclaredField​(<a href="String.html" title="class in java.lang">String</a>&nbsp;name)
                       throws <a href="NoSuchFieldException.html" title="class in java.lang">NoSuchFieldException</a>,
                              <a href="SecurityException.html" title="class in java.lang">SecurityException</a></pre> 
            <div class="block"> 
             <span>返回<code>字段</code>对象，该对象反映此<code>类</code>对象表示的类或接口的指定声明字段。</span> 
             <span><code>name</code>参数是<code>String</code> ，它指定所需字段的简单名称。</span> 
             <p> <span>如果此<code>类</code>对象表示数组类型，则此方法找不到数组类型的<code>length</code>字段。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>name</code> - 字段的名称 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>字段</code>中指定字段的 
              <code>字段</code>对象 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="NoSuchFieldException.html" title="class in java.lang">NoSuchFieldException</a></code> - 如果找不到具有指定名称的字段。 
             </dd> 
             <dd> 
              <code><a href="NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
              <code>name</code>是 
              <code>null</code> 
             </dd> 
             <dd> 
              <span><code><a href="SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理器<i>s</i>且满足以下任一条件：</span> 
              <ul> 
               <li> <span>调用者的类加载器与此类的类加载器不同，并且调用<a href="SecurityManager.html#checkPermission(java.security.Permission)"><code>s.checkPermission</code></a>方法， <code>RuntimePermission("accessDeclaredMembers")</code>拒绝访问声明的字段</span> </li> 
               <li> <span>调用者的类加载器与当前类的类加载器的不同或者是祖先，并且<a href="SecurityManager.html#checkPackageAccess(java.lang.String)"><code>s.checkPackageAccess()</code>的</a>调用拒绝访问此类的包</span> </li> 
              </ul> 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.1 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">See <cite>The Java™ Language Specification</cite>:</span> 
             </dt> 
             <dd>
               8.2集体成员，8.3现场声明 
             </dd> 
            </dl> </li> 
          </ul> <a id="getDeclaredMethod(java.lang.String,java.lang.Class...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getDeclaredMethod</h4> <pre class="methodSignature">public&nbsp;<a href="reflect/Method.html" title="class in java.lang.reflect">方法</a>&nbsp;getDeclaredMethod​(<a href="String.html" title="class in java.lang">String</a>&nbsp;name,
                                <a href="Class.html" title="class in java.lang">类</a>&lt;?&gt;...&nbsp;parameterTypes)
                         throws <a href="NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a>,
                                <a href="SecurityException.html" title="class in java.lang">SecurityException</a></pre> 
            <div class="block"> 
             <span>返回<code>方法</code>对象，该对象反映此<code>类</code>对象所表示的类或接口的指定声明方法。</span> 
             <span><code>name</code>参数是<code>String</code> ，它指定所需方法的简单名称， <code>parameterTypes</code>参数是<code>类</code>对象的数组， <code>类</code>对象按声明的顺序标识方法的形式参数类型。</span> 
             <span>如果在类中声明了多个具有相同参数类型的方法，并且其中一个方法的返回类型比任何其他方法更具体，则返回该方法;</span> 
             <span>否则任意选择其中一种方法。</span> 
             <span>如果名称为“&lt;init&gt;”或“&lt;clinit&gt;”，则引发<code>NoSuchMethodException</code> 。</span> 
             <p> <span>如果此<code>类</code>对象表示数组类型，则此方法找不到<code>clone()</code>方法。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>name</code> - 方法的名称 
             </dd> 
             <dd> 
              <code>parameterTypes</code> - 参数数组 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>方法</code>对象为此类的方法匹配指定的名称和参数 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a></code> - 如果找不到匹配的方法。 
             </dd> 
             <dd> 
              <code><a href="NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
              <code>name</code>是 
              <code>null</code> 
             </dd> 
             <dd> 
              <span><code><a href="SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理器<i>s</i>且满足以下任一条件：</span> 
              <ul> 
               <li> <span>调用者的类加载器与此类的类加载器不同，并且<a href="SecurityManager.html#checkPermission(java.security.Permission)"><code>s.checkPermission</code></a>方法的调用<code>RuntimePermission("accessDeclaredMembers")</code>拒绝访问声明的方法</span> </li> 
               <li> <span>调用者的类加载器与当前类的类加载器不同或是祖先，并且<a href="SecurityManager.html#checkPackageAccess(java.lang.String)"><code>s.checkPackageAccess()</code>的</a>调用拒绝访问此类的包</span> </li> 
              </ul> 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.1 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">See <cite>The Java™ Language Specification</cite>:</span> 
             </dt> 
             <dd>
               8.2类成员，8.4方法声明 
             </dd> 
            </dl> </li> 
          </ul> <a id="getDeclaredConstructor(java.lang.Class...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getDeclaredConstructor</h4> <pre class="methodSignature">public&nbsp;<a href="reflect/Constructor.html" title="class in java.lang.reflect">构造器</a>&lt;<a href="Class.html" title="type parameter in Class">T</a>&gt;&nbsp;getDeclaredConstructor​(<a href="Class.html" title="class in java.lang">类</a>&lt;?&gt;...&nbsp;parameterTypes)
                                      throws <a href="NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a>,
                                             <a href="SecurityException.html" title="class in java.lang">SecurityException</a></pre> 
            <div class="block"> 
             <span>返回一个<code>构造器</code>对象，该对象反映此<code>类</code>对象所表示的类或接口的指定构造函数。</span> 
             <span><code>parameterTypes</code>参数是一个<code>类</code>对象的数组，它按声明的顺序标识构造函数的形式参数类型。</span> 
             <span>如果此<code>类</code>对象表示在非静态上下文中声明的内部类，则形式参数类型包括显式封闭实例作为第一个参数。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>parameterTypes</code> - 参数数组 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               具有指定参数列表的构造函数的 
              <code>构造器</code>对象 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a></code> - 如果找不到匹配的方法。 
             </dd> 
             <dd> 
              <span><code><a href="SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理器<i>s</i>且满足以下任一条件：</span> 
              <ul> 
               <li> <span>调用者的类加载器与此类的类加载器不同，并且调用<a href="SecurityManager.html#checkPermission(java.security.Permission)"><code>s.checkPermission</code></a>方法和<code>RuntimePermission("accessDeclaredMembers")</code>拒绝访问声明的构造函数</span> </li> 
               <li> <span>调用者的类加载器与当前类的类加载器不同或是祖先，并且<a href="SecurityManager.html#checkPackageAccess(java.lang.String)"><code>s.checkPackageAccess()</code>的</a>调用拒绝访问此类的包</span> </li> 
              </ul> 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.1 
             </dd> 
            </dl> </li> 
          </ul> <a id="getResourceAsStream(java.lang.String)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getResourceAsStream</h4> <pre class="methodSignature">public&nbsp;<a href="../io/InputStream.html" title="class in java.io">InputStream</a>&nbsp;getResourceAsStream​(<a href="String.html" title="class in java.lang">String</a>&nbsp;name)</pre> 
            <div class="block"> 
             <span>查找具有给定名称的资源。</span> 
             <p> <span>如果此类位于命名的<a href="Module.html" title="java.lang中的类"><code>模块</code>中，</a>则此方法将尝试在模块中查找资源。</span> <span>这是通过委托模块的类加载器<a href="ClassLoader.html#findResource(java.lang.String,java.lang.String)"><code>findResource(String,String)</code></a>方法完成的，使用模块名称和资源的绝对名称调用它。</span> <span>命名模块中的资源受<code>模块</code> <a href="Module.html#getResourceAsStream(java.lang.String)"><code>getResourceAsStream</code></a>方法中指定的封装规则的<code>模块</code> ，因此当资源是未对调用方模块打开的包中的非“ <code>.class</code> ”资源时，此方法返回<code>null</code> 。</span> </p> 
             <p> <span>否则，如果此类不在命名模块中，则用于搜索与给定类关联的资源的规则由类的定义<a href="ClassLoader.html" title="java.lang中的类">class loader</a>实现。</span> <span>此方法委托给该对象的类加载器。</span> <span>如果此对象由引导类加载器加载，则该方法委托给<a href="ClassLoader.html#getSystemResourceAsStream(java.lang.String)"><code>ClassLoader.getSystemResourceAsStream(java.lang.String)</code></a> 。</span> </p> 
             <p> <span>在委派之前，使用此算法从给定资源名称构造绝对资源名称：</span> </p> 
             <ul> 
              <li> <span>如果<code>name</code>以<code>'/'</code> （ <code>'\u002f'</code> ）开头，那么资源的绝对名称是<code>name</code>之后的<code>'/'</code> 。</span> </li> 
              <li> <span>否则，绝对名称具有以下形式：</span> 
               <blockquote> 
                <span><code>modified_package_name/name</code></span> 
               </blockquote><p> <span>其中<code>modified_package_name</code>是此对象的包名称， <code>'/'</code>替换为<code>'.'</code> （ <code>'\u002e'</code> ）。</span> </p></li> 
             </ul> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>name</code> - 所需资源的名称 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <span>A <a href="../io/InputStream.html" title="java.io中的类"><code>InputStream</code></a>对象;</span> 
              <span><code>null</code>如果未找到具有此名称的资源，则资源位于至少为调用方模块的<a href="Module.html#isOpen(java.lang.String,java.lang.Module)">open</a>的程序包中，或者安全管理器拒绝对该资源的访问。</span> 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
              <code>name</code>是 
              <code>null</code> 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.1 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="Module.html#getResourceAsStream(java.lang.String)"><code>Module.getResourceAsStream(String)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getResource(java.lang.String)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getResource</h4> <pre class="methodSignature">public&nbsp;<a href="../net/URL.html" title="class in java.net">URL</a>&nbsp;getResource​(<a href="String.html" title="class in java.lang">String</a>&nbsp;name)</pre> 
            <div class="block"> 
             <span>查找具有给定名称的资源。</span> 
             <p> <span>如果此类位于命名的<a href="Module.html" title="java.lang中的类"><code>模块</code>中，</a>则此方法将尝试在模块中查找资源。</span> <span>这是通过委托模块的类加载器<a href="ClassLoader.html#findResource(java.lang.String,java.lang.String)"><code>findResource(String,String)</code></a>方法完成的，使用模块名称和资源的绝对名称调用它。</span> <span>命名模块中的资源受<code>模块</code> <a href="Module.html#getResourceAsStream(java.lang.String)"><code>getResourceAsStream</code></a>方法中指定的封装规则的<code>模块</code> ，因此当资源是未对调用方模块打开的包中的非“ <code>.class</code> ”资源时，此方法返回<code>null</code> 。</span> </p> 
             <p> <span>否则，如果此类不在命名模块中，则用于搜索与给定类关联的资源的规则由类的定义<a href="ClassLoader.html" title="java.lang中的类">class loader</a>实现。</span> <span>此方法委托给该对象的类加载器。</span> <span>如果此对象由引导类加载器加载，则该方法委托给<a href="ClassLoader.html#getSystemResource(java.lang.String)"><code>ClassLoader.getSystemResource(java.lang.String)</code></a> 。</span> </p> 
             <p> <span>在委派之前，使用此算法从给定资源名称构造绝对资源名称：</span> </p> 
             <ul> 
              <li> <span>如果<code>name</code>以<code>'/'</code> （ <code>'\u002f'</code> ）开头，那么资源的绝对名称是<code>name</code>之后的<code>'/'</code> 。</span> </li> 
              <li> <span>否则，绝对名称具有以下形式：</span> 
               <blockquote> 
                <span><code>modified_package_name/name</code></span> 
               </blockquote><p> <span>其中<code>modified_package_name</code>是此对象的包名称， <code>'/'</code>替换为<code>'.'</code> （ <code>'\u002e'</code> ）。</span> </p></li> 
             </ul> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>name</code> - 所需资源的名称 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <span>A <a href="../net/URL.html" title="java.net中的类"><code>URL</code></a>对象;</span> 
              <span><code>null</code>如果找不到具有此名称的资源，则无法通过URL找到该资源，该资源位于至少为调用方模块的<a href="Module.html#isOpen(java.lang.String,java.lang.Module)">open</a>的包中，或者安全管理器拒绝对该资源的访问。</span> 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
              <code>name</code>是 
              <code>null</code> 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.1 
             </dd> 
            </dl> </li> 
          </ul> <a id="getProtectionDomain()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getProtectionDomain</h4> <pre class="methodSignature">public&nbsp;<a href="../security/ProtectionDomain.html" title="class in java.security">ProtectionDomain</a>&nbsp;getProtectionDomain()</pre> 
            <div class="block"> 
             <span>返回<code>ProtectionDomain</code> 。</span> 
             <span>如果安装了安全管理器，则此方法首先使用<code>RuntimePermission("getProtectionDomain")</code>权限调用安全管理器的<code>checkPermission</code>方法，以确保可以获取<code>ProtectionDomain</code> 。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此类的ProtectionDomain 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理器且其 
              <code>checkPermission</code>方法不允许获取ProtectionDomain。 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.2 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <span><a href="../security/ProtectionDomain.html" title="java.security中的类"><code>ProtectionDomain</code></a> ， <a href="SecurityManager.html#checkPermission(java.security.Permission)"><code>SecurityManager.checkPermission(java.security.Permission)</code></a> ， <a href="RuntimePermission.html" title="java.lang中的类"><code>RuntimePermission</code></a></span> 
             </dd> 
            </dl> </li> 
          </ul> <a id="desiredAssertionStatus()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>desiredAssertionStatus</h4> <pre class="methodSignature">public&nbsp;boolean&nbsp;desiredAssertionStatus()</pre> 
            <div class="block"> 
             <span>如果要在调用此方法时初始化，则返回将分配给此类的断言状态。</span> 
             <span>如果此类已设置其断言状态，则将返回最新的设置;</span> 
             <span>否则，如果任何包默认断言状态属于此类，则返回最具体的相关包默认断言状态的最新设置;</span> 
             <span>否则，如果此类不是系统类（即，它具有类加载器），则返回其类加载器的默认断言状态;</span> 
             <span>否则，返回系统类的默认断言状态。</span> 
             <p> <span>很少有程序员需要这种方法;</span> <span>它是为了JRE本身的利益而提供的。</span> <span>（它允许类在初始化时确定是否应该启用断言。）请注意，此方法不保证返回与指定类关联的（或将要）关联的实际断言状态（或将被初始化。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               指定类的所需断言状态。 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.4 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="ClassLoader.html#setClassAssertionStatus(java.lang.String,boolean)"><code>ClassLoader.setClassAssertionStatus(java.lang.String, boolean)</code></a> ， 
              <a href="ClassLoader.html#setPackageAssertionStatus(java.lang.String,boolean)"><code>ClassLoader.setPackageAssertionStatus(java.lang.String, boolean)</code></a> ， 
              <a href="ClassLoader.html#setDefaultAssertionStatus(boolean)"><code>ClassLoader.setDefaultAssertionStatus(boolean)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="isEnum()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>isEnum</h4> <pre class="methodSignature">public&nbsp;boolean&nbsp;isEnum()</pre> 
            <div class="block">
              当且仅当此类在源代码中声明为枚举时返回true。 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               当且仅当此类在源代码中声明为枚举时才返回true 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.5 
             </dd> 
            </dl> </li> 
          </ul> <a id="getEnumConstants()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getEnumConstants</h4> <pre class="methodSignature">public&nbsp;<a href="Class.html" title="type parameter in Class">T</a>[]&nbsp;getEnumConstants()</pre> 
            <div class="block">
              返回此枚举类的元素，如果此Class对象不表示枚举类型，则返回null。 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               包含由此Class对象按其声明的顺序表示的枚举类的值的数组，如果此Class对象不表示枚举类型，则返回null 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.5 
             </dd> 
            </dl> </li> 
          </ul> <a id="cast(java.lang.Object)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>cast</h4> <pre class="methodSignature">public&nbsp;<a href="Class.html" title="type parameter in Class">T</a>&nbsp;cast​(<a href="Object.html" title="class in java.lang">Object</a>&nbsp;obj)</pre> 
            <div class="block">
              将对象 
             <code>类</code>为此 
             <code>类</code>对象表示的类或接口。 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>obj</code> - 要转换的对象 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               转换后的对象，如果obj为null，则返回null 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果对象不为null且不能分配给类型T. 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.5 
             </dd> 
            </dl> </li> 
          </ul> <a id="asSubclass(java.lang.Class)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>asSubclass</h4> <pre class="methodSignature">public&nbsp;&lt;U&gt;&nbsp;<a href="Class.html" title="class in java.lang">类</a>&lt;? extends U&gt;&nbsp;asSubclass​(<a href="Class.html" title="class in java.lang">类</a>&lt;U&gt;&nbsp;clazz)</pre> 
            <div class="block"> 
             <span>转换此<code>类</code>对象以表示由指定的类对象表示的类的子类。</span> 
             <span>检查<code>ClassCastException</code>是否有效，如果不是，则抛出<code>ClassCastException</code> 。</span> 
             <span>如果此方法成功，则它始终返回对此类对象的引用。</span> 
             <p> <span>当客户端需要“缩小” <code>类</code>对象的类型以将其传递给限制其愿意接受的<code>类</code>对象的API时，此方法很有用。</span> <span>强制转换将生成编译时警告，因为无法在运行时检查强制转换的正确性（因为泛型类型是通过擦除实现的）。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>U</code> - 要将此类对象 
              <code>U</code>为的类型 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>clazz</code> - 要将此类对象 
              <code>clazz</code>为的类的类 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               这个 
              <code>类</code>对象， 
              <code>类</code>为表示指定类对象的子类。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果此 
              <code>类</code>对象不表示指定类的子类（此处“子类”包括类本身）。 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.5 
             </dd> 
            </dl> </li> 
          </ul> <a id="getAnnotation(java.lang.Class)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getAnnotation</h4> <pre class="methodSignature">public&nbsp;&lt;A extends <a href="annotation/Annotation.html" title="interface in java.lang.annotation">Annotation</a>&gt;&nbsp;A&nbsp;getAnnotation​(<a href="Class.html" title="class in java.lang">类</a>&lt;A&gt;&nbsp;annotationClass)</pre> 
            <div class="block"> 
             <span class="descfrmTypeLabel">从界面复制的说明： <code><a href="reflect/AnnotatedElement.html#getAnnotation(java.lang.Class)">AnnotatedElement</a></code></span> 
            </div> 
            <div class="block">
              返回该元素的，如果这样的注释 
             <em>，</em>否则返回null指定类型的注释。 
            </div> 
            <dl> 
             <dt> 
              <span class="overrideSpecifyLabel">Specified by:</span> 
             </dt> 
             <dd> 
              <code><a href="reflect/AnnotatedElement.html#getAnnotation(java.lang.Class)">getAnnotation</a></code>在接口 
              <code><a href="reflect/AnnotatedElement.html" title="interface in java.lang.reflect">AnnotatedElement</a></code> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>A</code> - 要查询的注释的类型，如果存在则返回 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>annotationClass</code> - 与注释类型对应的Class对象 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               如果此元素上存在指定注释类型，则此元素的注释，否则为null 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果给定的注释类为null 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.5 
             </dd> 
            </dl> </li> 
          </ul> <a id="isAnnotationPresent(java.lang.Class)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>isAnnotationPresent</h4> <pre class="methodSignature">public&nbsp;boolean&nbsp;isAnnotationPresent​(<a href="Class.html" title="class in java.lang">类</a>&lt;? extends <a href="annotation/Annotation.html" title="interface in java.lang.annotation">Annotation</a>&gt;&nbsp;annotationClass)</pre> 
            <div class="block"> 
             <span>如果此元素上<em>存在</em>指定类型的注释，则返回true，否则返回false。</span> 
             <span>此方法主要用于方便地访问标记注释。</span> 
             <p> <span>此方法返回的真值等价于： <code>getAnnotation(annotationClass) != null</code></span> </p> 
             <p> <span>默认方法的主体被指定为上面的代码。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="overrideSpecifyLabel">Specified by:</span> 
             </dt> 
             <dd> 
              <code><a href="reflect/AnnotatedElement.html#isAnnotationPresent(java.lang.Class)">isAnnotationPresent</a></code>在接口 
              <code><a href="reflect/AnnotatedElement.html" title="interface in java.lang.reflect">AnnotatedElement</a></code> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>annotationClass</code> - 与注释类型对应的Class对象 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               如果此元素上存在指定注释类型的注释，则返回true，否则返回false 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果给定的注释类为null 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.5 
             </dd> 
            </dl> </li> 
          </ul> <a id="getAnnotationsByType(java.lang.Class)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getAnnotationsByType</h4> <pre class="methodSignature">public&nbsp;&lt;A extends <a href="annotation/Annotation.html" title="interface in java.lang.annotation">Annotation</a>&gt;&nbsp;A[]&nbsp;getAnnotationsByType​(<a href="Class.html" title="class in java.lang">类</a>&lt;A&gt;&nbsp;annotationClass)</pre> 
            <div class="block"> 
             <span class="descfrmTypeLabel">从界面复制的说明： <code><a href="reflect/AnnotatedElement.html#getAnnotationsByType(java.lang.Class)">AnnotatedElement</a></code></span> 
            </div> 
            <div class="block"> 
             <span>返回与此元素<em>关联的</em>注释。</span> 
             <span>如果没有与此元素<em>关联的</em>注释，则返回值是长度为0的数组。此方法与<a href="reflect/AnnotatedElement.html#getAnnotation(java.lang.Class)"><code>AnnotatedElement.getAnnotation(Class)</code></a>之间的区别在于此方法检测其参数是否为<em>可重复注释类型</em> （JLS 9.6），如果是，则尝试通过“查看”容器注释来查找该类型的一个或多个注释。</span> 
             <span>此方法的调用者可以自由修改返回的数组;</span> 
             <span>它对返回给其他调用者的数组没有影响。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="overrideSpecifyLabel">Specified by:</span> 
             </dt> 
             <dd> 
              <code><a href="reflect/AnnotatedElement.html#getAnnotationsByType(java.lang.Class)">getAnnotationsByType</a></code>在接口 
              <code><a href="reflect/AnnotatedElement.html" title="interface in java.lang.reflect">AnnotatedElement</a></code> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>A</code> - 要查询的注释的类型，如果存在则返回 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>annotationClass</code> - 与注释类型对应的Class对象 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               如果与此元素关联，则指定注释类型的所有此元素的注释，否则为长度为零的数组 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果给定的注释类为null 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.8 
             </dd> 
            </dl> </li> 
          </ul> <a id="getAnnotations()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getAnnotations</h4> <pre class="methodSignature">public&nbsp;<a href="annotation/Annotation.html" title="interface in java.lang.annotation">Annotation</a>[]&nbsp;getAnnotations()</pre> 
            <div class="block"> 
             <span class="descfrmTypeLabel">从界面复制的说明： <code><a href="reflect/AnnotatedElement.html#getAnnotations()">AnnotatedElement</a></code></span> 
            </div> 
            <div class="block"> 
             <span>返回此元素上<em>存在的</em>注释。</span> 
             <span>如果没有<em>存在</em>于此元素上注解，返回值是长度为0这种方法的调用者可以随意修改返回的数组的数组;</span> 
             <span>它对返回给其他调用者的数组没有影响。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="overrideSpecifyLabel">Specified by:</span> 
             </dt> 
             <dd> 
              <code><a href="reflect/AnnotatedElement.html#getAnnotations()">getAnnotations</a></code> ，界面 
              <code><a href="reflect/AnnotatedElement.html" title="interface in java.lang.reflect">AnnotatedElement</a></code> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此元素上的注释 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.5 
             </dd> 
            </dl> </li> 
          </ul> <a id="getDeclaredAnnotation(java.lang.Class)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getDeclaredAnnotation</h4> <pre class="methodSignature">public&nbsp;&lt;A extends <a href="annotation/Annotation.html" title="interface in java.lang.annotation">Annotation</a>&gt;&nbsp;A&nbsp;getDeclaredAnnotation​(<a href="Class.html" title="class in java.lang">类</a>&lt;A&gt;&nbsp;annotationClass)</pre> 
            <div class="block"> 
             <span class="descfrmTypeLabel">从界面复制的说明： <code><a href="reflect/AnnotatedElement.html#getDeclaredAnnotation(java.lang.Class)">AnnotatedElement</a></code></span> 
            </div> 
            <div class="block"> 
             <span>如果<em>直接存在</em>这样的注释，则返回指定类型的此元素的注释，否则返回null。</span> 
             <span>此方法忽略继承的注释。</span> 
             <span>（如果此元素上没有直接出现注释，则返回null。）</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="overrideSpecifyLabel">Specified by:</span> 
             </dt> 
             <dd> 
              <code><a href="reflect/AnnotatedElement.html#getDeclaredAnnotation(java.lang.Class)">getDeclaredAnnotation</a></code>在界面 
              <code><a href="reflect/AnnotatedElement.html" title="interface in java.lang.reflect">AnnotatedElement</a></code> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>A</code> - 要查询的注释的类型，如果直接存在则返回 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>annotationClass</code> - 与注释类型对应的Class对象 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               如果直接出现在此元素上，则此元素的指定注释类型的注释，否则为null 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果给定的注释类为null 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.8 
             </dd> 
            </dl> </li> 
          </ul> <a id="getDeclaredAnnotationsByType(java.lang.Class)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getDeclaredAnnotationsByType</h4> <pre class="methodSignature">public&nbsp;&lt;A extends <a href="annotation/Annotation.html" title="interface in java.lang.annotation">Annotation</a>&gt;&nbsp;A[]&nbsp;getDeclaredAnnotationsByType​(<a href="Class.html" title="class in java.lang">类</a>&lt;A&gt;&nbsp;annotationClass)</pre> 
            <div class="block"> 
             <span class="descfrmTypeLabel">从界面复制的说明： <code><a href="reflect/AnnotatedElement.html#getDeclaredAnnotationsByType(java.lang.Class)">AnnotatedElement</a></code></span> 
            </div> 
            <div class="block"> 
             <span>如果此类注释<em>直接存在</em>或<em>间接存在</em> ，则返回指定类型的此元素的注释。</span> 
             <span>此方法忽略继承的注释。</span> 
             <span>如果此元素上没有直接或间接存在的指定注释，则返回值为长度为0的数组。此方法与<a href="reflect/AnnotatedElement.html#getDeclaredAnnotation(java.lang.Class)"><code>AnnotatedElement.getDeclaredAnnotation(Class)</code></a>之间的区别在于此方法检测其参数是否为<em>可重复注释类型</em> （JLS 9.6），并且如果是，则尝试通过“查看”容器注释（例如，如果存在）来查找该类型的一个或多个注释。</span> 
             <span>此方法的调用者可以自由修改返回的数组;</span> 
             <span>它对返回给其他调用者的数组没有影响。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="overrideSpecifyLabel">Specified by:</span> 
             </dt> 
             <dd> 
              <code><a href="reflect/AnnotatedElement.html#getDeclaredAnnotationsByType(java.lang.Class)">getDeclaredAnnotationsByType</a></code>在界面 
              <code><a href="reflect/AnnotatedElement.html" title="interface in java.lang.reflect">AnnotatedElement</a></code> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>A</code> - 要查询的注释的类型，如果直接或间接存在则返回 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>annotationClass</code> - 与注释类型对应的Class对象 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               如果直接或间接出现在此元素上，则指定注释类型的所有此元素的注释，否则为长度为零的数组 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果给定的注释类为null 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.8 
             </dd> 
            </dl> </li> 
          </ul> <a id="getDeclaredAnnotations()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getDeclaredAnnotations</h4> <pre class="methodSignature">public&nbsp;<a href="annotation/Annotation.html" title="interface in java.lang.annotation">Annotation</a>[]&nbsp;getDeclaredAnnotations()</pre> 
            <div class="block"> 
             <span class="descfrmTypeLabel">从界面复制的说明： <code><a href="reflect/AnnotatedElement.html#getDeclaredAnnotations()">AnnotatedElement</a></code></span> 
            </div> 
            <div class="block"> 
             <span>返回<em>直接出现</em>在此元素上的注释。</span> 
             <span>此方法忽略继承的注释。</span> 
             <span>如果此元素上没有<em>直接存在</em>注释，则返回值为长度为0的数组。此方法的调用者可以自由修改返回的数组;</span> 
             <span>它对返回给其他调用者的数组没有影响。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="overrideSpecifyLabel">Specified by:</span> 
             </dt> 
             <dd> 
              <code><a href="reflect/AnnotatedElement.html#getDeclaredAnnotations()">getDeclaredAnnotations</a></code>在接口 
              <code><a href="reflect/AnnotatedElement.html" title="interface in java.lang.reflect">AnnotatedElement</a></code> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               注释直接出现在此元素上 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.5 
             </dd> 
            </dl> </li> 
          </ul> <a id="getAnnotatedSuperclass()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getAnnotatedSuperclass</h4> <pre class="methodSignature">public&nbsp;<a href="reflect/AnnotatedType.html" title="interface in java.lang.reflect">AnnotatedType</a>&nbsp;getAnnotatedSuperclass()</pre> 
            <div class="block"> 
             <span>返回一个<code>AnnotatedType</code>对象，该对象表示使用类型来指定此<code>类</code>对象所表示的实体的超类。</span> 
             <span>（ <em>使用</em>类型Foo来指定'... extends Foo'中的超类与Foo类型的<em>声明</em>不同。）</span> 
             <p> <span>如果此<code>类</code>对象表示其声明未明确指示带注释的超类的类型，则返回值是表示没有注释的元素的<code>AnnotatedType</code>对象。</span> </p> 
             <p> <span>如果此<code>类</code>表示<code>Object</code>类，接口类型，数组类型，基元类型或void，则返回值为<code>null</code> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               表示超类的对象 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.8 
             </dd> 
            </dl> </li> 
          </ul> <a id="getAnnotatedInterfaces()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getAnnotatedInterfaces</h4> <pre class="methodSignature">public&nbsp;<a href="reflect/AnnotatedType.html" title="interface in java.lang.reflect">AnnotatedType</a>[]&nbsp;getAnnotatedInterfaces()</pre> 
            <div class="block"> 
             <span>返回<code>AnnotatedType</code>对象的数组， <code>AnnotatedType</code>对象表示使用类型来指定此<code>类</code>对象所表示的实体的超<code>类</code> 。</span> 
             <span>（ <em>使用</em>类型Foo在'... implements Foo'中指定超接口与Foo类型的<em>声明</em>不同。）</span> 
             <p> <span>如果此<code>类</code>对象表示类，则返回值是一个数组，其中包含表示接口类型用于指定类实现的接口的对象。</span> <span>数组中对象的顺序对应于此<code>类</code>对象的声明的“implements”子句中使用的接口类型的顺序。</span> </p> 
             <p> <span>如果此<code>类</code>对象表示接口，则返回值是一个数组，其中包含表示接口类型用途的对象，以指定由接口直接扩展的接口。</span> <span>数组中对象的顺序对应于此<code>类</code>对象的声明的“extends”子句中使用的接口类型的顺序。</span> </p> 
             <p> <span>如果此<code>类</code>对象表示其声明未明确指示任何带注释的超接口的类或接口，则返回值为长度为0的数组。</span> </p> 
             <p> <span>如果此<code>类</code>对象表示<code>Object</code>类，数组类型，基本类型或void，则返回值是长度为0的数组。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               表示超接口的数组 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.8 
             </dd> 
            </dl> </li> 
          </ul> <a id="getNestHost()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getNestHost</h4> <pre class="methodSignature">public&nbsp;<a href="Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;getNestHost()</pre> 
            <div class="block"> 
             <span>返回此<code>类</code>对象所代表的类或接口所属的<a href="#nest">nest</a>的嵌套主机。</span> 
             <span>每个类和接口都是一个嵌套的成员。</span> 
             <span>未记录为属于嵌套的类或接口属于仅由其自身组成的嵌套，并且是嵌套主机。</span> 
             <p> <span>表示数组类型，基元类型和<code>void</code>的<code>类</code>对象中的每一个返回<code>this</code>以指示所表示的实体属于仅<code>this</code>自身组成的嵌套，并且是嵌套主机。</span> </p> 
             <p> <span>如果存在访问嵌套主机的<a href="LinkageError.html" title="java.lang中的类">linkage error</a> ，或者嵌套主机未将此类或接口枚举为嵌套成员，则认为它属于自己的嵌套，并且<code>this</code>作为主机返回。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>版本55.0或更高版本的<code>class</code>可以使用<code>NestHost</code>属性（JVMS 4.7.28）记录它所属的嵌套的主机。</span> 
              <span>或者，版本55.0或更高版本的<code>class</code>文件可以通过使用<code>NestMembers</code>属性（JVMS 4.7.29）枚举嵌套的其他成员来充当嵌套主机。</span> 
              <span>版本54.0或更低版本的<code>class</code>文件不使用这些属性。</span> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此类或接口的嵌套主机 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果返回的类不是当前类，并且存在安全管理器 
              <i>s</i> ，并且调用者的类加载器与返回类的类加载器不同或是祖先，并且调用 
              <a href="SecurityManager.html#checkPackageAccess(java.lang.String)"><code>s.checkPackageAccess()</code></a>拒绝访问返回类的包 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               11 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">See <cite>The Java™ Virtual Machine Specification</cite>:</span> 
             </dt> 
             <dd>
               4.7.28和4.7.29 NestHost和NestMembers属性，5.4.4访问控制 
             </dd> 
            </dl> </li> 
          </ul> <a id="isNestmateOf(java.lang.Class)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>isNestmateOf</h4> <pre class="methodSignature">public&nbsp;boolean&nbsp;isNestmateOf​(<a href="Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;c)</pre> 
            <div class="block"> 
             <span>确定给定的<code>类</code>是否是此<code>类</code>对象所表示的类或接口的<code>类</code> 。</span> 
             <span>如果两个类或接口具有相同的<a href="#getNestHost()">nest host，</a>则它们是<a href="#getNestHost()">嵌套的</a> 。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>c</code> - 要检查的类 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <span><code>true</code>如果此类和<code>c</code>是同一个嵌套的成员;</span> 
              <span>和<code>false</code> 。</span> 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               11 
             </dd> 
            </dl> </li> 
          </ul> <a id="getNestMembers()"> 
           <!--   --> </a> 
          <ul class="blockListLast"> 
           <li class="blockList"> <h4>getNestMembers</h4> <pre class="methodSignature">public&nbsp;<a href="Class.html" title="class in java.lang">类</a>&lt;?&gt;[]&nbsp;getNestMembers()</pre> 
            <div class="block"> 
             <span>返回一个数组，其中包含<code>类</code>对象，这些对象表示作为此<code>类</code>对象所表示的类或接口所属的嵌套成员的所有类和接口。</span> 
             <span>该嵌套的<a href="#getNestHost()">nest host</a>是数组的第0个元素。</span> 
             <span>后续元素表示由嵌套主机记录为嵌套成员的任何类或接口;</span> 
             <span>这些元素的顺序是未指定的。</span> 
             <span>允许重复。</span> 
             <span>如果该嵌套的嵌套主机未枚举任何成员，则该数组具有包含<code>this</code>的单个元素。</span> 
             <p> <span>表示数组类型，基元类型和<code>void</code>每个<code>类</code>对象<code>void</code>返回仅包含<code>this</code>的数组。</span> </p> 
             <p> <span>此方法验证，对于由嵌套主机记录为嵌套成员的每个类或接口，该类或接口将自身记录为同一嵌套的成员。</span> <span>此验证期间发生的任何异常都会被此方法重新抛出。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               与此类位于同一个嵌套中的所有类和接口的数组 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="LinkageError.html" title="class in java.lang">LinkageError</a></code> - 如果加载或验证嵌套成员或其嵌套主机有任何问题 
             </dd> 
             <dd> 
              <code><a href="SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果任何返回的类不是当前类，并且存在安全管理器 
              <i>s</i> ，并且调用者的类加载器与该返回类的类加载器不同或是其祖先，并且调用 
              <a href="SecurityManager.html#checkPackageAccess(java.lang.String)"><code>s.checkPackageAccess()</code></a>拒绝访问返回类的包 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               11 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#getNestHost()"><code>getNestHost()</code></a> 
             </dd> 
            </dl> </li> 
          </ul> </li> 
        </ul> 
       </section> </li> 
     </ul> 
    </div> 
   </div> 
  </main> 
  <!-- ========= END OF CLASS DATA ========= --> 
  <footer role="contentinfo"> 
   <nav role="navigation"> 
    <!-- ======= START OF BOTTOM NAVBAR ====== --> 
    <div class="bottomNav"> 
     <a id="navbar.bottom"> 
      <!--   --> </a> 
     <div class="skipNav"> 
      <a href="#skip.navbar.bottom" title="Skip navigation links">跳过导航</a> 
     </div> 
     <a id="navbar.bottom.firstrow"> 
      <!--   --> </a> 
     <ul class="navList" title="Navigation"> 
      <li><a href="../../../index.html">概述</a></li> 
      <li><a href="../../module-summary.html">模块</a></li> 
      <li><a href="package-summary.html">软件包</a></li> 
      <li class="navBarCell1Rev">类</li> 
      <li><a href="class-use/Class.html">使用</a></li> 
      <li><a href="package-tree.html">树</a></li> 
      <li><a href="../../../deprecated-list.html">已过时的</a></li> 
      <li><a href="../../../index-files/index-1.html">索引</a></li> 
      <li><a href="../../../help-doc.html">帮助</a></li> 
     </ul> 
     <div class="aboutLanguage"> 
      <div style="margin-top: 14px;"> 
       <strong>Java SE 11 &amp; JDK 11</strong> 
      </div> 
     </div> 
    </div> 
    <div class="subNav"> 
     <ul class="navList" id="allclasses_navbar_bottom"> 
      <li><a href="../../../allclasses.html">所有类</a></li> 
     </ul> 
     <div> 
      <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
      <noscript> 
       <div>
         JavaScript is disabled on your browser. 
       </div> 
      </noscript> 
     </div> 
     <div> 
      <ul class="subNavList"> 
       <li>概要：&nbsp;</li> 
       <li>嵌套&nbsp;|&nbsp;</li> 
       <li>字段&nbsp;|&nbsp;</li> 
       <li>构造方法&nbsp;|&nbsp;</li> 
       <li><a href="#method.summary">方法</a></li> 
      </ul> 
      <ul class="subNavList"> 
       <li>详细信息：&nbsp;</li> 
       <li>字段&nbsp;|&nbsp;</li> 
       <li>构造方法&nbsp;|&nbsp;</li> 
       <li><a href="#method.detail">方法</a></li> 
      </ul> 
     </div> 
     <a id="skip.navbar.bottom"> 
      <!--   --> </a> 
    </div> 
    <!-- ======== END OF BOTTOM NAVBAR ======= --> 
   </nav> 
   <p class="legalCopy"><small><a href="http://bugreport.java.com/bugreport/">Report a bug or suggest an enhancement</a><br> For further API reference and developer documentation see the <a href="http://www.oracle.com/pls/topic/lookup?ctx=javase11.0.1&amp;id=homepage" target="_blank">Java SE Documentation</a>, which contains more detailed, developer-targeted descriptions with conceptual overviews, definitions of terms, workarounds, and working code examples.<br> Java is a trademark or registered trademark of Oracle and/or its affiliates in the US and other countries.<br> <a href="../../../../legal/copyright.html">Copyright</a> © 1993, 2018, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.<br>All rights reserved. Use is subject to <a href="http://www.oracle.com/technetwork/java/javase/terms/license/java11.0.1speclicense.html">license terms</a> and the <a href="http://www.oracle.com/technetwork/java/redist-137594.html">documentation redistribution policy</a>. 
     <!-- Version 11.0.1+13-LTS --></small></p> 
  </footer>  
 </body>
</html>