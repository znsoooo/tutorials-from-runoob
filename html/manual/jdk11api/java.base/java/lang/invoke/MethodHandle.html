<!doctype html>
<!-- NewPage -->
<html lang="en">
 <head> 
  <!-- Generated by javadoc --> 
  <title>MethodHandle</title> 
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> 
  <meta name="keywords" content="java.lang.invoke.MethodHandle class"> 
  <meta name="keywords" content="type()"> 
  <meta name="keywords" content="invokeExact()"> 
  <meta name="keywords" content="invoke()"> 
  <meta name="keywords" content="invokeWithArguments()"> 
  <meta name="keywords" content="asType()"> 
  <meta name="keywords" content="asSpreader()"> 
  <meta name="keywords" content="withVarargs()"> 
  <meta name="keywords" content="asCollector()"> 
  <meta name="keywords" content="asVarargsCollector()"> 
  <meta name="keywords" content="isVarargsCollector()"> 
  <meta name="keywords" content="asFixedArity()"> 
  <meta name="keywords" content="bindTo()"> 
  <meta name="keywords" content="toString()"> 
  <link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style"> 
  <link rel="stylesheet" type="text/css" href="../../../../jquery/jquery-ui.css" title="Style"> 
  <script type="text/javascript" src="../../../../script.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jszip/dist/jszip.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script> 
  <!--[if IE]>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]--> 
  <script type="text/javascript" src="../../../../jquery/jquery-1.10.2.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jquery-migrate-1.2.1.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jquery-ui.js"></script> 
 </head> 
 <body> <SCRIPT LANGUAGE="JavaScript"><!-- Hide  
   function ResumeError() {     return true;}window.onerror = ResumeError;// --></SCRIPT>
  <script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="MethodHandle (Java SE 11 & JDK 11 )";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script> 
  <noscript> 
   <div>
     JavaScript is disabled on your browser. 
   </div> 
  </noscript> 
  <header role="banner"> 
   <nav role="navigation"> 
    <div class="fixedNav"> 
     <!-- ========= START OF TOP NAVBAR ======= --> 
     <div class="topNav"> 
      <a id="navbar.top"> 
       <!--   --> </a> 
      <div class="skipNav"> 
       <a href="#skip.navbar.top" title="Skip navigation links">跳过导航</a> 
      </div> 
      <a id="navbar.top.firstrow"> 
       <!--   --> </a> 
      <ul class="navList" title="Navigation"> 
       <li><a href="../../../../index.html">概述</a></li> 
       <li><a href="../../../module-summary.html">模块</a></li> 
       <li><a href="package-summary.html">软件包</a></li> 
       <li class="navBarCell1Rev">类</li> 
       <li><a href="class-use/MethodHandle.html">使用</a></li> 
       <li><a href="package-tree.html">树</a></li> 
       <li><a href="../../../../deprecated-list.html">已过时的</a></li> 
       <li><a href="../../../../index-files/index-1.html">索引</a></li> 
       <li><a href="../../../../help-doc.html">帮助</a></li> 
      </ul> 
      <div class="aboutLanguage"> 
       <div style="margin-top: 14px;"> 
        <strong>Java SE 11 &amp; JDK 11</strong> 
       </div> 
      </div> 
     </div> 
     <div class="subNav"> 
      <ul class="navList" id="allclasses_navbar_top"> 
       <li><a href="../../../../allclasses.html">所有类</a></li> 
      </ul> 
      <ul class="navListSearch"> 
       <li><label for="search">SEARCH:</label> <input type="text" id="search" value="search" disabled> <input type="reset" id="reset" value="reset" disabled> </li> 
      </ul> 
      <div> 
       <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
       <noscript> 
        <div>
          JavaScript is disabled on your browser. 
        </div> 
       </noscript> 
      </div> 
       <div class="fixedNav">
       <ul class="subNavList"> 
        <li>概要：&nbsp;</li> 
        <li>嵌套&nbsp;|&nbsp;</li> 
        <li>字段&nbsp;|&nbsp;</li> 
        <li>构造方法&nbsp;|&nbsp;</li> 
        <li><a href="#method.summary">方法</a></li> 
       </ul> 
       <ul class="subNavList"> 
        <li>详细信息：&nbsp;</li> 
        <li>字段&nbsp;|&nbsp;</li> 
        <li>构造方法&nbsp;|&nbsp;</li> 
        <li><a href="#method.detail">方法</a></li> 
       </ul> 
      </div> 
      <a id="skip.navbar.top"> 
       <!--   --> </a> 
     </div> 
     <!-- ========= END OF TOP NAVBAR ========= --> 
    </div> 
    <div class="navPadding">
      &nbsp; 
    </div> 
    <script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script> 
   </nav> 
  </header> 
  <!-- ======== START OF CLASS DATA ======== --> 
  <main role="main"> 
   <div class="header"> 
    <div class="subTitle"> 
     <span class="moduleLabelInType">模块</span>&nbsp; 
     <a href="../../../module-summary.html">java.base</a> 
    </div> 
    <div class="subTitle"> 
     <span class="packageLabelInType">软件包</span>&nbsp; 
     <a href="package-summary.html">java.lang.invoke</a> 
    </div> 
    <h2 title="Class MethodHandle" class="title">Class MethodHandle</h2> 
   </div> 
   <div class="contentContainer"> 
    <ul class="inheritance"> 
     <li><a href="../Object.html" title="class in java.lang">java.lang.Object</a></li> 
     <li> 
      <ul class="inheritance"> 
       <li>java.lang.invoke.MethodHandle</li> 
      </ul> </li> 
    </ul> 
    <div class="description"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <hr> <pre>public abstract class <span class="typeNameLabel">MethodHandle</span>
extends <a href="../Object.html" title="class in java.lang">Object</a></pre> 
       <div class="block"> 
        <span>方法句柄是对基础方法，构造函数，字段或类似的低级操作的类型化，直接可执行的引用，具有可选的参数或返回值转换。</span> 
        <span>这些转换是相当普遍的，并且包括这样的模式为<a href="#asType(java.lang.invoke.MethodType)">conversion</a> ， <a href="#bindTo(java.lang.Object)">insertion</a> ， <a href="MethodHandles.html#dropArguments(java.lang.invoke.MethodHandle,int,java.util.List)">deletion</a>和<a href="MethodHandles.html#filterArguments(java.lang.invoke.MethodHandle,int,java.lang.invoke.MethodHandle...)">substitution</a> 。</span> 
        <h1> <span>方法处理内容</span> </h1> 
        <span>方法句柄根据其参数和返回类型进行动态和强类型化。</span> 
        <span>它们的名称或其基础方法的定义类没有区分。</span> 
        <span>必须使用与方法句柄自己的<a href="#type()">type descriptor</a>匹配的符号类型描述符来调用方法句柄。</span> 
        <p> <span>每个方法句柄都通过<a href="#type()"><code>type</code></a>访问器报告其类型描述符。</span> <span>此类型描述符是<a href="MethodType.html" title="java.lang.invoke中的类"><code>MethodType</code></a>对象，其结构是一系列类，其中一个是方法的返回类型（如果没有， <code>void.class</code> ）。</span> </p> 
        <p> <span>方法句柄的类型控制它接受的调用类型以及适用于它的变换类型。</span> </p> 
        <p> <span>方法句柄包含一对称为<a href="#invokeExact(java.lang.Object...)"><code>invokeExact</code></a>和<a href="#invoke(java.lang.Object...)"><code>invoke</code></a>的特殊调用方法。</span> <span>两种调用方法都提供对方法句柄的底层方法，构造函数，字段或其他操作的直接访问，这些操作由参数和返回值的转换修改。</span> <span>两个调用者都接受与方法句柄自己的类型完全匹配的调用。</span> <span>简单，不精确的调用者也接受一系列其他呼叫类型。</span> </p> 
        <p> <span>方法句柄是不可变的，没有可见状态。</span> <span>当然，它们可以绑定到表现状态的基础方法或数据。</span> <span>对于Java内存模型，任何方法句柄的行为都好像它的所有（内部）字段都是最终变量。</span> <span>这意味着应用程序可见的任何方法句柄将始终完全形成。</span> <span>即使方法句柄是通过数据争用中的共享变量发布的，也是如此。</span> </p> 
        <p> <span>方法句柄不能由用户子类化。</span> <span>实现可能（或可能不）创建<code>MethodHandle</code>内部子类，这可以通过<a href="../Object.html#getClass()"><code>Object.getClass</code></a>操作看到。</span> <span>程序员不应该从特定类中得出关于方法句柄的结论，因为方法句柄类层次结构（如果有的话）可能会不时地或不同供应商的实现之间发生变化。</span> </p> 
        <h1> <span>方法句柄编译</span> </h1> 
        <span>Java方法调用表达式命名<code>invokeExact</code>或<code>invoke</code>可以从Java源代码调用方法句柄。</span> 
        <span>从源代码的角度来看，这些方法可以接受任何参数，并且它们的结果可以转换为任何返回类型。</span> 
        <span>正式地，这是通过给出调用者方法<code>Object</code>返回类型和变量arity <code>Object</code>参数来实现的，但是它们具有称为<em>签名多态</em>的附加质量，其将这种调用自由直接连接到JVM执行堆栈。</span> 
        <p> <span>与通常的虚拟方法一样，对<code>invokeExact</code>和<code>invoke</code>源级调用将编译为<code>invokevirtual</code>指令。</span> <span>更不寻常的是，编译器必须记录实际的参数类型，并且可能不会对参数执行方法调用转换。</span> <span>相反，它必须根据自己未转换的类型生成将它们压入堆栈的指令。</span> <span>方法句柄对象本身在参数之前被压入堆栈。</span> <span>然后，编译器生成<code>invokevirtual</code>指令，该指令使用描述参数和返回类型的符号类型描述符调用方法句柄。</span> </p> 
        <p> <span>要发出完整的符号类型描述符，编译器还必须确定返回类型。</span> <span>这是基于对方法调用表达式的<code>Object</code> （如果有），或者如果调用是表达式<code>void</code> ，否则为<code>void</code>如果调用是语句）。</span> <span>演员表可能是原始类型（但不是<code>void</code> ）。</span> </p> 
        <p> <span>作为极端情况，未发布的<code>null</code>参数被赋予符号类型描述符<code>java.lang.Void</code> 。</span> <span><code>Void</code>类型的<code>Void</code>是无害的，因为除了null引用之外没有类型<code>Void</code>的引用。</span> </p> 
        <h1> <span>方法句柄调用</span> </h1> 
        <span>第一次执行<code>invokevirtual</code>指令时，它通过符号解析指令中的名称并验证方法调用是静态合法的来链接。</span> 
        <span>这也适用于<code>invokeExact</code>和<code>invoke</code>调用。</span> 
        <span>在这种情况下，将检查编译器发出的符号类型描述符的语法是否正确，并解析它包含的名称。</span> 
        <span>因此，只要符号类型描述符在语法上格式良好并且存在类型，则调用方法句柄的<code>invokevirtual</code>指令将始终链接。</span> 
        <p> <span>在链接之后执行<code>invokevirtual</code> ，JVM首先检查接收方法句柄的类型，以确保它与符号类型描述符匹配。</span> <span>如果类型匹配失败，则意味着调用者正在调用的方法不存在于被调用的单个方法句柄上。</span> </p> 
        <p> <span>在<code>invokeExact</code>的情况下，调用的类型描述符（在解析符号类型名称之后）必须与接收方法句柄的方法类型完全匹配。</span> <span>在普通的，不精确的<code>invoke</code>的情况下，解析的类型描述符必须是接收器的<a href="#asType(java.lang.invoke.MethodType)"><code>asType</code></a>方法的有效参数。</span> <span>因此，普通<code>invoke</code>比<code>invokeExact</code>更<code>invokeExact</code> 。</span> </p> 
        <p> <span>在类型匹配之后，直接调用<code>invokeExact</code>并立即调用方法句柄的底层方法（或其他行为，视情况而定）。</span> </p> 
        <p> <span>如果调用者指定的符号类型描述符与方法句柄自己的类型完全匹配，则对<code>invokeExact</code>的调用与调用<code>invoke</code>工作方式相同。</span> <span>如果存在类型不匹配，则<code>invoke</code>尝试调整接收方法句柄的类型，就好像通过调用<a href="#asType(java.lang.invoke.MethodType)"><code>asType</code>一样</a> ，获取完全可调用的方法句柄<code>M2</code> 。</span> <span>这允许在调用者和被调用者之间进行更强大的方法类型协商。</span> </p> 
        <p> <span>（ <em>注意：</em>调整后的方法句柄<code>M2</code>不能直接观察，因此不需要实现来实现它。）</span> </p> 
        <h1> <span>调用检查</span> </h1> 
        <span>在典型的程序中，方法句柄类型匹配通常会成功。</span> 
        <span>但是，如果地址不匹配时，JVM将抛出一个<a href="WrongMethodTypeException.html" title="java.lang.invoke中的类"><code>WrongMethodTypeException</code></a> ，直接（在的情况下<code>invokeExact</code> ）或间接仿佛被呼叫失败到<code>asType</code> （在的情况下<code>invoke</code> ）。</span> 
        <p> <span>因此，在静态类型的程序中可能显示为链接错误的方法类型不匹配可以在使用方法句柄的程序中显示为动态<code>WrongMethodTypeException</code> 。</span> </p> 
        <p> <span>由于方法类型包含“实时” <code>类</code>对象，因此方法类型匹配会同时考虑类型名称和类加载器。</span> <span>因此，即使在一个类加载器<code>L1</code>创建方法句柄<code>M</code>并在另一个<code>L2</code> ，方法句柄调用也是类型安全的，因为调用者的符号类型描述符（在<code>L2</code>中已解析）与原始被调用方法的符号类型匹配描述符，如<code>L1</code> 。</span> <span>决议<code>L1</code>时发生<code>M</code>被创建，其类型分配，而在分辨率<code>L2</code>当发生<code>invokevirtual</code>指令链接。</span> </p> 
        <p> <span>除了类型描述符检查之外，方法句柄调用其基础方法的能力是不受限制的。</span> <span>如果有权访问该方法的类在非公共方法上形成方法句柄，则任何接收对它的引用的调用者都可以在任何地方使用生成的句柄。</span> </p> 
        <p> <span>与Core Reflection API不同，每次调用反射方法时都会检查访问权限，执行方法句柄访问检查<a href="MethodHandles.Lookup.html#access">when the method handle is created</a> 。</span> <span>在<code>ldc</code> （见下文）的情况下，访问检查作为链接常量方法句柄下的常量池条目的一部分执行。</span> </p> 
        <p> <span>因此，非公共方法或非公共类中的方法的处理通常应该保密。</span> <span>除非从不受信任的代码中使用它们是无害的，否则不应将它们传递给不受信任的代码。</span> </p> 
        <h1> <span>方法句柄创建</span> </h1> 
        <span>Java代码可以创建一个方法句柄，直接访问该代码可访问的任何方法，构造函数或字段。</span> 
        <span>这是通过一个名为<a href="MethodHandles.Lookup.html" title="java.lang.invoke中的类"><code>MethodHandles.Lookup</code></a>的基于功能的反射API <a href="MethodHandles.Lookup.html" title="java.lang.invoke中的类">完成的</a> 。</span> 
        <span>例如，可以从<a href="MethodHandles.Lookup.html#findStatic(java.lang.Class,java.lang.String,java.lang.invoke.MethodType)"><code>Lookup.findStatic</code></a>获得静态方法句柄。</span> 
        <span>还有Core Reflection API对象的转换方法，例如<a href="MethodHandles.Lookup.html#unreflect(java.lang.reflect.Method)"><code>Lookup.unreflect</code></a> 。</span> 
        <p> <span>与类和字符串一样，对应于可访问字段，方法和构造函数的方法句柄也可以直接在类文件的常量池中表示为由<code>ldc</code>字节码加载的<code>ldc</code> 。</span> <span>一种新型的常量存储库项，的<code>CONSTANT_MethodHandle</code> ，直接指的是相关的<code>CONSTANT_Methodref</code> ， <code>CONSTANT_InterfaceMethodref</code> ，或<code>CONSTANT_Fieldref</code>常量存储库项。</span> <span>（有关方法句柄常量的完整详细信息，请参阅Java虚拟机规范的4.4.8和5.4.3.5节。）</span> </p> 
        <p> <span>通过查找或来自方法或构造函数的常量加载生成的方法句柄，其变量arity修饰符位（ <code>0x0080</code> ）具有相应的变量arity，就好像它们是在<a href="#asVarargsCollector(java.lang.Class)"><code>asVarargsCollector</code></a>或<a href="#withVarargs(boolean)"><code>withVarargs</code></a>的帮助下定义的<a href="#withVarargs(boolean)">一样</a> 。</span> </p> 
        <p> <span>方法参考可以指静态或非静态方法。</span> <span>在非静态情况下，方法句柄类型包括显式接收器参数，在任何其他参数之前添加。</span> <span>在方法句柄的类型中，根据最初请求方法的类来键入初始接收器参数。</span> <span>（例如，如果通过<code>ldc</code>获得非静态方法句柄，则接收器的类型是常量池条目中指定的类。）</span> </p> 
        <p> <span>方法句柄常量受相同的链接时访问检查其对应的字节码指令，如果字节码行为会引发此类错误，则<code>ldc</code>指令将抛出相应的链接错误。</span> </p> 
        <p> <span>作为其必然结果，对受保护成员的访问仅限于访问类或其子类之一的接收者，并且访问类必须又是受保护成员的定义类的子类（或包兄弟）。</span> <span>如果方法引用引用当前包之外的类的受保护的非静态方法或字段，则receiver参数将缩小为访问类的类型。</span> </p> 
        <p> <span>当调用虚方法的方法句柄时，始终在接收器中查找该方法（即第一个参数）。</span> </p> 
        <p> <span>还可以创建特定虚拟方法实现的非虚方法句柄。</span> <span>这些不基于接收器类型执行虚拟查找。</span> <span>这样的方法句柄模拟<code>invokespecial</code>指令对同一方法的影响。</span> <span>还可以创建非虚方法句柄，以模拟<code>invokevirtual</code>或<code>invokeinterface</code>指令对私有方法的影响（如果适用）。</span> </p> 
        <h1> <span>用法示例</span> </h1> 
        <span>以下是一些用法示例：</span> 
        <blockquote> 
         <span><pre><code>
Object x, y; String s; int i;
MethodType mt; MethodHandle mh;
MethodHandles.Lookup lookup = MethodHandles.lookup();
// mt is (char,char)String
mt = MethodType.methodType(String.class, char.class, char.class);
mh = lookup.findVirtual(String.class, "replace", mt);
s = (String) mh.invokeExact("daddy",'d','n');
// invokeExact(Ljava/lang/String;CC)Ljava/lang/String;
assertEquals(s, "nanny");
// weakly typed invocation (using MHs.invoke)
s = (String) mh.invokeWithArguments("sappy", 'p', 'v');
assertEquals(s, "savvy");
// mt is (Object[])List
mt = MethodType.methodType(java.util.List.class, Object[].class);
mh = lookup.findStatic(java.util.Arrays.class, "asList", mt);
assert(mh.isVarargsCollector());
x = mh.invoke("one", "two");
// invoke(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;
assertEquals(x, java.util.Arrays.asList("one","two"));
// mt is (Object,Object,Object)Object
mt = MethodType.genericMethodType(3);
mh = mh.asType(mt);
x = mh.invokeExact((Object)1, (Object)2, (Object)3);
// invokeExact(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
assertEquals(x, java.util.Arrays.asList(1,2,3));
// mt is ()int
mt = MethodType.methodType(int.class);
mh = lookup.findVirtual(java.util.List.class, "size", mt);
i = (int) mh.invokeExact(java.util.Arrays.asList(1,2,3));
// invokeExact(Ljava/util/List;)I
assert(i == 3);
mt = MethodType.methodType(void.class, String.class);
mh = lookup.findVirtual(java.io.PrintStream.class, "println", mt);
mh.invokeExact(System.out, "Hello, world.");
// invokeExact(Ljava/io/PrintStream;Ljava/lang/String;)V
 </code></pre></span> 
        </blockquote> 
        <span>上述对<code>invokeExact</code>或plain <code>invoke</code>每个调用<code>invoke</code>生成一个<code>invoke</code>指令，其中符号类型描述符在以下注释中指示。</span> 
        <span>在这些示例中，假设辅助方法<code>assertEquals</code>是对其参数调用<a href="../../util/Objects.html#equals(java.lang.Object,java.lang.Object)"><code>Objects.equals</code></a>的方法，并断言结果为true。</span> 
        <h1> <span>例外</span> </h1> 
        <span>方法<code>invokeExact</code>和<code>invoke</code>被声明为抛出<a href="../Throwable.html" title="java.lang中的类"><code>Throwable</code></a> ，也就是说方法句柄可以抛出的内容没有静态限制。</span> 
        <span>由于JVM不区分已检查和未检查的异常（当然除了它们的类之外），因此将检查的异常归因于方法句柄调用对字节码形状没有特别的影响。</span> 
        <span>但是在Java源代码中，执行方法句柄调用的方法必须显式抛出<code>Throwable</code> ，否则必须在本地捕获所有throwable，重新抛出那些在上下文中合法的东西，并包装那些非法的抛出。</span> 
        <h1> <span><a id="sigpoly"></a>签名多态性</span> </h1> 
        <span><code>invokeExact</code>和plain <code>invoke</code>的异常编译和链接行为由术语<em>签名多态性</em>引用。</span> 
        <span>如Java语言规范中所定义的，签名多态方法是可以使用各种呼叫签名和返回类型操作的方法。</span> 
        <p> <span>在源代码中，无论请求的符号类型描述符如何，都将编译对签名多态方法的调用。</span> <span>像往常一样，Java编译器使用给定的符号类型描述符针对命名方法发出<code>invokevirtual</code>指令。</span> <span>不寻常的部分是符号类型描述符是从实际的参数和返回类型派生的，而不是从方法声明派生的。</span> </p> 
        <p> <span>当JVM处理包含签名多态调用的字节码时，无论其符号类型描述符如何，它都将成功链接任何此类调用。</span> <span>（为了保持类型安全性，JVM将使用适当的动态类型检查来保护此类调用，如其他地方所述。）</span> </p> 
        <p> <span>字节码生成器（包括编译器后端）需要为这些方法发出未转换的符号类型描述符。</span> <span>确定符号链接的工具需要接受这种未转换的描述符，而不报告链接错误。</span> </p> 
        <h1> <span>方法句柄和Core Reflection API之间的互操作</span> </h1> 
        <span>使用<a href="MethodHandles.Lookup.html" title="java.lang.invoke中的类"><code>Lookup</code></a> API中的工厂方法，可以将Core Reflection API对象表示的任何类成员转换为行为等效的方法句柄。</span> 
        <span>例如，可以使用<a href="MethodHandles.Lookup.html#unreflect(java.lang.reflect.Method)"><code>Lookup.unreflect</code></a>将反射<a href="../reflect/Method.html" title="java.lang.reflect中的类"><code>方法</code></a>转换为方法句柄。</span> 
        <span>生成的方法句柄通常提供对底层类成员的更直接和有效的访问。</span> 
        <p> <span>作为特殊情况，当Core Reflection API用于查看<code>invokeExact</code>的签名多态方法<code>invokeExact</code>或plain <code>invoke</code>时，它们看起来像普通的非多态方法。</span> <span>如<a href="../Class.html#getDeclaredMethod(java.lang.String,java.lang.Class...)"><code>Class.getDeclaredMethod</code>所示</a> ，它们的反射外观不受其在此API中的特殊状态的影响。</span> <span>例如， <a href="../reflect/Executable.html#getModifiers()"><code>Method.getModifiers</code></a>将准确报告任何类似声明的方法所需的那些修饰符位，包括<code>native</code>和<code>varargs</code>位。</span> </p> 
        <p> <span>与任何反射方法一样，这些方法（反映时）可以通过<a href="../reflect/Method.html#invoke(java.lang.Object,java.lang.Object...)"><code>java.lang.reflect.Method.invoke</code></a>调用。</span> <span>但是，这种反射调用不会导致方法句柄调用。</span> <span>这样的调用，如果传递了必需的参数（类型为<code>Object[]</code>的单个参数），将忽略该参数并抛出<code>UnsupportedOperationException</code> 。</span> </p> 
        <p> <span>由于<code>invokevirtual</code>指令可以在任何符号类型描述符下本机调用方法句柄，因此该反射视图与通过字节码的这些方法的正常表示冲突。</span> <span>因此，当<code>Class.getDeclaredMethod</code>反思地查看时，这两种本机方法可以仅被视为占位符。</span> </p> 
        <p> <span>要获取特定类型描述符的调用方法，请使用<a href="MethodHandles.html#exactInvoker(java.lang.invoke.MethodType)"><code>MethodHandles.exactInvoker</code></a>或<a href="MethodHandles.html#invoker(java.lang.invoke.MethodType)"><code>MethodHandles.invoker</code></a> 。</span> <span>对于任何指定的类型描述符， <a href="MethodHandles.Lookup.html#findVirtual(java.lang.Class,java.lang.String,java.lang.invoke.MethodType)"><code>Lookup.findVirtual</code></a> API还能够返回一个方法句柄来调用<code>invokeExact</code>或plain <code>invoke</code> 。</span> </p> 
        <h1> <span>方法句柄和Java泛型之间的互操作</span> </h1> 
        <span>可以在使用Java泛型类型声明的方法，构造函数或字段上获取方法句柄。</span> 
        <span>与Core Reflection API一样，方法句柄的类型将从源级别类型的擦除构造。</span> 
        <span>调用方法句柄时，其参数类型或返回值强制类型可以是泛型类型或类型实例。</span> 
        <span>如果发生这种情况，编译器在构造<code>invokevirtual</code>指令的符号类型描述符时将通过其擦除替换这些类型。</span> 
        <p> <span>方法句柄不代表Java参数化（通用）类型的类函数类型，因为类函数类型和参数化Java类型之间存在三种不匹配。</span> </p> 
        <ul> 
         <li> <span>方法类型适用于所有可能的arities，从无参数到最多<a href="MethodHandle.html#maxarity">maximum number</a>的允许参数。</span> <span>泛型不是变量，因此不能代表这一点。</span> </li> 
         <li> <span>方法类型可以指定基本类型的参数，Java泛型类型不能超出范围。</span> </li> 
         <li> <span>方法句柄（组合器）上的高阶函数通常在各种函数类型中是通用的，包括多个元素的函数类型。</span> <span>用Java类型参数表示这种通用性是不可能的。</span> </li> 
        </ul> 
        <h1> <span><a id="maxarity"></a> Arity limits</span> </h1> 
        <span>JVM强加任何类型的所有方法和构造函数，绝对限制为255个堆栈参数。</span> 
        <span>在某些情况下，此限制似乎更具限制性：</span> 
        <ul> 
         <li> <span><code>long</code>或<code>double</code>参数计算（出于arity限制的目的）作为两个参数槽。</span> </li> 
         <li> <span>非静态方法为调用该方法的对象使用额外的参数。</span> </li> 
         <li> <span>构造函数为正在构造的对象使用额外的参数。</span> </li> 
         <li> <span>由于方法句柄<code>invoke</code>方法（或其他签名多态方法）是非虚拟的，因此除了任何非虚拟接收器对象之外，它还会为方法句柄本身消耗额外的参数。</span> </li> 
        </ul> 
        <span>这些限制意味着无法创建某些方法句柄，仅仅因为堆栈参数的JVM限制。</span> 
        <span>例如，如果静态JVM方法只接受255个参数，则无法为其创建方法句柄。</span> 
        <span>尝试使用不可能的方法类型创建方法句柄会导致<a href="../IllegalArgumentException.html" title="java.lang中的类"><code>IllegalArgumentException</code></a> 。</span> 
        <span>特别是，方法句柄的类型不能具有精确最大值为255的arity。</span> 
       </div> 
       <dl> 
        <dt> 
         <span class="simpleTagLabel">从以下版本开始：</span> 
        </dt> 
        <dd>
          1.7 
        </dd> 
        <dt> 
         <span class="seeLabel">另请参见：</span> 
        </dt> 
        <dd> 
         <span><a href="MethodType.html" title="java.lang.invoke中的类"><code>MethodType</code></a> ， <a href="MethodHandles.html" title="java.lang.invoke中的类"><code>MethodHandles</code></a></span> 
        </dd> 
       </dl> </li> 
     </ul> 
    </div> 
    <div class="summary"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <!-- ========== METHOD SUMMARY =========== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="method.summary"> 
           <!--   --> </a> <h3>方法摘要</h3> 
          <table class="memberSummary"> 
           <caption> 
           <span id="t0" class="activeTableTab"><span>所有方法</span><span class="tabEnd">&nbsp;</span>
             <span id="t2" class="tableTab"><span><a href="javascript:show(2);">实例方法</a>  </span></span> 
            <span id="t4" class="tableTab"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd">&nbsp;</span></span> 
           </caption> 
           <tbody> 
            <tr> 
             <th class="colFirst" scope="col">变量和类型</th> 
             <th class="colSecond" scope="col">方法</th> 
             <th class="colLast" scope="col">描述</th> 
            </tr> 
            <tr id="i0" class="altColor"> 
             <td class="colFirst"><code><a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#asCollector(int,java.lang.Class,int)">asCollector</a></span>​(int&nbsp;collectArgPos, <a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;arrayType, int&nbsp;arrayLength)</code></th> 
             <td class="colLast"> 
              <div class="block">
                创建一个 
               <em>数组收集</em>方法句柄，它接受从给定位置开始的给定数量的位置参数，并将它们收集到数组参数中。 
              </div> </td> 
            </tr> 
            <tr id="i1" class="rowColor"> 
             <td class="colFirst"><code><a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#asCollector(java.lang.Class,int)">asCollector</a></span>​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;arrayType, int&nbsp;arrayLength)</code></th> 
             <td class="colLast"> 
              <div class="block">
                创建一个 
               <em>数组收集</em>方法句柄，它接受给定数量的尾随位置参数并将它们收集到数组参数中。 
              </div> </td> 
            </tr> 
            <tr id="i2" class="altColor"> 
             <td class="colFirst"><code><a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#asFixedArity()">asFixedArity</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                创建一个 
               <em>固定的arity</em>方法句柄，该句柄与当前方法句柄等效。 
              </div> </td> 
            </tr> 
            <tr id="i3" class="rowColor"> 
             <td class="colFirst"><code><a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#asSpreader(int,java.lang.Class,int)">asSpreader</a></span>​(int&nbsp;spreadArgPos, <a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;arrayType, int&nbsp;arrayLength)</code></th> 
             <td class="colLast"> 
              <div class="block">
                创建一个 
               <em>数组传播</em>方法句柄，它接受给定位置的数组参数，并将其元素作为位置参数传播，代替数组。 
              </div> </td> 
            </tr> 
            <tr id="i4" class="altColor"> 
             <td class="colFirst"><code><a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#asSpreader(java.lang.Class,int)">asSpreader</a></span>​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;arrayType, int&nbsp;arrayLength)</code></th> 
             <td class="colLast"> 
              <div class="block">
                创建一个 
               <em>数组传播</em>方法句柄，它接受一个尾随数组参数并将其元素作为位置参数传播。 
              </div> </td> 
            </tr> 
            <tr id="i5" class="rowColor"> 
             <td class="colFirst"><code><a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#asType(java.lang.invoke.MethodType)">asType</a></span>​(<a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;newType)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成适配器方法句柄，该句柄将当前方法句柄的类型调整为新类型。 
              </div> </td> 
            </tr> 
            <tr id="i6" class="altColor"> 
             <td class="colFirst"><code><a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#asVarargsCollector(java.lang.Class)">asVarargsCollector</a></span>​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;arrayType)</code></th> 
             <td class="colLast"> 
              <div class="block">
                使 
               <em>变量arity</em>适配器能够接受任意数量的尾随位置参数并将它们收集到数组参数中。 
              </div> </td> 
            </tr> 
            <tr id="i7" class="rowColor"> 
             <td class="colFirst"><code><a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#bindTo(java.lang.Object)">bindTo</a></span>​(<a href="../Object.html" title="class in java.lang">Object</a>&nbsp;x)</code></th> 
             <td class="colLast"> 
              <div class="block">
                将值 
               <code>x</code>绑定到方法句柄的第一个参数，而不调用它。 
              </div> </td> 
            </tr> 
            <tr id="i8" class="altColor"> 
             <td class="colFirst"><code><a href="../Object.html" title="class in java.lang">Object</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#invoke(java.lang.Object...)">invoke</a></span>​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</code></th> 
             <td class="colLast"> 
              <div class="block">
                调用方法句柄，允许任何调用者类型描述符，并可选择对参数和返回值执行转换。 
              </div> </td> 
            </tr> 
            <tr id="i9" class="rowColor"> 
             <td class="colFirst"><code><a href="../Object.html" title="class in java.lang">Object</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#invokeExact(java.lang.Object...)">invokeExact</a></span>​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</code></th> 
             <td class="colLast"> 
              <div class="block">
                调用方法句柄，允许任何调用者类型描述符，但需要精确的类型匹配。 
              </div> </td> 
            </tr> 
            <tr id="i10" class="altColor"> 
             <td class="colFirst"><code><a href="../Object.html" title="class in java.lang">Object</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#invokeWithArguments(java.lang.Object...)">invokeWithArguments</a></span>​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;arguments)</code></th> 
             <td class="colLast"> 
              <div class="block">
                执行变量arity调用，将给定数组中的参数传递给方法句柄，就好像通过来自调用站点的不精确 
               <a href="#invoke(java.lang.Object...)"><code>invoke</code></a> ，其仅提及类型 
               <code>Object</code> ，并且其实际参数计数是参数数组的长度。 
              </div> </td> 
            </tr> 
            <tr id="i11" class="rowColor"> 
             <td class="colFirst"><code><a href="../Object.html" title="class in java.lang">Object</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#invokeWithArguments(java.util.List)">invokeWithArguments</a></span>​(<a href="../../util/List.html" title="interface in java.util">List</a>&lt;?&gt;&nbsp;arguments)</code></th> 
             <td class="colLast"> 
              <div class="block">
                执行变量arity调用，将给定列表中的参数传递给方法句柄，就好像通过来自调用站点的不精确 
               <a href="#invoke(java.lang.Object...)"><code>invoke</code>一样</a> ，其仅提及类型 
               <code>Object</code> ，并且其实际参数计数是参数列表的长度。 
              </div> </td> 
            </tr> 
            <tr id="i12" class="altColor"> 
             <td class="colFirst"><code>boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isVarargsCollector()">isVarargsCollector</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                确定此方法句柄是否支持 
               <a href="#asVarargsCollector(java.lang.Class)">variable arity</a>调用。 
              </div> </td> 
            </tr> 
            <tr id="i13" class="rowColor"> 
             <td class="colFirst"><code><a href="../String.html" title="class in java.lang">String</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toString()">toString</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回方法句柄的字符串表示形式，从字符串 
               <code>"MethodHandle"</code>开始，以方法句柄类型的字符串表示形式结束。 
              </div> </td> 
            </tr> 
            <tr id="i14" class="altColor"> 
             <td class="colFirst"><code><a href="MethodType.html" title="class in java.lang.invoke">MethodType</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#type()">type</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                报告此方法句柄的类型。 
              </div> </td> 
            </tr> 
            <tr id="i15" class="rowColor"> 
             <td class="colFirst"><code><a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#withVarargs(boolean)">withVarargs</a></span>​(boolean&nbsp;makeVarargs)</code></th> 
             <td class="colLast"> 
              <div class="block">
                如果布尔标志为真，则将此方法句柄调整为 
               <a href="#asVarargsCollector(java.lang.Class)">variable arity</a> ，否则为 
               <a href="#asFixedArity()">fixed arity</a> 。 
              </div> </td> 
            </tr> 
           </tbody> 
          </table> 
          <ul class="blockList"> 
           <li class="blockList"><a id="methods.inherited.from.class.java.lang.Object"> 
             <!--   --> </a> <h3>声明方法的类&nbsp;java.lang.<a href="../Object.html" title="class in java.lang">Object</a></h3> <code><a href="../Object.html#clone()">clone</a>, <a href="../Object.html#equals(java.lang.Object)">equals</a>, <a href="../Object.html#finalize()">finalize</a>, <a href="../Object.html#getClass()">getClass</a>, <a href="../Object.html#hashCode()">hashCode</a>, <a href="../Object.html#notify()">notify</a>, <a href="../Object.html#notifyAll()">notifyAll</a>, <a href="../Object.html#wait()">wait</a>, <a href="../Object.html#wait(long)">wait</a>, <a href="../Object.html#wait(long,int)">wait</a></code></li> 
          </ul> </li> 
        </ul> 
       </section> </li> 
     </ul> 
    </div> 
    <div class="details"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <!-- ============ METHOD DETAIL ========== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="method.detail"> 
           <!--   --> </a> <h3>方法详细信息</h3> <a id="type()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>type</h4> <pre class="methodSignature">public&nbsp;<a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type()</pre> 
            <div class="block"> 
             <span>报告此方法句柄的类型。</span> 
             <span>通过<code>invokeExact</code>对此方法句柄的每次调用<code>invokeExact</code>必须与此类型完全匹配。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               方法句柄类型 
             </dd> 
            </dl> </li> 
          </ul> <a id="invokeExact(java.lang.Object...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>invokeExact</h4> <pre class="methodSignature">public final&nbsp;<a href="../Object.html" title="class in java.lang">Object</a>&nbsp;invokeExact​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)
                         throws <a href="../Throwable.html" title="class in java.lang">Throwable</a></pre> 
            <div class="block"> 
             <span>调用方法句柄，允许任何调用者类型描述符，但需要精确的类型匹配。</span> 
             <span>调用站点<code>invokeExact</code>处的符号类型描述符必须与此方法句柄<a href="#type()"><code>type</code></a>完全匹配。</span> 
             <span>参数或返回值不允许转换。</span> 
             <p> <span>当通过Core Reflection API观察到此方法时，它将显示为单个本机方法，获取对象数组并返回对象。</span> <span>如果直接通过<a href="../reflect/Method.html#invoke(java.lang.Object,java.lang.Object...)"><code>java.lang.reflect.Method.invoke</code></a> ，通过JNI或间接通过<a href="MethodHandles.Lookup.html#unreflect(java.lang.reflect.Method)"><code>Lookup.unreflect</code></a>调用此本机方法，则会抛出<code>UnsupportedOperationException</code> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>args</code> - 签名多态参数列表，使用varargs静态表示 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               签名 - 多态结果，使用 
              <code>Object</code>静态表示 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果目标的类型与调用者的符号类型描述符不同 
             </dd> 
             <dd> 
              <code><a href="../Throwable.html" title="class in java.lang">Throwable</a></code> - 底层方法抛出的任何内容都会通过方法句柄调用继续传播 
             </dd> 
            </dl> </li> 
          </ul> <a id="invoke(java.lang.Object...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>invoke</h4> <pre class="methodSignature">public final&nbsp;<a href="../Object.html" title="class in java.lang">Object</a>&nbsp;invoke​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)
                    throws <a href="../Throwable.html" title="class in java.lang">Throwable</a></pre> 
            <div class="block"> 
             <span>调用方法句柄，允许任何调用者类型描述符，并可选择对参数和返回值执行转换。</span> 
             <p> <span>如果调用站点的符号类型描述符与此方法句柄<a href="#type()"><code>type</code></a>完全匹配，则调用将按照<a href="#invokeExact(java.lang.Object...)"><code>invokeExact</code>进行</a> 。</span> </p> 
             <p> <span>否则，调用继续进行，好像首先通过调用<a href="#asType(java.lang.invoke.MethodType)"><code>asType</code></a>调整此方法句柄以将该方法句柄调整为所需类型，然后调用如同<a href="#invokeExact(java.lang.Object...)"><code>invokeExact</code>一样</a>在调整后的方法句柄上进行。</span> </p> 
             <p> <span>无法保证实际发出<code>asType</code>电话。</span> <span>如果JVM可以预测调用的结果，它可以直接对调用者的参数执行调整，并根据自己的确切类型调用目标方法句柄。</span> </p> 
             <p> <span>呼叫站点<code>invoke</code>处的已解析类型描述符必须是接收器<code>asType</code>方法的有效参数。</span> <span>特别是，如果被调用者不是<a href="#asVarargsCollector(java.lang.Class)">variable arity collector</a> ，则调用者必须指定与被调用者类型相同的参数arity。</span> </p> 
             <p> <span>当通过Core Reflection API观察到此方法时，它将显示为单个本机方法，获取对象数组并返回对象。</span> <span>如果直接通过<a href="../reflect/Method.html#invoke(java.lang.Object,java.lang.Object...)"><code>java.lang.reflect.Method.invoke</code></a> ，通过JNI或间接通过<a href="MethodHandles.Lookup.html#unreflect(java.lang.reflect.Method)"><code>Lookup.unreflect</code></a>调用此本机方法，则会抛出<code>UnsupportedOperationException</code> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>args</code> - 签名多态参数列表，使用varargs静态表示 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               签名 - 多态结果，使用 
              <code>Object</code>静态表示 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果无法将目标的类型调整为调用者的符号类型描述符 
             </dd> 
             <dd> 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果可以将目标的类型调整为调用者，但引用 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code>失败 
             </dd> 
             <dd> 
              <code><a href="../Throwable.html" title="class in java.lang">Throwable</a></code> - 底层方法抛出的任何内容都会通过方法句柄调用继续传播 
             </dd> 
            </dl> </li> 
          </ul> <a id="invokeWithArguments(java.lang.Object...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>invokeWithArguments</h4> <pre class="methodSignature">public&nbsp;<a href="../Object.html" title="class in java.lang">Object</a>&nbsp;invokeWithArguments​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;arguments)
                           throws <a href="../Throwable.html" title="class in java.lang">Throwable</a></pre> 
            <div class="block"> 
             <span>执行变量arity调用，将给定数组中的参数传递给方法句柄，就好像通过来自调用站点的不精确<a href="#invoke(java.lang.Object...)"><code>invoke</code></a> ，其仅提及类型<code>Object</code> ，并且其实际参数计数是参数数组的长度。</span> 
             <p> <span>具体而言，执行就像通过以下步骤一样进行，尽管如果JVM可以预测它们的影响，则不能保证调用这些方法。</span> </p> 
             <ul> 
              <li> <span>确定参数数组的长度为<code>N</code> 。</span> <span>对于空引用， <code>N=0</code> 。</span> </li> 
              <li> <span>将数组的<code>N</code>元素收集为逻辑参数列表，每个参数静态类型为<code>Object</code> 。</span> </li> 
              <li> <span>确定，作为<code>M</code> ，此方法句柄的类型的参数计数。</span> </li> 
              <li> <span>确定<code>N</code>参数的一般类型<code>TN</code>或<code>M</code>参数（如果小于<code>N</code> ，如<code>TN=MethodType.genericMethodType(Math.min(N, M))</code> 。</span> </li> 
              <li> <span>如果<code>N</code>大于<code>M</code> ，请执行以下检查和操作以缩短逻辑参数列表：</span> 
               <ul> 
                <li> <span>检查此方法句柄是否具有变量arity，其中<a href="MethodType.html#lastParameterType()">trailing parameter</a>是某种数组类型<code>A[]</code> 。</span> <span>如果没有，请使用<code>WrongMethodTypeException</code> 。</span> </li> 
                <li> <span>收集后缘元件（有<code>N-M+1</code>他们的）从逻辑参数列表成型的单个阵列<code>A[]</code> ，使用<code>asType</code>转换到每个后参数输入转换<code>A</code> 。</span> </li> 
                <li> <span>如果任何这些转换的证明是不可能的，会失败，无论是<code>ClassCastException</code>如果任何尾随元件不能被转换为<code>A</code>或<code>NullPointerException</code>如果任何尾随元件是<code>null</code>和<code>A</code>是不是引用类型。</span> </li> 
                <li> <span>将收集到<code>A[]</code>类型数组中的逻辑参数替换为数组本身，从而将参数列表缩短为长度<code>M</code> 。</span> <span>此最终参数保留静态类型<code>A[]</code> 。</span> </li> 
                <li> <span>调节型<code>TN</code>通过改变<code>N</code>个参数类型从<code>Object</code>到<code>A[]</code> 。</span> </li> 
               </ul></li> 
              <li> <span>强制原始目标方法句柄<code>MH0</code>为所需类型，如<code>MH1 = MH0.asType(TN)</code> 。</span> </li> 
              <li> <span>将参数列表传播到<code>N</code>单独的参数<code>A0, ...</code> 。</span> </li> 
              <li> <span>在解压缩的参数上调用类型调整的方法句柄：MH1.invokeExact（A0，...）。</span> </li> 
              <li> <span>将返回值作为<code>Object</code>参考。</span> </li> 
             </ul> 
             <p> <span>如果目标方法句柄具有变量arity，并且参数列表比该arity长，那么从尾随数组参数的位置开始的多余参数将被收集（如果可能，就像通过<code>asType</code>转换一样）到一个数组中适当的类型，调用将在缩短的参数列表上进行。</span> <span>通过这种方式，仍可以统一处理扩展到超过254个时隙的<em>巨型参数列表</em> 。</span> </p> 
             <p> <span>与可以“循环”数组参数的<a href="#invoke(java.lang.Object...)"><code>generic</code></a>调用模式（将其直接传递给目标方法）不同，此调用模式<em>始终</em>会创建一个新的数组参数，即使传递给<code>invokeWithArguments</code>的原始数组可以作为直接参数接受目标方法。</span> <span>即使实际参数的数字<code>M</code>是arity <code>N</code> ，并且最后一个参数动态地是类型<code>A[]</code>的合适数组，它仍将被装箱成新的单元素数组，因为调用站点将参数静态地键入为<code>Object</code> ，不是数组类型。</span> <span>这不是此方法的特殊规则，而是<a href="#asVarargsCollector(java.lang.Class)">rules for variable-arity invocation</a>的常规效果。</span> </p> 
             <p> <span>由于<code>asType</code>步骤的操作，将根据需要应用以下参数转换：</span> </p> 
             <ul> 
              <li> <span>参考铸造</span> </li> 
              <li> <span>拆箱</span> </li> 
              <li> <span>扩大原始转换</span> </li> 
              <li> <span>变量转换</span> </li> 
             </ul> 
             <p> <span>如果调用返回原语，则调用返回的结果为boxed;如果返回类型为void，则强制为null。</span> </p> 
             <p> <span>与签名多态方法<code>invokeExact</code>和<code>invoke</code> ， <code>invokeWithArguments</code>可以通过Core Reflection API和JNI正常访问。</span> <span>因此，它可以用作本机或反射代码和方法句柄之间的桥梁。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>此调用大致相当于以下代码：</span> 
              <blockquote> 
               <span><pre><code>
 // for jumbo argument lists, adapt varargs explicitly:
 int N = (arguments == null? 0: arguments.length);
 int M = this.type.parameterCount();
 int MAX_SAFE = 127;  // 127 longs require 254 slots, which is OK
 if (N &gt; MAX_SAFE &amp;&amp; N &gt; M &amp;&amp; this.isVarargsCollector()) {
   Class&lt;?&gt; arrayType = this.type().lastParameterType();
   Class&lt;?&gt; elemType = arrayType.getComponentType();
   if (elemType != null) {
     Object args2 = Array.newInstance(elemType, M);
     MethodHandle arraySetter = MethodHandles.arrayElementSetter(arrayType);
     for (int i = 0; i &lt; M; i++) {
       arraySetter.invoke(args2, i, arguments[M-1 + i]);
     }
     arguments = Arrays.copyOf(arguments, M);
     arguments[M-1] = args2;
     return this.asFixedArity().invokeWithArguments(arguments);
   }
 } // done with explicit varargs processing

 // Handle fixed arity and non-jumbo variable arity invocation.
 MethodHandle invoker = MethodHandles.spreadInvoker(this.type(), 0);
 Object result = invoker.invokeExact(this, arguments);
 </code></pre></span> 
              </blockquote> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>arguments</code> - 传递给目标的参数 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               目标返回的结果 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果参数转换无法转换参数 
             </dd> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果无法调整目标的类型以获取给定数量的 
              <code>Object</code>参数 
             </dd> 
             <dd> 
              <code><a href="../Throwable.html" title="class in java.lang">Throwable</a></code> - 目标方法调用抛出的任何内容 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="MethodHandles.html#spreadInvoker(java.lang.invoke.MethodType,int)"><code>MethodHandles.spreadInvoker(java.lang.invoke.MethodType, int)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="invokeWithArguments(java.util.List)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>invokeWithArguments</h4> <pre class="methodSignature">public&nbsp;<a href="../Object.html" title="class in java.lang">Object</a>&nbsp;invokeWithArguments​(<a href="../../util/List.html" title="interface in java.util">List</a>&lt;?&gt;&nbsp;arguments)
                           throws <a href="../Throwable.html" title="class in java.lang">Throwable</a></pre> 
            <div class="block"> 
             <span>执行变量arity调用，将给定列表中的参数传递给方法句柄，就好像通过来自调用站点的不精确<a href="#invoke(java.lang.Object...)"><code>invoke</code></a> ，其仅提及类型<code>Object</code> ，并且其实际参数计数是参数列表的长度。</span> 
             <p> <span>此方法也等效于以下代码：</span> </p> 
             <blockquote> 
              <span><pre><code>
   invokeWithArguments(arguments.toArray())
 </code></pre></span> 
             </blockquote> 
             <p> <span>如果此方法句柄具有可变arity，则可以接受巨型大小的列表。</span> <span>有关详细信息，请参见<a href="#invokeWithArguments(java.lang.Object...)"><code>invokeWithArguments(Object[])</code></a> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>arguments</code> - 传递给目标的参数 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               目标返回的结果 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
              <code>arguments</code>是空引用 
             </dd> 
             <dd> 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果参数转换无法转换参数 
             </dd> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果无法调整目标的类型以获取给定数量的 
              <code>Object</code>参数 
             </dd> 
             <dd> 
              <code><a href="../Throwable.html" title="class in java.lang">Throwable</a></code> - 目标方法调用抛出的任何内容 
             </dd> 
            </dl> </li> 
          </ul> <a id="asType(java.lang.invoke.MethodType)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>asType</h4> <pre class="methodSignature">public&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;asType​(<a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;newType)</pre> 
            <div class="block"> 
             <span>生成适配器方法句柄，该句柄将当前方法句柄的类型调整为新类型。</span> 
             <span>保证生成的方法句柄报告一个等于所需新类型的类型。</span> 
             <p> <span>如果原始类型和新类型相等，则返回<code>this</code> 。</span> </p> 
             <p> <span>调用新方法句柄时，将执行以下步骤：</span> </p> 
             <ul> 
              <li> <span>转换传入参数列表以匹配原始方法句柄的参数列表。</span> </li> 
              <li> <span>在已转换的参数列表上调用原始方法句柄。</span> </li> 
              <li> <span>将原始方法句柄返回的任何结果转换为新方法句柄的返回类型。</span> </li> 
             </ul> 
             <p> <span>这种方法提供了<a href="#invokeExact(java.lang.Object...)"><code>invokeExact</code></a>与普通，不精确<a href="#invoke(java.lang.Object...)"><code>invoke</code></a>之间的关键行为差异。</span> <span>当调用者的类型描述符与被调用者完全匹配时，这两个方法执行相同的步骤，但是当类型不同时，普通<a href="#invoke(java.lang.Object...)"><code>invoke</code></a>也调用<code>asType</code> （或一些内部等价物）以匹配调用者和被调用者的类型。</span> </p> 
             <p> <span>如果当前方法是一个变量arity方法，则句柄参数列表转换可能涉及将几个参数转换并收集到一个数组中，如<a href="#asVarargsCollector(java.lang.Class)">described elsewhere</a> 。</span> <span>在所有其他情况下，所有转换都是<em>成对</em>应用的，这意味着每个参数或返回值都只转换为一个参数或返回值（或没有返回值）。</span> <span>应用的转换是通过查询旧方法句柄类型和新方法句柄类型的相应组件类型来定义的。</span> </p> 
             <p> <span>设<em>T0</em>和<em>T1</em>为对应的新旧参数类型，或旧的和新的返回类型。</span> <span>具体而言，对于某些有效索引<code>i</code> ，设<em>T0</em> <code>=newType.parameterType(i)</code>和<em>T1</em> <code>=this.type().parameterType(i)</code> 。</span> <span>或者，以其他方式返回值，让<em>T0</em> <code>=this.type().returnType()</code>和<em>T1</em> <code>=newType.returnType()</code> 。</span> <span>如果类型相同，则新方法句柄不会更改相应的参数或返回值（如果有）。</span> <span>否则，如果可能，将应用以下转换之一：</span> </p> 
             <ul> 
              <li> <span>如果<em>T0</em>和<em>T1</em>是引用，则应用转换为<em>T1</em> 。</span> <span>（这些类型不需要以任何特定方式相关。这是因为null的动态值可以转换为任何引用类型。）</span> </li> 
              <li> <span>如果<em>T0</em>和<em>T1</em>是基元，则应用Java方法调用转换（JLS 5.3）（如果存在）。</span> <span>（具体来说， <em>T0</em>必须通过扩展原语转换转换为<em>T1</em> 。）</span> </li> 
              <li> <span>如果<em>T0</em>是基元并且<em>T1</em>是引用，则应用Java转换（JLS 5.5）（如果存在）。</span> <span>（具体来说，该值从<em>T0加载</em>到其包装类，然后根据需要将其加宽到<em>T1</em> 。）</span> </li> 
              <li> <span>如果<em>T0</em>是引用而<em>T1</em>是原语，则将在运行时应用取消装箱转换，之后可能会对原始值进行Java方法调用转换（JLS 5.3）。</span> <span>（这些是原始的扩展转换。） <em>T0</em>必须是包装类或超类型。</span> <span>（在<em>T0</em>是Object的情况下，这些是<a href="../reflect/Method.html#invoke(java.lang.Object,java.lang.Object...)"><code>java.lang.reflect.Method.invoke</code></a>允许的转换。）取消装箱转换必须有成功的可能性，这意味着如果<em>T0</em>本身不是包装类，则必须存在至少一个包装类<em>TW</em> ，是<em>T0</em>的子类型，其未装箱的原始值可以扩展为<em>T1</em> 。</span> </li> 
              <li> <span>如果返回类型<em>T1</em>标记为void，则丢弃任何返回的值</span> </li> 
              <li> <span>如果返回类型<em>T0</em>为空且<em>T1</em>为引用，则引入空值。</span> </li> 
              <li> <span>如果返回类型<em>T0</em>为空并且<em>T1</em>为基元，则引入零值。</span> </li> 
             </ul> 
             <span>（ <em>注意：</em> <em>T0</em>和<em>T1</em>都可以视为静态类型，因为它们都不是特定于任何实际参数或返回值的<em>动态类型</em> 。）</span> 
             <p> <span>如果无法进行任何一个所需的成对转换，则无法进行方法句柄转换。</span> </p> 
             <p> <span>在运行时，应用于引用参数或返回值的转换可能需要额外的运行时检查，这可能会失败。</span> <span>取消装箱操作可能会失败，因为原始引用为空，从而导致<a href="../NullPointerException.html" title="java.lang中的类"><code>NullPointerException</code></a> 。</span> <span>取消装箱操作或参考演员也可能在对错误类型的对象的引用上失败，从而导致<a href="../ClassCastException.html" title="java.lang中的类"><code>ClassCastException</code></a> 。</span> <span>虽然取消装箱操作可能会接受几种包装，但如果没有，则会抛出<code>ClassCastException</code> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>newType</code> - 新方法句柄的预期类型 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               在执行任何必要的参数转换后委派给 
              <code>this</code>的方法句柄，并安排任何必要的返回值转换 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
              <code>newType</code>是空引用 
             </dd> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果无法进行转换 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="MethodHandles.html#explicitCastArguments(java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)"><code>MethodHandles.explicitCastArguments(java.lang.invoke.MethodHandle, java.lang.invoke.MethodType)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="asSpreader(java.lang.Class,int)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>asSpreader</h4> <pre class="methodSignature">public&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;asSpreader​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;arrayType,
                               int&nbsp;arrayLength)</pre> 
            <div class="block"> 
             <span>创建一个<em>数组传播</em>方法句柄，它接受一个尾随数组参数并将其元素作为位置参数传播。</span> 
             <span>新方法句柄将当前方法句柄作为其<i>目标进行</i>调整。</span> 
             <span>适配器的类型将与目标的类型相同，除了目标类型的最终<code>arrayLength</code>参数被<code>arrayLength</code>类型的单个数组参数<code>arrayType</code> 。</span> 
             <p> <span>如果数组元素类型与原始目标上的任何相应参数类型不同，则原始目标将适合直接获取数组元素，就像调用<a href="#asType(java.lang.invoke.MethodType)"><code>asType</code>一样</a> 。</span> </p> 
             <p> <span>调用时，适配器用数组的元素替换尾随数组参数，每个元素作为目标的自己的参数。</span> <span>（保留参数的顺序。）通过转换和/或取消装箱将它们成对转换为目标的尾随参数的类型。</span> <span>最后调用目标。</span> <span>目标最终返回的内容由适配器返回。</span> </p> 
             <p> <span>在调用目标之前，适配器会验证数组是否包含足够的元素，以便为目标方法句柄提供正确的参数计数。</span> <span>（当需要零元素时，数组也可以为null。）</span> </p> 
             <p> <span>调用适配器时，将查询提供的<code>array</code>参数的长度，如同<code>array.length</code>或<code>arraylength</code>字节码一样。</span> <span>如果适配器接受零长度尾随数组参数，则提供的<code>array</code>参数可以是零长度数组或<code>null</code> ;</span> <span>否则，如果阵列是<code>null</code> ，则适配器将抛出<code>NullPointerException</code>如果阵列没有正确数量的元素，则抛出<a href="../IllegalArgumentException.html" title="java.lang中的类"><code>IllegalArgumentException</code></a> 。</span> </p> 
             <p> <span>以下是数组传播方法句柄的一些简单示例：</span> </p> 
             <blockquote> 
              <span><pre><code>
MethodHandle equals = publicLookup()
  .findVirtual(String.class, "equals", methodType(boolean.class, Object.class));
assert( (boolean) equals.invokeExact("me", (Object)"me"));
assert(!(boolean) equals.invokeExact("me", (Object)"thee"));
// spread both arguments from a 2-array:
MethodHandle eq2 = equals.asSpreader(Object[].class, 2);
assert( (boolean) eq2.invokeExact(new Object[]{ "me", "me" }));
assert(!(boolean) eq2.invokeExact(new Object[]{ "me", "thee" }));
// try to spread from anything but a 2-array:
for (int n = 0; n &lt;= 10; n++) {
  Object[] badArityArgs = (n == 2 ? new Object[0] : new Object[n]);
  try { assert((boolean) eq2.invokeExact(badArityArgs) &amp;&amp; false); }
  catch (IllegalArgumentException ex) { } // OK
}
// spread both arguments from a String array:
MethodHandle eq2s = equals.asSpreader(String[].class, 2);
assert( (boolean) eq2s.invokeExact(new String[]{ "me", "me" }));
assert(!(boolean) eq2s.invokeExact(new String[]{ "me", "thee" }));
// spread second arguments from a 1-array:
MethodHandle eq1 = equals.asSpreader(Object[].class, 1);
assert( (boolean) eq1.invokeExact("me", new Object[]{ "me" }));
assert(!(boolean) eq1.invokeExact("me", new Object[]{ "thee" }));
// spread no arguments from a 0-array or null:
MethodHandle eq0 = equals.asSpreader(Object[].class, 0);
assert( (boolean) eq0.invokeExact("me", (Object)"me", new Object[0]));
assert(!(boolean) eq0.invokeExact("me", (Object)"thee", (Object[])null));
// asSpreader and asCollector are approximate inverses:
for (int n = 0; n &lt;= 2; n++) {
    for (Class&lt;?&gt; a : new Class&lt;?&gt;[]{Object[].class, String[].class, CharSequence[].class}) {
        MethodHandle equals2 = equals.asSpreader(a, n).asCollector(a, n);
        assert( (boolean) equals2.invokeWithArguments("me", "me"));
        assert(!(boolean) equals2.invokeWithArguments("me", "thee"));
    }
}
MethodHandle caToString = publicLookup()
  .findStatic(Arrays.class, "toString", methodType(String.class, char[].class));
assertEquals("[A, B, C]", (String) caToString.invokeExact("ABC".toCharArray()));
MethodHandle caString3 = caToString.asCollector(char[].class, 3);
assertEquals("[A, B, C]", (String) caString3.invokeExact('A', 'B', 'C'));
MethodHandle caToString2 = caString3.asSpreader(char[].class, 2);
assertEquals("[A, B, C]", (String) caToString2.invokeExact('A', "BC".toCharArray()));
 </code></pre></span> 
             </blockquote> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>arrayType</code> - 通常为 
              <code>Object[]</code> ，从中提取扩展参数的数组参数的类型 
             </dd> 
             <dd> 
              <code>arrayLength</code> - 从传入数组参数传播的参数数 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               在调用原始方法句柄之前传递最终数组参数的新方法句柄 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
              <code>arrayType</code>是空引用 
             </dd> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
              <code>arrayType</code>不是数组类型，或者目标不具有至少 
              <code>arrayLength</code>参数类型，或者如果 
              <code>arrayLength</code>为负数，或者结果方法句柄的类型将具有 
              <a href="MethodHandle.html#maxarity">too many parameters</a> 
             </dd> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果隐含的 
              <code>asType</code>呼叫失败 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#asCollector(java.lang.Class,int)"><code>asCollector(java.lang.Class&lt;?&gt;, int)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="asSpreader(int,java.lang.Class,int)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>asSpreader</h4> <pre class="methodSignature">public&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;asSpreader​(int&nbsp;spreadArgPos,
                               <a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;arrayType,
                               int&nbsp;arrayLength)</pre> 
            <div class="block"> 
             <span>创建一个<em>数组传播</em>方法句柄，它接受给定位置的数组参数，并将其元素作为位置参数传播，代替数组。</span> 
             <span>新方法句柄将当前方法句柄作为其<i>目标进行</i>调整。</span> 
             <span>适配器的类型将与目标类型相同，除了从零开始位置<code>spreadArgPos</code>开始的目标类型的<code>arrayLength</code>参数被<code>arrayLength</code>类型的单个数组参数<code>arrayType</code> 。</span> 
             <p> <span>此方法的行为与<a href="#asSpreader(java.lang.Class,int)"><code>asSpreader(Class, int)</code></a>非常相似，但接受另外的<code>spreadArgPos</code>参数以指示参数列表中的哪个位置应进行扩散。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>例：</span> 
              <blockquote> 
               <span><pre><code>
    MethodHandle compare = LOOKUP.findStatic(Objects.class, "compare", methodType(int.class, Object.class, Object.class, Comparator.class));
    MethodHandle compare2FromArray = compare.asSpreader(0, Object[].class, 2);
    Object[] ints = new Object[]{3, 9, 7, 7};
    Comparator&lt;Integer&gt; cmp = (a, b) -&gt; a - b;
    assertTrue((int) compare2FromArray.invoke(Arrays.copyOfRange(ints, 0, 2), cmp) &lt; 0);
    assertTrue((int) compare2FromArray.invoke(Arrays.copyOfRange(ints, 1, 3), cmp) &gt; 0);
    assertTrue((int) compare2FromArray.invoke(Arrays.copyOfRange(ints, 2, 4), cmp) == 0);
 </code></pre></span> 
              </blockquote> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>spreadArgPos</code> - 参数列表中应开始传播的位置（从零开始的索引）。 
             </dd> 
             <dd> 
              <code>arrayType</code> - 通常为 
              <code>Object[]</code> ，从中提取扩展参数的数组参数的类型 
             </dd> 
             <dd> 
              <code>arrayLength</code> - 从传入数组参数传播的参数数 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               在调用原始方法句柄之前，在给定位置传播数组参数的新方法句柄 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
              <code>arrayType</code>是空引用 
             </dd> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
              <code>arrayType</code>不是数组类型，或者目标不具有至少 
              <code>arrayLength</code>参数类型，或者 
              <code>arrayLength</code>为负数，或者 
              <code>spreadArgPos</code>具有非法值（否定，或者与arrayLength一起超过参数数量），或者如果结果方法句柄的类型将具有 
              <a href="MethodHandle.html#maxarity">too many parameters</a> 
             </dd> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果隐含的 
              <code>asType</code>呼叫失败 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#asSpreader(java.lang.Class,int)"><code>asSpreader(Class, int)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="withVarargs(boolean)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>withVarargs</h4> <pre class="methodSignature">public&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;withVarargs​(boolean&nbsp;makeVarargs)</pre> 
            <div class="block"> 
             <span>如果布尔标志为真，则将此方法句柄调整为<a href="#asVarargsCollector(java.lang.Class)">variable arity</a> ，否则为<a href="#asFixedArity()">fixed arity</a> 。</span> 
             <span>如果方法句柄已经是正确的arity模式，则返回不变。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <p> <span>当调整可能是变量arity的方法句柄时，此方法有时很有用，以确保当且仅当原始句柄是时，生成的适配器也是可变arity。</span> <span>例如，此代码将句柄<code>mh</code>的第一个参数更改为<code>int</code>而不会干扰其变量arity属性： <code>mh.asType(mh.type().changeParameterType(0,int.class)) .withVarargs(mh.isVarargsCollector())</code></span> </p> 
              <p> <span>此调用大致相当于以下代码：</span> </p> 
              <blockquote> 
               <span><pre><code>
 if (makeVarargs == isVarargsCollector())
   return this;
 else if (makeVarargs)
   return asVarargsCollector(type().lastParameterType());
 else
   return return asFixedArity();
 </code></pre></span> 
              </blockquote> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>makeVarargs</code> - 如果返回方法句柄应具有可变的arity行为， 
              <code>makeVarargs</code> true 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个相同类型的方法句柄，可能调整了变量arity行为 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
              <code>makeVarargs</code>为true且此方法句柄没有尾随数组参数 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#asVarargsCollector(java.lang.Class)"><code>asVarargsCollector(java.lang.Class&lt;?&gt;)</code></a> ， 
              <a href="#asFixedArity()"><code>asFixedArity()</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="asCollector(java.lang.Class,int)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>asCollector</h4> <pre class="methodSignature">public&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;asCollector​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;arrayType,
                                int&nbsp;arrayLength)</pre> 
            <div class="block"> 
             <span>创建一个<em>数组收集</em>方法句柄，它接受给定数量的尾随位置参数并将它们收集到数组参数中。</span> 
             <span>新方法句柄将当前方法句柄作为其<i>目标进行</i>调整。</span> 
             <span>适配器的类型将与目标的类型相同，除了单个尾随参数（通常为<code>arrayType</code>类型）由<code>arrayLength</code>参数替换，其类型为元素类型<code>arrayType</code> 。</span> 
             <p> <span>如果数组类型与原始目标上的最终参数类型不同，则原始目标将适合直接获取数组类型，就像调用<a href="#asType(java.lang.invoke.MethodType)"><code>asType</code>一样</a> 。</span> </p> 
             <p> <span>当被调用时，该适配器替换其尾随<code>arrayLength</code>由类型的单个新数组参数<code>arrayType</code> ，其元素包括（按顺序）被替换的参数。</span> <span>最后调用目标。</span> <span>目标最终返回的内容由适配器返回。</span> </p> 
             <p> <span>（当<code>arrayLength</code>为零时，该数组也可以是共享常量。）</span> </p> 
             <p> <span>（ <em>注意：</em> <code>arrayType</code>通常与原始目标的<a href="MethodType.html#lastParameterType()">last parameter type</a>相同。它是<code>asSpreader</code>对称性的显式参数，并且还允许目标使用简单的<code>Object</code>作为其最后一个参数类型。）</span> </p> 
             <p> <span>要创建不限于特定数量的已收集参数的收集适配器，请改用<a href="#asVarargsCollector(java.lang.Class)"><code>asVarargsCollector</code></a>或<a href="#withVarargs(boolean)"><code>withVarargs</code></a> 。</span> </p> 
             <p> <span>以下是数组收集方法句柄的一些示例：</span> </p> 
             <blockquote> 
              <span><pre><code>
MethodHandle deepToString = publicLookup()
  .findStatic(Arrays.class, "deepToString", methodType(String.class, Object[].class));
assertEquals("[won]",   (String) deepToString.invokeExact(new Object[]{"won"}));
MethodHandle ts1 = deepToString.asCollector(Object[].class, 1);
assertEquals(methodType(String.class, Object.class), ts1.type());
//assertEquals("[won]", (String) ts1.invokeExact(         new Object[]{"won"})); //FAIL
assertEquals("[[won]]", (String) ts1.invokeExact((Object) new Object[]{"won"}));
// arrayType can be a subtype of Object[]
MethodHandle ts2 = deepToString.asCollector(String[].class, 2);
assertEquals(methodType(String.class, String.class, String.class), ts2.type());
assertEquals("[two, too]", (String) ts2.invokeExact("two", "too"));
MethodHandle ts0 = deepToString.asCollector(Object[].class, 0);
assertEquals("[]", (String) ts0.invokeExact());
// collectors can be nested, Lisp-style
MethodHandle ts22 = deepToString.asCollector(Object[].class, 3).asCollector(String[].class, 2);
assertEquals("[A, B, [C, D]]", ((String) ts22.invokeExact((Object)'A', (Object)"B", "C", "D")));
// arrayType can be any primitive array type
MethodHandle bytesToString = publicLookup()
  .findStatic(Arrays.class, "toString", methodType(String.class, byte[].class))
  .asCollector(byte[].class, 3);
assertEquals("[1, 2, 3]", (String) bytesToString.invokeExact((byte)1, (byte)2, (byte)3));
MethodHandle longsToString = publicLookup()
  .findStatic(Arrays.class, "toString", methodType(String.class, long[].class))
  .asCollector(long[].class, 1);
assertEquals("[123]", (String) longsToString.invokeExact((long)123));
 </code></pre></span> 
             </blockquote> 
             <p> <span><em>注意：</em>生成的适配器永远不会是<a href="#asVarargsCollector(java.lang.Class)">variable-arity method handle</a> ，即使原始目标方法句柄是。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>arrayType</code> - 通常为 
              <code>Object[]</code> ，将收集参数的数组参数的类型 
             </dd> 
             <dd> 
              <code>arrayLength</code> - 要收集到新数组参数中的参数数 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个新的方法句柄，它在调用原始方法句柄之前将一些尾随参数收集到一个数组中 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
              <code>arrayType</code>是空引用 
             </dd> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
              <code>arrayType</code>不是数组类型或 
              <code>arrayType</code>不能分配给此方法句柄的尾随参数类型，或者 
              <code>arrayLength</code>不是合法的数组大小，或者生成的方法句柄的类型将具有 
              <a href="MethodHandle.html#maxarity">too many parameters</a> 
             </dd> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果隐含的 
              <code>asType</code>呼叫失败 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#asSpreader(java.lang.Class,int)"><code>asSpreader(java.lang.Class&lt;?&gt;, int)</code></a> ， 
              <a href="#asVarargsCollector(java.lang.Class)"><code>asVarargsCollector(java.lang.Class&lt;?&gt;)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="asCollector(int,java.lang.Class,int)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>asCollector</h4> <pre class="methodSignature">public&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;asCollector​(int&nbsp;collectArgPos,
                                <a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;arrayType,
                                int&nbsp;arrayLength)</pre> 
            <div class="block"> 
             <span>创建一个<em>数组收集</em>方法句柄，它接受从给定位置开始的给定数量的位置参数，并将它们收集到数组参数中。</span> 
             <span>新方法句柄将当前方法句柄作为其<i>目标进行</i>调整。</span> 
             <span>适配器的类型将与目标的类型相同，除了<code>collectArgPos</code> （通常为<code>arrayType</code>类型）指示的位置处的参数被<code>arrayLength</code>参数替换，其类型为元素类型<code>arrayType</code> 。</span> 
             <p> <span>此方法的行为与<a href="#asCollector(java.lang.Class,int)"><code>asCollector(Class, int)</code></a>非常相似，但不同之处在于其<code>collectArgPos</code>参数指示应在参数列表参数中的哪个位置进行收集。</span> <span>该指数从零开始。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>例子：</span> 
              <blockquote> 
               <span><pre><code>
    StringWriter swr = new StringWriter();
    MethodHandle swWrite = LOOKUP.findVirtual(StringWriter.class, "write", methodType(void.class, char[].class, int.class, int.class)).bindTo(swr);
    MethodHandle swWrite4 = swWrite.asCollector(0, char[].class, 4);
    swWrite4.invoke('A', 'B', 'C', 'D', 1, 2);
    assertEquals("BC", swr.toString());
    swWrite4.invoke('P', 'Q', 'R', 'S', 0, 4);
    assertEquals("BCPQRS", swr.toString());
    swWrite4.invoke('W', 'X', 'Y', 'Z', 3, 1);
    assertEquals("BCPQRSZ", swr.toString());
 </code></pre></span> 
              </blockquote> 
              <p> <span><em>注意：</em>生成的适配器永远不会是<a href="#asVarargsCollector(java.lang.Class)">variable-arity method handle</a> ，即使原始目标方法句柄是。</span> </p> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>collectArgPos</code> - 参数列表中从零开始的位置，开始收集。 
             </dd> 
             <dd> 
              <code>arrayType</code> - 通常为 
              <code>Object[]</code> ，将收集参数的数组参数的类型 
             </dd> 
             <dd> 
              <code>arrayLength</code> - 要收集到新数组参数中的参数数 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个新的方法句柄，它在调用原始方法句柄之前将一些参数收集到一个数组中 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
              <code>arrayType</code>是空引用 
             </dd> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
              <code>arrayType</code>不是数组类型或 
              <code>arrayType</code>不能分配给此方法句柄的数组参数类型，或者 
              <code>arrayLength</code>不是合法的数组大小，或者 
              <code>collectArgPos</code>具有非法值（负数或大于参数数），或者生成的方法句柄的类型将具有 
              <a href="MethodHandle.html#maxarity">too many parameters</a> 
             </dd> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果隐含的 
              <code>asType</code>调用失败 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#asCollector(java.lang.Class,int)"><code>asCollector(Class, int)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="asVarargsCollector(java.lang.Class)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>asVarargsCollector</h4> <pre class="methodSignature">public&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;asVarargsCollector​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;arrayType)</pre> 
            <div class="block"> 
             <span>使<em>变量arity</em>适配器能够接受任意数量的尾随位置参数并将它们收集到数组参数中。</span> 
             <p> <span>适配器的类型和行为将与目标的类型和行为相同，除了某些<code>invoke</code>和<code>asType</code>请求可能导致将尾随位置参数收集到目标的尾随参数中。</span> <span>此外，适配器的<a href="MethodType.html#lastParameterType()">last parameter type</a>将为<code>arrayType</code> ，即使目标具有不同的最后一个参数类型。</span> </p> 
             <p> <span>这种转化可以返回<code>this</code>如果该方法手柄是可变的元数的已和它的尾部参数类型是相同的<code>arrayType</code> 。</span> </p> 
             <p> <span>使用<a href="#invokeExact(java.lang.Object...)"><code>invokeExact</code></a>调用时，适配器将调用目标而不更改参数。</span> <span>（ <em>注意：</em>此行为与<a href="#asCollector(java.lang.Class,int)">fixed arity collector</a>不同，因为它接受整个不确定长度的数组，而不是固定数量的参数。）</span> </p> 
             <p> <span>当使用普通的，不精确的<a href="#invoke(java.lang.Object...)"><code>invoke</code></a>调用时，如果调用者类型与适配器相同，则适配器将像<code>invokeExact</code>一样调用目标。</span> <span>（当类型匹配时，这是<code>invoke</code>的正常行为。）</span> </p> 
             <p> <span>否则，如果调用者和适配器arity相同，并且调用者的尾随参数类型是与适配器的尾随参数类型相同或可分配的引用类型，则参数和返回值<a href="#asType(java.lang.invoke.MethodType)">将成</a>对转换，就像<a href="#asType(java.lang.invoke.MethodType)"><code>asType</code>一样</a>在一个固定的arity方法句柄上。</span> </p> 
             <p> <span>否则，arities会有所不同，或者适配器的尾随参数类型不能从相应的调用者类型中分配。</span> <span>在这种情况下，适配器通过<code>arrayType</code>类型的新数组替换原始尾随参数位置的所有尾随参数，其元素包含（按顺序）替换的参数。</span> </p> 
             <p> <span>调用者类型必须提供足够少的参数和正确的类型，以满足目标对尾随数组参数之前的位置参数的要求。</span> <span>因此，调用者必须至少提供<code>N-1</code>参数，其中<code>N</code>是目标的arity。</span> <span>此外，必须存在从传入参数到目标参数的转换。</span> <span>与普通<code>invoke</code>其他用途<code>invoke</code> ，如果未满足这些基本要求， <code>WrongMethodTypeException</code>可能会抛出<code>WrongMethodTypeException</code> 。</span> </p> 
             <p> <span>在所有情况下，适配器都会返回目标最终返回的内容。</span> </p> 
             <p> <span>在最后一种情况下，就好像目标方法句柄暂时适应了调用者类型所需的arity <a href="#asCollector(java.lang.Class,int)">fixed arity collector</a> 。</span> <span>（与<code>asCollector</code> ，如果数组长度为零，则可以使用共享常量而不是新数组。如果对<code>asCollector</code>的隐含调用将抛出<code>IllegalArgumentException</code>或<code>WrongMethodTypeException</code> ，则对变量arity适配器的调用必须抛出<code>WrongMethodTypeException</code> ）</span> </p> 
             <p> <span>的行为<a href="#asType(java.lang.invoke.MethodType)"><code>asType</code></a>还专门为可变参数数量的适配器，保持不变的是普通的，不精确<code>invoke</code>总是相当于<code>asType</code>呼叫调整目标类型，其次为<code>invokeExact</code> 。</span> <span>因此，当且仅当适配器和请求的类型在arity或trailing参数类型中不同时，变量arity适配器通过构建固定的arity收集器来响应<code>asType</code>请求。</span> <span>得到的固定arity收集器的类型通过成对转换进一步调整（如果需要）到所请求的类型，就像<code>asType</code>的另一个应用程序<code>asType</code> 。</span> </p> 
             <p> <span>当通过执行<code>CONSTANT_MethodHandle</code>常量的<code>ldc</code>指令获得方法句柄，并且目标方法被标记为变量arity方法（使用修饰符位<code>0x0080</code> ）时，方法句柄将接受多个arities，就好像方法句柄常量是通过致电<code>asVarargsCollector</code> 。</span> </p> 
             <p> <span>为了创建收集预定数量的参数的收集适配器，并且其类型反映该预定数量，请改用<a href="#asCollector(java.lang.Class,int)"><code>asCollector</code></a> 。</span> </p> 
             <p> <span>没有方法句柄转换会产生具有变量arity的新方法句柄，除非它们被记录为这样做。</span> <span>因此，除了<code>asVarargsCollector</code>和<code>withVarargs</code> ，在所有方法<code>MethodHandle</code>和<code>MethodHandles</code>将返回一个方法手柄固定元数，除非他们被指定为返回原来的操作数（例如，案件<code>asType</code>的方法手柄自身的类型）。</span> </p> 
             <p> <span>在已经是变量arity的方法句柄上调用<code>asVarargsCollector</code>将生成具有相同类型和行为的方法句柄。</span> <span>它可能（或可能不）返回原始变量arity方法句柄。</span> </p> 
             <p> <span>这是一个列表制作变量arity方法句柄的示例：</span> </p> 
             <blockquote> 
              <span><pre><code>
MethodHandle deepToString = publicLookup()
  .findStatic(Arrays.class, "deepToString", methodType(String.class, Object[].class));
MethodHandle ts1 = deepToString.asVarargsCollector(Object[].class);
assertEquals("[won]",   (String) ts1.invokeExact(    new Object[]{"won"}));
assertEquals("[won]",   (String) ts1.invoke(         new Object[]{"won"}));
assertEquals("[won]",   (String) ts1.invoke(                      "won" ));
assertEquals("[[won]]", (String) ts1.invoke((Object) new Object[]{"won"}));
// findStatic of Arrays.asList(...) produces a variable arity method handle:
MethodHandle asList = publicLookup()
  .findStatic(Arrays.class, "asList", methodType(List.class, Object[].class));
assertEquals(methodType(List.class, Object[].class), asList.type());
assert(asList.isVarargsCollector());
assertEquals("[]", asList.invoke().toString());
assertEquals("[1]", asList.invoke(1).toString());
assertEquals("[two, too]", asList.invoke("two", "too").toString());
String[] argv = { "three", "thee", "tee" };
assertEquals("[three, thee, tee]", asList.invoke(argv).toString());
assertEquals("[three, thee, tee]", asList.invoke((Object[])argv).toString());
List ls = (List) asList.invoke((Object)argv);
assertEquals(1, ls.size());
assertEquals("[three, thee, tee]", Arrays.toString((Object[])ls.get(0)));
 </code></pre></span> 
             </blockquote> 
             <p style="font-size:smaller;"> <span><em>讨论：</em>这些规则被设计为变量arity方法的Java规则的动态类型变体。</span> <span>在这两种情况下，可变arity方法或方法句柄的调用者可以传递零个或多个位置参数，或者传递任何长度的预收集数组。</span> <span>用户应该知道最终参数的特殊作用，以及类型匹配对最终参数的影响，它确定单个尾随参数是否被解释为整个数组或数组的单个元素集。</span> <span>请注意，尾随参数的动态类型对此决定没有影响，只是调用站点的符号类型描述符和方法句柄的类型描述符之间的比较。）</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>arrayType</code> - 通常为 
              <code>Object[]</code> ，将收集参数的数组参数的类型 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个新的方法句柄，它可以在调用原始方法句柄之前将任意数量的尾随参数收集到一个数组中 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
              <code>arrayType</code>是空引用 
             </dd> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
              <code>arrayType</code>不是数组类型或 
              <code>arrayType</code>无法分配给此方法句柄的尾随参数类型 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#asCollector(java.lang.Class,int)"><code>asCollector(java.lang.Class&lt;?&gt;, int)</code></a> ， 
              <a href="#isVarargsCollector()"><code>isVarargsCollector()</code></a> ， 
              <a href="#withVarargs(boolean)"><code>withVarargs(boolean)</code></a> ， 
              <a href="#asFixedArity()"><code>asFixedArity()</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="isVarargsCollector()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>isVarargsCollector</h4> <pre class="methodSignature">public&nbsp;boolean&nbsp;isVarargsCollector()</pre> 
            <div class="block"> 
             <span>确定此方法句柄是否支持<a href="#asVarargsCollector(java.lang.Class)">variable arity</a>调用。</span> 
             <span>此类方法句柄来自以下来源：</span> 
             <ul> 
              <li> <span>致电<a href="#asVarargsCollector(java.lang.Class)">asVarargsCollector</a></span> </li> 
              <li> <span>调用<a href="MethodHandles.Lookup.html" title="java.lang.invoke中的类">lookup method</a> ，它解析为变量arity Java方法或构造函数</span> </li> 
              <li> <span>一个<code>ldc</code>一个的指令<code>CONSTANT_MethodHandle</code>其解析为一个可变参数数量的Java方法或构造</span> </li> 
             </ul> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               如果此方法句柄接受多个简单，不精确的 
              <code>invoke</code>调用，则 
              <code>invoke</code> 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#asVarargsCollector(java.lang.Class)"><code>asVarargsCollector(java.lang.Class&lt;?&gt;)</code></a> ， 
              <a href="#asFixedArity()"><code>asFixedArity()</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="asFixedArity()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>asFixedArity</h4> <pre class="methodSignature">public&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;asFixedArity()</pre> 
            <div class="block"> 
             <span>创建一个<em>固定的arity</em>方法句柄，该句柄与当前方法句柄等效。</span> 
             <p> <span>如果当前方法句柄不是<a href="#asVarargsCollector(java.lang.Class)">variable arity</a> ，则返回当前方法句柄。</span> <span>即使当前方法句柄不能是<code>asVarargsCollector</code>的有效输入， <code>asVarargsCollector</code> 。</span> </p> 
             <p> <span>否则，生成的fixed-arity方法句柄与当前方法句柄具有相同的类型和行为，但<a href="#isVarargsCollector()"><code>isVarargsCollector</code></a>将为false。</span> <span>fixed-arity方法句柄可能（或可能不）是<code>asVarargsCollector</code>的先前参数。</span> </p> 
             <p> <span>这是一个列表制作变量arity方法句柄的示例：</span> </p> 
             <blockquote> 
              <span><pre><code>
MethodHandle asListVar = publicLookup()
  .findStatic(Arrays.class, "asList", methodType(List.class, Object[].class))
  .asVarargsCollector(Object[].class);
MethodHandle asListFix = asListVar.asFixedArity();
assertEquals("[1]", asListVar.invoke(1).toString());
Exception caught = null;
try { asListFix.invoke((Object)1); }
catch (Exception ex) { caught = ex; }
assert(caught instanceof ClassCastException);
assertEquals("[two, too]", asListVar.invoke("two", "too").toString());
try { asListFix.invoke("two", "too"); }
catch (Exception ex) { caught = ex; }
assert(caught instanceof WrongMethodTypeException);
Object[] argv = { "three", "thee", "tee" };
assertEquals("[three, thee, tee]", asListVar.invoke(argv).toString());
assertEquals("[three, thee, tee]", asListFix.invoke(argv).toString());
assertEquals(1, ((List) asListVar.invoke((Object)argv)).size());
assertEquals("[three, thee, tee]", asListFix.invoke((Object)argv).toString());
 </code></pre></span> 
             </blockquote> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个新方法句柄，只接受固定数量的参数 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#asVarargsCollector(java.lang.Class)"><code>asVarargsCollector(java.lang.Class&lt;?&gt;)</code></a> ， 
              <a href="#isVarargsCollector()"><code>isVarargsCollector()</code></a> ， 
              <a href="#withVarargs(boolean)"><code>withVarargs(boolean)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="bindTo(java.lang.Object)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>bindTo</h4> <pre class="methodSignature">public&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;bindTo​(<a href="../Object.html" title="class in java.lang">Object</a>&nbsp;x)</pre> 
            <div class="block"> 
             <span>将值<code>x</code>绑定到方法句柄的第一个参数，而不调用它。</span> 
             <span>新方法句柄通过将当前方法句柄绑定到给定参数来将其作为其<i>目标进行</i>调整。</span> 
             <span>绑定句柄的类型将与目标的类型相同，除了将省略单个前导引用参数。</span> 
             <p> <span>调用时，绑定句柄将给定值<code>x</code>作为目标的新前导参数插入。</span> <span>其他参数也保持不变。</span> <span>目标最终返回的内容由绑定句柄返回。</span> </p> 
             <p> <span>参考<code>x</code>必须可转换为目标的第一个参数类型。</span> </p> 
             <p> <span><em>注意：</em>因为方法句柄是不可变的，所以目标方法句柄保留其原始类型和行为。</span> </p> 
             <p> <span><em>注意：</em>生成的适配器永远不会是<a href="#asVarargsCollector(java.lang.Class)">variable-arity method handle</a> ，即使原始目标方法句柄是。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>x</code> - 要绑定到目标的第一个参数的值 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个新的方法句柄，它在调用原始方法句柄之前将给定值预先添加到传入的参数列表中 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果目标没有作为引用类型的前导参数类型 
             </dd> 
             <dd> 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果 
              <code>x</code>无法转换为目标的前导参数类型 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="MethodHandles.html#insertArguments(java.lang.invoke.MethodHandle,int,java.lang.Object...)"><code>MethodHandles.insertArguments(java.lang.invoke.MethodHandle, int, java.lang.Object...)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="toString()"> 
           <!--   --> </a> 
          <ul class="blockListLast"> 
           <li class="blockList"> <h4>toString</h4> <pre class="methodSignature">public&nbsp;<a href="../String.html" title="class in java.lang">String</a>&nbsp;toString()</pre> 
            <div class="block"> 
             <span>返回方法句柄的字符串表示形式，从字符串<code>"MethodHandle"</code>开始，以方法句柄类型的字符串表示形式结束。</span> 
             <span>换句话说，此方法返回一个等于值的字符串：</span> 
             <blockquote> 
              <span><pre><code>
 "MethodHandle" + type().toString()
 </code></pre></span> 
             </blockquote> 
             <p> <span>（ <em>注意：</em>此API的未来版本可能会向字符串表示添加更多信息。因此，应用程序不应解析当前语法。）</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="overrideSpecifyLabel">重写：</span> 
             </dt> 
             <dd> 
              <code><a href="../Object.html#toString()">toString</a></code>在类 
              <code><a href="../Object.html" title="class in java.lang">Object</a></code> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               方法句柄的字符串表示形式 
             </dd> 
            </dl> </li> 
          </ul> </li> 
        </ul> 
       </section> </li> 
     </ul> 
    </div> 
   </div> 
  </main> 
  <!-- ========= END OF CLASS DATA ========= --> 
  <footer role="contentinfo"> 
   <nav role="navigation"> 
    <!-- ======= START OF BOTTOM NAVBAR ====== --> 
    <div class="bottomNav"> 
     <a id="navbar.bottom"> 
      <!--   --> </a> 
     <div class="skipNav"> 
      <a href="#skip.navbar.bottom" title="Skip navigation links">跳过导航</a> 
     </div> 
     <a id="navbar.bottom.firstrow"> 
      <!--   --> </a> 
     <ul class="navList" title="Navigation"> 
      <li><a href="../../../../index.html">概述</a></li> 
      <li><a href="../../../module-summary.html">模块</a></li> 
      <li><a href="package-summary.html">软件包</a></li> 
      <li class="navBarCell1Rev">类</li> 
      <li><a href="class-use/MethodHandle.html">使用</a></li> 
      <li><a href="package-tree.html">树</a></li> 
      <li><a href="../../../../deprecated-list.html">已过时的</a></li> 
      <li><a href="../../../../index-files/index-1.html">索引</a></li> 
      <li><a href="../../../../help-doc.html">帮助</a></li> 
     </ul> 
     <div class="aboutLanguage"> 
      <div style="margin-top: 14px;"> 
       <strong>Java SE 11 &amp; JDK 11</strong> 
      </div> 
     </div> 
    </div> 
    <div class="subNav"> 
     <ul class="navList" id="allclasses_navbar_bottom"> 
      <li><a href="../../../../allclasses.html">所有类</a></li> 
     </ul> 
     <div> 
      <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
      <noscript> 
       <div>
         JavaScript is disabled on your browser. 
       </div> 
      </noscript> 
     </div> 
     <div> 
      <ul class="subNavList"> 
       <li>概要：&nbsp;</li> 
       <li>嵌套&nbsp;|&nbsp;</li> 
       <li>字段&nbsp;|&nbsp;</li> 
       <li>构造方法&nbsp;|&nbsp;</li> 
       <li><a href="#method.summary">方法</a></li> 
      </ul> 
      <ul class="subNavList"> 
       <li>详细信息：&nbsp;</li> 
       <li>字段&nbsp;|&nbsp;</li> 
       <li>构造方法&nbsp;|&nbsp;</li> 
       <li><a href="#method.detail">方法</a></li> 
      </ul> 
     </div> 
     <a id="skip.navbar.bottom"> 
      <!--   --> </a> 
    </div> 
    <!-- ======== END OF BOTTOM NAVBAR ======= --> 
   </nav> 
   <p class="legalCopy"><small><a href="http://bugreport.java.com/bugreport/">Report a bug or suggest an enhancement</a><br> For further API reference and developer documentation see the <a href="http://www.oracle.com/pls/topic/lookup?ctx=javase11.0.1&amp;id=homepage" target="_blank">Java SE Documentation</a>, which contains more detailed, developer-targeted descriptions with conceptual overviews, definitions of terms, workarounds, and working code examples.<br> Java is a trademark or registered trademark of Oracle and/or its affiliates in the US and other countries.<br> <a href="../../../../../legal/copyright.html">Copyright</a> © 1993, 2018, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.<br>All rights reserved. Use is subject to <a href="http://www.oracle.com/technetwork/java/javase/terms/license/java11.0.1speclicense.html">license terms</a> and the <a href="http://www.oracle.com/technetwork/java/redist-137594.html">documentation redistribution policy</a>. 
     <!-- Version 11.0.1+13-LTS --></small></p> 
  </footer>  
 </body>
</html>