<!doctype html>
<!-- NewPage -->
<html lang="en">
 <head> 
  <!-- Generated by javadoc --> 
  <title>VarHandle</title> 
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> 
  <meta name="keywords" content="java.lang.invoke.VarHandle class"> 
  <meta name="keywords" content="get()"> 
  <meta name="keywords" content="set()"> 
  <meta name="keywords" content="getVolatile()"> 
  <meta name="keywords" content="setVolatile()"> 
  <meta name="keywords" content="getOpaque()"> 
  <meta name="keywords" content="setOpaque()"> 
  <meta name="keywords" content="getAcquire()"> 
  <meta name="keywords" content="setRelease()"> 
  <meta name="keywords" content="compareAndSet()"> 
  <meta name="keywords" content="compareAndExchange()"> 
  <meta name="keywords" content="compareAndExchangeAcquire()"> 
  <meta name="keywords" content="compareAndExchangeRelease()"> 
  <meta name="keywords" content="weakCompareAndSetPlain()"> 
  <meta name="keywords" content="weakCompareAndSet()"> 
  <meta name="keywords" content="weakCompareAndSetAcquire()"> 
  <meta name="keywords" content="weakCompareAndSetRelease()"> 
  <meta name="keywords" content="getAndSet()"> 
  <meta name="keywords" content="getAndSetAcquire()"> 
  <meta name="keywords" content="getAndSetRelease()"> 
  <meta name="keywords" content="getAndAdd()"> 
  <meta name="keywords" content="getAndAddAcquire()"> 
  <meta name="keywords" content="getAndAddRelease()"> 
  <meta name="keywords" content="getAndBitwiseOr()"> 
  <meta name="keywords" content="getAndBitwiseOrAcquire()"> 
  <meta name="keywords" content="getAndBitwiseOrRelease()"> 
  <meta name="keywords" content="getAndBitwiseAnd()"> 
  <meta name="keywords" content="getAndBitwiseAndAcquire()"> 
  <meta name="keywords" content="getAndBitwiseAndRelease()"> 
  <meta name="keywords" content="getAndBitwiseXor()"> 
  <meta name="keywords" content="getAndBitwiseXorAcquire()"> 
  <meta name="keywords" content="getAndBitwiseXorRelease()"> 
  <meta name="keywords" content="varType()"> 
  <meta name="keywords" content="coordinateTypes()"> 
  <meta name="keywords" content="accessModeType()"> 
  <meta name="keywords" content="isAccessModeSupported()"> 
  <meta name="keywords" content="toMethodHandle()"> 
  <meta name="keywords" content="fullFence()"> 
  <meta name="keywords" content="acquireFence()"> 
  <meta name="keywords" content="releaseFence()"> 
  <meta name="keywords" content="loadLoadFence()"> 
  <meta name="keywords" content="storeStoreFence()"> 
  <link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style"> 
  <link rel="stylesheet" type="text/css" href="../../../../jquery/jquery-ui.css" title="Style"> 
  <script type="text/javascript" src="../../../../script.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jszip/dist/jszip.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script> 
  <!--[if IE]>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]--> 
  <script type="text/javascript" src="../../../../jquery/jquery-1.10.2.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jquery-migrate-1.2.1.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jquery-ui.js"></script> 
 </head> 
 <body> <SCRIPT LANGUAGE="JavaScript"><!-- Hide  
   function ResumeError() {     return true;}window.onerror = ResumeError;// --></SCRIPT>
  <script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="VarHandle (Java SE 11 & JDK 11 )";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":10,"i1":9,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":9,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10,"i24":10,"i25":10,"i26":10,"i27":10,"i28":9,"i29":9,"i30":10,"i31":10,"i32":10,"i33":10,"i34":9,"i35":10,"i36":10,"i37":10,"i38":10,"i39":10,"i40":10};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script> 
  <noscript> 
   <div>
     JavaScript is disabled on your browser. 
   </div> 
  </noscript> 
  <header role="banner"> 
   <nav role="navigation"> 
    <div class="fixedNav"> 
     <!-- ========= START OF TOP NAVBAR ======= --> 
     <div class="topNav"> 
      <a id="navbar.top"> 
       <!--   --> </a> 
      <div class="skipNav"> 
       <a href="#skip.navbar.top" title="Skip navigation links">跳过导航</a> 
      </div> 
      <a id="navbar.top.firstrow"> 
       <!--   --> </a> 
      <ul class="navList" title="Navigation"> 
       <li><a href="../../../../index.html">概述</a></li> 
       <li><a href="../../../module-summary.html">模块</a></li> 
       <li><a href="package-summary.html">软件包</a></li> 
       <li class="navBarCell1Rev">类</li> 
       <li><a href="class-use/VarHandle.html">使用</a></li> 
       <li><a href="package-tree.html">树</a></li> 
       <li><a href="../../../../deprecated-list.html">已过时的</a></li> 
       <li><a href="../../../../index-files/index-1.html">索引</a></li> 
       <li><a href="../../../../help-doc.html">帮助</a></li> 
      </ul> 
      <div class="aboutLanguage"> 
       <div style="margin-top: 14px;"> 
        <strong>Java SE 11 &amp; JDK 11</strong> 
       </div> 
      </div> 
     </div> 
     <div class="subNav"> 
      <ul class="navList" id="allclasses_navbar_top"> 
       <li><a href="../../../../allclasses.html">所有类</a></li> 
      </ul> 
      <ul class="navListSearch"> 
       <li><label for="search">SEARCH:</label> <input type="text" id="search" value="search" disabled> <input type="reset" id="reset" value="reset" disabled> </li> 
      </ul> 
      <div> 
       <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
       <noscript> 
        <div>
          JavaScript is disabled on your browser. 
        </div> 
       </noscript> 
      </div> 
       <div class="fixedNav">
       <ul class="subNavList"> 
        <li>概要：&nbsp;</li> 
        <li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li> 
        <li>字段&nbsp;|&nbsp;</li> 
        <li>构造方法&nbsp;|&nbsp;</li> 
        <li><a href="#method.summary">方法</a></li> 
       </ul> 
       <ul class="subNavList"> 
        <li>详细信息：&nbsp;</li> 
        <li>字段&nbsp;|&nbsp;</li> 
        <li>构造方法&nbsp;|&nbsp;</li> 
        <li><a href="#method.detail">方法</a></li> 
       </ul> 
      </div> 
      <a id="skip.navbar.top"> 
       <!--   --> </a> 
     </div> 
     <!-- ========= END OF TOP NAVBAR ========= --> 
    </div> 
    <div class="navPadding">
      &nbsp; 
    </div> 
    <script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script> 
   </nav> 
  </header> 
  <!-- ======== START OF CLASS DATA ======== --> 
  <main role="main"> 
   <div class="header"> 
    <div class="subTitle"> 
     <span class="moduleLabelInType">模块</span>&nbsp; 
     <a href="../../../module-summary.html">java.base</a> 
    </div> 
    <div class="subTitle"> 
     <span class="packageLabelInType">软件包</span>&nbsp; 
     <a href="package-summary.html">java.lang.invoke</a> 
    </div> 
    <h2 title="Class VarHandle" class="title">Class VarHandle</h2> 
   </div> 
   <div class="contentContainer"> 
    <ul class="inheritance"> 
     <li><a href="../Object.html" title="class in java.lang">java.lang.Object</a></li> 
     <li> 
      <ul class="inheritance"> 
       <li>java.lang.invoke.VarHandle</li> 
      </ul> </li> 
    </ul> 
    <div class="description"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <hr> <pre>public abstract class <span class="typeNameLabel">VarHandle</span>
extends <a href="../Object.html" title="class in java.lang">Object</a></pre> 
       <div class="block"> 
        <span>VarHandle是对变量或参数定义的变量系列的动态强类型引用，包括静态字段，非静态字段，数组元素或堆外数据结构的组件。</span> 
        <span>在各种<em>访问模式</em>下都支持访问这些变量，包括普通读/写访问，易失性读/写访问以及比较和设置。</span> 
        <p> <span>VarHandles是不可变的，没有可见状态。</span> <span>VarHandles不能被用户子类化。</span> </p> 
        <p> <span>VarHandle有：</span> </p> 
        <ul> 
         <li> <span>a <a href="#varType()"><code>variable type</code></a> T，此VarHandle引用的每个变量的类型;</span> <span>和</span> </li> 
         <li> <span><a href="#coordinateTypes()"><code>coordinate types</code></a> <code>CT1, CT2, ..., CTn</code>的列表，共同定位此VarHandle引用的变量的<em>坐标表达式</em>的类型。</span> </li> 
        </ul> 
        <span>变量和坐标类型可以是原始类型或引用类型，并由<code>类</code>对象表示。</span> 
        <span>坐标类型列表可以为空。</span> 
        <p> <span>生成的工厂方法或<a href="MethodHandles.Lookup.html" title="java.lang.invoke中的类"><code>lookup</code></a> VarHandle实例记录了支持的变量类型和坐标类型列表。</span> </p> 
        <p> <span>每种访问模式与一种<em>访问模式方法</em>相关联，该方法是以访问模式命名的<a href="MethodHandle.html#sigpoly">signature polymorphic</a>方法。</span> <span>当在VarHandle实例上调用访问模式方法时，调用的初始参数是坐标表达式，它们精确地指示要访问变量的对象。</span> <span>调用的尾随参数表示访问模式的重要值。</span> <span>例如，各种比较和设置或比较和交换访问模式需要两个尾随参数用于变量的预期值和新值。</span> </p> 
        <p> <span>不会静态检查调用访问模式方法的arity和参数类型。</span> <span>取而代之的是，每个接入模式的方法指定了一个<a href="#accessModeType(java.lang.invoke.VarHandle.AccessMode)"><code>access mode type</code></a> ，表示为的实例<a href="MethodType.html" title="java.lang.invoke中的类"><code>MethodType</code></a> ，即作为一种方法签名针对其参数是动态检查。</span> <span>访问模式类型根据VarHandle实例的坐标类型和访问模式的重要值类型给出形式参数类型。</span> <span>访问模式类型也提供返回类型，通常根据VarHandle实例的变量类型。</span> <span>在VarHandle实例上调用访问模式方法时，调用站点上的符号类型描述符，调用的参数的运行时类型以及返回值的运行时类型，必须是<a href="#invoke">match</a>访问模式中给出的类型类型。</span> <span>如果匹配失败，将抛出运行时异常。</span> <span>例如，访问模式方法<a href="#compareAndSet(java.lang.Object...)"><code>compareAndSet(java.lang.Object...)</code></a>指定如果其接收器是具有坐标类型<code>CT1, ..., CTn</code>和变量类型<code>T</code>的VarHandle实例，则其访问模式类型是<code>(CT1 c1, ..., CTn cn, T expectedValue, T newValue)boolean</code> 。</span> <span>假设VarHandle实例可以访问数组元素，并且其坐标类型为<code>String[]</code>和<code>int</code>而其变量类型为<code>String</code> 。</span> <span>对于接入模式类型<code>compareAndSet</code>这个VarHandle实例是<code>(String[] c1, int c2, String expectedValue, String newValue)boolean</code> 。</span> <span>这样的VarHandle实例可以由<a href="MethodHandles.html#arrayElementVarHandle(java.lang.Class)"><code>array factory method</code></a>和访问数组元素产生，如下所示：</span> </p> 
        <pre>  <span><code> String[] sa = ... VarHandle avh = MethodHandles.arrayElementVarHandle(String[].class); boolean r = avh.compareAndSet(sa, 10, "expected", "new"); </code></span> </pre> 
        <p> <span>访问模式控制原子性和一致性属性。</span> <span><em>普通</em>读取（ <code>get</code> ）和写入（ <code>set</code> ）访问保证仅对于引用和最多32位的原始值是按位原子的，并且对于除执行线程之外的线程没有强加可观察的排序约束。</span> <span>对于访问同一变量， <em>不透明</em>操作是按位原子和相干有序的。</span> <span>除了遵守不透明属性之外，在匹配<em>释放</em>模式写入及其先前的访问之后，还会对<em>获取</em>模式读取及其后续访问进行排序。</span> <span>除了遵守Acquire和Release属性之外，所有<em>Volatile</em>操作都是相互完全排序的。</span> </p> 
        <p> <span>访问模式分为以下几类：</span> </p> 
        <ul> 
         <li> <span>读取访问模式，获取指定内存排序效果下的变量值。</span> <span>该组对应属于该组的访问模式的方法的组成的方法<a href="#get(java.lang.Object...)"><code>get</code></a> ， <a href="#getVolatile(java.lang.Object...)"><code>getVolatile</code></a> ， <a href="#getAcquire(java.lang.Object...)"><code>getAcquire</code></a> ， <a href="#getOpaque(java.lang.Object...)"><code>getOpaque</code></a> 。</span> </li> 
         <li> <span>写入访问模式，在指定的内存排序效果下设置变量的值。</span> <span>该组对应属于该组的访问模式的方法的组成的方法<a href="#set(java.lang.Object...)"><code>set</code></a> ， <a href="#setVolatile(java.lang.Object...)"><code>setVolatile</code></a> ， <a href="#setRelease(java.lang.Object...)"><code>setRelease</code></a> ， <a href="#setOpaque(java.lang.Object...)"><code>setOpaque</code></a> 。</span> </li> 
         <li> <span>原子更新访问模式，例如，在指定的内存排序效果下，原子地比较和设置变量的值。</span> <span>该组对应属于该组的访问模式的方法的组成的方法<a href="#compareAndSet(java.lang.Object...)"><code>compareAndSet</code></a> ， <a href="#weakCompareAndSetPlain(java.lang.Object...)"><code>weakCompareAndSetPlain</code></a> ， <a href="#weakCompareAndSet(java.lang.Object...)"><code>weakCompareAndSet</code></a> ， <a href="#weakCompareAndSetAcquire(java.lang.Object...)"><code>weakCompareAndSetAcquire</code></a> ， <a href="#weakCompareAndSetRelease(java.lang.Object...)"><code>weakCompareAndSetRelease</code></a> ， <a href="#compareAndExchangeAcquire(java.lang.Object...)"><code>compareAndExchangeAcquire</code></a> ， <a href="#compareAndExchange(java.lang.Object...)"><code>compareAndExchange</code></a> ， <a href="#compareAndExchangeRelease(java.lang.Object...)"><code>compareAndExchangeRelease</code></a> ， <a href="#getAndSet(java.lang.Object...)"><code>getAndSet</code></a> ， <a href="#getAndSetAcquire(java.lang.Object...)"><code>getAndSetAcquire</code></a> ， <a href="#getAndSetRelease(java.lang.Object...)"><code>getAndSetRelease</code></a> 。</span> </li> 
         <li> <span>数字原子更新访问模式，例如，通过在指定的内存排序效果下添加变量的值，以原子方式获取和设置。</span> <span>该组的属于该组的相应的访问模式的方法由方法<a href="#getAndAdd(java.lang.Object...)"><code>getAndAdd</code></a> ， <a href="#getAndAddAcquire(java.lang.Object...)"><code>getAndAddAcquire</code></a> ， <a href="#getAndAddRelease(java.lang.Object...)"><code>getAndAddRelease</code></a> ，</span> </li> 
         <li> <span>按位原子更新访问模式，例如，在指定的内存排序效果下，以原子方式获取和按位OR变量的值。</span> <span>该组对应属于该组的访问模式的方法的组成的方法<a href="#getAndBitwiseOr(java.lang.Object...)"><code>getAndBitwiseOr</code></a> ， <a href="#getAndBitwiseOrAcquire(java.lang.Object...)"><code>getAndBitwiseOrAcquire</code></a> ， <a href="#getAndBitwiseOrRelease(java.lang.Object...)"><code>getAndBitwiseOrRelease</code></a> ， <a href="#getAndBitwiseAnd(java.lang.Object...)"><code>getAndBitwiseAnd</code></a> ， <a href="#getAndBitwiseAndAcquire(java.lang.Object...)"><code>getAndBitwiseAndAcquire</code></a> ， <a href="#getAndBitwiseAndRelease(java.lang.Object...)"><code>getAndBitwiseAndRelease</code></a> ， <a href="#getAndBitwiseXor(java.lang.Object...)"><code>getAndBitwiseXor</code></a> ， <a href="#getAndBitwiseXorAcquire(java.lang.Object...)"><code>getAndBitwiseXorAcquire</code></a> ， <a href="#getAndBitwiseXorRelease(java.lang.Object...)"><code>getAndBitwiseXorRelease</code></a> 。</span> </li> 
        </ul> 
        <p> <span>生成的工厂方法或<a href="MethodHandles.Lookup.html" title="java.lang.invoke中的类"><code>lookup</code></a> VarHandle实例记录了所支持的访问模式集，其中还可能包括基于变量类型的文档限制以及变量是否为只读。</span> <span>如果不支持访问模式，那么相应的访问模式方法将在调用时抛出<code>UnsupportedOperationException</code> 。</span> <span>工厂方法应记录访问模式方法可能引发的任何其他未声明的异常。</span> <span>所有VarHandle实例都支持<a href="#get(java.lang.Object...)"><code>get</code></a>访问模式，相应的方法永远不会抛出<code>UnsupportedOperationException</code> 。</span> <span>如果VarHandle引用只读变量（例如<code>final</code>字段），则不支持写入，原子更新，数字原子更新和按位原子更新访问模式，并且相应的方法抛出<code>UnsupportedOperationException</code> 。</span> <span>读/写访问模式（如果支持）， <code>get</code>和<code>set</code> ，为引用类型和所有基元类型提供原子访问。</span> <span>除非在工厂方法的文档中另有说明，否则访问模式<code>get</code>和<code>set</code> （如果支持）为参考类型和所有基元类型提供原子访问，但32位平台上的<code>long</code>和<code>double</code>除外。</span> </p> 
        <p> <span>访问模式将覆盖变量声明站点上指定的任何内存排序效果。</span> <span>例如，使用<code>get</code>访问模式访问字段的<code>get</code>将访问<em>由其访问模式</em>指定的字段，即使该字段声明为<code>volatile</code> 。</span> <span>当执行混合访问时，应特别小心，因为Java内存模型可能会产生令人惊讶的结果。</span> </p> 
        <p> <span>除了支持在各种访问模式下访问变量之外，还提供了一组静态方法，称为内存栅栏方法，用于细粒度控制内存排序。</span> <span>Java语言规范允许其他线程观察操作，就像它们以不同于程序源代码中明显的顺序执行，受到例如使用锁， <code>volatile</code>字段或VarHandles的限制。</span> <span>静态方法， <a href="#fullFence()"><code>fullFence</code></a> ， <a href="#acquireFence()"><code>acquireFence</code></a> ， <a href="#releaseFence()"><code>releaseFence</code></a> ， <a href="#loadLoadFence()"><code>loadLoadFence</code></a>和<a href="#storeStoreFence()"><code>storeStoreFence</code></a> ，也可以用来施加约束。</span> <span>与某些访问模式的情况一样，它们的规范是根据缺乏“重新排序”来表达的 - 如果不存在围栏，则可能出现可观察到的排序效应。</span> <span>访问模式方法和存储器范围方法的规范的更精确的措辞可以伴随Java语言规范的未来更新。</span> </p> 
        <h1> <span>编译访问模式方法的调用</span> </h1> 
        <span>命名访问模式方法的Java方法调用表达式可以从Java源代码调用VarHandle。</span> 
        <span>从源代码的角度来看，这些方法可以接受任何参数，并且它们的多态结果（如果表达的话）可以转换为任何返回类型。</span> 
        <span>正式地，这是通过给出访问模式方法变量arity <code>Object</code>参数和<code>Object</code>返回类型（如果返回类型是多态的）来实现的，但是它们具有称为<em>签名多态</em>的附加质量，其将这种调用自由直接连接到JVM执行堆栈。</span> 
        <p> <span>与通常的虚方法一样，对访问模式方法的源级调用将编译为<code>invokevirtual</code>指令。</span> <span>更不寻常的是，编译器必须记录实际的参数类型，并且可能不会对参数执行方法调用转换。</span> <span>相反，它必须根据自己未转换的类型生成将它们压入堆栈的指令。</span> <span>VarHandle对象本身将在参数之前被压入堆栈。</span> <span>然后，编译器生成<code>invokevirtual</code>指令，该指令使用描述参数和返回类型的符号类型描述符调用访问模式方法。</span> </p> 
        <p> <span>要发出完整的符号类型描述符，编译器还必须确定返回类型（如果是多态的）。</span> <span>这是基于对方法调用表达式的<code>Object</code> （如果有），或者如果调用是表达式<code>void</code>如果调用是语句， <code>void</code> 。</span> <span>演员表可以是原始类型（但不是<code>void</code> ）。</span> </p> 
        <p> <span>作为极端情况，未发布的<code>null</code>参数被赋予符号类型描述符<code>java.lang.Void</code> 。</span> <span>类型<code>Void</code>的模糊性是无害的，因为除了null引用之外没有类型<code>Void</code>的引用。</span> </p> 
        <h1> <span><a id="invoke">Performing invocation of access mode methods</a></span> </h1> 
        <span>第一次执行<code>invokevirtual</code>指令时，它通过符号解析指令中的名称并验证方法调用是静态合法的来链接。</span> 
        <span>这也适用于访问模式方法的调用。</span> 
        <span>在这种情况下，将检查编译器发出的符号类型描述符的语法是否正确，并解析它包含的名称。</span> 
        <span>因此，只要符号类型描述符在语法上格式良好并且存在类型，则调用访问模式方法的<code>invokevirtual</code>指令将始终链接。</span> 
        <p> <span>当<code>invokevirtual</code>被连接之后执行，则接收VarHandle的接入模式类型首先被JVM检查，以确保它的符号类型描述符相匹配。</span> <span>如果类型匹配失败，则意味着调用者正在调用的访问模式方法不会出现在被调用的单个VarHandle上。</span> </p> 
        <p> <span>调用访问模式方法的行为就像调用<a href="MethodHandle.html#invoke(java.lang.Object...)"><code>MethodHandle.invoke(java.lang.Object...)</code>一样</a> ，其中接收方法句柄接受VarHandle实例作为前导参数。</span> <span>更具体地说，以下，其中<code>{access-mode}</code>对应于访问模式方法名称：</span> </p> 
        <pre>  <span><code> VarHandle vh = .. R r = (R) vh.{access-mode}(p1, p2, ..., pN); </code></span> </pre> 
        <span>表现得好像：</span> 
        <pre>  <span><code> VarHandle vh = .. VarHandle.AccessMode am = VarHandle.AccessMode.valueFromMethodName("{access-mode}"); MethodHandle mh = MethodHandles.varHandleExactInvoker( am, vh.accessModeType(am)); R r = (R) mh.invoke(vh, p1, p2, ..., pN) </code></span> </pre> 
        <span>（模访问模式方法不声明抛出<code>Throwable</code> ）。</span> 
        <span>这相当于：</span> 
        <pre>  <span><code> MethodHandle mh = MethodHandles.lookup().findVirtual( VarHandle.class, "{access-mode}", MethodType.methodType(R, p1, p2, ..., pN)); R r = (R) mh.invokeExact(vh, p1, p2, ..., pN) </code></span> </pre> 
        <span>其中所需的方法类型是符号类型描述符并且执行<a href="MethodHandle.html#invokeExact(java.lang.Object...)"><code>MethodHandle.invokeExact(java.lang.Object...)</code></a> ，因为在调用目标之前，句柄将根据需要应用引用强制转换以及box，unbox或widen原始值，就像<a href="MethodHandle.html#asType(java.lang.invoke.MethodType)"><code>asType</code>一样</a> （另请参阅<a href="MethodHandles.html#varHandleInvoker(java.lang.invoke.VarHandle.AccessMode,java.lang.invoke.MethodType)"><code>MethodHandles.varHandleInvoker(java.lang.invoke.VarHandle.AccessMode, java.lang.invoke.MethodType)</code></a> ） 。</span> 
        <span>更简洁地说，这种行为相当于：</span> 
        <pre>  <span><code> VarHandle vh = .. VarHandle.AccessMode am = VarHandle.AccessMode.valueFromMethodName("{access-mode}"); MethodHandle mh = vh.toMethodHandle(am); R r = (R) mh.invoke(p1, p2, ..., pN) </code></span> </pre> 
        <span>在这种情况下，方法句柄绑定到VarHandle实例。</span> 
        <h1> <span>调用检查</span> </h1> 
        <span>在典型的程序中，VarHandle访问模式类型匹配通常会成功。</span> 
        <span>但如果匹配失败，JVM将抛出<a href="WrongMethodTypeException.html" title="java.lang.invoke中的类"><code>WrongMethodTypeException</code></a> 。</span> 
        <p> <span>因此，接入模式类型不匹配可能显示为在一个静态类型节目联动误差最多可以显示作为动态<code>WrongMethodTypeException</code>在使用VarHandles的程序。</span> </p> 
        <p> <span>由于访问模式类型包含“实时” <code>类</code>对象，因此方法类型匹配会同时考虑类型名称和类加载器。</span> <span>因此，即使VarHandle <code>VH</code>在一个类加载器<code>L1</code>创建并在另一个<code>L2</code> ，VarHandle访问模式方法调用也是类型安全的，因为调用者的符号类型描述符（在<code>L2</code>中已解析）与原始被调用方法的符号相匹配类型描述符，如<code>L1</code> 。</span> <span>决议<code>L1</code>时发生<code>VH</code>创建和访问模式类型分配，而在分辨率<code>L2</code>当发生<code>invokevirtual</code>指令链接。</span> </p> 
        <p> <span>除了类型描述符检查之外，VarHandles访问它的变量的能力是不受限制的。</span> <span>如果一个VarHandle由一个可以访问该变量的类在非公共变量上形成，那么任何接收对它的引用的调用者都可以在任何地方使用生成的VarHandle。</span> </p> 
        <p> <span>与Core Reflection API不同，每次调用反射方法时都会检查访问权限，执行<a href="MethodHandles.Lookup.html#access">VarHandle</a>访问检查<a href="MethodHandles.Lookup.html#access">when the VarHandle is created</a> 。</span> <span>因此，VarHandles与非公共变量或非公共类中的变量一般应保密。</span> <span>除非从不受信任的代码中使用它们是无害的，否则不应将它们传递给不受信任的代码。</span> </p> 
        <h1> <span>VarHandle创作</span> </h1> 
        <span>Java代码可以创建一个VarHandle，直接访问该代码可访问的任何字段。</span> 
        <span>这是通过一个名为<a href="MethodHandles.Lookup.html" title="java.lang.invoke中的类"><code>MethodHandles.Lookup</code></a>的基于功能的反射API <a href="MethodHandles.Lookup.html" title="java.lang.invoke中的类">完成的</a> 。</span> 
        <span>例如，可以从<a href="MethodHandles.Lookup.html#findVarHandle(java.lang.Class,java.lang.String,java.lang.Class)"><code>Lookup.findVarHandle</code></a>获得非静态字段的<a href="MethodHandles.Lookup.html#findVarHandle(java.lang.Class,java.lang.String,java.lang.Class)">VarHandle</a> 。</span> 
        <span>Core Reflection API对象还有一种转换方法， <a href="MethodHandles.Lookup.html#unreflectVarHandle(java.lang.reflect.Field)"><code>Lookup.unreflectVarHandle</code></a> 。</span> 
        <p> <span>对受保护字段成员的访问仅限于访问类或其子类之一的接收者，并且访问类必须又是受保护成员的定义类的子类（或包兄弟）。</span> <span>如果VarHandle引用当前包之外的声明类的受保护的非静态字段，则receiver参数将缩小为访问类的类型。</span> </p> 
        <h1> <span>VarHandles与Core Reflection API之间的互操作</span> </h1> 
        <span>使用<a href="MethodHandles.Lookup.html" title="java.lang.invoke中的类"><code>Lookup</code></a> API中的工厂方法，可以将Core Reflection API对象表示的任何字段转换为行为等效的VarHandle。</span> 
        <span>例如，可以使用<a href="MethodHandles.Lookup.html#unreflectVarHandle(java.lang.reflect.Field)"><code>Lookup.unreflectVarHandle</code></a>将反射<a href="../reflect/Field.html" title="java.lang.reflect中的类"><code>字段</code></a>转换为<a href="MethodHandles.Lookup.html#unreflectVarHandle(java.lang.reflect.Field)">VarHandle</a> 。</span> 
        <span>生成的VarHandles通常提供对底层字段的更直接和有效的访问。</span> 
        <p> <span>作为一种特殊情况，当Core Reflection API用于查看此类中的签名多态访问模式方法时，它们显示为普通的非多态方法。</span> <span>如<a href="../Class.html#getDeclaredMethod(java.lang.String,java.lang.Class...)"><code>Class.getDeclaredMethod</code>所示</a> ，它们的反射外观不受其在此API中的特殊状态的影响。</span> <span>例如， <a href="../reflect/Executable.html#getModifiers()"><code>Method.getModifiers</code></a>将准确报告任何类似声明的方法所需的那些修饰符位，包括<code>native</code>和<code>varargs</code>位。</span> </p> 
        <p> <span>与任何反射方法一样，这些方法（反映时）可以通过<a href="../reflect/Method.html#invoke(java.lang.Object,java.lang.Object...)"><code>java.lang.reflect.Method.invoke</code></a> ，JNI或间接通过<a href="MethodHandles.Lookup.html#unreflect(java.lang.reflect.Method)"><code>Lookup.unreflect</code></a>直接调用。</span> <span>但是，这种反射调用不会导致访问模式方法调用。</span> <span>这样的调用，如果传递了所需的参数（类型为<code>Object[]</code>的单个参数），将忽略该参数并将抛出<code>UnsupportedOperationException</code> 。</span> </p> 
        <p> <span>由于<code>invokevirtual</code>指令可以在任何符号类型描述符下原生调用VarHandle访问模式方法，因此该反射视图与通过字节码的这些方法的正常表示冲突。</span> <span>因此，当<code>Class.getDeclaredMethod</code>反思地查看时，这些本机方法可能仅被视为占位符。</span> </p> 
        <p> <span>要获取特定访问模式类型的调用方法，请使用<a href="MethodHandles.html#varHandleExactInvoker(java.lang.invoke.VarHandle.AccessMode,java.lang.invoke.MethodType)"><code>MethodHandles.varHandleExactInvoker(java.lang.invoke.VarHandle.AccessMode, java.lang.invoke.MethodType)</code></a>或<a href="MethodHandles.html#varHandleInvoker(java.lang.invoke.VarHandle.AccessMode,java.lang.invoke.MethodType)"><code>MethodHandles.varHandleInvoker(java.lang.invoke.VarHandle.AccessMode, java.lang.invoke.MethodType)</code></a> 。</span> <span><a href="MethodHandles.Lookup.html#findVirtual(java.lang.Class,java.lang.String,java.lang.invoke.MethodType)"><code>Lookup.findVirtual</code></a> API还能够返回方法句柄，以便为任何指定的访问模式类型调用访问模式方法，并且行为与<a href="MethodHandles.html#varHandleInvoker(java.lang.invoke.VarHandle.AccessMode,java.lang.invoke.MethodType)"><code>MethodHandles.varHandleInvoker(java.lang.invoke.VarHandle.AccessMode, java.lang.invoke.MethodType)</code>相同</a> 。</span> </p> 
        <h1> <span>VarHandles与Java泛型之间的互操作</span> </h1> 
        <span>可以为变量（例如字段）获取VarHandle，该变量使用Java泛型类型声明。</span> 
        <span>与Core Reflection API一样，VarHandle的变量类型将从源级别类型的擦除构造。</span> 
        <span>调用VarHandle访问模式方法时，其参数类型或返回值强制转换类型可以是泛型类型或类型实例。</span> 
        <span>如果发生这种情况，编译器将在构造<code>invokevirtual</code>指令的符号类型描述符时通过其擦除替换这些类型。</span> 
       </div> 
       <dl> 
        <dt> 
         <span class="simpleTagLabel">从以下版本开始：</span> 
        </dt> 
        <dd>
          9 
        </dd> 
        <dt> 
         <span class="seeLabel">另请参见：</span> 
        </dt> 
        <dd> 
         <span><a href="MethodHandle.html" title="java.lang.invoke中的类"><code>MethodHandle</code></a> ， <a href="MethodHandles.html" title="java.lang.invoke中的类"><code>MethodHandles</code></a> ， <a href="MethodType.html" title="java.lang.invoke中的类"><code>MethodType</code></a></span> 
        </dd> 
       </dl> </li> 
     </ul> 
    </div> 
    <div class="summary"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <!-- ======== NESTED CLASS SUMMARY ======== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="nested.class.summary"> 
           <!--   --> </a> <h3>嵌套类汇总</h3> 
          <table class="memberSummary"> 
           <caption> 
            <span>嵌套类</span> 
            <span class="tabEnd">&nbsp;</span> 
           </caption> 
           <tbody> 
            <tr> 
             <th class="colFirst" scope="col">变量和类型</th> 
             <th class="colSecond" scope="col">类</th> 
             <th class="colLast" scope="col">描述</th> 
            </tr> 
            <tr class="altColor"> 
             <td class="colFirst"><code>static class&nbsp;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="VarHandle.AccessMode.html" title="enum in java.lang.invoke">VarHandle.AccessMode</a></span></code></th> 
             <td class="colLast"> 
              <div class="block">
                一组访问模式，用于指定如何访问由VarHandle引用的变量。 
              </div> </td> 
            </tr> 
           </tbody> 
          </table> </li> 
        </ul> 
       </section> 
       <!-- ========== METHOD SUMMARY =========== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="method.summary"> 
           <!--   --> </a> <h3>方法摘要</h3> 
          <table class="memberSummary"> 
           <caption> 
           <span id="t0" class="activeTableTab"><span>所有方法</span><span class="tabEnd">&nbsp;</span>
            <span id="t1" class="tableTab"><span><a href="javascript:show(1);">静态方法</a></span><span class="tabEnd">&nbsp;</span></span> 
             <span id="t2" class="tableTab"><span><a href="javascript:show(2);">实例方法</a>  </span></span> 
            <span id="t4" class="tableTab"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd">&nbsp;</span></span> 
           </caption> 
           <tbody> 
            <tr> 
             <th class="colFirst" scope="col">变量和类型</th> 
             <th class="colSecond" scope="col">方法</th> 
             <th class="colLast" scope="col">描述</th> 
            </tr> 
            <tr id="i0" class="altColor"> 
             <td class="colFirst"><code><a href="MethodType.html" title="class in java.lang.invoke">MethodType</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#accessModeType(java.lang.invoke.VarHandle.AccessMode)">accessModeType</a></span>​(<a href="VarHandle.AccessMode.html" title="enum in java.lang.invoke">VarHandle.AccessMode</a>&nbsp;accessMode)</code></th> 
             <td class="colLast"> 
              <div class="block">
                获得此VarHandle的访问模式类型和给定的访问模式。 
              </div> </td> 
            </tr> 
            <tr id="i1" class="rowColor"> 
             <td class="colFirst"><code>static void</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#acquireFence()">acquireFence</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                确保栅栏前的载荷不会在栅栏后的载荷和存储中重新排序。 
              </div> </td> 
            </tr> 
            <tr id="i2" class="altColor"> 
             <td class="colFirst"><code><a href="../Object.html" title="class in java.lang">Object</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#compareAndExchange(java.lang.Object...)">compareAndExchange</a></span>​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</code></th> 
             <td class="colLast"> 
              <div class="block">
                原子性地将变量的值设置为 
               <code>newValue</code> ，其内存语义为 
               <a href="#setVolatile(java.lang.Object...)"><code>setVolatile(java.lang.Object...)</code>，</a>如果变量的当前值（称为 
               <em>见证值</em> 
               <code>==</code> 
               <code>expectedValue</code> ，则使用 
               <code>expectedValue</code>的内存语义进行 
               <a href="#getVolatile(java.lang.Object...)">访问</a> 。 
              </div> </td> 
            </tr> 
            <tr id="i3" class="rowColor"> 
             <td class="colFirst"><code><a href="../Object.html" title="class in java.lang">Object</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#compareAndExchangeAcquire(java.lang.Object...)">compareAndExchangeAcquire</a></span>​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</code></th> 
             <td class="colLast"> 
              <div class="block">
                以原子方式设置的变量的值 
               <code>newValue</code>用的存储器语义 
               <a href="#set(java.lang.Object...)"><code>set(java.lang.Object...)</code></a>如果该变量的当前值，被称为 
               <em>证人值</em> ， 
               <code>==</code>的 
               <code>expectedValue</code> ，与的存储器访问语义 
               <a href="#getAcquire(java.lang.Object...)"><code>getAcquire(java.lang.Object...)</code></a> 。 
              </div> </td> 
            </tr> 
            <tr id="i4" class="altColor"> 
             <td class="colFirst"><code><a href="../Object.html" title="class in java.lang">Object</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#compareAndExchangeRelease(java.lang.Object...)">compareAndExchangeRelease</a></span>​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</code></th> 
             <td class="colLast"> 
              <div class="block">
                以原子方式设置的变量的值 
               <code>newValue</code>用的存储器语义 
               <a href="#setRelease(java.lang.Object...)"><code>setRelease(java.lang.Object...)</code></a>如果该变量的当前值，被称为 
               <em>证人值</em> ， 
               <code>==</code>的 
               <code>expectedValue</code> ，与的存储器访问语义 
               <a href="#get(java.lang.Object...)"><code>get(java.lang.Object...)</code></a> 。 
              </div> </td> 
            </tr> 
            <tr id="i5" class="rowColor"> 
             <td class="colFirst"><code>boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#compareAndSet(java.lang.Object...)">compareAndSet</a></span>​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</code></th> 
             <td class="colLast"> 
              <div class="block">
                以原子方式设置的变量的值 
               <code>newValue</code>用的存储器语义 
               <a href="#setVolatile(java.lang.Object...)"><code>setVolatile(java.lang.Object...)</code></a>如果该变量的当前值，被称为 
               <em>证人值</em> ， 
               <code>==</code>的 
               <code>expectedValue</code> ，与的存储器访问语义 
               <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(java.lang.Object...)</code></a> 。 
              </div> </td> 
            </tr> 
            <tr id="i6" class="altColor"> 
             <td class="colFirst"><code><a href="../../util/List.html" title="interface in java.util">List</a>&lt;<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#coordinateTypes()">coordinateTypes</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回此VarHandle的坐标类型。 
              </div> </td> 
            </tr> 
            <tr id="i7" class="rowColor"> 
             <td class="colFirst"><code>static void</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fullFence()">fullFence</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                确保围栏之前的装载和存储不会在围栏之后与装载和存储重新排序。 
              </div> </td> 
            </tr> 
            <tr id="i8" class="altColor"> 
             <td class="colFirst"><code><a href="../Object.html" title="class in java.lang">Object</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#get(java.lang.Object...)">get</a></span>​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回变量的值，读取的内存语义就像变量声明为非 
               <code>volatile</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i9" class="rowColor"> 
             <td class="colFirst"><code><a href="../Object.html" title="class in java.lang">Object</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getAcquire(java.lang.Object...)">getAcquire</a></span>​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回变量的值，并确保在此访问之前不会重新排序后续加载和存储。 
              </div> </td> 
            </tr> 
            <tr id="i10" class="altColor"> 
             <td class="colFirst"><code><a href="../Object.html" title="class in java.lang">Object</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getAndAdd(java.lang.Object...)">getAndAdd</a></span>​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</code></th> 
             <td class="colLast"> 
              <div class="block">
                原子地将 
               <code>value</code>添加到变量的当前值，其内存语义为 
               <a href="#setVolatile(java.lang.Object...)"><code>setVolatile(java.lang.Object...)</code></a> ，并返回变量的先前值，如内存语义 
               <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(java.lang.Object...)</code>所示</a> 。 
              </div> </td> 
            </tr> 
            <tr id="i11" class="rowColor"> 
             <td class="colFirst"><code><a href="../Object.html" title="class in java.lang">Object</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getAndAddAcquire(java.lang.Object...)">getAndAddAcquire</a></span>​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</code></th> 
             <td class="colLast"> 
              <div class="block">
                原子地将 
               <code>value</code>添加到变量的当前值，其内存语义为 
               <a href="#set(java.lang.Object...)"><code>set(java.lang.Object...)</code></a> ，并返回变量的先前值，如使用 
               <a href="#getAcquire(java.lang.Object...)"><code>getAcquire(java.lang.Object...)</code></a>的内存语义访问的 
               <a href="#getAcquire(java.lang.Object...)">那样</a> 。 
              </div> </td> 
            </tr> 
            <tr id="i12" class="altColor"> 
             <td class="colFirst"><code><a href="../Object.html" title="class in java.lang">Object</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getAndAddRelease(java.lang.Object...)">getAndAddRelease</a></span>​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</code></th> 
             <td class="colLast"> 
              <div class="block">
                原子地将 
               <code>value</code>添加到变量的当前值，其内存语义为 
               <a href="#setRelease(java.lang.Object...)"><code>setRelease(java.lang.Object...)</code></a> ，并返回变量的先前值，如使用 
               <a href="#get(java.lang.Object...)"><code>get(java.lang.Object...)</code></a>的内存语义访问的 
               <a href="#get(java.lang.Object...)">那样</a> 。 
              </div> </td> 
            </tr> 
            <tr id="i13" class="rowColor"> 
             <td class="colFirst"><code><a href="../Object.html" title="class in java.lang">Object</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getAndBitwiseAnd(java.lang.Object...)">getAndBitwiseAnd</a></span>​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</code></th> 
             <td class="colLast"> 
              <div class="block">
                原子地将变量的值设置为变量的当前值与 
               <code>mask</code>之间的按位AND结果，其内存语义为 
               <a href="#setVolatile(java.lang.Object...)"><code>setVolatile(java.lang.Object...)</code>，</a>并返回变量的先前值，如内存语义 
               <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(java.lang.Object...)</code>所示</a> 。 
              </div> </td> 
            </tr> 
            <tr id="i14" class="altColor"> 
             <td class="colFirst"><code><a href="../Object.html" title="class in java.lang">Object</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getAndBitwiseAndAcquire(java.lang.Object...)">getAndBitwiseAndAcquire</a></span>​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</code></th> 
             <td class="colLast"> 
              <div class="block">
                原子地将变量的值设置为变量的当前值与 
               <code>mask</code>之间的按位AND结果，其内存语义为 
               <a href="#set(java.lang.Object...)"><code>set(java.lang.Object...)</code>，</a>并返回变量的先前值，如内存语义 
               <a href="#getAcquire(java.lang.Object...)"><code>getAcquire(java.lang.Object...)</code>所示</a> 。 
              </div> </td> 
            </tr> 
            <tr id="i15" class="rowColor"> 
             <td class="colFirst"><code><a href="../Object.html" title="class in java.lang">Object</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getAndBitwiseAndRelease(java.lang.Object...)">getAndBitwiseAndRelease</a></span>​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</code></th> 
             <td class="colLast"> 
              <div class="block">
                以原子方式将变量的值设置为变量的当前值与 
               <code>mask</code>之间的按位AND结果，内存语义为 
               <a href="#setRelease(java.lang.Object...)"><code>setRelease(java.lang.Object...)</code>，</a>并返回变量的先前值，如内存语义 
               <a href="#get(java.lang.Object...)"><code>get(java.lang.Object...)</code>所示</a> 。 
              </div> </td> 
            </tr> 
            <tr id="i16" class="altColor"> 
             <td class="colFirst"><code><a href="../Object.html" title="class in java.lang">Object</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getAndBitwiseOr(java.lang.Object...)">getAndBitwiseOr</a></span>​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</code></th> 
             <td class="colLast"> 
              <div class="block">
                原子地将变量的值设置为变量的当前值与 
               <code>mask</code>之间的按位OR结果，其内存语义为 
               <a href="#setVolatile(java.lang.Object...)"><code>setVolatile(java.lang.Object...)</code>，</a>并返回变量的先前值，如内存语义 
               <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(java.lang.Object...)</code>所示</a> 。 
              </div> </td> 
            </tr> 
            <tr id="i17" class="rowColor"> 
             <td class="colFirst"><code><a href="../Object.html" title="class in java.lang">Object</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getAndBitwiseOrAcquire(java.lang.Object...)">getAndBitwiseOrAcquire</a></span>​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</code></th> 
             <td class="colLast"> 
              <div class="block">
                原子地将变量的值设置为变量的当前值与 
               <code>mask</code>之间的按位OR结果，其内存语义为 
               <a href="#set(java.lang.Object...)"><code>set(java.lang.Object...)</code>，</a>并返回变量的先前值，如内存语义 
               <a href="#getAcquire(java.lang.Object...)"><code>getAcquire(java.lang.Object...)</code>所示</a> 。 
              </div> </td> 
            </tr> 
            <tr id="i18" class="altColor"> 
             <td class="colFirst"><code><a href="../Object.html" title="class in java.lang">Object</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getAndBitwiseOrRelease(java.lang.Object...)">getAndBitwiseOrRelease</a></span>​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</code></th> 
             <td class="colLast"> 
              <div class="block">
                原子地将变量的值设置为变量的当前值与 
               <code>mask</code>之间的按位OR结果，其内存语义为 
               <a href="#setRelease(java.lang.Object...)"><code>setRelease(java.lang.Object...)</code>，</a>并返回变量的先前值，如内存语义 
               <a href="#get(java.lang.Object...)"><code>get(java.lang.Object...)</code>所示</a> 。 
              </div> </td> 
            </tr> 
            <tr id="i19" class="rowColor"> 
             <td class="colFirst"><code><a href="../Object.html" title="class in java.lang">Object</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getAndBitwiseXor(java.lang.Object...)">getAndBitwiseXor</a></span>​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</code></th> 
             <td class="colLast"> 
              <div class="block">
                原子地将变量的值设置为变量的当前值与 
               <code>mask</code>之间的按位异或结果，其内存语义为 
               <a href="#setVolatile(java.lang.Object...)"><code>setVolatile(java.lang.Object...)</code>，</a>并返回变量的先前值，如内存语义 
               <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(java.lang.Object...)</code>所示</a> 。 
              </div> </td> 
            </tr> 
            <tr id="i20" class="altColor"> 
             <td class="colFirst"><code><a href="../Object.html" title="class in java.lang">Object</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getAndBitwiseXorAcquire(java.lang.Object...)">getAndBitwiseXorAcquire</a></span>​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</code></th> 
             <td class="colLast"> 
              <div class="block">
                原子地将变量的值设置为变量的当前值与 
               <code>mask</code>之间的按位异或结果，其内存语义为 
               <a href="#set(java.lang.Object...)"><code>set(java.lang.Object...)</code>，</a>并返回变量的先前值，如内存语义 
               <a href="#getAcquire(java.lang.Object...)"><code>getAcquire(java.lang.Object...)</code>所示</a> 。 
              </div> </td> 
            </tr> 
            <tr id="i21" class="rowColor"> 
             <td class="colFirst"><code><a href="../Object.html" title="class in java.lang">Object</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getAndBitwiseXorRelease(java.lang.Object...)">getAndBitwiseXorRelease</a></span>​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</code></th> 
             <td class="colLast"> 
              <div class="block">
                原子地将变量的值设置为变量的当前值与 
               <code>mask</code>之间的按位异或结果，其内存语义为 
               <a href="#setRelease(java.lang.Object...)"><code>setRelease(java.lang.Object...)</code>，</a>并返回变量的先前值，如内存语义 
               <a href="#get(java.lang.Object...)"><code>get(java.lang.Object...)</code>所示</a> 。 
              </div> </td> 
            </tr> 
            <tr id="i22" class="altColor"> 
             <td class="colFirst"><code><a href="../Object.html" title="class in java.lang">Object</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getAndSet(java.lang.Object...)">getAndSet</a></span>​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</code></th> 
             <td class="colLast"> 
              <div class="block">
                原子方式将变量的值设置为 
               <code>newValue</code> ，内存语义为 
               <a href="#setVolatile(java.lang.Object...)"><code>setVolatile(java.lang.Object...)</code>，</a>并返回变量的先前值，如内存语义 
               <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(java.lang.Object...)</code>所示</a> 。 
              </div> </td> 
            </tr> 
            <tr id="i23" class="rowColor"> 
             <td class="colFirst"><code><a href="../Object.html" title="class in java.lang">Object</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getAndSetAcquire(java.lang.Object...)">getAndSetAcquire</a></span>​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</code></th> 
             <td class="colLast"> 
              <div class="block">
                原子方式将变量的值设置为 
               <code>newValue</code> ，内存语义为 
               <a href="#set(java.lang.Object...)"><code>set(java.lang.Object...)</code>，</a>并返回变量的先前值，如内存语义 
               <a href="#getAcquire(java.lang.Object...)"><code>getAcquire(java.lang.Object...)</code>所示</a> 。 
              </div> </td> 
            </tr> 
            <tr id="i24" class="altColor"> 
             <td class="colFirst"><code><a href="../Object.html" title="class in java.lang">Object</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getAndSetRelease(java.lang.Object...)">getAndSetRelease</a></span>​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</code></th> 
             <td class="colLast"> 
              <div class="block">
                以原子方式将变量的值设置为 
               <code>newValue</code> ，内存语义为 
               <a href="#setRelease(java.lang.Object...)"><code>setRelease(java.lang.Object...)</code>，</a>并返回变量的先前值，如内存语义 
               <a href="#get(java.lang.Object...)"><code>get(java.lang.Object...)</code>所示</a> 。 
              </div> </td> 
            </tr> 
            <tr id="i25" class="rowColor"> 
             <td class="colFirst"><code><a href="../Object.html" title="class in java.lang">Object</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getOpaque(java.lang.Object...)">getOpaque</a></span>​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回以程序顺序访问的变量的值，但不保证相对于其他线程的内存排序效果。 
              </div> </td> 
            </tr> 
            <tr id="i26" class="altColor"> 
             <td class="colFirst"><code><a href="../Object.html" title="class in java.lang">Object</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getVolatile(java.lang.Object...)">getVolatile</a></span>​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回变量的值，读取的内存语义就像声明变量 
               <code>volatile</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i27" class="rowColor"> 
             <td class="colFirst"><code>boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isAccessModeSupported(java.lang.invoke.VarHandle.AccessMode)">isAccessModeSupported</a></span>​(<a href="VarHandle.AccessMode.html" title="enum in java.lang.invoke">VarHandle.AccessMode</a>&nbsp;accessMode)</code></th> 
             <td class="colLast"> 
              <div class="block">
                如果支持给定的访问模式，则返回 
               <code>true</code> ，否则 
               <code>false</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i28" class="altColor"> 
             <td class="colFirst"><code>static void</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#loadLoadFence()">loadLoadFence</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                确保栅栏前的载荷不会与栅栏后的载荷重新排序。 
              </div> </td> 
            </tr> 
            <tr id="i29" class="rowColor"> 
             <td class="colFirst"><code>static void</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#releaseFence()">releaseFence</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                确保栅栏前的装载和存储不会在栅栏后与存储重新排序。 
              </div> </td> 
            </tr> 
            <tr id="i30" class="altColor"> 
             <td class="colFirst"><code>void</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#set(java.lang.Object...)">set</a></span>​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</code></th> 
             <td class="colLast"> 
              <div class="block">
                将变量的值设置为 
               <code>newValue</code> ，其内存语义设置为将变量声明为非 
               <code>volatile</code> 
               <code>final</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i31" class="rowColor"> 
             <td class="colFirst"><code>void</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setOpaque(java.lang.Object...)">setOpaque</a></span>​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</code></th> 
             <td class="colLast"> 
              <div class="block">
                按程序顺序将变量的值设置为 
               <code>newValue</code> ，但不保证相对于其他线程的内存排序效果。 
              </div> </td> 
            </tr> 
            <tr id="i32" class="altColor"> 
             <td class="colFirst"><code>void</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setRelease(java.lang.Object...)">setRelease</a></span>​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</code></th> 
             <td class="colLast"> 
              <div class="block">
                将变量的值设置为 
               <code>newValue</code> ，并确保在此访问后不重新排序先前的加载和存储。 
              </div> </td> 
            </tr> 
            <tr id="i33" class="rowColor"> 
             <td class="colFirst"><code>void</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setVolatile(java.lang.Object...)">setVolatile</a></span>​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</code></th> 
             <td class="colLast"> 
              <div class="block">
                将变量的值设置为 
               <code>newValue</code> ，设置的内存语义就像声明变量 
               <code>volatile</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i34" class="altColor"> 
             <td class="colFirst"><code>static void</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#storeStoreFence()">storeStoreFence</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                确保栅栏前的商店不会在栅栏后与商店重新订购。 
              </div> </td> 
            </tr> 
            <tr id="i35" class="rowColor"> 
             <td class="colFirst"><code><a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toMethodHandle(java.lang.invoke.VarHandle.AccessMode)">toMethodHandle</a></span>​(<a href="VarHandle.AccessMode.html" title="enum in java.lang.invoke">VarHandle.AccessMode</a>&nbsp;accessMode)</code></th> 
             <td class="colLast"> 
              <div class="block">
                获取绑定到此VarHandle的方法句柄和给定的访问模式。 
              </div> </td> 
            </tr> 
            <tr id="i36" class="altColor"> 
             <td class="colFirst"><code><a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#varType()">varType</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回此VarHandle引用的变量的变量类型。 
              </div> </td> 
            </tr> 
            <tr id="i37" class="rowColor"> 
             <td class="colFirst"><code>boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#weakCompareAndSet(java.lang.Object...)">weakCompareAndSet</a></span>​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</code></th> 
             <td class="colLast"> 
              <div class="block">
                可能原子将变量到值 
               <code>newValue</code>用的存储器语义 
               <a href="#setVolatile(java.lang.Object...)"><code>setVolatile(java.lang.Object...)</code></a>如果该变量的当前值，被称为 
               <em>证人值</em> ， 
               <code>==</code>的 
               <code>expectedValue</code> ，与的存储器访问语义 
               <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(java.lang.Object...)</code></a> 。 
              </div> </td> 
            </tr> 
            <tr id="i38" class="altColor"> 
             <td class="colFirst"><code>boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#weakCompareAndSetAcquire(java.lang.Object...)">weakCompareAndSetAcquire</a></span>​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</code></th> 
             <td class="colLast"> 
              <div class="block">
                可能原子将变量到值 
               <code>newValue</code>用的语义 
               <a href="#set(java.lang.Object...)"><code>set(java.lang.Object...)</code></a>如果变量的当前值，被称为 
               <em>证人值</em> ， 
               <code>==</code>的 
               <code>expectedValue</code> ，与的存储器访问语义 
               <a href="#getAcquire(java.lang.Object...)"><code>getAcquire(java.lang.Object...)</code></a> 。 
              </div> </td> 
            </tr> 
            <tr id="i39" class="rowColor"> 
             <td class="colFirst"><code>boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#weakCompareAndSetPlain(java.lang.Object...)">weakCompareAndSetPlain</a></span>​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</code></th> 
             <td class="colLast"> 
              <div class="block">
                可能原子将变量到值 
               <code>newValue</code>用的语义 
               <a href="#set(java.lang.Object...)"><code>set(java.lang.Object...)</code></a>如果变量的当前值，被称为 
               <em>证人值</em> ， 
               <code>==</code>的 
               <code>expectedValue</code> ，与的存储器访问语义 
               <a href="#get(java.lang.Object...)"><code>get(java.lang.Object...)</code></a> 。 
              </div> </td> 
            </tr> 
            <tr id="i40" class="altColor"> 
             <td class="colFirst"><code>boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#weakCompareAndSetRelease(java.lang.Object...)">weakCompareAndSetRelease</a></span>​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</code></th> 
             <td class="colLast"> 
              <div class="block">
                可能原子将变量到值 
               <code>newValue</code>用的语义 
               <a href="#setRelease(java.lang.Object...)"><code>setRelease(java.lang.Object...)</code></a>如果变量的当前值，被称为 
               <em>证人值</em> ， 
               <code>==</code>的 
               <code>expectedValue</code> ，与的存储器访问语义 
               <a href="#get(java.lang.Object...)"><code>get(java.lang.Object...)</code></a> 。 
              </div> </td> 
            </tr> 
           </tbody> 
          </table> 
          <ul class="blockList"> 
           <li class="blockList"><a id="methods.inherited.from.class.java.lang.Object"> 
             <!--   --> </a> <h3>声明方法的类&nbsp;java.lang.<a href="../Object.html" title="class in java.lang">Object</a></h3> <code><a href="../Object.html#clone()">clone</a>, <a href="../Object.html#equals(java.lang.Object)">equals</a>, <a href="../Object.html#finalize()">finalize</a>, <a href="../Object.html#getClass()">getClass</a>, <a href="../Object.html#hashCode()">hashCode</a>, <a href="../Object.html#notify()">notify</a>, <a href="../Object.html#notifyAll()">notifyAll</a>, <a href="../Object.html#toString()">toString</a>, <a href="../Object.html#wait()">wait</a>, <a href="../Object.html#wait(long)">wait</a>, <a href="../Object.html#wait(long,int)">wait</a></code></li> 
          </ul> </li> 
        </ul> 
       </section> </li> 
     </ul> 
    </div> 
    <div class="details"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <!-- ============ METHOD DETAIL ========== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="method.detail"> 
           <!--   --> </a> <h3>方法详细信息</h3> <a id="get(java.lang.Object...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>get</h4> <pre class="methodSignature">public final&nbsp;<a href="../Object.html" title="class in java.lang">Object</a>&nbsp;get​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</pre> 
            <div class="block"> 
             <span>返回变量的值，读取的内存语义就像变量被声明为非<code>volatile</code> 。</span> 
             <span>通常称为普通读取访问。</span> 
             <p> <span>方法签名的格式为<code>(CT1 ct1, ..., CTn ctn)T</code> 。</span> </p> 
             <p> <span>调用站点<code>get</code>处的符号类型描述符必须与在此VarHandle上调用<code>accessModeType(VarHandle.AccessMode.GET)</code>的结果的访问模式类型匹配。</span> </p> 
             <p> <span>所有VarHandle实例都支持此访问模式，并且从不抛出<code>UnsupportedOperationException</code> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>args</code> - 形式 
              <code>(CT1 ct1, ..., CTn)</code>的签名多态参数列表，使用varargs静态表示。 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               签名 - 多态结果，即变量的值，使用 
              <code>Object</code>静态表示。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果访问模式类型与调用者的符号类型描述符不匹配。 
             </dd> 
             <dd> 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果访问模式类型与调用者的符号类型描述符匹配，但引用 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code>失败。 
             </dd> 
            </dl> </li> 
          </ul> <a id="set(java.lang.Object...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>set</h4> <pre class="methodSignature">public final&nbsp;void&nbsp;set​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</pre> 
            <div class="block"> 
             <span>将变量的值设置为<code>newValue</code> ，设置的内存语义就像变量被声明为非<code>volatile</code>和非<code>final</code> 。</span> 
             <span>通常称为普通写访问。</span> 
             <p> <span>方法签名的格式为<code>(CT1 ct1, ..., CTn ctn, T newValue)void</code></span> </p> 
             <p> <span>调用站点<code>set</code>处的符号类型描述符必须与在此VarHandle上调用<code>accessModeType(VarHandle.AccessMode.SET)</code>的结果的访问模式类型匹配。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>args</code> - 形式 
              <code>(CT1 ct1, ..., CTn ctn, T newValue)</code>的签名多态参数列表，使用varargs静态表示。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果此VarHandle不支持访问模式。 
             </dd> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果访问模式类型与调用者的符号类型描述符不匹配。 
             </dd> 
             <dd> 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果访问模式类型与调用者的符号类型描述符匹配，但引用 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code>失败。 
             </dd> 
            </dl> </li> 
          </ul> <a id="getVolatile(java.lang.Object...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getVolatile</h4> <pre class="methodSignature">public final&nbsp;<a href="../Object.html" title="class in java.lang">Object</a>&nbsp;getVolatile​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</pre> 
            <div class="block"> 
             <span>返回变量的值，读取的内存语义就像声明变量<code>volatile</code> 。</span> 
             <p> <span>方法签名的格式为<code>(CT1 ct1, ..., CTn ctn)T</code> 。</span> </p> 
             <p> <span>调用站点<code>getVolatile</code>处的符号类型描述符必须与在此VarHandle上调用<code>accessModeType(VarHandle.AccessMode.GET_VOLATILE)</code>的结果的访问模式类型匹配。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>args</code> - 形式为 
              <code>(CT1 ct1, ..., CTn ctn)</code>的签名多态参数列表，使用varargs静态表示。 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               签名 - 多态结果，即变量的值，使用 
              <code>Object</code>静态表示。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果此VarHandle不支持访问模式。 
             </dd> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果访问模式类型与调用者的符号类型描述符不匹配。 
             </dd> 
             <dd> 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果访问模式类型与调用者的符号类型描述符匹配，但引用 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code>失败。 
             </dd> 
            </dl> </li> 
          </ul> <a id="setVolatile(java.lang.Object...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>setVolatile</h4> <pre class="methodSignature">public final&nbsp;void&nbsp;setVolatile​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</pre> 
            <div class="block"> 
             <span>将变量的值设置为<code>newValue</code> ，设置的内存语义就像声明变量<code>volatile</code> 。</span> 
             <p> <span>方法签名的格式为<code>(CT1 ct1, ..., CTn ctn, T newValue)void</code> 。</span> </p> 
             <p> <span>调用站点<code>setVolatile</code>处的符号类型描述符必须与在此VarHandle上调用<code>accessModeType(VarHandle.AccessMode.SET_VOLATILE)</code>的结果的访问模式类型匹配。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd>
               忽略C和C ++的许多语义差异，此方法具有与 
              <code>memory_order_seq_cst</code>兼容的内存排序效果。 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>args</code> - 形式 
              <code>(CT1 ct1, ..., CTn ctn, T newValue)</code>的签名多态参数列表，使用varargs静态表示。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果此VarHandle不支持访问模式。 
             </dd> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果访问模式类型与调用者的符号类型描述符不匹配。 
             </dd> 
             <dd> 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果访问模式类型与调用者的符号类型描述符匹配，但引用 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code>失败。 
             </dd> 
            </dl> </li> 
          </ul> <a id="getOpaque(java.lang.Object...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getOpaque</h4> <pre class="methodSignature">public final&nbsp;<a href="../Object.html" title="class in java.lang">Object</a>&nbsp;getOpaque​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</pre> 
            <div class="block"> 
             <span>返回以程序顺序访问的变量的值，但不保证相对于其他线程的内存排序效果。</span> 
             <p> <span>方法签名的格式为<code>(CT1 ct1, ..., CTn ctn)T</code> 。</span> </p> 
             <p> <span>调用站点<code>getOpaque</code>处的符号类型描述符必须与访问模式类型匹配，该访问模式类型是在此VarHandle上调用<code>accessModeType(VarHandle.AccessMode.GET_OPAQUE)</code>的结果。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>args</code> - 形式 
              <code>(CT1 ct1, ..., CTn ctn)</code>的签名多态参数列表，使用varargs静态表示。 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               签名 - 多态结果，即变量的值，使用 
              <code>Object</code>静态表示。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果此VarHandle不支持访问模式。 
             </dd> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果访问模式类型与调用者的符号类型描述符不匹配。 
             </dd> 
             <dd> 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果访问模式类型与调用者的符号类型描述符匹配，但引用 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code>失败。 
             </dd> 
            </dl> </li> 
          </ul> <a id="setOpaque(java.lang.Object...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>setOpaque</h4> <pre class="methodSignature">public final&nbsp;void&nbsp;setOpaque​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</pre> 
            <div class="block"> 
             <span>按程序顺序将变量的值设置为<code>newValue</code> ，但不保证相对于其他线程的内存排序效果。</span> 
             <p> <span>方法签名的格式为<code>(CT1 ct1, ..., CTn ctn, T newValue)void</code> 。</span> </p> 
             <p> <span>调用站点<code>setOpaque</code>处的符号类型描述符必须与访问模式类型匹配，该访问模式类型是在此VarHandle上调用<code>accessModeType(VarHandle.AccessMode.SET_OPAQUE)</code>的结果。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>args</code> - 形式为 
              <code>(CT1 ct1, ..., CTn ctn, T newValue)</code>的签名多态参数列表，使用varargs静态表示。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果此VarHandle不支持访问模式。 
             </dd> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果访问模式类型与调用者的符号类型描述符不匹配。 
             </dd> 
             <dd> 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果访问模式类型与调用者的符号类型描述符匹配，但引用 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code>失败。 
             </dd> 
            </dl> </li> 
          </ul> <a id="getAcquire(java.lang.Object...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getAcquire</h4> <pre class="methodSignature">public final&nbsp;<a href="../Object.html" title="class in java.lang">Object</a>&nbsp;getAcquire​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</pre> 
            <div class="block"> 
             <span>返回变量的值，并确保在此访问之前不会重新排序后续加载和存储。</span> 
             <p> <span>方法签名的格式为<code>(CT1 ct1, ..., CTn ctn)T</code> 。</span> </p> 
             <p> <span>调用站点<code>getAcquire</code>处的符号类型描述符必须与访问模式类型匹配，该访问模式类型是在此VarHandle上调用<code>accessModeType(VarHandle.AccessMode.GET_ACQUIRE)</code>的结果。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd>
               忽略C和C ++的许多语义差异，此方法具有与 
              <code>memory_order_acquire</code>排序兼容的内存排序效果。 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>args</code> -形式的签名的多态参数列表 
              <code>(CT1 ct1, ..., CTn ctn)</code> ，使用可变参数静态表示。 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               签名 - 多态结果，即变量的值，使用 
              <code>Object</code>静态表示。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果此VarHandle不支持访问模式。 
             </dd> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果访问模式类型与调用者的符号类型描述符不匹配。 
             </dd> 
             <dd> 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果访问模式类型与调用者的符号类型描述符匹配，但引用 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code>失败。 
             </dd> 
            </dl> </li> 
          </ul> <a id="setRelease(java.lang.Object...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>setRelease</h4> <pre class="methodSignature">public final&nbsp;void&nbsp;setRelease​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</pre> 
            <div class="block"> 
             <span>将变量的值设置为<code>newValue</code> ，并确保在此访问后不会重新排序先前的加载和存储。</span> 
             <p> <span>方法签名的格式为<code>(CT1 ct1, ..., CTn ctn, T newValue)void</code> 。</span> </p> 
             <p> <span>调用站点<code>setRelease</code>处的符号类型描述符必须与在此VarHandle上调用<code>accessModeType(VarHandle.AccessMode.SET_RELEASE)</code>的结果的访问模式类型匹配。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd>
               忽略C和C ++的许多语义差异，此方法具有与 
              <code>memory_order_release</code>排序兼容的内存排序效果。 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>args</code> - 形式为 
              <code>(CT1 ct1, ..., CTn ctn, T newValue)</code>的签名多态参数列表，使用varargs静态表示。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果此VarHandle不支持访问模式。 
             </dd> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果访问模式类型与调用者的符号类型描述符不匹配。 
             </dd> 
             <dd> 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果访问模式类型与调用者的符号类型描述符匹配，但引用 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code>失败。 
             </dd> 
            </dl> </li> 
          </ul> <a id="compareAndSet(java.lang.Object...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>compareAndSet</h4> <pre class="methodSignature">public final&nbsp;boolean&nbsp;compareAndSet​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</pre> 
            <div class="block"> 
             <span>以原子方式设置的变量的值<code>newValue</code>用的存储器语义<a href="#setVolatile(java.lang.Object...)"><code>setVolatile(java.lang.Object...)</code></a>如果该变量的当前值，被称为<em>证人值</em> ， <code>==</code>的<code>expectedValue</code> ，与的存储器访问语义<a href="#getVolatile(java.lang.Object...)"><code>getVolatile(java.lang.Object...)</code></a> 。</span> 
             <p> <span>方法签名的格式为<code>(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)boolean</code> 。</span> </p> 
             <p> <span>呼叫站点<code>compareAndSet</code>处的符号类型描述符必须与在此VarHandle上调用<code>accessModeType(VarHandle.AccessMode.COMPARE_AND_SET)</code>的结果的访问模式类型匹配。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>args</code> - 形式为 
              <code>(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)</code>的签名多态参数列表，使用varargs静态表示。 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>true</code>如果成功，否则 
              <code>false</code>如果见证值与 
              <code>expectedValue</code> 。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果此VarHandle不支持访问模式。 
             </dd> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果访问模式类型与调用者的符号类型描述符不匹配。 
             </dd> 
             <dd> 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果访问模式类型与调用者的符号类型描述符匹配，但引用 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code>失败。 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#setVolatile(java.lang.Object...)"><code>setVolatile(Object...)</code></a> ， 
              <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(Object...)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="compareAndExchange(java.lang.Object...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>compareAndExchange</h4> <pre class="methodSignature">public final&nbsp;<a href="../Object.html" title="class in java.lang">Object</a>&nbsp;compareAndExchange​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</pre> 
            <div class="block"> 
             <span>以原子方式设置的变量的值<code>newValue</code>用的存储器语义<a href="#setVolatile(java.lang.Object...)"><code>setVolatile(java.lang.Object...)</code></a>如果该变量的当前值，被称为<em>证人值</em> ， <code>==</code>的<code>expectedValue</code> ，与的存储器访问语义<a href="#getVolatile(java.lang.Object...)"><code>getVolatile(java.lang.Object...)</code></a> 。</span> 
             <p> <span>方法签名的格式为<code>(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)T</code> 。</span> </p> 
             <p> <span>调用站点<code>compareAndExchange</code>处的符号类型描述符必须与在此VarHandle上调用<code>accessModeType(VarHandle.AccessMode.COMPARE_AND_EXCHANGE)</code>的结果的访问模式类型匹配。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>args</code> - 形式为 
              <code>(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)</code>的签名多态参数列表，使用varargs静态表示。 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               签名多态结果即见证值，如果成功则与 
              <code>expectedValue</code>相同，使用 
              <code>Object</code>静态表示。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果此VarHandle不支持访问模式。 
             </dd> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果访问模式类型与调用者的符号类型描述符不兼容。 
             </dd> 
             <dd> 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果访问模式类型与调用者的符号类型描述符兼容，但引用 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code>失败。 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#setVolatile(java.lang.Object...)"><code>setVolatile(Object...)</code></a> ， 
              <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(Object...)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="compareAndExchangeAcquire(java.lang.Object...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>compareAndExchangeAcquire</h4> <pre class="methodSignature">public final&nbsp;<a href="../Object.html" title="class in java.lang">Object</a>&nbsp;compareAndExchangeAcquire​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</pre> 
            <div class="block"> 
             <span>以原子方式设置的变量的值<code>newValue</code>用的存储器语义<a href="#set(java.lang.Object...)"><code>set(java.lang.Object...)</code></a>如果该变量的当前值，被称为<em>证人值</em> ， <code>==</code>的<code>expectedValue</code> ，与的存储器访问语义<a href="#getAcquire(java.lang.Object...)"><code>getAcquire(java.lang.Object...)</code></a> 。</span> 
             <p> <span>方法签名的格式为<code>(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)T</code> 。</span> </p> 
             <p> <span>呼叫站点<code>compareAndExchangeAcquire</code>处的符号类型描述符必须与在此VarHandle上调用<code>accessModeType(VarHandle.AccessMode.COMPARE_AND_EXCHANGE_ACQUIRE)</code>的结果的访问模式类型匹配。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>args</code> - 形式 
              <code>(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)</code>的签名多态参数列表，使用varargs静态表示。 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               签名多态结果即见证值，如果成功则与 
              <code>expectedValue</code>相同，使用 
              <code>Object</code>静态表示。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果此VarHandle不支持访问模式。 
             </dd> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果访问模式类型与调用者的符号类型描述符不匹配。 
             </dd> 
             <dd> 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果访问模式类型与调用者的符号类型描述符匹配，但引用 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code>失败。 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#set(java.lang.Object...)"><code>set(Object...)</code></a> ， 
              <a href="#getAcquire(java.lang.Object...)"><code>getAcquire(Object...)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="compareAndExchangeRelease(java.lang.Object...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>compareAndExchangeRelease</h4> <pre class="methodSignature">public final&nbsp;<a href="../Object.html" title="class in java.lang">Object</a>&nbsp;compareAndExchangeRelease​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</pre> 
            <div class="block"> 
             <span>以原子方式设置的变量的值<code>newValue</code>用的存储器语义<a href="#setRelease(java.lang.Object...)"><code>setRelease(java.lang.Object...)</code></a>如果该变量的当前值，被称为<em>证人值</em> ， <code>==</code>的<code>expectedValue</code> ，与的存储器访问语义<a href="#get(java.lang.Object...)"><code>get(java.lang.Object...)</code></a> 。</span> 
             <p> <span>方法签名的格式为<code>(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)T</code> 。</span> </p> 
             <p> <span>调用站点<code>compareAndExchangeRelease</code>处的符号类型描述符必须与在此VarHandle上调用<code>accessModeType(VarHandle.AccessMode.COMPARE_AND_EXCHANGE_RELEASE)</code>的结果的访问模式类型匹配。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>args</code> - 形式 
              <code>(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)</code>的签名多态参数列表，使用varargs静态表示。 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               作为见证值的签名多态结果，如果成功则与 
              <code>expectedValue</code>相同，使用 
              <code>Object</code>静态表示。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果此VarHandle不支持访问模式。 
             </dd> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果访问模式类型与调用者的符号类型描述符不匹配。 
             </dd> 
             <dd> 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果访问模式类型与调用者的符号类型描述符匹配，但引用转换失败。 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#setRelease(java.lang.Object...)"><code>setRelease(Object...)</code></a> ， 
              <a href="#get(java.lang.Object...)"><code>get(Object...)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="weakCompareAndSetPlain(java.lang.Object...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>weakCompareAndSetPlain</h4> <pre class="methodSignature">public final&nbsp;boolean&nbsp;weakCompareAndSetPlain​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</pre> 
            <div class="block"> 
             <span>可能原子将变量到值<code>newValue</code>用的语义<a href="#set(java.lang.Object...)"><code>set(java.lang.Object...)</code></a>如果变量的当前值，被称为<em>证人值</em> ， <code>==</code>的<code>expectedValue</code> ，与的存储器访问语义<a href="#get(java.lang.Object...)"><code>get(java.lang.Object...)</code></a> 。</span> 
             <p> <span>即使见证值与预期值匹配，此操作也可能是虚假失败（通常是由于内存争用）。</span> </p> 
             <p> <span>方法签名的格式为<code>(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)boolean</code> 。</span> </p> 
             <p> <span>调用站点<code>weakCompareAndSetPlain</code>处的符号类型描述符必须与在此VarHandle上调用<code>accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET_PLAIN)</code>的结果的访问模式类型匹配。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>args</code> - 形式为 
              <code>(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)</code>的签名多态参数列表，使用varargs静态表示。 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>true</code>如果成功，否则 
              <code>false</code>如果见证值与 
              <code>expectedValue</code>或者此操作虚假失败。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果此VarHandle不支持访问模式。 
             </dd> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果访问模式类型与调用者的符号类型描述符不匹配。 
             </dd> 
             <dd> 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果访问模式类型与调用者的符号类型描述符匹配，但引用 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code>失败。 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#set(java.lang.Object...)"><code>set(Object...)</code></a> ， 
              <a href="#get(java.lang.Object...)"><code>get(Object...)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="weakCompareAndSet(java.lang.Object...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>weakCompareAndSet</h4> <pre class="methodSignature">public final&nbsp;boolean&nbsp;weakCompareAndSet​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</pre> 
            <div class="block"> 
             <span>可能原子将变量到值<code>newValue</code>用的存储器语义<a href="#setVolatile(java.lang.Object...)"><code>setVolatile(java.lang.Object...)</code></a>如果该变量的当前值，被称为<em>证人值</em> ， <code>==</code>的<code>expectedValue</code> ，与的存储器访问语义<a href="#getVolatile(java.lang.Object...)"><code>getVolatile(java.lang.Object...)</code></a> 。</span> 
             <p> <span>即使见证值与预期值匹配，此操作也可能是虚假失败（通常是由于内存争用）。</span> </p> 
             <p> <span>方法签名的格式为<code>(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)boolean</code> 。</span> </p> 
             <p> <span>调用站点<code>weakCompareAndSet</code>处的符号类型描述符必须与在此VarHandle上调用<code>accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET)</code>的结果的访问模式类型匹配。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>args</code> - 形式为 
              <code>(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)</code>的签名多态参数列表，使用varargs静态表示。 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>true</code>如果成功，否则 
              <code>false</code>如果见证值与 
              <code>expectedValue</code>或者此操作虚假失败。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果此VarHandle不支持访问模式。 
             </dd> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果访问模式类型与调用者的符号类型描述符不匹配。 
             </dd> 
             <dd> 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果访问模式类型与调用者的符号类型描述符匹配，但引用 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code>失败。 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#setVolatile(java.lang.Object...)"><code>setVolatile(Object...)</code></a> ， 
              <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(Object...)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="weakCompareAndSetAcquire(java.lang.Object...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>weakCompareAndSetAcquire</h4> <pre class="methodSignature">public final&nbsp;boolean&nbsp;weakCompareAndSetAcquire​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</pre> 
            <div class="block"> 
             <span>可能原子将变量到值<code>newValue</code>用的语义<a href="#set(java.lang.Object...)"><code>set(java.lang.Object...)</code></a>如果变量的当前值，被称为<em>证人值</em> ， <code>==</code>的<code>expectedValue</code> ，与的存储器访问语义<a href="#getAcquire(java.lang.Object...)"><code>getAcquire(java.lang.Object...)</code></a> 。</span> 
             <p> <span>即使见证值与预期值匹配，此操作也可能是虚假失败（通常是由于内存争用）。</span> </p> 
             <p> <span>方法签名的格式为<code>(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)boolean</code> 。</span> </p> 
             <p> <span>调用站点<code>weakCompareAndSetAcquire</code>处的符号类型描述符必须与访问模式类型匹配，该访问模式类型是在此VarHandle上调用<code>accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET_ACQUIRE)</code>的结果。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>args</code> - 形式 
              <code>(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)</code>的签名多态参数列表，使用varargs静态表示。 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>true</code>如果成功，否则 
              <code>false</code>如果见证值与 
              <code>expectedValue</code>或者此操作虚假失败。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果此VarHandle不支持访问模式。 
             </dd> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果访问模式类型与调用者的符号类型描述符不匹配。 
             </dd> 
             <dd> 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果访问模式类型与调用者的符号类型描述符匹配，但引用 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code>失败。 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#set(java.lang.Object...)"><code>set(Object...)</code></a> ， 
              <a href="#getAcquire(java.lang.Object...)"><code>getAcquire(Object...)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="weakCompareAndSetRelease(java.lang.Object...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>weakCompareAndSetRelease</h4> <pre class="methodSignature">public final&nbsp;boolean&nbsp;weakCompareAndSetRelease​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</pre> 
            <div class="block"> 
             <span>可能原子将变量到值<code>newValue</code>用的语义<a href="#setRelease(java.lang.Object...)"><code>setRelease(java.lang.Object...)</code></a>如果变量的当前值，被称为<em>证人值</em> ， <code>==</code>的<code>expectedValue</code> ，与的存储器访问语义<a href="#get(java.lang.Object...)"><code>get(java.lang.Object...)</code></a> 。</span> 
             <p> <span>即使见证值与预期值匹配，此操作也可能是虚假失败（通常是由于内存争用）。</span> </p> 
             <p> <span>方法签名的格式为<code>(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)boolean</code> 。</span> </p> 
             <p> <span>呼叫站点<code>weakCompareAndSetRelease</code>处的符号类型描述符必须与在此VarHandle上调用<code>accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET_RELEASE)</code>的结果的访问模式类型匹配。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>args</code> - 形式 
              <code>(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)</code>的签名多态参数列表，使用varargs静态表示。 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>true</code>如果成功，否则 
              <code>false</code>如果见证值与 
              <code>expectedValue</code>或者此操作虚假失败。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果此VarHandle不支持访问模式。 
             </dd> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果访问模式类型与调用者的符号类型描述符不匹配。 
             </dd> 
             <dd> 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果访问模式类型与调用者的符号类型描述符匹配，但引用 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code>失败。 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#setRelease(java.lang.Object...)"><code>setRelease(Object...)</code></a> ， 
              <a href="#get(java.lang.Object...)"><code>get(Object...)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getAndSet(java.lang.Object...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getAndSet</h4> <pre class="methodSignature">public final&nbsp;<a href="../Object.html" title="class in java.lang">Object</a>&nbsp;getAndSet​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</pre> 
            <div class="block"> 
             <span>以原子方式将变量的值设置为<code>newValue</code> ，内存语义为<a href="#setVolatile(java.lang.Object...)"><code>setVolatile(java.lang.Object...)</code>，</a>并返回变量的先前值，如内存语义<a href="#getVolatile(java.lang.Object...)"><code>getVolatile(java.lang.Object...)</code>所示</a> 。</span> 
             <p> <span>方法签名的格式为<code>(CT1 ct1, ..., CTn ctn, T newValue)T</code> 。</span> </p> 
             <p> <span>呼叫站点<code>getAndSet</code>处的符号类型描述符必须与在此VarHandle上调用<code>accessModeType(VarHandle.AccessMode.GET_AND_SET)</code>的结果的访问模式类型匹配。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>args</code> - 形式为 
              <code>(CT1 ct1, ..., CTn ctn, T newValue)</code>的签名多态参数列表，使用varargs静态表示。 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               签名 - 多态结果，即变量的先前值，使用 
              <code>Object</code>静态表示。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果此VarHandle不支持访问模式。 
             </dd> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果访问模式类型与调用者的符号类型描述符不匹配。 
             </dd> 
             <dd> 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果访问模式类型与调用者的符号类型描述符匹配，但引用转换失败。 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#setVolatile(java.lang.Object...)"><code>setVolatile(Object...)</code></a> ， 
              <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(Object...)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getAndSetAcquire(java.lang.Object...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getAndSetAcquire</h4> <pre class="methodSignature">public final&nbsp;<a href="../Object.html" title="class in java.lang">Object</a>&nbsp;getAndSetAcquire​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</pre> 
            <div class="block"> 
             <span>以原子方式将变量的值设置为<code>newValue</code> ，内存语义为<a href="#set(java.lang.Object...)"><code>set(java.lang.Object...)</code>，</a>并返回变量的先前值，如内存语义<a href="#getAcquire(java.lang.Object...)"><code>getAcquire(java.lang.Object...)</code>所示</a> 。</span> 
             <p> <span>方法签名的格式为<code>(CT1 ct1, ..., CTn ctn, T newValue)T</code> 。</span> </p> 
             <p> <span>呼叫站点<code>getAndSetAcquire</code>处的符号类型描述符必须与在此VarHandle上调用<code>accessModeType(VarHandle.AccessMode.GET_AND_SET_ACQUIRE)</code>的结果的访问模式类型匹配。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>args</code> - 形式 
              <code>(CT1 ct1, ..., CTn ctn, T newValue)</code>的签名多态参数列表，使用varargs静态表示。 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               签名 - 多态结果，即变量的先前值，使用 
              <code>Object</code>静态表示。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果此VarHandle不支持访问模式。 
             </dd> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果访问模式类型与调用者的符号类型描述符不匹配。 
             </dd> 
             <dd> 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果访问模式类型与调用者的符号类型描述符匹配，但引用 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code>失败。 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#setVolatile(java.lang.Object...)"><code>setVolatile(Object...)</code></a> ， 
              <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(Object...)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getAndSetRelease(java.lang.Object...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getAndSetRelease</h4> <pre class="methodSignature">public final&nbsp;<a href="../Object.html" title="class in java.lang">Object</a>&nbsp;getAndSetRelease​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</pre> 
            <div class="block"> 
             <span>以原子方式将变量的值设置为<code>newValue</code> ，内存语义为<a href="#setRelease(java.lang.Object...)"><code>setRelease(java.lang.Object...)</code>，</a>并返回变量的先前值，如内存语义<a href="#get(java.lang.Object...)"><code>get(java.lang.Object...)</code>所示</a> 。</span> 
             <p> <span>方法签名的格式为<code>(CT1 ct1, ..., CTn ctn, T newValue)T</code> 。</span> </p> 
             <p> <span>调用站点<code>getAndSetRelease</code>处的符号类型描述符必须与在此VarHandle上调用<code>accessModeType(VarHandle.AccessMode.GET_AND_SET_RELEASE)</code>的访问模式类型匹配。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>args</code> - 形式 
              <code>(CT1 ct1, ..., CTn ctn, T newValue)</code>的签名多态参数列表，使用varargs静态表示。 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               签名 - 多态结果，即变量的先前值，使用 
              <code>Object</code>静态表示。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果此VarHandle不支持访问模式。 
             </dd> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果访问模式类型与调用者的符号类型描述符不匹配。 
             </dd> 
             <dd> 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果访问模式类型与调用者的符号类型描述符匹配，但引用 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code>失败。 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#setVolatile(java.lang.Object...)"><code>setVolatile(Object...)</code></a> ， 
              <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(Object...)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getAndAdd(java.lang.Object...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getAndAdd</h4> <pre class="methodSignature">public final&nbsp;<a href="../Object.html" title="class in java.lang">Object</a>&nbsp;getAndAdd​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</pre> 
            <div class="block"> 
             <span>原子地将<code>value</code>添加到变量的当前值，其内存语义为<a href="#setVolatile(java.lang.Object...)"><code>setVolatile(java.lang.Object...)</code></a> ，并返回变量的先前值，如内存语义<a href="#getVolatile(java.lang.Object...)"><code>getVolatile(java.lang.Object...)</code>所示</a> 。</span> 
             <p> <span>方法签名的格式为<code>(CT1 ct1, ..., CTn ctn, T value)T</code> 。</span> </p> 
             <p> <span>呼叫站点<code>getAndAdd</code>处的符号类型描述符必须与在此VarHandle上调用<code>accessModeType(VarHandle.AccessMode.GET_AND_ADD)</code>的结果的访问模式类型匹配。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>args</code> - 形式为 
              <code>(CT1 ct1, ..., CTn ctn, T value)</code>的签名多态参数列表，使用varargs静态表示。 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               签名 - 多态结果，即变量的先前值，使用 
              <code>Object</code>静态表示。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果此VarHandle不支持访问模式。 
             </dd> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果访问模式类型与调用者的符号类型描述符不匹配。 
             </dd> 
             <dd> 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果访问模式类型与调用者的符号类型描述符匹配，但引用 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code>失败。 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#setVolatile(java.lang.Object...)"><code>setVolatile(Object...)</code></a> ， 
              <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(Object...)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getAndAddAcquire(java.lang.Object...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getAndAddAcquire</h4> <pre class="methodSignature">public final&nbsp;<a href="../Object.html" title="class in java.lang">Object</a>&nbsp;getAndAddAcquire​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</pre> 
            <div class="block"> 
             <span>原子地将<code>value</code>添加到变量的当前值，其内存语义为<a href="#set(java.lang.Object...)"><code>set(java.lang.Object...)</code></a> ，并返回变量的先前值，如使用<a href="#getAcquire(java.lang.Object...)"><code>getAcquire(java.lang.Object...)</code></a>的内存语义访问的<a href="#getAcquire(java.lang.Object...)">那样</a> 。</span> 
             <p> <span>方法签名的格式为<code>(CT1 ct1, ..., CTn ctn, T value)T</code> 。</span> </p> 
             <p> <span>呼叫站点<code>getAndAddAcquire</code>处的符号类型描述符必须与在此VarHandle上调用<code>accessModeType(VarHandle.AccessMode.GET_AND_ADD_ACQUIRE)</code>的结果的访问模式类型匹配。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>args</code> - 形式 
              <code>(CT1 ct1, ..., CTn ctn, T value)</code>的签名多态参数列表，使用varargs静态表示。 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               签名 - 多态结果，即变量的先前值，使用 
              <code>Object</code>静态表示。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果此VarHandle不支持访问模式。 
             </dd> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果访问模式类型与调用者的符号类型描述符不匹配。 
             </dd> 
             <dd> 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果访问模式类型与调用者的符号类型描述符匹配，但引用 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code>失败。 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#setVolatile(java.lang.Object...)"><code>setVolatile(Object...)</code></a> ， 
              <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(Object...)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getAndAddRelease(java.lang.Object...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getAndAddRelease</h4> <pre class="methodSignature">public final&nbsp;<a href="../Object.html" title="class in java.lang">Object</a>&nbsp;getAndAddRelease​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</pre> 
            <div class="block"> 
             <span>原子地将<code>value</code>添加到变量的当前值，其内存语义为<a href="#setRelease(java.lang.Object...)"><code>setRelease(java.lang.Object...)</code></a> ，并返回变量的先前值，如内存语义<a href="#get(java.lang.Object...)"><code>get(java.lang.Object...)</code>所示</a> 。</span> 
             <p> <span>方法签名的格式为<code>(CT1 ct1, ..., CTn ctn, T value)T</code> 。</span> </p> 
             <p> <span>呼叫站点<code>getAndAddRelease</code>处的符号类型描述符必须与在此VarHandle上调用<code>accessModeType(VarHandle.AccessMode.GET_AND_ADD_RELEASE)</code>的结果的访问模式类型匹配。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>args</code> - 形式 
              <code>(CT1 ct1, ..., CTn ctn, T value)</code>的签名多态参数列表，使用varargs静态表示。 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               签名 - 多态结果，即变量的先前值，使用 
              <code>Object</code>静态表示。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果此VarHandle不支持访问模式。 
             </dd> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果访问模式类型与调用者的符号类型描述符不匹配。 
             </dd> 
             <dd> 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果访问模式类型与调用者的符号类型描述符匹配，但引用 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code>失败。 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#setVolatile(java.lang.Object...)"><code>setVolatile(Object...)</code></a> ， 
              <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(Object...)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getAndBitwiseOr(java.lang.Object...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getAndBitwiseOr</h4> <pre class="methodSignature">public final&nbsp;<a href="../Object.html" title="class in java.lang">Object</a>&nbsp;getAndBitwiseOr​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</pre> 
            <div class="block"> 
             <span>原子地将变量的值设置为变量的当前值与<code>mask</code>之间的按位OR结果，内存语义为<a href="#setVolatile(java.lang.Object...)"><code>setVolatile(java.lang.Object...)</code>，</a>并返回变量的先前值，如内存语义<a href="#getVolatile(java.lang.Object...)"><code>getVolatile(java.lang.Object...)</code>所示</a> 。</span> 
             <p> <span>如果变量类型是非整数<code>boolean</code>类型，则执行逻辑OR而不是按位OR。</span> </p> 
             <p> <span>方法签名的格式为<code>(CT1 ct1, ..., CTn ctn, T mask)T</code> 。</span> </p> 
             <p> <span>呼叫站点<code>getAndBitwiseOr</code>处的符号类型描述符必须与在此VarHandle上调用<code>accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_OR)</code>的结果的访问模式类型匹配。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>args</code> - 形式为 
              <code>(CT1 ct1, ..., CTn ctn, T mask)</code>的签名多态参数列表，使用varargs静态表示。 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               签名 - 多态结果，即变量的先前值，使用 
              <code>Object</code>静态表示。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果此VarHandle不支持访问模式。 
             </dd> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果访问模式类型与调用者的符号类型描述符不匹配。 
             </dd> 
             <dd> 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果访问模式类型与调用者的符号类型描述符匹配，但引用 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code>失败。 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#setVolatile(java.lang.Object...)"><code>setVolatile(Object...)</code></a> ， 
              <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(Object...)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getAndBitwiseOrAcquire(java.lang.Object...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getAndBitwiseOrAcquire</h4> <pre class="methodSignature">public final&nbsp;<a href="../Object.html" title="class in java.lang">Object</a>&nbsp;getAndBitwiseOrAcquire​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</pre> 
            <div class="block"> 
             <span>原子地将变量的值设置为变量的当前值与<code>mask</code>之间的按位OR结果，其内存语义为<a href="#set(java.lang.Object...)"><code>set(java.lang.Object...)</code>，</a>并返回变量的先前值，如内存语义<a href="#getAcquire(java.lang.Object...)"><code>getAcquire(java.lang.Object...)</code>所示</a> 。</span> 
             <p> <span>如果变量类型是非整数<code>boolean</code>类型，则执行逻辑OR而不是按位OR。</span> </p> 
             <p> <span>方法签名的格式为<code>(CT1 ct1, ..., CTn ctn, T mask)T</code> 。</span> </p> 
             <p> <span>呼叫站点<code>getAndBitwiseOrAcquire</code>处的符号类型描述符必须与在此VarHandle上调用<code>accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_OR_ACQUIRE)</code>的结果的访问模式类型匹配。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>args</code> - 形式 
              <code>(CT1 ct1, ..., CTn ctn, T mask)</code>的签名多态参数列表，使用varargs静态表示。 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               签名 - 多态结果，即变量的先前值，使用 
              <code>Object</code>静态表示。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果此VarHandle不支持访问模式。 
             </dd> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果访问模式类型与调用者的符号类型描述符不匹配。 
             </dd> 
             <dd> 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果访问模式类型与调用者的符号类型描述符匹配，但引用 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code>失败。 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#set(java.lang.Object...)"><code>set(Object...)</code></a> ， 
              <a href="#getAcquire(java.lang.Object...)"><code>getAcquire(Object...)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getAndBitwiseOrRelease(java.lang.Object...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getAndBitwiseOrRelease</h4> <pre class="methodSignature">public final&nbsp;<a href="../Object.html" title="class in java.lang">Object</a>&nbsp;getAndBitwiseOrRelease​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</pre> 
            <div class="block"> 
             <span>原子地将变量的值设置为变量的当前值与<code>mask</code>之间的按位OR结果，其内存语义为<a href="#setRelease(java.lang.Object...)"><code>setRelease(java.lang.Object...)</code>，</a>并返回变量的先前值，如内存语义<a href="#get(java.lang.Object...)"><code>get(java.lang.Object...)</code>所示</a> 。</span> 
             <p> <span>如果变量类型是非整数<code>boolean</code>类型，则执行逻辑OR而不是按位OR。</span> </p> 
             <p> <span>方法签名的格式为<code>(CT1 ct1, ..., CTn ctn, T mask)T</code> 。</span> </p> 
             <p> <span>调用站点<code>getAndBitwiseOrRelease</code>处的符号类型描述符必须与在此VarHandle上调用<code>accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_OR_RELEASE)</code>的结果的访问模式类型匹配。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>args</code> - 形式 
              <code>(CT1 ct1, ..., CTn ctn, T mask)</code>的签名多态参数列表，使用varargs静态表示。 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               签名 - 多态结果，即变量的先前值，使用 
              <code>Object</code>静态表示。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果此VarHandle不支持访问模式。 
             </dd> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果访问模式类型与调用者的符号类型描述符不匹配。 
             </dd> 
             <dd> 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果访问模式类型与调用者的符号类型描述符匹配，但引用 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code>失败。 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#setRelease(java.lang.Object...)"><code>setRelease(Object...)</code></a> ， 
              <a href="#get(java.lang.Object...)"><code>get(Object...)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getAndBitwiseAnd(java.lang.Object...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getAndBitwiseAnd</h4> <pre class="methodSignature">public final&nbsp;<a href="../Object.html" title="class in java.lang">Object</a>&nbsp;getAndBitwiseAnd​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</pre> 
            <div class="block"> 
             <span>原子地将变量的值设置为变量的当前值与<code>mask</code>之间的按位AND结果，内存语义为<a href="#setVolatile(java.lang.Object...)"><code>setVolatile(java.lang.Object...)</code>，</a>并返回变量的先前值，如内存语义<a href="#getVolatile(java.lang.Object...)"><code>getVolatile(java.lang.Object...)</code>所示</a> 。</span> 
             <p> <span>如果变量类型是非整数<code>boolean</code>类型，则执行逻辑AND而不是按位AND。</span> </p> 
             <p> <span>方法签名的格式为<code>(CT1 ct1, ..., CTn ctn, T mask)T</code> 。</span> </p> 
             <p> <span>呼叫站点<code>getAndBitwiseAnd</code>处的符号类型描述符必须与在此VarHandle上调用<code>accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_AND)</code>的结果的访问模式类型匹配。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>args</code> - 形式 
              <code>(CT1 ct1, ..., CTn ctn, T mask)</code>的签名多态参数列表，使用varargs静态表示。 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               签名 - 多态结果，即变量的先前值，使用 
              <code>Object</code>静态表示。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果此VarHandle不支持访问模式。 
             </dd> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果访问模式类型与调用者的符号类型描述符不匹配。 
             </dd> 
             <dd> 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果访问模式类型与调用者的符号类型描述符匹配，但引用 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code>失败。 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#setVolatile(java.lang.Object...)"><code>setVolatile(Object...)</code></a> ， 
              <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(Object...)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getAndBitwiseAndAcquire(java.lang.Object...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getAndBitwiseAndAcquire</h4> <pre class="methodSignature">public final&nbsp;<a href="../Object.html" title="class in java.lang">Object</a>&nbsp;getAndBitwiseAndAcquire​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</pre> 
            <div class="block"> 
             <span>原子地将变量的值设置为变量的当前值与<code>mask</code>之间的按位AND结果，内存语义为<a href="#set(java.lang.Object...)"><code>set(java.lang.Object...)</code>，</a>并返回变量的先前值，如内存语义<a href="#getAcquire(java.lang.Object...)"><code>getAcquire(java.lang.Object...)</code>所示</a> 。</span> 
             <p> <span>如果变量类型是非整数<code>boolean</code>类型，则执行逻辑AND而不是按位AND。</span> </p> 
             <p> <span>方法签名的格式为<code>(CT1 ct1, ..., CTn ctn, T mask)T</code> 。</span> </p> 
             <p> <span>调用站点<code>getAndBitwiseAndAcquire</code>处的符号类型描述符必须与在此VarHandle上调用<code>accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_AND_ACQUIRE)</code>的结果的访问模式类型匹配。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>args</code> - 形式为 
              <code>(CT1 ct1, ..., CTn ctn, T mask)</code>的签名多态参数列表，使用varargs静态表示。 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               签名 - 多态结果，即变量的先前值，使用 
              <code>Object</code>静态表示。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果此VarHandle不支持访问模式。 
             </dd> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果访问模式类型与调用者的符号类型描述符不匹配。 
             </dd> 
             <dd> 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果访问模式类型与调用者的符号类型描述符匹配，但引用 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code>失败。 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#set(java.lang.Object...)"><code>set(Object...)</code></a> ， 
              <a href="#getAcquire(java.lang.Object...)"><code>getAcquire(Object...)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getAndBitwiseAndRelease(java.lang.Object...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getAndBitwiseAndRelease</h4> <pre class="methodSignature">public final&nbsp;<a href="../Object.html" title="class in java.lang">Object</a>&nbsp;getAndBitwiseAndRelease​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</pre> 
            <div class="block"> 
             <span>原子地将变量的值设置为变量的当前值与<code>mask</code>之间的按位AND结果，其内存语义为<a href="#setRelease(java.lang.Object...)"><code>setRelease(java.lang.Object...)</code>，</a>并返回变量的先前值，如内存语义<a href="#get(java.lang.Object...)"><code>get(java.lang.Object...)</code>所示</a> 。</span> 
             <p> <span>如果变量类型是非整数<code>boolean</code>类型，则执行逻辑AND而不是按位AND。</span> </p> 
             <p> <span>方法签名的格式为<code>(CT1 ct1, ..., CTn ctn, T mask)T</code> 。</span> </p> 
             <p> <span>调用站点<code>getAndBitwiseAndRelease</code>处的符号类型描述符必须与访问模式类型匹配，该访问模式类型是在此VarHandle上调用<code>accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_AND_RELEASE)</code>的结果。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>args</code> - 形式为 
              <code>(CT1 ct1, ..., CTn ctn, T mask)</code>的签名多态参数列表，使用varargs静态表示。 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               签名 - 多态结果，即变量的先前值，使用 
              <code>Object</code>静态表示。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果此VarHandle不支持访问模式。 
             </dd> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果访问模式类型与调用者的符号类型描述符不匹配。 
             </dd> 
             <dd> 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果访问模式类型与调用者的符号类型描述符匹配，但引用 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code>失败。 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#setRelease(java.lang.Object...)"><code>setRelease(Object...)</code></a> ， 
              <a href="#get(java.lang.Object...)"><code>get(Object...)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getAndBitwiseXor(java.lang.Object...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getAndBitwiseXor</h4> <pre class="methodSignature">public final&nbsp;<a href="../Object.html" title="class in java.lang">Object</a>&nbsp;getAndBitwiseXor​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</pre> 
            <div class="block"> 
             <span>原子地将变量的值设置为变量的当前值与<code>mask</code>之间的按位异或结果，其内存语义为<a href="#setVolatile(java.lang.Object...)"><code>setVolatile(java.lang.Object...)</code>，</a>并返回变量的先前值，如内存语义<a href="#getVolatile(java.lang.Object...)"><code>getVolatile(java.lang.Object...)</code>所示</a> 。</span> 
             <p> <span>如果变量类型是非整数<code>boolean</code>类型，则执行逻辑XOR而不是按位异或。</span> </p> 
             <p> <span>方法签名的格式为<code>(CT1 ct1, ..., CTn ctn, T mask)T</code> 。</span> </p> 
             <p> <span>调用站点<code>getAndBitwiseXor</code>处的符号类型描述符必须与在此VarHandle上调用<code>accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_XOR)</code>的结果的访问模式类型匹配。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>args</code> - 形式为 
              <code>(CT1 ct1, ..., CTn ctn, T mask)</code>的签名多态参数列表，使用varargs静态表示。 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               签名 - 多态结果，即变量的先前值，使用 
              <code>Object</code>静态表示。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果此VarHandle不支持访问模式。 
             </dd> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果访问模式类型与调用者的符号类型描述符不匹配。 
             </dd> 
             <dd> 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果访问模式类型与调用者的符号类型描述符匹配，但引用 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code>失败。 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#setVolatile(java.lang.Object...)"><code>setVolatile(Object...)</code></a> ， 
              <a href="#getVolatile(java.lang.Object...)"><code>getVolatile(Object...)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getAndBitwiseXorAcquire(java.lang.Object...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getAndBitwiseXorAcquire</h4> <pre class="methodSignature">public final&nbsp;<a href="../Object.html" title="class in java.lang">Object</a>&nbsp;getAndBitwiseXorAcquire​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</pre> 
            <div class="block"> 
             <span>原子地将变量的值设置为变量的当前值与<code>mask</code>之间的按位异或结果，其内存语义为<a href="#set(java.lang.Object...)"><code>set(java.lang.Object...)</code>，</a>并返回变量的先前值，如内存语义<a href="#getAcquire(java.lang.Object...)"><code>getAcquire(java.lang.Object...)</code>所示</a> 。</span> 
             <p> <span>如果变量类型是非整数<code>boolean</code>类型，则执行逻辑XOR而不是按位异或。</span> </p> 
             <p> <span>方法签名的格式为<code>(CT1 ct1, ..., CTn ctn, T mask)T</code> 。</span> </p> 
             <p> <span>调用站点<code>getAndBitwiseXorAcquire</code>处的符号类型描述符必须与访问模式类型匹配，该访问模式类型是在此VarHandle上调用<code>accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_XOR_ACQUIRE)</code>的结果。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>args</code> - 形式 
              <code>(CT1 ct1, ..., CTn ctn, T mask)</code>的签名多态参数列表，使用varargs静态表示。 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               签名 - 多态结果，即变量的先前值，使用 
              <code>Object</code>静态表示。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果此VarHandle不支持访问模式。 
             </dd> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果访问模式类型与调用者的符号类型描述符不匹配。 
             </dd> 
             <dd> 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果访问模式类型与调用者的符号类型描述符匹配，但引用 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code>失败。 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#set(java.lang.Object...)"><code>set(Object...)</code></a> ， 
              <a href="#getAcquire(java.lang.Object...)"><code>getAcquire(Object...)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getAndBitwiseXorRelease(java.lang.Object...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getAndBitwiseXorRelease</h4> <pre class="methodSignature">public final&nbsp;<a href="../Object.html" title="class in java.lang">Object</a>&nbsp;getAndBitwiseXorRelease​(<a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;args)</pre> 
            <div class="block"> 
             <span>原子地将变量的值设置为变量的当前值与<code>mask</code>之间的按位异或结果，其内存语义为<a href="#setRelease(java.lang.Object...)"><code>setRelease(java.lang.Object...)</code>，</a>并返回变量的先前值，如内存语义<a href="#get(java.lang.Object...)"><code>get(java.lang.Object...)</code>所示</a> 。</span> 
             <p> <span>如果变量类型是非整数<code>boolean</code>类型，则执行逻辑XOR而不是按位异或。</span> </p> 
             <p> <span>方法签名的格式为<code>(CT1 ct1, ..., CTn ctn, T mask)T</code> 。</span> </p> 
             <p> <span>调用站点<code>getAndBitwiseXorRelease</code>处的符号类型描述符必须与访问模式类型匹配，该访问模式类型是在此VarHandle上调用<code>accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_XOR_RELEASE)</code>的结果。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>args</code> - 形式 
              <code>(CT1 ct1, ..., CTn ctn, T mask)</code>的签名多态参数列表，使用varargs静态表示。 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               签名 - 多态结果，即变量的先前值，使用 
              <code>Object</code>静态表示。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果此VarHandle不支持访问模式。 
             </dd> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果访问模式类型与调用者的符号类型描述符不匹配。 
             </dd> 
             <dd> 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果访问模式类型与调用者的符号类型描述符匹配，但引用 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code>失败。 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#setRelease(java.lang.Object...)"><code>setRelease(Object...)</code></a> ， 
              <a href="#get(java.lang.Object...)"><code>get(Object...)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="varType()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>varType</h4> <pre class="methodSignature">public final&nbsp;<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;varType()</pre> 
            <div class="block">
              返回此VarHandle引用的变量的变量类型。 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此VarHandle引用的变量类型的变量 
             </dd> 
            </dl> </li> 
          </ul> <a id="coordinateTypes()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>coordinateTypes</h4> <pre class="methodSignature">public final&nbsp;<a href="../../util/List.html" title="interface in java.util">List</a>&lt;<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&gt;&nbsp;coordinateTypes()</pre> 
            <div class="block">
              返回此VarHandle的坐标类型。 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <span>此VarHandle的坐标类型。</span> 
              <span>返回的列表是不可修改的</span> 
             </dd> 
            </dl> </li> 
          </ul> <a id="accessModeType(java.lang.invoke.VarHandle.AccessMode)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>accessModeType</h4> <pre class="methodSignature">public final&nbsp;<a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;accessModeType​(<a href="VarHandle.AccessMode.html" title="enum in java.lang.invoke">VarHandle.AccessMode</a>&nbsp;accessMode)</pre> 
            <div class="block"> 
             <span>获得此VarHandle的访问模式类型和给定的访问模式。</span> 
             <p> <span>访问模式类型的参数类型将包含一个前缀，该前缀是此VarHandle的坐标类型，后跟访问模式方法定义的其他类型。</span> <span>访问模式类型的返回类型由访问模式方法的返回类型定义。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>accessMode</code> - 访问模式，对应于同名的签名 - 多态方法 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               给定访问模式的访问模式类型 
             </dd> 
            </dl> </li> 
          </ul> <a id="isAccessModeSupported(java.lang.invoke.VarHandle.AccessMode)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>isAccessModeSupported</h4> <pre class="methodSignature">public final&nbsp;boolean&nbsp;isAccessModeSupported​(<a href="VarHandle.AccessMode.html" title="enum in java.lang.invoke">VarHandle.AccessMode</a>&nbsp;accessMode)</pre> 
            <div class="block"> 
             <span>如果支持给定的访问模式，则返回<code>true</code> ，否则<code>false</code> 。</span> 
             <p> <span>返回给定访问模式的<code>false</code>值表示在调用相应的访问模式方法时抛出<code>UnsupportedOperationException</code> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>accessMode</code> - 访问模式，对应于同名的签名 - 多态方法 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>true</code>如果支持给定的访问模式），否则为 
              <code>false</code> 。 
             </dd> 
            </dl> </li> 
          </ul> <a id="toMethodHandle(java.lang.invoke.VarHandle.AccessMode)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>toMethodHandle</h4> <pre class="methodSignature">public final&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;toMethodHandle​(<a href="VarHandle.AccessMode.html" title="enum in java.lang.invoke">VarHandle.AccessMode</a>&nbsp;accessMode)</pre> 
            <div class="block">
              获取绑定到此VarHandle的方法句柄和给定的访问模式。 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>对于VarHandle <code>vh</code>和访问模式<code>{access-mode}</code> ，此方法返回一个方法句柄，该句柄句柄<code>bmh</code>于以下代码中的方法句柄<code>bmh</code> （尽管它可能更有效）：</span> 
              <pre>  <span><code> MethodHandle mh = MethodHandles.varHandleExactInvoker( vh.accessModeType(VarHandle.AccessMode.{access-mode})); MethodHandle bmh = mh.bindTo(vh); </code></span> </pre> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>accessMode</code> - 访问模式，对应于同名的签名 - 多态方法 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               绑定到此VarHandle的方法句柄和给定的访问模式 
             </dd> 
            </dl> </li> 
          </ul> <a id="fullFence()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>fullFence</h4> <pre class="methodSignature">public static&nbsp;void&nbsp;fullFence()</pre> 
            <div class="block">
              确保围栏之前的装载和存储不会在围栏之后与装载和存储重新排序。 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd>
               忽略C和C ++的许多语义差异，此方法具有与 
              <code>atomic_thread_fence(memory_order_seq_cst)</code>兼容的内存排序效果 
             </dd> 
            </dl> </li> 
          </ul> <a id="acquireFence()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>acquireFence</h4> <pre class="methodSignature">public static&nbsp;void&nbsp;acquireFence()</pre> 
            <div class="block">
              确保栅栏前的载荷不会在栅栏后的载荷和存储中重新排序。 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd>
               忽略C和C ++的许多语义差异，此方法具有与 
              <code>atomic_thread_fence(memory_order_acquire)</code>兼容的内存排序效果 
             </dd> 
            </dl> </li> 
          </ul> <a id="releaseFence()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>releaseFence</h4> <pre class="methodSignature">public static&nbsp;void&nbsp;releaseFence()</pre> 
            <div class="block">
              确保栅栏前的装载和存储不会在栅栏后与存储重新排序。 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd>
               忽略C和C ++的许多语义差异，此方法具有与 
              <code>atomic_thread_fence(memory_order_release)</code>兼容的内存排序效果 
             </dd> 
            </dl> </li> 
          </ul> <a id="loadLoadFence()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>loadLoadFence</h4> <pre class="methodSignature">public static&nbsp;void&nbsp;loadLoadFence()</pre> 
            <div class="block">
              确保栅栏前的载荷不会与栅栏后的载荷重新排序。 
            </div> </li> 
          </ul> <a id="storeStoreFence()"> 
           <!--   --> </a> 
          <ul class="blockListLast"> 
           <li class="blockList"> <h4>storeStoreFence</h4> <pre class="methodSignature">public static&nbsp;void&nbsp;storeStoreFence()</pre> 
            <div class="block">
              确保栅栏前的商店不会在栅栏后与商店重新订购。 
            </div> </li> 
          </ul> </li> 
        </ul> 
       </section> </li> 
     </ul> 
    </div> 
   </div> 
  </main> 
  <!-- ========= END OF CLASS DATA ========= --> 
  <footer role="contentinfo"> 
   <nav role="navigation"> 
    <!-- ======= START OF BOTTOM NAVBAR ====== --> 
    <div class="bottomNav"> 
     <a id="navbar.bottom"> 
      <!--   --> </a> 
     <div class="skipNav"> 
      <a href="#skip.navbar.bottom" title="Skip navigation links">跳过导航</a> 
     </div> 
     <a id="navbar.bottom.firstrow"> 
      <!--   --> </a> 
     <ul class="navList" title="Navigation"> 
      <li><a href="../../../../index.html">概述</a></li> 
      <li><a href="../../../module-summary.html">模块</a></li> 
      <li><a href="package-summary.html">软件包</a></li> 
      <li class="navBarCell1Rev">类</li> 
      <li><a href="class-use/VarHandle.html">使用</a></li> 
      <li><a href="package-tree.html">树</a></li> 
      <li><a href="../../../../deprecated-list.html">已过时的</a></li> 
      <li><a href="../../../../index-files/index-1.html">索引</a></li> 
      <li><a href="../../../../help-doc.html">帮助</a></li> 
     </ul> 
     <div class="aboutLanguage"> 
      <div style="margin-top: 14px;"> 
       <strong>Java SE 11 &amp; JDK 11</strong> 
      </div> 
     </div> 
    </div> 
    <div class="subNav"> 
     <ul class="navList" id="allclasses_navbar_bottom"> 
      <li><a href="../../../../allclasses.html">所有类</a></li> 
     </ul> 
     <div> 
      <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
      <noscript> 
       <div>
         JavaScript is disabled on your browser. 
       </div> 
      </noscript> 
     </div> 
     <div> 
      <ul class="subNavList"> 
       <li>概要：&nbsp;</li> 
       <li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li> 
       <li>字段&nbsp;|&nbsp;</li> 
       <li>构造方法&nbsp;|&nbsp;</li> 
       <li><a href="#method.summary">方法</a></li> 
      </ul> 
      <ul class="subNavList"> 
       <li>详细信息：&nbsp;</li> 
       <li>字段&nbsp;|&nbsp;</li> 
       <li>构造方法&nbsp;|&nbsp;</li> 
       <li><a href="#method.detail">方法</a></li> 
      </ul> 
     </div> 
     <a id="skip.navbar.bottom"> 
      <!--   --> </a> 
    </div> 
    <!-- ======== END OF BOTTOM NAVBAR ======= --> 
   </nav> 
   <p class="legalCopy"><small><a href="http://bugreport.java.com/bugreport/">Report a bug or suggest an enhancement</a><br> For further API reference and developer documentation see the <a href="http://www.oracle.com/pls/topic/lookup?ctx=javase11.0.1&amp;id=homepage" target="_blank">Java SE Documentation</a>, which contains more detailed, developer-targeted descriptions with conceptual overviews, definitions of terms, workarounds, and working code examples.<br> Java is a trademark or registered trademark of Oracle and/or its affiliates in the US and other countries.<br> <a href="../../../../../legal/copyright.html">Copyright</a> © 1993, 2018, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.<br>All rights reserved. Use is subject to <a href="http://www.oracle.com/technetwork/java/javase/terms/license/java11.0.1speclicense.html">license terms</a> and the <a href="http://www.oracle.com/technetwork/java/redist-137594.html">documentation redistribution policy</a>. 
     <!-- Version 11.0.1+13-LTS --></small></p> 
  </footer>  
 </body>
</html>