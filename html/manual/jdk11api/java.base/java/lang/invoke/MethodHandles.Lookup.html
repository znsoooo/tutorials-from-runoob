<!doctype html>
<!-- NewPage -->
<html lang="en">
 <head> 
  <!-- Generated by javadoc --> 
  <title>MethodHandles.Lookup</title> 
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> 
  <meta name="keywords" content="java.lang.invoke.MethodHandles.Lookup class"> 
  <meta name="keywords" content="PUBLIC"> 
  <meta name="keywords" content="PRIVATE"> 
  <meta name="keywords" content="PROTECTED"> 
  <meta name="keywords" content="PACKAGE"> 
  <meta name="keywords" content="MODULE"> 
  <meta name="keywords" content="UNCONDITIONAL"> 
  <meta name="keywords" content="lookupClass()"> 
  <meta name="keywords" content="lookupModes()"> 
  <meta name="keywords" content="in()"> 
  <meta name="keywords" content="dropLookupMode()"> 
  <meta name="keywords" content="defineClass()"> 
  <meta name="keywords" content="toString()"> 
  <meta name="keywords" content="findStatic()"> 
  <meta name="keywords" content="findVirtual()"> 
  <meta name="keywords" content="findConstructor()"> 
  <meta name="keywords" content="findClass()"> 
  <meta name="keywords" content="accessClass()"> 
  <meta name="keywords" content="findSpecial()"> 
  <meta name="keywords" content="findGetter()"> 
  <meta name="keywords" content="findSetter()"> 
  <meta name="keywords" content="findVarHandle()"> 
  <meta name="keywords" content="findStaticGetter()"> 
  <meta name="keywords" content="findStaticSetter()"> 
  <meta name="keywords" content="findStaticVarHandle()"> 
  <meta name="keywords" content="bind()"> 
  <meta name="keywords" content="unreflect()"> 
  <meta name="keywords" content="unreflectSpecial()"> 
  <meta name="keywords" content="unreflectConstructor()"> 
  <meta name="keywords" content="unreflectGetter()"> 
  <meta name="keywords" content="unreflectSetter()"> 
  <meta name="keywords" content="unreflectVarHandle()"> 
  <meta name="keywords" content="revealDirect()"> 
  <meta name="keywords" content="hasPrivateAccess()"> 
  <link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style"> 
  <link rel="stylesheet" type="text/css" href="../../../../jquery/jquery-ui.css" title="Style"> 
  <script type="text/javascript" src="../../../../script.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jszip/dist/jszip.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script> 
  <!--[if IE]>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]--> 
  <script type="text/javascript" src="../../../../jquery/jquery-1.10.2.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jquery-migrate-1.2.1.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jquery-ui.js"></script> 
 </head> 
 <body> <SCRIPT LANGUAGE="JavaScript"><!-- Hide  
   function ResumeError() {     return true;}window.onerror = ResumeError;// --></SCRIPT>
  <script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="MethodHandles.Lookup (Java SE 11 & JDK 11 )";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10,"i24":10,"i25":10,"i26":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script> 
  <noscript> 
   <div>
     JavaScript is disabled on your browser. 
   </div> 
  </noscript> 
  <header role="banner"> 
   <nav role="navigation"> 
    <div class="fixedNav"> 
     <!-- ========= START OF TOP NAVBAR ======= --> 
     <div class="topNav"> 
      <a id="navbar.top"> 
       <!--   --> </a> 
      <div class="skipNav"> 
       <a href="#skip.navbar.top" title="Skip navigation links">跳过导航</a> 
      </div> 
      <a id="navbar.top.firstrow"> 
       <!--   --> </a> 
      <ul class="navList" title="Navigation"> 
       <li><a href="../../../../index.html">概述</a></li> 
       <li><a href="../../../module-summary.html">模块</a></li> 
       <li><a href="package-summary.html">软件包</a></li> 
       <li class="navBarCell1Rev">类</li> 
       <li><a href="class-use/MethodHandles.Lookup.html">使用</a></li> 
       <li><a href="package-tree.html">树</a></li> 
       <li><a href="../../../../deprecated-list.html">已过时的</a></li> 
       <li><a href="../../../../index-files/index-1.html">索引</a></li> 
       <li><a href="../../../../help-doc.html">帮助</a></li> 
      </ul> 
      <div class="aboutLanguage"> 
       <div style="margin-top: 14px;"> 
        <strong>Java SE 11 &amp; JDK 11</strong> 
       </div> 
      </div> 
     </div> 
     <div class="subNav"> 
      <ul class="navList" id="allclasses_navbar_top"> 
       <li><a href="../../../../allclasses.html">所有类</a></li> 
      </ul> 
      <ul class="navListSearch"> 
       <li><label for="search">SEARCH:</label> <input type="text" id="search" value="search" disabled> <input type="reset" id="reset" value="reset" disabled> </li> 
      </ul> 
      <div> 
       <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
       <noscript> 
        <div>
          JavaScript is disabled on your browser. 
        </div> 
       </noscript> 
      </div> 
       <div class="fixedNav">
       <ul class="subNavList"> 
        <li>概要：&nbsp;</li> 
        <li>嵌套&nbsp;|&nbsp;</li> 
        <li><a href="#field.summary">字段</a>&nbsp;|&nbsp;</li> 
        <li>构造方法&nbsp;|&nbsp;</li> 
        <li><a href="#method.summary">方法</a></li> 
       </ul> 
       <ul class="subNavList"> 
        <li>详细信息：&nbsp;</li> 
        <li><a href="#field.detail">字段</a>&nbsp;|&nbsp;</li> 
        <li>构造方法&nbsp;|&nbsp;</li> 
        <li><a href="#method.detail">方法</a></li> 
       </ul> 
      </div> 
      <a id="skip.navbar.top"> 
       <!--   --> </a> 
     </div> 
     <!-- ========= END OF TOP NAVBAR ========= --> 
    </div> 
    <div class="navPadding">
      &nbsp; 
    </div> 
    <script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script> 
   </nav> 
  </header> 
  <!-- ======== START OF CLASS DATA ======== --> 
  <main role="main"> 
   <div class="header"> 
    <div class="subTitle"> 
     <span class="moduleLabelInType">模块</span>&nbsp; 
     <a href="../../../module-summary.html">java.base</a> 
    </div> 
    <div class="subTitle"> 
     <span class="packageLabelInType">软件包</span>&nbsp; 
     <a href="package-summary.html">java.lang.invoke</a> 
    </div> 
    <h2 title="Class MethodHandles.Lookup" class="title">Class MethodHandles.Lookup</h2> 
   </div> 
   <div class="contentContainer"> 
    <ul class="inheritance"> 
     <li><a href="../Object.html" title="class in java.lang">java.lang.Object</a></li> 
     <li> 
      <ul class="inheritance"> 
       <li>java.lang.invoke.MethodHandles.Lookup</li> 
      </ul> </li> 
    </ul> 
    <div class="description"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <dl> 
        <dt>
          Enclosing class: 
        </dt> 
        <dd> 
         <span><a href="MethodHandles.html" title="java.lang.invoke中的类">MethodHandles</a></span> 
        </dd> 
       </dl> 
       <hr> <pre>public static final class <span class="typeNameLabel">MethodHandles.Lookup</span>
extends <a href="../Object.html" title="class in java.lang">Object</a></pre> 
       <div class="block"> 
        <span><em>查找对象</em>是用于在创建需要访问检查时创建方法句柄的工厂。</span> 
        <span>方法句柄在调用它们时不执行访问检查，而是在创建它们时执行。</span> 
        <span>因此，在创建方法句柄时必须强制执行方法句柄访问限制。</span> 
        <span>强制执行这些限制的调用者类称为<a href="#lookupClass()">lookup class</a> 。</span> 
        <p> <span>需要创建方法句柄的查找类将调用<a href="MethodHandles.html#lookup()"><code>MethodHandles.lookup</code></a>为自己创建工厂。</span> <span>创建<code>Lookup</code>工厂对象时，将确定查找类的标识，并将其安全地存储在<code>Lookup</code>对象中。</span> <span>然后，查找类（或其委托）可以使用<code>Lookup</code>对象上的工厂方法为访问检查的成员创建方法句柄。</span> <span>这包括允许查找类的所有方法，构造函数和字段，甚至是私有的。</span> </p> 
        <h1> <span><a id="lookups"></a>查找工厂方法</span> </h1> 
        <span><code>Lookup</code>对象上的工厂方法对应于方法，构造函数和字段的所有主要用例。</span> 
        <span>工厂方法创建的每个方法句柄都是特定<em>字节码行为</em>的功能等价物。</span> 
        <span>（字节码行为在Java虚拟机规范的5.4.3.5节中描述。）以下是这些工厂方法与生成的方法句柄行为之间的对应关系的摘要：</span> 
        <span> lookup method behaviors    <a id="equiv"></a>lookup expression member bytecode behavior     <a href="#findGetter(java.lang.Class,java.lang.String,java.lang.Class)"><code>lookup.findGetter(C.class,"f",FT.class)</code></a> <code>FT f;</code> <code>(T) this.f;</code>   <a href="#findStaticGetter(java.lang.Class,java.lang.String,java.lang.Class)"><code>lookup.findStaticGetter(C.class,"f",FT.class)</code></a> <code>static</code><br><code>FT f;</code> <code>(T) C.f;</code>   <a href="#findSetter(java.lang.Class,java.lang.String,java.lang.Class)"><code>lookup.findSetter(C.class,"f",FT.class)</code></a> <code>FT f;</code> <code>this.f = x;</code>   <a href="#findStaticSetter(java.lang.Class,java.lang.String,java.lang.Class)"><code>lookup.findStaticSetter(C.class,"f",FT.class)</code></a> <code>static</code><br><code>FT f;</code> <code>C.f = arg;</code>   <a href="#findVirtual(java.lang.Class,java.lang.String,java.lang.invoke.MethodType)"><code>lookup.findVirtual(C.class,"m",MT)</code></a> <code>T m(A*);</code> <code>(T) this.m(arg*);</code>   <a href="#findStatic(java.lang.Class,java.lang.String,java.lang.invoke.MethodType)"><code>lookup.findStatic(C.class,"m",MT)</code></a> <code>static</code><br><code>T m(A*);</code> <code>(T) C.m(arg*);</code>   <a href="#findSpecial(java.lang.Class,java.lang.String,java.lang.invoke.MethodType,java.lang.Class)"><code>lookup.findSpecial(C.class,"m",MT,this.class)</code></a> <code>T m(A*);</code> <code>(T) super.m(arg*);</code>   <a href="#findConstructor(java.lang.Class,java.lang.invoke.MethodType)"><code>lookup.findConstructor(C.class,MT)</code></a> <code>C(A*);</code> <code>new C(arg*);</code>   <a href="#unreflectGetter(java.lang.reflect.Field)"><code>lookup.unreflectGetter(aField)</code></a> (<code>static</code>)?<br><code>FT f;</code> <code>(FT) aField.get(thisOrNull);</code>   <a href="#unreflectSetter(java.lang.reflect.Field)"><code>lookup.unreflectSetter(aField)</code></a> (<code>static</code>)?<br><code>FT f;</code> <code>aField.set(thisOrNull, arg);</code>   <a href="#unreflect(java.lang.reflect.Method)"><code>lookup.unreflect(aMethod)</code></a> (<code>static</code>)?<br><code>T m(A*);</code> <code>(T) aMethod.invoke(thisOrNull, arg*);</code>   <a href="#unreflectConstructor(java.lang.reflect.Constructor)"><code>lookup.unreflectConstructor(aConstructor)</code></a> <code>C(A*);</code> <code>(C) aConstructor.newInstance(arg*);</code>   <a href="#unreflect(java.lang.reflect.Method)"><code>lookup.unreflect(aMethod)</code></a> (<code>static</code>)?<br><code>T m(A*);</code> <code>(T) aMethod.invoke(thisOrNull, arg*);</code>   <a href="#findClass(java.lang.String)"><code>lookup.findClass("C")</code></a> <code>class C { ... }</code> <code>C.class;</code>  </span> 
        <table class="striped"> 
        </table> 
        <span>这里，类型<code>C</code>是正在搜索成员的类或接口，在查找方法中记录为名为<code>refc</code>的参数。</span> 
        <span>方法类型<code>MT</code>由返回类型<code>T</code>和参数类型序列<code>A*</code> 。</span> 
        <span>构造函数也有一个参数类型序列<code>A*</code> ，并认为返回类型的新创建的对象<code>C</code> 。</span> 
        <span><code>MT</code>和字段类型<code>FT</code>都记录为名为<code>type</code>的参数。</span> 
        <span>形式参数<code>this</code>代表类型<code>C</code>的自引用;</span> 
        <span>如果它存在，它始终是方法句柄调用的主要参数。</span> 
        <span>（对于某些<code>protected</code>成员， <code>this</code>类型可能会被限制到查找类;请参阅下文。）名称<code>arg</code>代表所有其他方法句柄参数。</span> 
        <span>在Core Reflection API的代码示例中，如果访问的方法或字段是静态的，则名称<code>thisOrNull</code>表示空引用，否则表示<code>this</code> 。</span> 
        <span>名称<code>aMethod</code> ， <code>aField</code> ，和<code>aConstructor</code>代表对应于给定构件反射的对象。</span> 
        <p> <span><code>findClass</code>操作的字节码行为是常量类的加载，就像<code>ldc CONSTANT_Class</code> 。</span> <span>表示的行为不是作为方法句柄，而是直接表示为<code>类</code>常量。</span> </p> 
        <p> <span>在给定成员具有可变arity（即，方法或构造函数）的情况下，返回的方法句柄也将是<a href="MethodHandle.html#asVarargsCollector(java.lang.Class)">variable arity</a> 。</span> <span>在所有其他情况下，返回的方法句柄将是固定的。</span> </p> 
        <p style="font-size:smaller;"> <span><em>讨论：</em>查找方法句柄与底层类成员和字节码行为之间的等价可以通过以下几种方式分解：</span> </p> 
        <ul style="font-size:smaller;"> 
         <li> <span>如果<code>C</code>无法从查找类的加载器以符号形式访问，则查找仍然可以成功，即使没有等效的Java表达式或字节编码常量也是如此。</span> </li> 
         <li> <span>同样，如果<code>T</code>或<code>MT</code>无法从查找类的加载器以符号方式访问，则查找仍然可以成功。</span> <span>例如，无论请求的类型如何，查找<code>MethodHandle.invokeExact</code>和<code>MethodHandle.invoke</code>将始终成功。</span> </li> 
         <li> <span>如果安装了安全管理器，则可以基于各种理由禁止查找（ <a href="MethodHandles.Lookup.html#secmgr">see below</a> ）。</span> <span>相反， <code>CONSTANT_MethodHandle</code>常量上的<code>ldc</code>指令不受安全管理器检查的约束。</span> </li> 
         <li> <span>如果查找方法具有<a href="MethodHandle.html#maxarity">very large arity</a> ，则方法句柄创建可能会失败，因为方法句柄类型具有太多参数。</span> </li> 
        </ul> 
        <h1> <span><a id="access"></a>访问检查</span> </h1> 
        <span>创建方法句柄时，将在<code>Lookup</code>的工厂方法中应用访问检查。</span> 
        <span>这是与Core Reflection API的主要区别，因为<a href="../reflect/Method.html#invoke(java.lang.Object,java.lang.Object...)"><code>java.lang.reflect.Method.invoke</code></a>会在每次调用时对每个调用者执行访问检查。</span> 
        <p> <span>所有访问检查都从<code>Lookup</code>对象开始，该对象将其记录的查找类与创建方法句柄的所有请求进行比较。</span> <span>单个<code>Lookup</code>对象可用于创建任意数量的访问检查方法句柄，所有这些句柄都针对单个查找类进行检查。</span> </p> 
        <p> <span><code>Lookup</code>对象可以与其他可信代码共享，例如元对象协议。</span> <span>共享<code>Lookup</code>对象委托在查找类的私有成员上创建方法句柄的功能。</span> <span>即使特权代码使用<code>Lookup</code>对象，访问检查也仅限于原始查找类的特权。</span> </p> 
        <p> <span>查找可能会失败，因为查找类无法访问包含类，或者因为缺少所需的类成员，或者因为查找类无法访问所需的类成员，或者因为查找对象不够信任访问该成员。</span> <span>在任何这些情况下，将尝试查找抛出<code>ReflectiveOperationException</code> 。</span> <span>确切的类将是以下之一：</span> </p> 
        <ul> 
         <li> <span>NoSuchMethodException - 如果请求方法但不存在</span> </li> 
         <li> <span>NoSuchFieldException - 如果请求字段但不存在</span> </li> 
         <li> <span>IllegalAccessException - 如果成员存在但访问检查失败</span> </li> 
        </ul> 
        <p> <span>通常，可以为方法<code>M</code>查找方法句柄的条件不比查找类可以编译，验证和解析对<code>M</code>的调用的条件更具限制性。</span> <span>在JVM引发异常（如<code>NoSuchMethodError</code> ，方法句柄查找通常会引发相应的已检查异常，例如<code>NoSuchMethodException</code> 。</span> <span>并调用从查询产生的方法处理的效果是<a href="MethodHandles.Lookup.html#equiv">exactly equivalent</a> ，以执行编制，验证和解决呼叫<code>M</code> 。</span> <span>字段和构造函数也是如此。</span> </p> 
        <p style="font-size:smaller;"> <span><em>讨论：</em>访问检查仅适用于命名和反射的方法，构造函数和字段。</span> <span>其他方法句柄创建方法（如<a href="MethodHandle.html#asType(java.lang.invoke.MethodType)"><code>MethodHandle.asType</code>）</a>不需要任何访问检查，并且独立于任何<code>Lookup</code>对象使用。</span> </p> 
        <p> <span>如果所需成员是<code>protected</code> ，则应用通常的JVM规则，包括要求查找类必须与所需成员位于同一包中，或者必须继承该成员。</span> <span>（请参阅Java虚拟机规范，第4.9.2,5.4.3.5和6.4节。）此外，如果所需成员是不同包中的非静态字段或方法，则生成的方法句柄可能仅适用于查找类的对象或其子类之一。</span> <span>通过将前导<code>this</code>参数的类型从<code>C</code> （必须是查找类的超类）缩小到查找类本身来强制执行此要求。</span> </p> 
        <p> <span>JVM对<code>invokespecial</code>指令施加了类似的要求，即receiver参数必须与已解析的方法<em>和</em>当前类匹配。</span> <span>同样，通过将前导参数的类型缩小到结果方法句柄来强制执行此要求。</span> <span>（请参阅Java虚拟机规范，第4.10.1.9节。）</span> </p> 
        <p> <span>JVM将构造函数和静态初始化程序块表示为具有特殊名称的内部方法（ <code>"&lt;init&gt;"</code>和<code>"&lt;clinit&gt;"</code> ）。</span> <span>调用指令的内部语法允许它们引用这些内部方法，就好像它们是普通方法一样，但JVM字节码验证器拒绝它们。</span> <span>查找这样的内部方法将产生<code>NoSuchMethodException</code> 。</span> </p> 
        <p> <span>如果嵌套类型之间的关系直接通过<code>NestHost</code>和<code>NestMembers</code>属性表示（请参阅Java虚拟机规范，第4.7.28和4.7.29节），则关联的<code>Lookup</code>对象提供对查找类及其所有嵌套类的直接访问（见<a href="../Class.html#getNestHost()"><code>Class.getNestHost</code></a> ）。</span> <span>否则，Java编译器会创建一个包装器方法来访问同一个嵌套中另一个类的私有方法，从而获得嵌套类之间的访问。</span> <span>例如，一个嵌套类<code>C.D</code>可以其他相关的类如内访问私有成员<code>C</code> ， <code>C.D.E</code> ，或<code>C.B</code> ，但是Java编译器可能需要生成在这些相关的类包装方法。</span> <span>在这种情况下，一个<code>Lookup</code>的对象<code>C.E</code>将无法访问这些私有成员。</span> <span>此限制的解决方法是<a href="#in(java.lang.Class)"><code>Lookup.in</code></a>方法，该方法可以将<code>C.E</code>上的查找<code>C.E</code>为任何其他类上的查找，而无需特殊的特权提升。</span> </p> 
        <p> <span>允许给定查找对象的访问可以根据其<a href="#lookupModes()"><code>lookupModes</code></a>的集合限制为通常可由查找类访问的成员的子集。</span> <span>例如， <a href="MethodHandles.html#publicLookup()"><code>publicLookup</code></a>方法生成一个查找对象，该对象仅允许访问导出包的公共类中的公共成员。</span> <span>调用者敏感方法<a href="MethodHandles.html#lookup()"><code>lookup</code></a>产生具有相对于其调用者类的全部能力的查找对象，以模拟所有支持的字节码行为。</span> <span>此外， <a href="#in(java.lang.Class)"><code>Lookup.in</code></a>方法可以生成具有比原始查找对象更少的访问模式的查找对象。</span> </p> 
        <p style="font-size:smaller;"> <span><a id="privacc"></a> <em>关于</em> <a id="privacc">私人访问的</a> <em>讨论：</em>如果<a href="#lookupModes()">查询</a>包含访问<code>private</code>成员（包括巢友的私人成员）的可能性，我们说查找具有<em>私人访问权限</em> 。</span> <span>如其他地方的相关方法所述，只有具有私有访问权限的查找才具有以下功能：</span> </p> 
        <ul style="font-size:smaller;"> 
         <li> <span>访问查找类及其nestmates的私有字段，方法和构造函数</span> </li> 
         <li> <span>create方法句柄，用于调用<a href="MethodHandles.Lookup.html#callsens">caller sensitive</a>方法，例如<code>Class.forName</code></span> </li> 
         <li> <span>create方法句柄有哪些<a href="#findSpecial(java.lang.Class,java.lang.String,java.lang.invoke.MethodType,java.lang.Class)"><code>emulate invokespecial</code></a>指令</span> </li> 
         <li> <span>对于查找类可访问的类，请避免使用<a href="MethodHandles.Lookup.html#secmgr">package access checks</a></span> </li> 
         <li> <span>创建<a href="#in(java.lang.Class)"><code>delegated lookup objects</code></a> ，它可以私有访问同一个包成员中的其他类</span> </li> 
        </ul> 
        <p style="font-size:smaller;"> <span>这些权限中的每一个都是这样一个事实的结果：具有私有访问权限的查找对象可以安全地追溯到原始类，其<a href="MethodHandles.Lookup.html#equiv">bytecode behaviors</a>和Java语言访问权限可以通过方法句柄可靠地确定和模拟。</span> </p> 
        <h1> <span><a id="secmgr"></a>安全管理器交互</span> </h1> 
        <span>尽管字节码指令只能引用相关类加载器中的类，但只要对其<code>类</code>对象的引用可用，此API就可以在任何类中搜索方法。</span> 
        <span>使用Core Reflection API也可以使用这种交叉加载器引用，并且不可能对诸如<code>invokestatic</code>或<code>getfield</code>指令进行字节<code>getfield</code> 。</span> 
        <span>有一个<a href="../SecurityManager.html" title="java.lang中的类">security manager API</a>允许应用程序检查此类交叉加载器引用。</span> 
        <span>这些检查适用于<code>MethodHandles.Lookup</code> API和Core Reflection API（如<a href="../Class.html" title="java.lang中的类"><code>类</code>中所示</a> ）。</span> 
        <p> <span>如果存在安全管理器，则成员和类查找将受到额外检查。</span> <span>从一到三次调用安全管理器。</span> <span>任何这些调用都可以通过抛出<a href="../SecurityException.html" title="java.lang中的类"><code>SecurityException</code></a>来拒绝访问。</span> <span>将<code>smgr</code>定义为安全管理器，将<code>lookc</code>定义为当前查找对象的查找类，将<code>refc</code>为要在其中查找成员的包含类，将<code>defc</code>定义为实际定义该成员的类。</span> <span>（如果一个类或其他类型的被存取时， <code>refc</code>个<code>defc</code>值是类本身。）的值<code>lookc</code>被定义为<em>不存在</em> ，如果当前查找对象不具有<a href="MethodHandles.Lookup.html#privacc">private access</a> 。</span> <span>呼叫根据以下规则进行：</span> </p> 
        <ul> 
         <li> <span><b>步骤1：</b>如果<code>lookc</code>不存在，或者如果它的类加载器是不一样的或的类加载器的祖先<code>refc</code> ，然后<a href="../SecurityManager.html#checkPackageAccess(java.lang.String)"><code>smgr.checkPackageAccess(refcPkg)</code></a>被调用，其中<code>refcPkg</code>是的包<code>refc</code> 。</span> </li> 
         <li> <span><b>步骤2a：</b>如果检索到的成员不是公共的并且<code>lookc</code>不存在，则<a href="../SecurityManager.html#checkPermission(java.security.Permission)">调用<code>smgr.checkPermission</code></a>和<code>RuntimePermission("accessDeclaredMembers")</code> 。</span> </li> 
         <li> <span><b>步骤2b：</b>如果检索到的类具有<code>null</code>类加载器，并且<code>lookc</code>不存在，则<a href="../SecurityManager.html#checkPermission(java.security.Permission)">调用<code>smgr.checkPermission</code></a>和<code>RuntimePermission("getClassLoader")</code> 。</span> </li> 
         <li> <span><b>步骤3：</b>如果所检索的部件是不公开的，而如果<code>lookc</code>不存在，并且如果<code>defc</code>和<code>refc</code>不同，则<a href="../SecurityManager.html#checkPackageAccess(java.lang.String)"><code>smgr.checkPackageAccess(defcPkg)</code></a>被调用，其中<code>defcPkg</code>是的包<code>defc</code> 。</span> </li> 
        </ul> 
        <span>在其他访问检查通过后执行安全检查。</span> 
        <span>因此，上述规则预先假定一个公共成员或类，或者从具有访问该成员或类的权限的查找类访问的成员或类。</span> 
        <h1> <span><a id="callsens"></a>来电者敏感的方法</span> </h1> 
        <span>少数Java方法具有称为调用者敏感性的特殊属性。</span> 
        <span><em>调用者敏感</em>方法的行为可能会有所不同，具体取决于其直接调用者的身份。</span> 
        <p> <span>如果请求了调用者敏感方法的方法句柄，则适用<a href="MethodHandles.Lookup.html#equiv">bytecode behaviors</a>的一般规则，但它们以特殊方式考虑查找类。</span> <span>生成的方法句柄的行为就像从查找类中包含的指令调用一样，以便调用者敏感的方法检测查找类。</span> <span>（相比之下，方法句柄的调用者被忽略。）因此，在调用者敏感方法的情况下，不同的查找类可能会产生不同行为的方法句柄。</span> </p> 
        <p> <span>如果查找对象是<a href="MethodHandles.html#publicLookup()"><code>publicLookup()</code></a> ，或者没有<a href="MethodHandles.Lookup.html#privacc">private access的</a>其他查找对象，则忽略查找类。</span> <span>在这种情况下，不能创建调用者敏感的方法句柄，禁止访问，并且查找失败，并显示<code>IllegalAccessException</code> 。</span> </p> 
        <p style="font-size:smaller;"> <span><em>讨论：</em>例如，调用者敏感方法<a href="../Class.html#forName(java.lang.String)"><code>Class.forName(x)</code></a>可以返回不同的类或抛出不同的异常，具体取决于调用它的类的类加载器。</span> <span><code>Class.forName</code>的公共查找将失败，因为没有合理的方法来确定其字节码行为。</span> </p> 
        <p style="font-size:smaller;"> <span>如果应用程序缓存方法句柄以进行广泛共享，则应使用<code>publicLookup()</code>来创建它们。</span> <span>如果查找<code>Class.forName</code> ，它将失败，并且应用程序必须采取适当的操作。</span> <span>可能是稍后的查找（可能在调用引导方法期间）可以包含调用者的特定标识，从而使该方法可访问。</span> </p> 
        <p style="font-size:smaller;"> <span>函数<code>MethodHandles.lookup</code>调用者敏感，因此可以为查找提供安全的基础。</span> <span>JSR 292 API中几乎所有其他方法都依赖于查找对象来检查访问请求。</span> </p> 
       </div> </li> 
     </ul> 
    </div> 
    <div class="summary"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <!-- =========== FIELD SUMMARY =========== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="field.summary"> 
           <!--   --> </a> <h3>字段汇总</h3> 
          <table class="memberSummary"> 
           <caption> 
            <span>字段</span> 
            <span class="tabEnd">&nbsp;</span> 
           </caption> 
           <tbody> 
            <tr> 
             <th class="colFirst" scope="col">变量和类型</th> 
             <th class="colSecond" scope="col">字段</th> 
             <th class="colLast" scope="col">描述</th> 
            </tr> 
            <tr class="altColor"> 
             <td class="colFirst"><code>static int</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#MODULE">模块</a></span></code></th> 
             <td class="colLast"> 
              <div class="block">
                表示 
               <code>模块</code>访问（默认访问）的单位掩码，可能会导致 
               <a href="#lookupModes()"><code>lookupModes</code></a>的结果。 
              </div> </td> 
            </tr> 
            <tr class="rowColor"> 
             <td class="colFirst"><code>static int</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#PACKAGE">PACKAGE</a></span></code></th> 
             <td class="colLast"> 
              <div class="block">
                表示 
               <code>package</code>访问权限（默认访问权限）的单位掩码，可能会导致 
               <a href="#lookupModes()"><code>lookupModes</code></a>的结果。 
              </div> </td> 
            </tr> 
            <tr class="altColor"> 
             <td class="colFirst"><code>static int</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#PRIVATE">PRIVATE</a></span></code></th> 
             <td class="colLast"> 
              <div class="block">
                表示 
               <code>private</code>访问的单比特掩码，可能导致 
               <a href="#lookupModes()"><code>lookupModes</code></a>的结果。 
              </div> </td> 
            </tr> 
            <tr class="rowColor"> 
             <td class="colFirst"><code>static int</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#PROTECTED">PROTECTED</a></span></code></th> 
             <td class="colLast"> 
              <div class="block">
                表示 
               <code>protected</code>访问的单位掩码，可能导致 
               <a href="#lookupModes()"><code>lookupModes</code></a>的结果。 
              </div> </td> 
            </tr> 
            <tr class="altColor"> 
             <td class="colFirst"><code>static int</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#PUBLIC">PUBLIC</a></span></code></th> 
             <td class="colLast"> 
              <div class="block">
                表示 
               <code>public</code>访问的单位掩码，可能导致 
               <a href="#lookupModes()"><code>lookupModes</code></a>的结果。 
              </div> </td> 
            </tr> 
            <tr class="rowColor"> 
             <td class="colFirst"><code>static int</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#UNCONDITIONAL">UNCONDITIONAL</a></span></code></th> 
             <td class="colLast"> 
              <div class="block">
                表示 
               <code>unconditional</code>访问权限的单位掩码，可能导致 
               <a href="#lookupModes()"><code>lookupModes</code></a>的结果。 
              </div> </td> 
            </tr> 
           </tbody> 
          </table> </li> 
        </ul> 
       </section> 
       <!-- ========== METHOD SUMMARY =========== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="method.summary"> 
           <!--   --> </a> <h3>方法摘要</h3> 
          <table class="memberSummary"> 
           <caption> 
           <span id="t0" class="activeTableTab"><span>所有方法</span><span class="tabEnd">&nbsp;</span>
             <span id="t2" class="tableTab"><span><a href="javascript:show(2);">实例方法</a>  </span></span> 
            <span id="t4" class="tableTab"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd">&nbsp;</span></span> 
           </caption> 
           <tbody> 
            <tr> 
             <th class="colFirst" scope="col">变量和类型</th> 
             <th class="colSecond" scope="col">方法</th> 
             <th class="colLast" scope="col">描述</th> 
            </tr> 
            <tr id="i0" class="altColor"> 
             <td class="colFirst"><code><a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#accessClass(java.lang.Class)">accessClass</a></span>​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;targetClass)</code></th> 
             <td class="colLast"> 
              <div class="block">
                确定是否可以从此 
               <code>Lookup</code>对象定义的查找上下文中访问类。 
              </div> </td> 
            </tr> 
            <tr id="i1" class="rowColor"> 
             <td class="colFirst"><code><a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#bind(java.lang.Object,java.lang.String,java.lang.invoke.MethodType)">bind</a></span>​(<a href="../Object.html" title="class in java.lang">Object</a>&nbsp;receiver, <a href="../String.html" title="class in java.lang">String</a>&nbsp;name, <a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)</code></th> 
             <td class="colLast"> 
              <div class="block">
                为非静态方法生成早期绑定方法句柄。 
              </div> </td> 
            </tr> 
            <tr id="i2" class="altColor"> 
             <td class="colFirst"><code><a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#defineClass(byte%5B%5D)">defineClass</a></span>​(byte[]&nbsp;bytes)</code></th> 
             <td class="colLast"> 
              <div class="block"> 
               <span>为同一个类加载器和相同的运行时包定义一个类，并将<a href="../../security/ProtectionDomain.html" title="java.security中的类">protection domain</a>定义为此查找的<a href="#lookupClass()">lookup class</a> 。</span> 
              </div> </td> 
            </tr> 
            <tr id="i3" class="rowColor"> 
             <td class="colFirst"><code><a href="MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#dropLookupMode(int)">dropLookupMode</a></span>​(int&nbsp;modeToDrop)</code></th> 
             <td class="colLast"> 
              <div class="block">
                在查找对象找到成员的同一查找类上创建查找，但查找模式已丢失给定的查找模式。 
              </div> </td> 
            </tr> 
            <tr id="i4" class="altColor"> 
             <td class="colFirst"><code><a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findClass(java.lang.String)">findClass</a></span>​(<a href="../String.html" title="class in java.lang">String</a>&nbsp;targetName)</code></th> 
             <td class="colLast"> 
              <div class="block">
                从此 
               <code>Lookup</code>对象定义的查找上下文中按名称查找类。 
              </div> </td> 
            </tr> 
            <tr id="i5" class="rowColor"> 
             <td class="colFirst"><code><a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findConstructor(java.lang.Class,java.lang.invoke.MethodType)">findConstructor</a></span>​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;refc, <a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成一个方法句柄，该句柄使用指定类型的构造函数创建对象并对其进行初始化。 
              </div> </td> 
            </tr> 
            <tr id="i6" class="altColor"> 
             <td class="colFirst"><code><a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findGetter(java.lang.Class,java.lang.String,java.lang.Class)">findGetter</a></span>​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;refc, <a href="../String.html" title="class in java.lang">String</a>&nbsp;name, <a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;type)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成一个方法句柄，提供对非静态字段的读访问权限。 
              </div> </td> 
            </tr> 
            <tr id="i7" class="rowColor"> 
             <td class="colFirst"><code><a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findSetter(java.lang.Class,java.lang.String,java.lang.Class)">findSetter</a></span>​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;refc, <a href="../String.html" title="class in java.lang">String</a>&nbsp;name, <a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;type)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成一个方法句柄，提供对非静态字段的写访问权限。 
              </div> </td> 
            </tr> 
            <tr id="i8" class="altColor"> 
             <td class="colFirst"><code><a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findSpecial(java.lang.Class,java.lang.String,java.lang.invoke.MethodType,java.lang.Class)">findSpecial</a></span>​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;refc, <a href="../String.html" title="class in java.lang">String</a>&nbsp;name, <a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type, <a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;specialCaller)</code></th> 
             <td class="colLast"> 
              <div class="block">
                为虚方法生成早期绑定方法句柄。 
              </div> </td> 
            </tr> 
            <tr id="i9" class="rowColor"> 
             <td class="colFirst"><code><a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findStatic(java.lang.Class,java.lang.String,java.lang.invoke.MethodType)">findStatic</a></span>​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;refc, <a href="../String.html" title="class in java.lang">String</a>&nbsp;name, <a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成静态方法的方法句柄。 
              </div> </td> 
            </tr> 
            <tr id="i10" class="altColor"> 
             <td class="colFirst"><code><a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findStaticGetter(java.lang.Class,java.lang.String,java.lang.Class)">findStaticGetter</a></span>​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;refc, <a href="../String.html" title="class in java.lang">String</a>&nbsp;name, <a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;type)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成一个方法句柄，提供对静态字段的读访问权限。 
              </div> </td> 
            </tr> 
            <tr id="i11" class="rowColor"> 
             <td class="colFirst"><code><a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findStaticSetter(java.lang.Class,java.lang.String,java.lang.Class)">findStaticSetter</a></span>​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;refc, <a href="../String.html" title="class in java.lang">String</a>&nbsp;name, <a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;type)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成一个方法句柄，提供对静态字段的写访问权限。 
              </div> </td> 
            </tr> 
            <tr id="i12" class="altColor"> 
             <td class="colFirst"><code><a href="VarHandle.html" title="class in java.lang.invoke">VarHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findStaticVarHandle(java.lang.Class,java.lang.String,java.lang.Class)">findStaticVarHandle</a></span>​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;decl, <a href="../String.html" title="class in java.lang">String</a>&nbsp;name, <a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;type)</code></th> 
             <td class="colLast"> 
              <div class="block">
                产生VarHandle给访问静态字段 
               <code>name</code>类型 
               <code>type</code>在类类型的声明 
               <code>decl</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i13" class="rowColor"> 
             <td class="colFirst"><code><a href="VarHandle.html" title="class in java.lang.invoke">VarHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findVarHandle(java.lang.Class,java.lang.String,java.lang.Class)">findVarHandle</a></span>​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;recv, <a href="../String.html" title="class in java.lang">String</a>&nbsp;name, <a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;type)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成一个VarHandle，允许访问类型为 
               <code>name</code>的类型为 
               <code>type</code>的类型为 
               <code>recv</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i14" class="altColor"> 
             <td class="colFirst"><code><a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findVirtual(java.lang.Class,java.lang.String,java.lang.invoke.MethodType)">findVirtual</a></span>​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;refc, <a href="../String.html" title="class in java.lang">String</a>&nbsp;name, <a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成虚方法的方法句柄。 
              </div> </td> 
            </tr> 
            <tr id="i15" class="rowColor"> 
             <td class="colFirst"><code>boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasPrivateAccess()">hasPrivateAccess</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                如果此查找具有 
               <code>PRIVATE</code>访问权限，则返回 
               <code>true</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i16" class="altColor"> 
             <td class="colFirst"><code><a href="MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#in(java.lang.Class)">in</a></span>​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;requestedLookupClass)</code></th> 
             <td class="colLast"> 
              <div class="block">
                在指定的新查找类上创建查找。 
              </div> </td> 
            </tr> 
            <tr id="i17" class="rowColor"> 
             <td class="colFirst"><code><a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#lookupClass()">lookupClass</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                告诉哪个类正在执行查找。 
              </div> </td> 
            </tr> 
            <tr id="i18" class="altColor"> 
             <td class="colFirst"><code>int</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#lookupModes()">lookupModes</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                告知此查找对象可以生成哪些成员访问保护类。 
              </div> </td> 
            </tr> 
            <tr id="i19" class="rowColor"> 
             <td class="colFirst"><code><a href="MethodHandleInfo.html" title="interface in java.lang.invoke">MethodHandleInfo</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#revealDirect(java.lang.invoke.MethodHandle)">revealDirect</a></span>​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target)</code></th> 
             <td class="colLast"> 
              <div class="block">
                破解由此查找对象或类似对象创建的 
               <a href="MethodHandleInfo.html#directmh">direct method handle</a> 。 
              </div> </td> 
            </tr> 
            <tr id="i20" class="altColor"> 
             <td class="colFirst"><code><a href="../String.html" title="class in java.lang">String</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toString()">toString</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                显示要从中进行查找的类的名称。 
              </div> </td> 
            </tr> 
            <tr id="i21" class="rowColor"> 
             <td class="colFirst"><code><a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unreflect(java.lang.reflect.Method)">unreflect</a></span>​(<a href="../reflect/Method.html" title="class in java.lang.reflect">方法</a>&nbsp;m)</code></th> 
             <td class="colLast"> 
              <div class="block">
                如果查找类具有权限，则将 
               <a href="MethodHandleInfo.html#directmh">direct method handle设置</a>为 
               <i>m</i> 。 
              </div> </td> 
            </tr> 
            <tr id="i22" class="altColor"> 
             <td class="colFirst"><code><a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unreflectConstructor(java.lang.reflect.Constructor)">unreflectConstructor</a></span>​(<a href="../reflect/Constructor.html" title="class in java.lang.reflect">构造器</a>&lt;?&gt;&nbsp;c)</code></th> 
             <td class="colLast"> 
              <div class="block">
                为反射的构造函数生成方法句柄。 
              </div> </td> 
            </tr> 
            <tr id="i23" class="rowColor"> 
             <td class="colFirst"><code><a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unreflectGetter(java.lang.reflect.Field)">unreflectGetter</a></span>​(<a href="../reflect/Field.html" title="class in java.lang.reflect">字段</a>&nbsp;f)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成一个方法句柄，提供对反射字段的读访问权限。 
              </div> </td> 
            </tr> 
            <tr id="i24" class="altColor"> 
             <td class="colFirst"><code><a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unreflectSetter(java.lang.reflect.Field)">unreflectSetter</a></span>​(<a href="../reflect/Field.html" title="class in java.lang.reflect">字段</a>&nbsp;f)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成一个方法句柄，提供对反射字段的写访问权限。 
              </div> </td> 
            </tr> 
            <tr id="i25" class="rowColor"> 
             <td class="colFirst"><code><a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unreflectSpecial(java.lang.reflect.Method,java.lang.Class)">unreflectSpecial</a></span>​(<a href="../reflect/Method.html" title="class in java.lang.reflect">方法</a>&nbsp;m, <a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;specialCaller)</code></th> 
             <td class="colLast"> 
              <div class="block">
                为反射方法生成方法句柄。 
              </div> </td> 
            </tr> 
            <tr id="i26" class="altColor"> 
             <td class="colFirst"><code><a href="VarHandle.html" title="class in java.lang.invoke">VarHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unreflectVarHandle(java.lang.reflect.Field)">unreflectVarHandle</a></span>​(<a href="../reflect/Field.html" title="class in java.lang.reflect">字段</a>&nbsp;f)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成一个VarHandle，允许访问类型为 
               <code>f</code>的类型为 
               <code>T</code>的类型为 
               <code>R</code> 。 
              </div> </td> 
            </tr> 
           </tbody> 
          </table> 
          <ul class="blockList"> 
           <li class="blockList"><a id="methods.inherited.from.class.java.lang.Object"> 
             <!--   --> </a> <h3>声明方法的类&nbsp;java.lang.<a href="../Object.html" title="class in java.lang">Object</a></h3> <code><a href="../Object.html#clone()">clone</a>, <a href="../Object.html#equals(java.lang.Object)">equals</a>, <a href="../Object.html#finalize()">finalize</a>, <a href="../Object.html#getClass()">getClass</a>, <a href="../Object.html#hashCode()">hashCode</a>, <a href="../Object.html#notify()">notify</a>, <a href="../Object.html#notifyAll()">notifyAll</a>, <a href="../Object.html#wait()">wait</a>, <a href="../Object.html#wait(long)">wait</a>, <a href="../Object.html#wait(long,int)">wait</a></code></li> 
          </ul> </li> 
        </ul> 
       </section> </li> 
     </ul> 
    </div> 
    <div class="details"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <!-- ============ FIELD DETAIL =========== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="field.detail"> 
           <!--   --> </a> <h3>字段详细信息</h3> <a id="PUBLIC"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>PUBLIC</h4> <pre>public static final&nbsp;int PUBLIC</pre> 
            <div class="block"> 
             <span>表示<code>public</code>访问的单位掩码，可能导致<a href="#lookupModes()"><code>lookupModes</code></a>的结果。</span> 
             <span>值<code>0x01</code>恰好与<code>public</code> <a href="../reflect/Modifier.html#PUBLIC">modifier bit</a>的值相同。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="../../../../constant-values.html#java.lang.invoke.MethodHandles.Lookup.PUBLIC">常数字段值</a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="PRIVATE"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>PRIVATE</h4> <pre>public static final&nbsp;int PRIVATE</pre> 
            <div class="block"> 
             <span>代表<code>private</code>访问的单位掩码，可能导致<a href="#lookupModes()"><code>lookupModes</code></a>的结果。</span> 
             <span>值<code>0x02</code>恰好与<code>private</code> <a href="../reflect/Modifier.html#PRIVATE">modifier bit</a>的值相同。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="../../../../constant-values.html#java.lang.invoke.MethodHandles.Lookup.PRIVATE">常数字段值</a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="PROTECTED"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>PROTECTED</h4> <pre>public static final&nbsp;int PROTECTED</pre> 
            <div class="block"> 
             <span>表示<code>protected</code>访问的单位掩码，可能有助于<a href="#lookupModes()"><code>lookupModes</code></a>的结果。</span> 
             <span>值<code>0x04</code>恰好与<code>protected</code> <a href="../reflect/Modifier.html#PROTECTED">modifier bit</a>的值相同。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="../../../../constant-values.html#java.lang.invoke.MethodHandles.Lookup.PROTECTED">常数字段值</a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="PACKAGE"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>PACKAGE</h4> <pre>public static final&nbsp;int PACKAGE</pre> 
            <div class="block"> 
             <span>表示<code>package</code>访问（默认访问）的单位掩码，可能会导致<a href="#lookupModes()"><code>lookupModes</code></a>的结果。</span> 
             <span>值为<code>0x08</code> ，与任何特定的<a href="../reflect/Modifier.html" title="java.lang.reflect中的类">modifier bit</a>无意义地对应。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="../../../../constant-values.html#java.lang.invoke.MethodHandles.Lookup.PACKAGE">常数字段值</a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="MODULE"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>模块</h4> <pre>public static final&nbsp;int MODULE</pre> 
            <div class="block"> 
             <span>表示<code>模块</code>访问（默认访问）的单位掩码，可能会导致<a href="#lookupModes()"><code>lookupModes</code></a>的结果。</span> 
             <span>值为<code>0x10</code> ，与任何特定的<a href="../reflect/Modifier.html" title="java.lang.reflect中的类">modifier bit</a>无意义地对应。</span> 
             <span>与<code>PUBLIC</code>修饰符位一起使用具有此查找模式的<code>Lookup</code>可以访问查找类模块中的所有公共类型以及其他模块导出到查找类模块的包中的公共类型。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="../../../../constant-values.html#java.lang.invoke.MethodHandles.Lookup.MODULE">常数字段值</a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="UNCONDITIONAL"> 
           <!--   --> </a> 
          <ul class="blockListLast"> 
           <li class="blockList"> <h4>UNCONDITIONAL</h4> <pre>public static final&nbsp;int UNCONDITIONAL</pre> 
            <div class="block"> 
             <span>表示<code>unconditional</code>访问权限的单位掩码，可能导致<a href="#lookupModes()"><code>lookupModes</code></a>的结果。</span> 
             <span>值为<code>0x20</code> ，与任何特定的<a href="../reflect/Modifier.html" title="java.lang.reflect中的类">modifier bit</a>无意义地对应。</span> 
             <span>一个<code>Lookup</code>这种查找模式取得<a href="../Module.html#canRead(java.lang.Module)">readability</a> 。</span> 
             <span>与<code>PUBLIC</code>修饰符位一起使用具有此查找模式的<code>Lookup</code>可以访问所有模块的公共类型的所有公共成员，其中类型位于包<a href="../Module.html#isExported(java.lang.String)"><code>exported unconditionally</code>中</a> 。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="MethodHandles.html#publicLookup()"><code>MethodHandles.publicLookup()</code></a> ， 
              <a href="../../../../constant-values.html#java.lang.invoke.MethodHandles.Lookup.UNCONDITIONAL">常数字段值</a> 
             </dd> 
            </dl> </li> 
          </ul> </li> 
        </ul> 
       </section> 
       <!-- ============ METHOD DETAIL ========== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="method.detail"> 
           <!--   --> </a> <h3>方法详细信息</h3> <a id="lookupClass()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>lookupClass</h4> <pre class="methodSignature">public&nbsp;<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;lookupClass()</pre> 
            <div class="block"> 
             <span>告诉哪个类正在执行查找。</span> 
             <span>正是这个类针对可见性和访问权限执行检查。</span> 
             <p> <span>该类意味着最大级别的访问权限，但权限可能还受位掩码<a href="#lookupModes()"><code>lookupModes</code>的</a>限制，该位掩码控制是否可以访问非公共成员。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               查找类，代表该查找对象查找成员 
             </dd> 
            </dl> </li> 
          </ul> <a id="lookupModes()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>lookupModes</h4> <pre class="methodSignature">public&nbsp;int&nbsp;lookupModes()</pre> 
            <div class="block"> 
             <span>告知此查找对象可以生成哪些成员访问保护类。</span> 
             <span>结果是比特的位掩码<a href="#PUBLIC">PUBLIC (0x01)</a> ， <a href="#PRIVATE">PRIVATE (0x02)</a> ， <a href="#PROTECTED">PROTECTED (0x04)</a> ， <a href="#PACKAGE">PACKAGE (0x08)</a> ， <a href="#MODULE">MODULE (0x10)</a> ，和<a href="#UNCONDITIONAL">UNCONDITIONAL (0x20)</a> 。</span> 
             <p> <span><a href="MethodHandles.html#lookup()">caller's class</a>上新创建的查找对象具有所有可能的位设置，但<code>UNCONDITIONAL</code>除外。</span> <span>新查找类<a href="#in(java.lang.Class)">created from a previous lookup object</a>上的查找对象可能将某些模式位设置为零。</span> <span>模式位也可以是<a href="#dropLookupMode(int)">directly cleared</a> 。</span> <span>清除后，无法从降级的查找对象恢复模式位。</span> <span>这样做的目的是通过新的查找对象限制访问，以便它只能访问原始查找对象可以访问的名称，也可以访问新的查找类。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               查找模式，限制此查找对象执行的访问类型 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#in(java.lang.Class)"><code>in(java.lang.Class&lt;?&gt;)</code></a> ， 
              <a href="#dropLookupMode(int)"><code>dropLookupMode(int)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="in(java.lang.Class)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>in</h4> <pre class="methodSignature">public&nbsp;<a href="MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a>&nbsp;in​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;requestedLookupClass)</pre> 
            <div class="block"> 
             <span>在指定的新查找类上创建查找。</span> 
             <span>生成的对象将报告指定的类为其自己的<a href="#lookupClass()"><code>lookupClass</code></a> 。</span> 
             <p> <span>但是，保证生成的<code>Lookup</code>对象不再具有<code>Lookup</code>对象的访问权限。</span> <span>特别是，访问功能可能会丢失如下：</span> </p> 
             <ul> 
              <li> <span>如果旧查找类位于<a href="../Module.html#isNamed()"><code>named</code></a>模块中，并且新查找类位于不同的模块<code>M</code> ，则无法访问成员，甚至<code>M</code>的导出包中的公共成员。</span> <span>例外情况是此查找为<a href="MethodHandles.html#publicLookup()"><code>publicLookup</code></a> ，在这种情况下， <code>PUBLIC</code>访问不会丢失。</span> </li> 
              <li> <span>如果旧的查找类位于未命名的模块中，并且新的查找类是不同的模块，则会丢失<a href="#MODULE"><code>模块</code></a>访问权限。</span> </li> 
              <li> <span>如果新查找类与旧查找类不同，则丢失<code>UNCONDITIONAL</code> 。</span> </li> 
              <li> <span>如果新查找类与旧查找类不同，则无法访问受保护和默认（包）成员。</span> </li> 
              <li> <span>如果新查找类与旧查找类不在同一个包成员中，则不能访问私有成员，并且凭借继承将无法访问受保护的成员。</span> <span>（由于包共享，受保护的成员可能继续可访问。）</span> </li> 
              <li> <span>如果旧查找类无法访问新的查找类，则无法访问任何成员，甚至是公共成员。</span> <span>（在所有其他情况下，公共成员将继续可访问。）</span> </li> 
             </ul> 
             <p> <span>生成的查找加载类的功能（在<a href="#findClass(java.lang.String)"><code>findClass(java.lang.String)</code></a>调用期间使用）由查找类'加载程序确定，加载程序可能会因此操作而更改。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>requestedLookupClass</code> - 新查找对象的所需查找类 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               报告所需查找类的查找对象，如果没有更改则报告相同的对象 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果参数为null 
             </dd> 
            </dl> </li> 
          </ul> <a id="dropLookupMode(int)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>dropLookupMode</h4> <pre class="methodSignature">public&nbsp;<a href="MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a>&nbsp;dropLookupMode​(int&nbsp;modeToDrop)</pre> 
            <div class="block"> 
             <span>在查找对象找到成员的同一查找类上创建查找，但查找模式已丢失给定的查找模式。</span> 
             <span>查找模式下降是一个<a href="#PUBLIC"><code>PUBLIC</code></a> ， <a href="#MODULE"><code>模块</code></a> ， <a href="#PACKAGE"><code>PACKAGE</code></a> ， <a href="#PROTECTED"><code>PROTECTED</code></a>或<a href="#PRIVATE"><code>PRIVATE</code></a> 。</span> 
             <span><a href="#PROTECTED"><code>PROTECTED</code></a>和<a href="#UNCONDITIONAL"><code>UNCONDITIONAL</code></a>始终被删除，因此生成的查找模式将永远不会具有这些访问功能。</span> 
             <span>删除<code>PACKAGE</code> ，生成的查找将不具有<code>PACKAGE</code>或<code>PRIVATE</code>访问权限。</span> 
             <span>当拖放<code>模块</code>然后将得到的查找不会有<code>模块</code> ， <code>PACKAGE</code> ，或<code>PRIVATE</code>访问。</span> 
             <span>如果<code>PUBLIC</code> ，则生成的查找无权访问。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>modeToDrop</code> - 要删除的查找模式 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               缺少指示模式的查找对象，如果没有更改，则返回相同的对象 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果 
              <code>modeToDrop</code>不是一个 
              <code>PUBLIC</code> ， 
              <code>模块</code> ， 
              <code>PACKAGE</code> ， 
              <code>PROTECTED</code> ， 
              <code>PRIVATE</code>或 
              <code>UNCONDITIONAL</code> 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="MethodHandles.html#privateLookupIn(java.lang.Class,java.lang.invoke.MethodHandles.Lookup)"><code>MethodHandles.privateLookupIn(java.lang.Class&lt;?&gt;, java.lang.invoke.MethodHandles.Lookup)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="defineClass(byte[])"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>defineClass</h4> <pre class="methodSignature">public&nbsp;<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;defineClass​(byte[]&nbsp;bytes)
                     throws <a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre> 
            <div class="block"> 
             <span>为同一个类加载器和相同的运行时包定义一个类，并将<a href="../../security/ProtectionDomain.html" title="java.security中的类">protection domain</a>定义为此查找的<a href="#lookupClass()">lookup class</a> 。</span> 
             <p> <span>此查找的<a href="#lookupModes()">lookup modes</a>必须包含<a href="#PACKAGE"><code>PACKAGE</code></a>访问权限，因为<a href="#PACKAGE">该类</a>可以访问默认（包）成员。</span> <span><code>PACKAGE</code>查找模式用于验证查找对象是由运行时包中的调用者创建的（或者是从最初由适当特权代码创建的查找派生到运行时包中的目标类）。</span> </p> 
             <p> <span><code>bytes</code>参数是有效类文件的类字节（由<em>Java虚拟机规范</em>定义），其类名与查找类位于同一包中。</span> </p> 
             <p> <span>此方法不运行类初始值设定项。</span> <span>类初始化程序可以在以后运行，详见<em>“Java语言规范”的</em>第12.4节。</span> </p> 
             <p> <span>如果有安全管理器，则首先调用其<code>checkPermission</code>方法以检查<code>RuntimePermission("defineClass")</code> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>bytes</code> - 类字节 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>类</code>对象 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 字节用于查找类的不同包中的类 
             </dd> 
             <dd> 
              <code><a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code> - 如果此查找没有 
              <code>PACKAGE</code>访问权限 
             </dd> 
             <dd> 
              <code><a href="../LinkageError.html" title="class in java.lang">LinkageError</a></code> - 如果类格式错误（ 
              <code>ClassFormatError</code> ），无法验证（ 
              <code>VerifyError</code> ），已定义，或发生其他链接错误 
             </dd> 
             <dd> 
              <code><a href="../SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果安全经理拒绝 
             </dd> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
              <code>bytes</code>是 
              <code>null</code> 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="MethodHandles.html#privateLookupIn(java.lang.Class,java.lang.invoke.MethodHandles.Lookup)"><code>MethodHandles.privateLookupIn(java.lang.Class&lt;?&gt;, java.lang.invoke.MethodHandles.Lookup)</code></a> ， 
              <a href="#dropLookupMode(int)"><code>dropLookupMode(int)</code></a> ， 
              <a href="../ClassLoader.html#defineClass(java.lang.String,byte%5B%5D,int,int,java.security.ProtectionDomain)"><code>ClassLoader.defineClass(String,byte[],int,int,ProtectionDomain)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="toString()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>toString</h4> <pre class="methodSignature">public&nbsp;<a href="../String.html" title="class in java.lang">String</a>&nbsp;toString()</pre> 
            <div class="block"> 
             <span>显示要从中进行查找的类的名称。</span> 
             <span>（该名称是由<a href="../Class.html#getName()"><code>Class.getName</code></a>报告的<a href="../Class.html#getName()">名称</a> 。）如果对此查找允许的访问存在限制，则通过在类名称中添加后缀（由斜杠和关键字组成）来指示。</span> 
             <span>关键字代表最强的允许访问权限，选择如下：</span> 
             <ul> 
              <li> <span>如果不允许访问，则后缀为“/ noaccess”。</span> </li> 
              <li> <span>如果仅允许对导出包中的类型进行公共访问，则后缀为“/ public”。</span> </li> 
              <li> <span>如果仅允许公共访问和无条件访问，则后缀为“/ publicLookup”。</span> </li> 
              <li> <span>如果仅允许公共访问和模块访问，则后缀为“/ module”。</span> </li> 
              <li> <span>如果只允许公共，模块和包访问，则后缀为“/ package”。</span> </li> 
              <li> <span>如果仅允许公共，模块，包和私有访问，则后缀为“/ private”。</span> </li> 
             </ul> 
             <span>如果上述情况均不适用，则允许完全访问（公共，模块，包，私有和受保护）。</span> 
             <span>在这种情况下，不添加后缀。</span> 
             <span>这仅适用于最初从<a href="MethodHandles.html#lookup()"><code>MethodHandles.lookup</code></a>获得的对象。</span> 
             <span>由<a href="#in(java.lang.Class)"><code>Lookup.in</code></a>创建的<a href="#in(java.lang.Class)">对象</a>始终具有受限访问权限，并将显示后缀。</span> 
             <p> <span>（受保护的访问应该比私有访问更强大可能看起来很奇怪。独立于包访问，受保护的访问首先被丢失，因为它需要调用者和被调用者之间的直接子类关系。）</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="overrideSpecifyLabel">重写：</span> 
             </dt> 
             <dd> 
              <code><a href="../Object.html#toString()">toString</a></code>在类 
              <code><a href="../Object.html" title="class in java.lang">Object</a></code> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               对象的字符串表示形式。 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#in(java.lang.Class)"><code>in(java.lang.Class&lt;?&gt;)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="findStatic(java.lang.Class,java.lang.String,java.lang.invoke.MethodType)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>findStatic</h4> <pre class="methodSignature">public&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;findStatic​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;refc,
                               <a href="../String.html" title="class in java.lang">String</a>&nbsp;name,
                               <a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)
                        throws <a href="../NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a>,
                               <a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre> 
            <div class="block"> 
             <span>生成静态方法的方法句柄。</span> 
             <span>方法句柄的类型将是方法的类型。</span> 
             <span>（由于静态方法不接收接收器，因此没有额外的接收器参数插入到方法句柄类型中，就像<a href="#findVirtual(java.lang.Class,java.lang.String,java.lang.invoke.MethodType)"><code>findVirtual</code></a>或<a href="#findSpecial(java.lang.Class,java.lang.String,java.lang.invoke.MethodType,java.lang.Class)"><code>findSpecial</code>一样</a> 。）查找对象必须可以访问该方法及其所有参数类型。</span> 
             <p> <span>当且仅当设置了方法的变量arity修饰符位（ <code>0x0080</code> ）时，返回的方法句柄才会有<a href="MethodHandle.html#asVarargsCollector(java.lang.Class)">variable arity</a> 。</span> </p> 
             <p> <span>如果调用返回的方法句柄，则初始化方法的类（如果尚未初始化）。</span> </p> 
             <p> <span><b>例：</b></span> </p> 
             <blockquote> 
              <span><pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle MH_asList = publicLookup().findStatic(Arrays.class,
  "asList", methodType(List.class, Object[].class));
assertEquals("[x, y]", MH_asList.invoke("x", "y").toString());
 </code></pre></span> 
             </blockquote> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>refc</code> - 从中访问方法的类 
             </dd> 
             <dd> 
              <code>name</code> - 方法的名称 
             </dd> 
             <dd> 
              <code>type</code> - 方法的类型 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               所需的方法句柄 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a></code> - 如果该方法不存在 
             </dd> 
             <dd> 
              <code><a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code> - 如果访问检查失败，或者方法不是 
              <code>static</code> ，或者方法的变量arity修饰符位已设置且 
              <code>asVarargsCollector</code>失败 
             </dd> 
             <dd> 
              <code><a href="../SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理器且 
              <a href="MethodHandles.Lookup.html#secmgr">refuses access</a> 
             </dd> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任何参数为null 
             </dd> 
            </dl> </li> 
          </ul> <a id="findVirtual(java.lang.Class,java.lang.String,java.lang.invoke.MethodType)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>findVirtual</h4> <pre class="methodSignature">public&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;findVirtual​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;refc,
                                <a href="../String.html" title="class in java.lang">String</a>&nbsp;name,
                                <a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)
                         throws <a href="../NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a>,
                                <a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre> 
            <div class="block"> 
             <span>生成虚方法的方法句柄。</span> 
             <span>方法句柄的类型将是方法的类型，前缀为接收器类型（通常为<code>refc</code> ）。</span> 
             <span>查找对象必须可以访问该方法及其所有参数类型。</span> 
             <p> <span>调用时，句柄将第一个参数视为接收者，对于非私有方法，调度接收者的类型以确定要输入的方法实现。</span> <span>对于私有方法，将在接收器上调用<code>refc</code>的命名方法。</span> <span>（调度操作与<code>invokevirtual</code>或<code>invokeinterface</code>指令执行的操作相同。）</span> </p> 
             <p> <span>如果查找类具有访问该成员的完全权限，则第一个参数的类型为<code>refc</code> 。</span> <span>否则，该成员必须为<code>protected</code>并且第一个参数的类型将限制为查找类。</span> </p> 
             <p> <span>当且仅当设置了方法的变量arity修饰符位（ <code>0x0080</code> ）时，返回的方法句柄将具有<a href="MethodHandle.html#asVarargsCollector(java.lang.Class)">variable arity</a> 。</span> </p> 
             <p> <span>因为一般<a href="MethodHandles.Lookup.html#equiv">equivalence</a>之间<code>invokevirtual</code>的指令和方法所生产手柄<code>findVirtual</code> ，如果类是<code>MethodHandle</code>和名称的字符串是<code>invokeExact</code>或<code>invoke</code> ，所得方法手柄等效于一个由产生<a href="MethodHandles.html#exactInvoker(java.lang.invoke.MethodType)"><code>MethodHandles.exactInvoker</code></a>或<a href="MethodHandles.html#invoker(java.lang.invoke.MethodType)"><code>MethodHandles.invoker</code></a>具有相同<code>type</code>参数。</span> </p> 
             <p> <span>如果类为<code>VarHandle</code>且名称字符串对应于签名多态访问模式方法的名称，则生成的方法句柄等效于<a href="MethodHandles.html#varHandleInvoker(java.lang.invoke.VarHandle.AccessMode,java.lang.invoke.MethodType)"><code>MethodHandles.varHandleInvoker(java.lang.invoke.VarHandle.AccessMode, java.lang.invoke.MethodType)</code></a>生成的方法句柄，其访问模式对应于名称字符串且具有相同的<code>type</code>参数。</span> </p> 
             <p> <span><b>例：</b></span> </p> 
             <blockquote> 
              <span><pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle MH_concat = publicLookup().findVirtual(String.class,
  "concat", methodType(String.class, String.class));
MethodHandle MH_hashCode = publicLookup().findVirtual(Object.class,
  "hashCode", methodType(int.class));
MethodHandle MH_hashCode_String = publicLookup().findVirtual(String.class,
  "hashCode", methodType(int.class));
assertEquals("xy", (String) MH_concat.invokeExact("x", "y"));
assertEquals("xy".hashCode(), (int) MH_hashCode.invokeExact((Object)"xy"));
assertEquals("xy".hashCode(), (int) MH_hashCode_String.invokeExact("xy"));
// interface method:
MethodHandle MH_subSequence = publicLookup().findVirtual(CharSequence.class,
  "subSequence", methodType(CharSequence.class, int.class, int.class));
assertEquals("def", MH_subSequence.invoke("abcdefghi", 3, 6).toString());
// constructor "internal method" must be accessed differently:
MethodType MT_newString = methodType(void.class); //()V for new String()
try { assertEquals("impossible", lookup()
        .findVirtual(String.class, "&lt;init&gt;", MT_newString));
 } catch (NoSuchMethodException ex) { } // OK
MethodHandle MH_newString = publicLookup()
  .findConstructor(String.class, MT_newString);
assertEquals("", (String) MH_newString.invokeExact());
 </code></pre></span> 
             </blockquote> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>refc</code> - 从中访问方法的类或接口 
             </dd> 
             <dd> 
              <code>name</code> - 方法的名称 
             </dd> 
             <dd> 
              <code>type</code> - 方法的类型，省略receiver参数 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               所需的方法句柄 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a></code> - 如果该方法不存在 
             </dd> 
             <dd> 
              <code><a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code> - 如果访问检查失败，或者方法是 
              <code>static</code> ，或者方法的变量arity修饰符位已设置且 
              <code>asVarargsCollector</code>失败 
             </dd> 
             <dd> 
              <code><a href="../SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理器且 
              <a href="MethodHandles.Lookup.html#secmgr">refuses access</a> 
             </dd> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任何参数为null 
             </dd> 
            </dl> </li> 
          </ul> <a id="findConstructor(java.lang.Class,java.lang.invoke.MethodType)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>findConstructor</h4> <pre class="methodSignature">public&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;findConstructor​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;refc,
                                    <a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)
                             throws <a href="../NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a>,
                                    <a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre> 
            <div class="block"> 
             <span>生成一个方法句柄，该句柄使用指定类型的构造函数创建对象并对其进行初始化。</span> 
             <span>方法句柄的参数类型将是构造函数的参数类型，而返回类型将是对构造函数类的引用。</span> 
             <span>查找对象必须可以访问构造函数及其所有参数类型。</span> 
             <p> <span>请求的类型必须具有返回类型<code>void</code> 。</span> <span>（这与JVM对构造函数类型描述符的处理一致。）</span> </p> 
             <p> <span>当且仅当构造函数的变量arity修饰符位（ <code>0x0080</code> ）已设置时，返回的方法句柄才会有<a href="MethodHandle.html#asVarargsCollector(java.lang.Class)">variable arity</a> 。</span> </p> 
             <p> <span>如果调用返回的方法句柄，则初始化构造函数的类（如果尚未初始化）。</span> </p> 
             <p> <span><b>例：</b></span> </p> 
             <blockquote> 
              <span><pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle MH_newArrayList = publicLookup().findConstructor(
  ArrayList.class, methodType(void.class, Collection.class));
Collection orig = Arrays.asList("x", "y");
Collection copy = (ArrayList) MH_newArrayList.invokeExact(orig);
assert(orig != copy);
assertEquals(orig, copy);
// a variable-arity constructor:
MethodHandle MH_newProcessBuilder = publicLookup().findConstructor(
  ProcessBuilder.class, methodType(void.class, String[].class));
ProcessBuilder pb = (ProcessBuilder)
  MH_newProcessBuilder.invoke("x", "y", "z");
assertEquals("[x, y, z]", pb.command().toString());
 </code></pre></span> 
             </blockquote> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>refc</code> - 从中访问方法的类或接口 
             </dd> 
             <dd> 
              <code>type</code> - 方法的类型，省略了receiver参数，以及void返回类型 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               所需的方法句柄 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a></code> - 如果构造函数不存在 
             </dd> 
             <dd> 
              <code><a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code> - 如果访问检查失败或者方法的变量arity修饰符位已设置且 
              <code>asVarargsCollector</code>失败 
             </dd> 
             <dd> 
              <code><a href="../SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理器且 
              <a href="MethodHandles.Lookup.html#secmgr">refuses access</a> 
             </dd> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任何参数为null 
             </dd> 
            </dl> </li> 
          </ul> <a id="findClass(java.lang.String)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>findClass</h4> <pre class="methodSignature">public&nbsp;<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;findClass​(<a href="../String.html" title="class in java.lang">String</a>&nbsp;targetName)
                   throws <a href="../ClassNotFoundException.html" title="class in java.lang">ClassNotFoundException</a>,
                          <a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre> 
            <div class="block"> 
             <span>从此<code>Lookup</code>对象定义的查找上下文中按名称查找类。</span> 
             <span>该类的静态初始值设定项未运行。</span> 
             <p> <span>此处的查找上下文由<a href="#lookupClass()">lookup class</a>及其类加载器和<a href="#lookupModes()">lookup modes确定</a> 。</span> <span>特别是，该方法首先尝试加载所请求的类，然后确定该查找对象是否可以访问该类。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>targetName</code> - 要查找的类的完全限定名称。 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               要求的课程。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理器且 
              <a href="MethodHandles.Lookup.html#secmgr">refuses access</a> 
             </dd> 
             <dd> 
              <code><a href="../LinkageError.html" title="class in java.lang">LinkageError</a></code> - 如果链接失败 
             </dd> 
             <dd> 
              <code><a href="../ClassNotFoundException.html" title="class in java.lang">ClassNotFoundException</a></code> - 如果查找类的加载程序无法加载该类。 
             </dd> 
             <dd> 
              <code><a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code> - 如果无法访问该类，则使用允许的访问模式。 
             </dd> 
             <dd> 
              <code><a href="../SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理器且 
              <a href="MethodHandles.Lookup.html#secmgr">refuses access</a> 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
            </dl> </li> 
          </ul> <a id="accessClass(java.lang.Class)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>accessClass</h4> <pre class="methodSignature">public&nbsp;<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;accessClass​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;targetClass)
                     throws <a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre> 
            <div class="block"> 
             <span>确定是否可以从此<code>Lookup</code>对象定义的查找上下文中访问类。</span> 
             <span>该类的静态初始值设定项未运行。</span> 
             <p> <span>此处的查找上下文由<a href="#lookupClass()">lookup class</a>和<a href="#lookupModes()">lookup modes</a>确定。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>targetClass</code> - 要访问检查的类 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               已访问检查的类 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code> - 如果无法使用允许的访问模式从查找类访问该类。 
             </dd> 
             <dd> 
              <code><a href="../SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理器且 
              <a href="MethodHandles.Lookup.html#secmgr">refuses access</a> 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
            </dl> </li> 
          </ul> <a id="findSpecial(java.lang.Class,java.lang.String,java.lang.invoke.MethodType,java.lang.Class)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>findSpecial</h4> <pre class="methodSignature">public&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;findSpecial​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;refc,
                                <a href="../String.html" title="class in java.lang">String</a>&nbsp;name,
                                <a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type,
                                <a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;specialCaller)
                         throws <a href="../NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a>,
                                <a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre> 
            <div class="block"> 
             <span>为虚方法生成早期绑定方法句柄。</span> 
             <span>它会绕过检查重写在接收机，方法<a href="MethodHandles.Lookup.html#equiv">as if called</a>从<code>invokespecial</code>从明确内指令指定<code>specialCaller</code> 。</span> 
             <span>方法句柄的类型将是方法的类型，具有适当受限的接收器类型。</span> 
             <span>（接收器类型将为<code>specialCaller</code>或子类型。）查找对象必须可以访问该方法及其所有参数类型。</span> 
             <p> <span>在方法解析之前，如果显式指定的调用者类与查找类不相同，或者此查找对象没有<a href="MethodHandles.Lookup.html#privacc">private access</a>特权，则访问将失败。</span> </p> 
             <p> <span>当且仅当设置了方法的变量arity修饰符位（ <code>0x0080</code> ）时，返回的方法句柄将具有<a href="MethodHandle.html#asVarargsCollector(java.lang.Class)">variable arity</a> 。</span> </p> 
             <p style="font-size:smaller;"> <span><em>（注意：此API不显示名为<code>"&lt;init&gt;"</code> JVM内部方法，即使<code>invokespecial</code>指令在特殊情况下可以引用它们。使用<a href="#findConstructor(java.lang.Class,java.lang.invoke.MethodType)"><code>findConstructor</code></a>以安全的方式访问实例初始化方法。）</em></span> </p> 
             <p> <span><b>例：</b></span> </p> 
             <blockquote> 
              <span><pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
static class Listie extends ArrayList {
  public String toString() { return "[wee Listie]"; }
  static Lookup lookup() { return MethodHandles.lookup(); }
}
...
// no access to constructor via invokeSpecial:
MethodHandle MH_newListie = Listie.lookup()
  .findConstructor(Listie.class, methodType(void.class));
Listie l = (Listie) MH_newListie.invokeExact();
try { assertEquals("impossible", Listie.lookup().findSpecial(
        Listie.class, "&lt;init&gt;", methodType(void.class), Listie.class));
 } catch (NoSuchMethodException ex) { } // OK
// access to super and self methods via invokeSpecial:
MethodHandle MH_super = Listie.lookup().findSpecial(
  ArrayList.class, "toString" , methodType(String.class), Listie.class);
MethodHandle MH_this = Listie.lookup().findSpecial(
  Listie.class, "toString" , methodType(String.class), Listie.class);
MethodHandle MH_duper = Listie.lookup().findSpecial(
  Object.class, "toString" , methodType(String.class), Listie.class);
assertEquals("[]", (String) MH_super.invokeExact(l));
assertEquals(""+l, (String) MH_this.invokeExact(l));
assertEquals("[]", (String) MH_duper.invokeExact(l)); // ArrayList method
try { assertEquals("inaccessible", Listie.lookup().findSpecial(
        String.class, "toString", methodType(String.class), Listie.class));
 } catch (IllegalAccessException ex) { } // OK
Listie subl = new Listie() { public String toString() { return "[subclass]"; } };
assertEquals(""+l, (String) MH_this.invokeExact(subl)); // Listie method
 </code></pre></span> 
             </blockquote> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>refc</code> - 从中访问方法的类或接口 
             </dd> 
             <dd> 
              <code>name</code> - 方法的名称（不能是“&lt;init&gt;”） 
             </dd> 
             <dd> 
              <code>type</code> - 方法的类型，省略receiver参数 
             </dd> 
             <dd> 
              <code>specialCaller</code> - 建议的调用类执行 
              <code>invokespecial</code> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               所需的方法句柄 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a></code> - 如果该方法不存在 
             </dd> 
             <dd> 
              <code><a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code> - 如果访问检查失败，或者方法是 
              <code>static</code> ，或者方法的变量arity修饰符位已设置且 
              <code>asVarargsCollector</code>失败 
             </dd> 
             <dd> 
              <code><a href="../SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理器且 
              <a href="MethodHandles.Lookup.html#secmgr">refuses access</a> 
             </dd> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任何参数为null 
             </dd> 
            </dl> </li> 
          </ul> <a id="findGetter(java.lang.Class,java.lang.String,java.lang.Class)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>findGetter</h4> <pre class="methodSignature">public&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;findGetter​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;refc,
                               <a href="../String.html" title="class in java.lang">String</a>&nbsp;name,
                               <a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;type)
                        throws <a href="../NoSuchFieldException.html" title="class in java.lang">NoSuchFieldException</a>,
                               <a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre> 
            <div class="block"> 
             <span>生成一个方法句柄，提供对非静态字段的读访问权限。</span> 
             <span>方法句柄的类型将具有字段值类型的返回类型。</span> 
             <span>方法句柄的单个参数将是包含该字段的实例。</span> 
             <span>代表查找类立即执行访问检查。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>refc</code> - 从中访问方法的类或接口 
             </dd> 
             <dd> 
              <code>name</code> - 该字段的名称 
             </dd> 
             <dd> 
              <code>type</code> - 字段的类型 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个方法句柄，可以从字段加载值 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NoSuchFieldException.html" title="class in java.lang">NoSuchFieldException</a></code> - 如果该字段不存在 
             </dd> 
             <dd> 
              <code><a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code> - 如果访问检查失败，或者字段为 
              <code>static</code> 
             </dd> 
             <dd> 
              <code><a href="../SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理器且 
              <a href="MethodHandles.Lookup.html#secmgr">refuses access</a> 
             </dd> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任何参数为null 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#findVarHandle(java.lang.Class,java.lang.String,java.lang.Class)"><code>findVarHandle(Class, String, Class)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="findSetter(java.lang.Class,java.lang.String,java.lang.Class)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>findSetter</h4> <pre class="methodSignature">public&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;findSetter​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;refc,
                               <a href="../String.html" title="class in java.lang">String</a>&nbsp;name,
                               <a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;type)
                        throws <a href="../NoSuchFieldException.html" title="class in java.lang">NoSuchFieldException</a>,
                               <a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre> 
            <div class="block"> 
             <span>生成一个方法句柄，提供对非静态字段的写访问权限。</span> 
             <span>方法句柄的类型将具有void返回类型。</span> 
             <span>方法句柄将采用两个参数，包含字段的实例和要存储的值。</span> 
             <span>第二个参数将是字段的值类型。</span> 
             <span>代表查找类立即执行访问检查。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>refc</code> - 从中访问方法的类或接口 
             </dd> 
             <dd> 
              <code>name</code> - 该字段的名称 
             </dd> 
             <dd> 
              <code>type</code> - 字段的类型 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个方法句柄，可以将值存储到字段中 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NoSuchFieldException.html" title="class in java.lang">NoSuchFieldException</a></code> - 如果该字段不存在 
             </dd> 
             <dd> 
              <code><a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code> - 如果访问检查失败，或者字段为 
              <code>static</code> 
             </dd> 
             <dd> 
              <code><a href="../SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理器且 
              <a href="MethodHandles.Lookup.html#secmgr">refuses access</a> 
             </dd> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任何参数为null 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#findVarHandle(java.lang.Class,java.lang.String,java.lang.Class)"><code>findVarHandle(Class, String, Class)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="findVarHandle(java.lang.Class,java.lang.String,java.lang.Class)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>findVarHandle</h4> <pre class="methodSignature">public&nbsp;<a href="VarHandle.html" title="class in java.lang.invoke">VarHandle</a>&nbsp;findVarHandle​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;recv,
                               <a href="../String.html" title="class in java.lang">String</a>&nbsp;name,
                               <a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;type)
                        throws <a href="../NoSuchFieldException.html" title="class in java.lang">NoSuchFieldException</a>,
                               <a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre> 
            <div class="block"> 
             <span>生成VarHandle，允许访问类型为<code>name</code>的类型为<code>type</code>的非静态字段<code>recv</code> 。</span> 
             <span>VarHandle的变量类型是<code>type</code> ，它有一个坐标类型， <code>recv</code> 。</span> 
             <p> <span>代表查找类立即执行访问检查。</span> </p> 
             <p> <span>在以下条件下，不支持返回的VarHandle的某些访问模式：</span> </p> 
             <ul> 
              <li> <span>如果声明字段为<code>final</code> ，则不支持写入，原子更新，数字原子更新和按位原子更新访问模式。</span> </li> 
              <li> <span>如果字段的类型是比其他任何<code>byte</code> ， <code>short</code> ， <code>char</code> ， <code>int</code> ， <code>long</code> ， <code>float</code> ，或<code>double</code>然后数字原子更新的接入方式是不受支持的。</span> </li> 
              <li> <span>如果字段的类型是比其他任何<code>boolean</code> ， <code>byte</code> ， <code>short</code> ， <code>char</code> ， <code>int</code>或<code>long</code>然后按位原子更新的接入方式是不受支持的。</span> </li> 
             </ul> 
             <p> <span>如果该字段被声明为<code>volatile</code>则返回的VarHandle将根据其指定的访问模式覆盖对该字段的访问（实际上忽略<code>volatile</code>声明）。</span> </p> 
             <p> <span>如果字段类型为<code>float</code>或<code>double</code>则数字和原子更新访问模式使用其按位表示形式比较值（分别参见<a href="../Float.html#floatToRawIntBits(float)"><code>Float.floatToRawIntBits(float)</code></a>和<a href="../Double.html#doubleToRawLongBits(double)"><code>Double.doubleToRawLongBits(double)</code></a> ）。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>由数值和原子更新访问模式执行的<code>float</code>值或<code>double</code>值的按位比较不同于原始<code>==</code>运算符和<a href="../Float.html#equals(java.lang.Object)"><code>Float.equals(java.lang.Object)</code></a>和<a href="../Double.html#equals(java.lang.Object)"><code>Double.equals(java.lang.Object)</code></a>方法，特别是关于比较NaN值或比较<code>-0.0</code>与<code>+0.0</code> 。</span> 
              <span>由于操作可能意外失败，因此在执行比较和设置或比较和交换操作时应小心这些值。</span> 
              <span>Java中有许多可能的NaN值被认为是<code>NaN</code> ，尽管Java提供的IEEE 754浮点运算不能区分它们。</span> 
              <span>如果预期值或见证值是NaN值并且它（可能以平台特定方式）转换为另一个NaN值，则可能发生操作失败，因此具有不同的按位表示（有关更多详细信息，请参阅<a href="../Float.html#intBitsToFloat(int)"><code>Float.intBitsToFloat(int)</code></a>或<a href="../Double.html#longBitsToDouble(long)"><code>Double.longBitsToDouble(long)</code></a> ）。</span> 
              <span>值<code>-0.0</code>和<code>+0.0</code>具有不同的按位表示，但在使用原语<code>==</code>运算符时被认为是相等的。</span> 
              <span>如果，例如，数字算法计算的预期值是说可能会出现操作故障<code>-0.0</code>和先前计算的见证价值被说<code>+0.0</code> 。</span> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>recv</code> - 类型为 
              <code>R</code>的接收器类，声明非静态字段 
             </dd> 
             <dd> 
              <code>name</code> - 该字段的名称 
             </dd> 
             <dd> 
              <code>type</code> - 字段的类型，类型 
              <code>T</code> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个VarHandle，可以访问非静态字段。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NoSuchFieldException.html" title="class in java.lang">NoSuchFieldException</a></code> - 如果该字段不存在 
             </dd> 
             <dd> 
              <code><a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code> - 如果访问检查失败，或者字段为 
              <code>static</code> 
             </dd> 
             <dd> 
              <code><a href="../SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理器且 
              <a href="MethodHandles.Lookup.html#secmgr">refuses access</a> 
             </dd> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任何参数为null 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
            </dl> </li> 
          </ul> <a id="findStaticGetter(java.lang.Class,java.lang.String,java.lang.Class)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>findStaticGetter</h4> <pre class="methodSignature">public&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;findStaticGetter​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;refc,
                                     <a href="../String.html" title="class in java.lang">String</a>&nbsp;name,
                                     <a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;type)
                              throws <a href="../NoSuchFieldException.html" title="class in java.lang">NoSuchFieldException</a>,
                                     <a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre> 
            <div class="block"> 
             <span>生成一个方法句柄，提供对静态字段的读访问权限。</span> 
             <span>方法句柄的类型将具有字段值类型的返回类型。</span> 
             <span>方法句柄不带参数。</span> 
             <span>代表查找类立即执行访问检查。</span> 
             <p> <span>如果调用返回的方法句柄，则初始化字段的类（如果尚未初始化）。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>refc</code> - 从中访问方法的类或接口 
             </dd> 
             <dd> 
              <code>name</code> - 该字段的名称 
             </dd> 
             <dd> 
              <code>type</code> - 字段的类型 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个方法句柄，可以从字段加载值 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NoSuchFieldException.html" title="class in java.lang">NoSuchFieldException</a></code> - 如果该字段不存在 
             </dd> 
             <dd> 
              <code><a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code> - 如果访问检查失败，或者该字段不是 
              <code>static</code> 
             </dd> 
             <dd> 
              <code><a href="../SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理器且 
              <a href="MethodHandles.Lookup.html#secmgr">refuses access</a> 
             </dd> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任何参数为null 
             </dd> 
            </dl> </li> 
          </ul> <a id="findStaticSetter(java.lang.Class,java.lang.String,java.lang.Class)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>findStaticSetter</h4> <pre class="methodSignature">public&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;findStaticSetter​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;refc,
                                     <a href="../String.html" title="class in java.lang">String</a>&nbsp;name,
                                     <a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;type)
                              throws <a href="../NoSuchFieldException.html" title="class in java.lang">NoSuchFieldException</a>,
                                     <a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre> 
            <div class="block"> 
             <span>生成一个方法句柄，提供对静态字段的写访问权限。</span> 
             <span>方法句柄的类型将具有void返回类型。</span> 
             <span>方法句柄将采用字段值类型的单个参数，即要存储的值。</span> 
             <span>代表查找类立即执行访问检查。</span> 
             <p> <span>如果调用返回的方法句柄，则初始化字段的类（如果尚未初始化）。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>refc</code> - 从中访问方法的类或接口 
             </dd> 
             <dd> 
              <code>name</code> - 该字段的名称 
             </dd> 
             <dd> 
              <code>type</code> - 字段的类型 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个方法句柄，可以将值存储到字段中 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NoSuchFieldException.html" title="class in java.lang">NoSuchFieldException</a></code> - 如果该字段不存在 
             </dd> 
             <dd> 
              <code><a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code> - 如果访问检查失败，或者该字段不是 
              <code>static</code> 
             </dd> 
             <dd> 
              <code><a href="../SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理器且 
              <a href="MethodHandles.Lookup.html#secmgr">refuses access</a> 
             </dd> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任何参数为null 
             </dd> 
            </dl> </li> 
          </ul> <a id="findStaticVarHandle(java.lang.Class,java.lang.String,java.lang.Class)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>findStaticVarHandle</h4> <pre class="methodSignature">public&nbsp;<a href="VarHandle.html" title="class in java.lang.invoke">VarHandle</a>&nbsp;findStaticVarHandle​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;decl,
                                     <a href="../String.html" title="class in java.lang">String</a>&nbsp;name,
                                     <a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;type)
                              throws <a href="../NoSuchFieldException.html" title="class in java.lang">NoSuchFieldException</a>,
                                     <a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre> 
            <div class="block"> 
             <span>生成一个VarHandle，允许访问类型为<code>name</code>的类型为<code>type</code>的静态字段<code>decl</code> 。</span> 
             <span>VarHandle的变量类型是<code>type</code> ，它没有坐标类型。</span> 
             <p> <span>代表查找类立即执行访问检查。</span> </p> 
             <p> <span>如果操作返回的VarHandle，则初始化声明类（如果尚未初始化）。</span> </p> 
             <p> <span>在以下条件下，不支持返回的VarHandle的某些访问模式：</span> </p> 
             <ul> 
              <li> <span>如果该字段声明为<code>final</code> ，则不支持写入，原子更新，数字原子更新和按位原子更新访问模式。</span> </li> 
              <li> <span>如果字段的类型是比其他任何<code>byte</code> ， <code>short</code> ， <code>char</code> ， <code>int</code> ， <code>long</code> ， <code>float</code> ，或<code>double</code> ，然后数字原子更新的接入方式是不受支持的。</span> </li> 
              <li> <span>如果字段的类型是比其他任何<code>boolean</code> ， <code>byte</code> ， <code>short</code> ， <code>char</code> ， <code>int</code>或<code>long</code>然后按位原子更新的接入方式是不受支持的。</span> </li> 
             </ul> 
             <p> <span>如果该字段被声明为<code>volatile</code>则返回的VarHandle将根据其指定的访问模式覆盖对该字段的访问（实际上忽略<code>volatile</code>声明）。</span> </p> 
             <p> <span>如果字段类型为<code>float</code>或<code>double</code>则数字和原子更新访问模式使用其按位表示形式比较值（分别参见<a href="../Float.html#floatToRawIntBits(float)"><code>Float.floatToRawIntBits(float)</code></a>和<a href="../Double.html#doubleToRawLongBits(double)"><code>Double.doubleToRawLongBits(double)</code></a> ）。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>由数值和原子更新访问模式执行的<code>float</code>值或<code>double</code>值的按位比较与原始<code>==</code>运算符和<a href="../Float.html#equals(java.lang.Object)"><code>Float.equals(java.lang.Object)</code></a>和<a href="../Double.html#equals(java.lang.Object)"><code>Double.equals(java.lang.Object)</code></a>方法不同，特别是在比较NaN值或比较<code>-0.0</code>与<code>+0.0</code> 。</span> 
              <span>由于操作可能意外失败，因此在执行比较和设置或比较和交换操作时应小心这些值。</span> 
              <span>Java中有许多可能的NaN值被认为是<code>NaN</code> ，尽管Java提供的IEEE 754浮点运算不能区分它们。</span> 
              <span>如果预期值或见证值是NaN值并且它（可能以特定于平台的方式）转换为另一个NaN值，则可能发生操作失败，因此具有不同的按位表示（有关详细信息，请参阅<a href="../Float.html#intBitsToFloat(int)"><code>Float.intBitsToFloat(int)</code></a>或<a href="../Double.html#longBitsToDouble(long)"><code>Double.longBitsToDouble(long)</code></a> ）。</span> 
              <span>值<code>-0.0</code>和<code>+0.0</code>具有不同的按位表示，但在使用原语<code>==</code>运算符时被认为是相等的。</span> 
              <span>如果，例如，数字算法计算的预期值是说可能会出现操作故障<code>-0.0</code>和先前计算的见证价值被说<code>+0.0</code> 。</span> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>decl</code> - 声明静态字段的类 
             </dd> 
             <dd> 
              <code>name</code> - 该字段的名称 
             </dd> 
             <dd> 
              <code>type</code> - 字段的类型，类型 
              <code>T</code> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个VarHandle，可以访问静态字段 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NoSuchFieldException.html" title="class in java.lang">NoSuchFieldException</a></code> - 如果该字段不存在 
             </dd> 
             <dd> 
              <code><a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code> - 如果访问检查失败，或者该字段不是 
              <code>static</code> 
             </dd> 
             <dd> 
              <code><a href="../SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理器且 
              <a href="MethodHandles.Lookup.html#secmgr">refuses access</a> 
             </dd> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任何参数为null 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
            </dl> </li> 
          </ul> <a id="bind(java.lang.Object,java.lang.String,java.lang.invoke.MethodType)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>bind</h4> <pre class="methodSignature">public&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;bind​(<a href="../Object.html" title="class in java.lang">Object</a>&nbsp;receiver,
                         <a href="../String.html" title="class in java.lang">String</a>&nbsp;name,
                         <a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)
                  throws <a href="../NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a>,
                         <a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre> 
            <div class="block"> 
             <span>为非静态方法生成早期绑定方法句柄。</span> 
             <span>接收方必须具有超类型<code>defc</code> ，其中查找类可以访问给定名称和类型的方法。</span> 
             <span>查找对象必须可以访问该方法及其所有参数类型。</span> 
             <span>方法句柄的类型将是方法的类型，而不插入任何额外的接收器参数。</span> 
             <span>给定的接收器将绑定到方法句柄中，以便对方法句柄的每次调用都将在给定的接收器上调用所请求的方法。</span> 
             <p> <span>当且仅当方法的变量arity修饰符位（ <code>0x0080</code> ）已设置<em>且</em>尾随数组参数不是唯一参数时，返回的方法句柄将具有<a href="MethodHandle.html#asVarargsCollector(java.lang.Class)">variable arity</a> 。</span> <span>（如果尾随数组参数是唯一的参数，则给定的接收器值将绑定到它。）</span> </p> 
             <p> <span>这几乎等同于以下代码，下面提到了一些差异：</span> </p> 
             <blockquote> 
              <span><pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle mh0 = lookup().findVirtual(defc, name, type);
MethodHandle mh1 = mh0.bindTo(receiver);
mh1 = mh1.withVarargs(mh0.isVarargsCollector());
return mh1;
 </code></pre></span> 
             </blockquote> 
             <span>其中<code>defc</code>是<code>receiver.getClass()</code>或<code>receiver.getClass()</code>的超类型，其中查找类可以访问所请求的方法。</span> 
             <span>（与<code>bind</code>不同， <code>bindTo</code>不保留变量arity。另外， <code>bindTo</code>可能会抛出<code>ClassCastException</code> ，其中<code>bind</code>会抛出<code>IllegalAccessException</code> ，如成员为<code>protected</code>并且接收器被<code>findVirtual</code>限制为查找类。）</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>receiver</code> - 从中访问方法的对象 
             </dd> 
             <dd> 
              <code>name</code> - 方法的名称 
             </dd> 
             <dd> 
              <code>type</code> - 方法的类型，省略receiver参数 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               所需的方法句柄 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a></code> - 如果该方法不存在 
             </dd> 
             <dd> 
              <code><a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code> - 如果访问检查失败或者方法的变量arity修饰符位已设置且 
              <code>asVarargsCollector</code>失败 
             </dd> 
             <dd> 
              <code><a href="../SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理器且 
              <a href="MethodHandles.Lookup.html#secmgr">refuses access</a> 
             </dd> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任何参数为null 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="MethodHandle.html#bindTo(java.lang.Object)"><code>MethodHandle.bindTo(java.lang.Object)</code></a> ， 
              <a href="#findVirtual(java.lang.Class,java.lang.String,java.lang.invoke.MethodType)"><code>findVirtual(java.lang.Class&lt;?&gt;, java.lang.String, java.lang.invoke.MethodType)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="unreflect(java.lang.reflect.Method)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>unreflect</h4> <pre class="methodSignature">public&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;unreflect​(<a href="../reflect/Method.html" title="class in java.lang.reflect">方法</a>&nbsp;m)
                       throws <a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre> 
            <div class="block"> 
             <span>如果查找类具有权限，则将<a href="MethodHandleInfo.html#directmh">direct method handle设置</a>为<i>m</i> 。</span> 
             <span>如果<i>m</i>是非静态的，则将receiver参数视为初始参数。</span> 
             <span>如果<i>m</i>是虚拟的，则在每次调用时都会遵守覆盖。</span> 
             <span>与Core Reflection API不同， <em>不</em>包含异常。</span> 
             <span>方法句柄的类型将是方法的类型，接收器类型前置（但仅当它是非静态的）。</span> 
             <span>如果未设置方法的<code>accessible</code>标志，则代表查找类立即执行访问检查。</span> 
             <span>如果<i>m</i>不公开，请不要与不受信任的方共享生成的句柄。</span> 
             <p> <span>当且仅当设置了方法的变量arity修饰符位（ <code>0x0080</code> ）时，返回的方法句柄将具有<a href="MethodHandle.html#asVarargsCollector(java.lang.Class)">variable arity</a> 。</span> </p> 
             <p> <span>如果<i>m</i>是静态的，并且如果调用返回的方法句柄，则初始化方法的类（如果尚未初始化）。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>m</code> - 反映的方法 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个方法句柄，可以调用反射的方法 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code> - 如果访问检查失败或者方法的变量arity修饰符位已设置且 
              <code>asVarargsCollector</code>失败 
             </dd> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果参数为null 
             </dd> 
            </dl> </li> 
          </ul> <a id="unreflectSpecial(java.lang.reflect.Method,java.lang.Class)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>unreflectSpecial</h4> <pre class="methodSignature">public&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;unreflectSpecial​(<a href="../reflect/Method.html" title="class in java.lang.reflect">方法</a>&nbsp;m,
                                     <a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;specialCaller)
                              throws <a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre> 
            <div class="block"> 
             <span>为反射方法生成方法句柄。</span> 
             <span>它会绕过检查重写在接收机，方法<a href="MethodHandles.Lookup.html#equiv">as if called</a>从<code>invokespecial</code>从明确内指令指定<code>specialCaller</code> 。</span> 
             <span>方法句柄的类型将是方法的类型，具有适当受限的接收器类型。</span> 
             <span>（接收器类型将为<code>specialCaller</code>或子类型。）如果未设置方法的<code>accessible</code>标志，则代表查找类立即执行访问检查，就像链接了<code>invokespecial</code>指令一样。</span> 
             <p> <span>在方法解析之前，如果显式指定的调用者类与查找类不相同，或者此查找对象没有<a href="MethodHandles.Lookup.html#privacc">private access</a>特权，则访问将失败。</span> </p> 
             <p> <span>当且仅当设置了方法的变量arity修饰符位（ <code>0x0080</code> ）时，返回的方法句柄将具有<a href="MethodHandle.html#asVarargsCollector(java.lang.Class)">variable arity</a> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>m</code> - 反映的方法 
             </dd> 
             <dd> 
              <code>specialCaller</code> - 名义上调用该方法的类 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个方法句柄，可以调用反射的方法 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code> - 如果访问检查失败，或者方法是 
              <code>static</code> ，或者方法的变量arity修饰符位已设置且 
              <code>asVarargsCollector</code>失败 
             </dd> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任何参数为null 
             </dd> 
            </dl> </li> 
          </ul> <a id="unreflectConstructor(java.lang.reflect.Constructor)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>unreflectConstructor</h4> <pre class="methodSignature">public&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;unreflectConstructor​(<a href="../reflect/Constructor.html" title="class in java.lang.reflect">构造器</a>&lt;?&gt;&nbsp;c)
                                  throws <a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre> 
            <div class="block"> 
             <span>为反射的构造函数生成方法句柄。</span> 
             <span>方法句柄的类型将是构造函数的类型，返回类型更改为声明类。</span> 
             <span>方法句柄将执行<code>newInstance</code>操作，在传递给方法句柄的参数上创建构造函数类的新实例。</span> 
             <p> <span>如果未设置构造函数的<code>accessible</code>标志，则代表查找类立即执行访问检查。</span> </p> 
             <p> <span>当且仅当设置了构造函数的变量arity修饰符位（ <code>0x0080</code> ）时，返回的方法句柄才会有<a href="MethodHandle.html#asVarargsCollector(java.lang.Class)">variable arity</a> 。</span> </p> 
             <p> <span>如果调用返回的方法句柄，则初始化构造函数的类（如果尚未初始化）。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>c</code> - 反射的构造函数 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个方法句柄，可以调用反射的构造函数 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code> - 如果访问检查失败或者方法的变量arity修饰符位已设置且 
              <code>asVarargsCollector</code>失败 
             </dd> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果参数为null 
             </dd> 
            </dl> </li> 
          </ul> <a id="unreflectGetter(java.lang.reflect.Field)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>unreflectGetter</h4> <pre class="methodSignature">public&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;unreflectGetter​(<a href="../reflect/Field.html" title="class in java.lang.reflect">字段</a>&nbsp;f)
                             throws <a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre> 
            <div class="block"> 
             <span>生成一个方法句柄，提供对反射字段的读访问权限。</span> 
             <span>方法句柄的类型将具有字段值类型的返回类型。</span> 
             <span>如果该字段是静态的，则方法句柄不带参数。</span> 
             <span>否则，它的单个参数将是包含该字段的实例。</span> 
             <span>如果未设置字段的<code>accessible</code>标志，则代表查找类立即执行访问检查。</span> 
             <p> <span>如果该字段是静态的，并且如果调用返回的方法句柄，则将初始化该字段的类（如果尚未初始化）。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>f</code> - 反射场 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               方法句柄，可以从反射字段加载值 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code> - 如果访问检查失败 
             </dd> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果参数为null 
             </dd> 
            </dl> </li> 
          </ul> <a id="unreflectSetter(java.lang.reflect.Field)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>unreflectSetter</h4> <pre class="methodSignature">public&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;unreflectSetter​(<a href="../reflect/Field.html" title="class in java.lang.reflect">字段</a>&nbsp;f)
                             throws <a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre> 
            <div class="block"> 
             <span>生成一个方法句柄，提供对反射字段的写访问权限。</span> 
             <span>方法句柄的类型将具有void返回类型。</span> 
             <span>如果该字段是静态的，则方法句柄将采用字段值类型的单个参数，即要存储的值。</span> 
             <span>否则，这两个参数将是包含该字段的实例，以及要存储的值。</span> 
             <span>如果未设置字段的<code>accessible</code>标志，则代表查找类立即执行访问检查。</span> 
             <p> <span>如果该字段是静态的，并且如果调用返回的方法句柄，则将初始化该字段的类（如果尚未初始化）。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>f</code> - 反射场 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               方法句柄，可以将值存储到反射字段中 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code> - 如果访问检查失败 
             </dd> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果参数为null 
             </dd> 
            </dl> </li> 
          </ul> <a id="unreflectVarHandle(java.lang.reflect.Field)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>unreflectVarHandle</h4> <pre class="methodSignature">public&nbsp;<a href="VarHandle.html" title="class in java.lang.invoke">VarHandle</a>&nbsp;unreflectVarHandle​(<a href="../reflect/Field.html" title="class in java.lang.reflect">字段</a>&nbsp;f)
                             throws <a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre> 
            <div class="block"> 
             <span>生成一个VarHandle，允许访问类型为<code>T</code>的一个<code>f</code>类型的反射字段<code>R</code> 。</span> 
             <span>VarHandle的变量类型是<code>T</code> 。</span> 
             <span>如果该字段是非静态的，则VarHandle具有一个坐标类型， <code>R</code> 。</span> 
             <span>否则，该字段是静态的，VarHandle没有坐标类型。</span> 
             <p> <span>无论字段<code>accessible</code>标志的值如何，都会立即代表查找类执行访问检查。</span> </p> 
             <p> <span>如果该字段是静态的，并且如果操作返回的VarHandle，则字段的声明类将被初始化（如果尚未初始化）。</span> </p> 
             <p> <span>在以下条件下，不支持返回的VarHandle的某些访问模式：</span> </p> 
             <ul> 
              <li> <span>如果声明字段为<code>final</code> ，则不支持写入，原子更新，数字原子更新和按位原子更新访问模式。</span> </li> 
              <li> <span>如果字段的类型是比其他任何<code>byte</code> ， <code>short</code> ， <code>char</code> ， <code>int</code> ， <code>long</code> ， <code>float</code> ，或<code>double</code>然后数字原子更新的接入方式是不受支持的。</span> </li> 
              <li> <span>如果字段的类型是比其他任何<code>boolean</code> ， <code>byte</code> ， <code>short</code> ， <code>char</code> ， <code>int</code>或<code>long</code>然后按位原子更新的接入方式是不受支持的。</span> </li> 
             </ul> 
             <p> <span>如果该字段被声明为<code>volatile</code>则返回的VarHandle将根据其指定的访问模式覆盖对该字段的访问（实际上忽略<code>volatile</code>声明）。</span> </p> 
             <p> <span>如果字段类型为<code>float</code>或<code>double</code>则数字和原子更新访问模式使用其按位表示形式比较值（分别参见<a href="../Float.html#floatToRawIntBits(float)"><code>Float.floatToRawIntBits(float)</code></a>和<a href="../Double.html#doubleToRawLongBits(double)"><code>Double.doubleToRawLongBits(double)</code></a> ）。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>由数值和原子更新访问模式执行的<code>float</code>值或<code>double</code>值的按位比较不同于原始<code>==</code>运算符和<a href="../Float.html#equals(java.lang.Object)"><code>Float.equals(java.lang.Object)</code></a>和<a href="../Double.html#equals(java.lang.Object)"><code>Double.equals(java.lang.Object)</code></a>方法，特别是关于比较NaN值或将<code>-0.0</code>与<code>+0.0</code>进行比较。</span> 
              <span>由于操作可能意外失败，因此在执行比较和设置或比较和交换操作时应小心这些值。</span> 
              <span>Java中有许多可能的NaN值被认为是<code>NaN</code> ，尽管Java提供的IEEE 754浮点运算不能区分它们。</span> 
              <span>如果预期值或见证值是NaN值并且它（可能以特定于平台的方式）转换为另一个NaN值，则可能发生操作失败，因此具有不同的按位表示（有关详细信息，请参阅<a href="../Float.html#intBitsToFloat(int)"><code>Float.intBitsToFloat(int)</code></a>或<a href="../Double.html#longBitsToDouble(long)"><code>Double.longBitsToDouble(long)</code></a> ）。</span> 
              <span>值<code>-0.0</code>和<code>+0.0</code>具有不同的按位表示，但在使用原语<code>==</code>运算符时被视为相等。</span> 
              <span>如果，例如，数字算法计算的预期值是说可能会出现操作故障<code>-0.0</code>和先前计算的见证价值被说<code>+0.0</code> 。</span> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>f</code> -反射场，用类型的字段 
              <code>T</code> ，以及声明类型的 
              <code>R</code> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个VarHandle，可以访问非静态字段或静态字段 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code> - 如果访问检查失败 
             </dd> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果参数为null 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
            </dl> </li> 
          </ul> <a id="revealDirect(java.lang.invoke.MethodHandle)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>revealDirect</h4> <pre class="methodSignature">public&nbsp;<a href="MethodHandleInfo.html" title="interface in java.lang.invoke">MethodHandleInfo</a>&nbsp;revealDirect​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target)</pre> 
            <div class="block"> 
             <span>破解由此查找对象或类似对象创建的<a href="MethodHandleInfo.html#directmh">direct method handle</a> 。</span> 
             <span>执行安全性和访问检查以确保该查找对象能够再现目标方法句柄。</span> 
             <span>这意味着如果target是直接方法句柄但是由不相关的查找对象创建，则破解可能会失败。</span> 
             <span>如果方法句柄是<a href="MethodHandles.Lookup.html#callsens">caller sensitive</a>并且由另一个类的查找对象创建，则会发生这种情况。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>target</code> - 破解为符号引用组件的直接方法句柄 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个符号引用，可用于从此查找对象重建此方法句柄 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果存在安全管理器且 
              <a href="MethodHandles.Lookup.html#secmgr">refuses access</a> 
             </dd> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果目标不是直接方法句柄或访问检查失败 
             </dd> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果目标是 
              <code>null</code> 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.8 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <span><a href="MethodHandleInfo.html" title="java.lang.invoke中的接口"><code>MethodHandleInfo</code></a></span> 
             </dd> 
            </dl> </li> 
          </ul> <a id="hasPrivateAccess()"> 
           <!--   --> </a> 
          <ul class="blockListLast"> 
           <li class="blockList"> <h4>hasPrivateAccess</h4> <pre class="methodSignature">public&nbsp;boolean&nbsp;hasPrivateAccess()</pre> 
            <div class="block">
              如果此查找具有 
             <code>PRIVATE</code>访问权限，则返回 
             <code>true</code> 。 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>true</code>如果此查找具有 
              <code>PRIVATE</code>访问权限。 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
            </dl> </li> 
          </ul> </li> 
        </ul> 
       </section> </li> 
     </ul> 
    </div> 
   </div> 
  </main> 
  <!-- ========= END OF CLASS DATA ========= --> 
  <footer role="contentinfo"> 
   <nav role="navigation"> 
    <!-- ======= START OF BOTTOM NAVBAR ====== --> 
    <div class="bottomNav"> 
     <a id="navbar.bottom"> 
      <!--   --> </a> 
     <div class="skipNav"> 
      <a href="#skip.navbar.bottom" title="Skip navigation links">跳过导航</a> 
     </div> 
     <a id="navbar.bottom.firstrow"> 
      <!--   --> </a> 
     <ul class="navList" title="Navigation"> 
      <li><a href="../../../../index.html">概述</a></li> 
      <li><a href="../../../module-summary.html">模块</a></li> 
      <li><a href="package-summary.html">软件包</a></li> 
      <li class="navBarCell1Rev">类</li> 
      <li><a href="class-use/MethodHandles.Lookup.html">使用</a></li> 
      <li><a href="package-tree.html">树</a></li> 
      <li><a href="../../../../deprecated-list.html">已过时的</a></li> 
      <li><a href="../../../../index-files/index-1.html">索引</a></li> 
      <li><a href="../../../../help-doc.html">帮助</a></li> 
     </ul> 
     <div class="aboutLanguage"> 
      <div style="margin-top: 14px;"> 
       <strong>Java SE 11 &amp; JDK 11</strong> 
      </div> 
     </div> 
    </div> 
    <div class="subNav"> 
     <ul class="navList" id="allclasses_navbar_bottom"> 
      <li><a href="../../../../allclasses.html">所有类</a></li> 
     </ul> 
     <div> 
      <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
      <noscript> 
       <div>
         JavaScript is disabled on your browser. 
       </div> 
      </noscript> 
     </div> 
     <div> 
      <ul class="subNavList"> 
       <li>概要：&nbsp;</li> 
       <li>嵌套&nbsp;|&nbsp;</li> 
       <li><a href="#field.summary">字段</a>&nbsp;|&nbsp;</li> 
       <li>构造方法&nbsp;|&nbsp;</li> 
       <li><a href="#method.summary">方法</a></li> 
      </ul> 
      <ul class="subNavList"> 
       <li>详细信息：&nbsp;</li> 
       <li><a href="#field.detail">字段</a>&nbsp;|&nbsp;</li> 
       <li>构造方法&nbsp;|&nbsp;</li> 
       <li><a href="#method.detail">方法</a></li> 
      </ul> 
     </div> 
     <a id="skip.navbar.bottom"> 
      <!--   --> </a> 
    </div> 
    <!-- ======== END OF BOTTOM NAVBAR ======= --> 
   </nav> 
   <p class="legalCopy"><small><a href="http://bugreport.java.com/bugreport/">Report a bug or suggest an enhancement</a><br> For further API reference and developer documentation see the <a href="http://www.oracle.com/pls/topic/lookup?ctx=javase11.0.1&amp;id=homepage" target="_blank">Java SE Documentation</a>, which contains more detailed, developer-targeted descriptions with conceptual overviews, definitions of terms, workarounds, and working code examples.<br> Java is a trademark or registered trademark of Oracle and/or its affiliates in the US and other countries.<br> <a href="../../../../../legal/copyright.html">Copyright</a> © 1993, 2018, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.<br>All rights reserved. Use is subject to <a href="http://www.oracle.com/technetwork/java/javase/terms/license/java11.0.1speclicense.html">license terms</a> and the <a href="http://www.oracle.com/technetwork/java/redist-137594.html">documentation redistribution policy</a>. 
     <!-- Version 11.0.1+13-LTS --></small></p> 
  </footer>  
 </body>
</html>