<!doctype html>
<!-- NewPage -->
<html lang="en">
 <head> 
  <!-- Generated by javadoc --> 
  <title>MethodHandles</title> 
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> 
  <meta name="keywords" content="java.lang.invoke.MethodHandles class"> 
  <meta name="keywords" content="lookup()"> 
  <meta name="keywords" content="publicLookup()"> 
  <meta name="keywords" content="privateLookupIn()"> 
  <meta name="keywords" content="reflectAs()"> 
  <meta name="keywords" content="arrayConstructor()"> 
  <meta name="keywords" content="arrayLength()"> 
  <meta name="keywords" content="arrayElementGetter()"> 
  <meta name="keywords" content="arrayElementSetter()"> 
  <meta name="keywords" content="arrayElementVarHandle()"> 
  <meta name="keywords" content="byteArrayViewVarHandle()"> 
  <meta name="keywords" content="byteBufferViewVarHandle()"> 
  <meta name="keywords" content="spreadInvoker()"> 
  <meta name="keywords" content="exactInvoker()"> 
  <meta name="keywords" content="invoker()"> 
  <meta name="keywords" content="varHandleExactInvoker()"> 
  <meta name="keywords" content="varHandleInvoker()"> 
  <meta name="keywords" content="explicitCastArguments()"> 
  <meta name="keywords" content="permuteArguments()"> 
  <meta name="keywords" content="constant()"> 
  <meta name="keywords" content="identity()"> 
  <meta name="keywords" content="zero()"> 
  <meta name="keywords" content="empty()"> 
  <meta name="keywords" content="insertArguments()"> 
  <meta name="keywords" content="dropArguments()"> 
  <meta name="keywords" content="dropArgumentsToMatch()"> 
  <meta name="keywords" content="filterArguments()"> 
  <meta name="keywords" content="collectArguments()"> 
  <meta name="keywords" content="filterReturnValue()"> 
  <meta name="keywords" content="foldArguments()"> 
  <meta name="keywords" content="guardWithTest()"> 
  <meta name="keywords" content="catchException()"> 
  <meta name="keywords" content="throwException()"> 
  <meta name="keywords" content="loop()"> 
  <meta name="keywords" content="whileLoop()"> 
  <meta name="keywords" content="doWhileLoop()"> 
  <meta name="keywords" content="countedLoop()"> 
  <meta name="keywords" content="iteratedLoop()"> 
  <meta name="keywords" content="tryFinally()"> 
  <link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style"> 
  <link rel="stylesheet" type="text/css" href="../../../../jquery/jquery-ui.css" title="Style"> 
  <script type="text/javascript" src="../../../../script.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jszip/dist/jszip.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script> 
  <!--[if IE]>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]--> 
  <script type="text/javascript" src="../../../../jquery/jquery-1.10.2.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jquery-migrate-1.2.1.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jquery-ui.js"></script> 
 </head> 
 <body> <SCRIPT LANGUAGE="JavaScript"><!-- Hide  
   function ResumeError() {     return true;}window.onerror = ResumeError;// --></SCRIPT>
  <script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="MethodHandles (Java SE 11 & JDK 11 )";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":9,"i1":9,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9,"i8":9,"i9":9,"i10":9,"i11":9,"i12":9,"i13":9,"i14":9,"i15":9,"i16":9,"i17":9,"i18":9,"i19":9,"i20":9,"i21":9,"i22":9,"i23":9,"i24":9,"i25":9,"i26":9,"i27":9,"i28":9,"i29":9,"i30":9,"i31":9,"i32":9,"i33":9,"i34":9,"i35":9,"i36":9,"i37":9,"i38":9,"i39":9,"i40":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script> 
  <noscript> 
   <div>
     JavaScript is disabled on your browser. 
   </div> 
  </noscript> 
  <header role="banner"> 
   <nav role="navigation"> 
    <div class="fixedNav"> 
     <!-- ========= START OF TOP NAVBAR ======= --> 
     <div class="topNav"> 
      <a id="navbar.top"> 
       <!--   --> </a> 
      <div class="skipNav"> 
       <a href="#skip.navbar.top" title="Skip navigation links">跳过导航</a> 
      </div> 
      <a id="navbar.top.firstrow"> 
       <!--   --> </a> 
      <ul class="navList" title="Navigation"> 
       <li><a href="../../../../index.html">概述</a></li> 
       <li><a href="../../../module-summary.html">模块</a></li> 
       <li><a href="package-summary.html">软件包</a></li> 
       <li class="navBarCell1Rev">类</li> 
       <li><a href="class-use/MethodHandles.html">使用</a></li> 
       <li><a href="package-tree.html">树</a></li> 
       <li><a href="../../../../deprecated-list.html">已过时的</a></li> 
       <li><a href="../../../../index-files/index-1.html">索引</a></li> 
       <li><a href="../../../../help-doc.html">帮助</a></li> 
      </ul> 
      <div class="aboutLanguage"> 
       <div style="margin-top: 14px;"> 
        <strong>Java SE 11 &amp; JDK 11</strong> 
       </div> 
      </div> 
     </div> 
     <div class="subNav"> 
      <ul class="navList" id="allclasses_navbar_top"> 
       <li><a href="../../../../allclasses.html">所有类</a></li> 
      </ul> 
      <ul class="navListSearch"> 
       <li><label for="search">SEARCH:</label> <input type="text" id="search" value="search" disabled> <input type="reset" id="reset" value="reset" disabled> </li> 
      </ul> 
      <div> 
       <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
       <noscript> 
        <div>
          JavaScript is disabled on your browser. 
        </div> 
       </noscript> 
      </div> 
       <div class="fixedNav">
       <ul class="subNavList"> 
        <li>概要：&nbsp;</li> 
        <li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li> 
        <li>字段&nbsp;|&nbsp;</li> 
        <li>构造方法&nbsp;|&nbsp;</li> 
        <li><a href="#method.summary">方法</a></li> 
       </ul> 
       <ul class="subNavList"> 
        <li>详细信息：&nbsp;</li> 
        <li>字段&nbsp;|&nbsp;</li> 
        <li>构造方法&nbsp;|&nbsp;</li> 
        <li><a href="#method.detail">方法</a></li> 
       </ul> 
      </div> 
      <a id="skip.navbar.top"> 
       <!--   --> </a> 
     </div> 
     <!-- ========= END OF TOP NAVBAR ========= --> 
    </div> 
    <div class="navPadding">
      &nbsp; 
    </div> 
    <script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script> 
   </nav> 
  </header> 
  <!-- ======== START OF CLASS DATA ======== --> 
  <main role="main"> 
   <div class="header"> 
    <div class="subTitle"> 
     <span class="moduleLabelInType">模块</span>&nbsp; 
     <a href="../../../module-summary.html">java.base</a> 
    </div> 
    <div class="subTitle"> 
     <span class="packageLabelInType">软件包</span>&nbsp; 
     <a href="package-summary.html">java.lang.invoke</a> 
    </div> 
    <h2 title="Class MethodHandles" class="title">Class MethodHandles</h2> 
   </div> 
   <div class="contentContainer"> 
    <ul class="inheritance"> 
     <li><a href="../Object.html" title="class in java.lang">java.lang.Object</a></li> 
     <li> 
      <ul class="inheritance"> 
       <li>java.lang.invoke.MethodHandles</li> 
      </ul> </li> 
    </ul> 
    <div class="description"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <hr> <pre>public class <span class="typeNameLabel">MethodHandles</span>
extends <a href="../Object.html" title="class in java.lang">Object</a></pre> 
       <div class="block"> 
        <span>此类仅包含对方法句柄进行操作或返回方法句柄的静态方法。</span> 
        <span>它们分为几类：</span> 
        <ul> 
         <li> <span>查找方法有助于为方法和字段创建方法句柄。</span> </li> 
         <li> <span>组合方法，将预先存在的方法句柄组合或转换为新方法。</span> </li> 
         <li> <span>创建方法句柄的其他工厂方法，用于模拟其他常见JVM操作或控制流模式。</span> </li> 
        </ul> 
       </div> 
       <dl> 
        <dt> 
         <span class="simpleTagLabel">从以下版本开始：</span> 
        </dt> 
        <dd>
          1.7 
        </dd> 
       </dl> </li> 
     </ul> 
    </div> 
    <div class="summary"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <!-- ======== NESTED CLASS SUMMARY ======== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="nested.class.summary"> 
           <!--   --> </a> <h3>嵌套类汇总</h3> 
          <table class="memberSummary"> 
           <caption> 
            <span>嵌套类</span> 
            <span class="tabEnd">&nbsp;</span> 
           </caption> 
           <tbody> 
            <tr> 
             <th class="colFirst" scope="col">变量和类型</th> 
             <th class="colSecond" scope="col">类</th> 
             <th class="colLast" scope="col">描述</th> 
            </tr> 
            <tr class="altColor"> 
             <td class="colFirst"><code>static class&nbsp;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a></span></code></th> 
             <td class="colLast"> 
              <div class="block"> 
               <em>查找对象</em>是用于在创建需要访问检查时创建方法句柄的工厂。 
              </div> </td> 
            </tr> 
           </tbody> 
          </table> </li> 
        </ul> 
       </section> 
       <!-- ========== METHOD SUMMARY =========== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="method.summary"> 
           <!--   --> </a> <h3>方法摘要</h3> 
          <table class="memberSummary"> 
           <caption> 
           <span id="t0" class="activeTableTab"><span>所有方法</span><span class="tabEnd">&nbsp;</span>
            <span id="t1" class="tableTab"><span><a href="javascript:show(1);">静态方法</a></span><span class="tabEnd">&nbsp;</span></span> 
            <span id="t4" class="tableTab"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd">&nbsp;</span></span> 
           </caption> 
           <tbody> 
            <tr> 
             <th class="colFirst" scope="col">变量和类型</th> 
             <th class="colSecond" scope="col">方法</th> 
             <th class="colLast" scope="col">描述</th> 
            </tr> 
            <tr id="i0" class="altColor"> 
             <td class="colFirst"><code>static <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#arrayConstructor(java.lang.Class)">arrayConstructor</a></span>​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;arrayClass)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成一个方法句柄，构造所需类型的数组，就好像通过 
               <code>anewarray</code>字节码一样。 
              </div> </td> 
            </tr> 
            <tr id="i1" class="rowColor"> 
             <td class="colFirst"><code>static <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#arrayElementGetter(java.lang.Class)">arrayElementGetter</a></span>​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;arrayClass)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成一个方法句柄，提供对数组元素的读访问，就像 
               <code>aaload</code>字节码一样。 
              </div> </td> 
            </tr> 
            <tr id="i2" class="altColor"> 
             <td class="colFirst"><code>static <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#arrayElementSetter(java.lang.Class)">arrayElementSetter</a></span>​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;arrayClass)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成一个方法句柄，提供对数组元素的写访问，就像 
               <code>astore</code>字节码一样。 
              </div> </td> 
            </tr> 
            <tr id="i3" class="rowColor"> 
             <td class="colFirst"><code>static <a href="VarHandle.html" title="class in java.lang.invoke">VarHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#arrayElementVarHandle(java.lang.Class)">arrayElementVarHandle</a></span>​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;arrayClass)</code></th> 
             <td class="colLast"> 
              <div class="block">
                产生VarHandle给予访问类型的数组的元素 
               <code>arrayClass</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i4" class="altColor"> 
             <td class="colFirst"><code>static <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#arrayLength(java.lang.Class)">arrayLength</a></span>​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;arrayClass)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成一个返回数组长度的方法句柄，就像 
               <code>arraylength</code>字节码一样。 
              </div> </td> 
            </tr> 
            <tr id="i5" class="rowColor"> 
             <td class="colFirst"><code>static <a href="VarHandle.html" title="class in java.lang.invoke">VarHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#byteArrayViewVarHandle(java.lang.Class,java.nio.ByteOrder)">byteArrayViewVarHandle</a></span>​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;viewArrayClass, <a href="../../nio/ByteOrder.html" title="class in java.nio">ByteOrder</a>&nbsp;byteOrder)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成一个VarHandle，可以访问 
               <code>byte[]</code>数组的元素，就像它是一个不同的原始数组类型一样，例如 
               <code>int[]</code>或 
               <code>long[]</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i6" class="altColor"> 
             <td class="colFirst"><code>static <a href="VarHandle.html" title="class in java.lang.invoke">VarHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#byteBufferViewVarHandle(java.lang.Class,java.nio.ByteOrder)">byteBufferViewVarHandle</a></span>​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;viewArrayClass, <a href="../../nio/ByteOrder.html" title="class in java.nio">ByteOrder</a>&nbsp;byteOrder)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成一个VarHandle，可以访问ByteBuffer的元素，就像它是 
               <code>ByteBuffer</code>的不同原始组件类型的元素数组 
               <code>byte</code> ，例如 
               <code>int[]</code>或 
               <code>long[]</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i7" class="rowColor"> 
             <td class="colFirst"><code>static <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#catchException(java.lang.invoke.MethodHandle,java.lang.Class,java.lang.invoke.MethodHandle)">catchException</a></span>​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, <a href="../Class.html" title="class in java.lang">类</a>&lt;? extends <a href="../Throwable.html" title="class in java.lang">Throwable</a>&gt;&nbsp;exType, <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;handler)</code></th> 
             <td class="colLast"> 
              <div class="block">
                通过在异常处理程序中运行，使方法句柄适应目标方法句柄。 
              </div> </td> 
            </tr> 
            <tr id="i8" class="altColor"> 
             <td class="colFirst"><code>static <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#collectArguments(java.lang.invoke.MethodHandle,int,java.lang.invoke.MethodHandle)">collectArguments</a></span>​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, int&nbsp;pos, <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;filter)</code></th> 
             <td class="colLast"> 
              <div class="block">
                通过使用过滤器（另一个方法句柄）预处理其参数的子序列来调整目标方法句柄。 
              </div> </td> 
            </tr> 
            <tr id="i9" class="rowColor"> 
             <td class="colFirst"><code>static <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#constant(java.lang.Class,java.lang.Object)">constant</a></span>​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;type, <a href="../Object.html" title="class in java.lang">Object</a>&nbsp;value)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成请求的返回类型的方法句柄，每次调用它时都返回给定的常量值。 
              </div> </td> 
            </tr> 
            <tr id="i10" class="altColor"> 
             <td class="colFirst"><code>static <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#countedLoop(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)">countedLoop</a></span>​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;iterations, <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;init, <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;body)</code></th> 
             <td class="colLast"> 
              <div class="block">
                构造一个运行给定迭代次数的循环。 
              </div> </td> 
            </tr> 
            <tr id="i11" class="rowColor"> 
             <td class="colFirst"><code>static <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#countedLoop(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)">countedLoop</a></span>​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;start, <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;end, <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;init, <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;body)</code></th> 
             <td class="colLast"> 
              <div class="block">
                构造一个计算一系列数字的循环。 
              </div> </td> 
            </tr> 
            <tr id="i12" class="altColor"> 
             <td class="colFirst"><code>static <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#doWhileLoop(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)">doWhileLoop</a></span>​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;init, <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;body, <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;pred)</code></th> 
             <td class="colLast"> 
              <div class="block">
                从初始值设定项，正文和谓词构造一个 
               <code>do-while</code>循环。 
              </div> </td> 
            </tr> 
            <tr id="i13" class="rowColor"> 
             <td class="colFirst"><code>static <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#dropArguments(java.lang.invoke.MethodHandle,int,java.lang.Class...)">dropArguments</a></span>​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, int&nbsp;pos, <a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;...&nbsp;valueTypes)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成一个方法句柄，它会在调用其他指定的 
               <i>目标</i>方法句柄之前丢弃一些伪参数。 
              </div> </td> 
            </tr> 
            <tr id="i14" class="altColor"> 
             <td class="colFirst"><code>static <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#dropArguments(java.lang.invoke.MethodHandle,int,java.util.List)">dropArguments</a></span>​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, int&nbsp;pos, <a href="../../util/List.html" title="interface in java.util">List</a>&lt;<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&gt;&nbsp;valueTypes)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成一个方法句柄，它会在调用其他指定的 
               <i>目标</i>方法句柄之前丢弃一些伪参数。 
              </div> </td> 
            </tr> 
            <tr id="i15" class="rowColor"> 
             <td class="colFirst"><code>static <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#dropArgumentsToMatch(java.lang.invoke.MethodHandle,int,java.util.List,int)">dropArgumentsToMatch</a></span>​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, int&nbsp;skip, <a href="../../util/List.html" title="interface in java.util">List</a>&lt;<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&gt;&nbsp;newTypes, int&nbsp;pos)</code></th> 
             <td class="colLast"> 
              <div class="block">
                调整目标方法句柄以匹配给定的参数类型列表。 
              </div> </td> 
            </tr> 
            <tr id="i16" class="altColor"> 
             <td class="colFirst"><code>static <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#empty(java.lang.invoke.MethodType)">empty</a></span>​(<a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成所请求类型的方法句柄，该句柄忽略任何参数，不执行任何操作，并根据返回类型返回合适的默认值。 
              </div> </td> 
            </tr> 
            <tr id="i17" class="rowColor"> 
             <td class="colFirst"><code>static <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#exactInvoker(java.lang.invoke.MethodType)">exactInvoker</a></span>​(<a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成一个特殊的 
               <em>调用者方法句柄</em> ，可以用来调用给定类型的任何方法句柄，就像 
               <a href="MethodHandle.html#invokeExact(java.lang.Object...)"><code>invokeExact</code>一样</a> 。 
              </div> </td> 
            </tr> 
            <tr id="i18" class="altColor"> 
             <td class="colFirst"><code>static <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#explicitCastArguments(java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)">explicitCastArguments</a></span>​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, <a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;newType)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成一个方法句柄，通过成对参数和返回类型转换使给定方法句柄的类型适应新类型。 
              </div> </td> 
            </tr> 
            <tr id="i19" class="rowColor"> 
             <td class="colFirst"><code>static <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#filterArguments(java.lang.invoke.MethodHandle,int,java.lang.invoke.MethodHandle...)">filterArguments</a></span>​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, int&nbsp;pos, <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>...&nbsp;filters)</code></th> 
             <td class="colLast"> 
              <div class="block">
                通过预处理一个或多个参数来调整目标方法句柄，每个参数都有自己的一元过滤函数，然后调用目标，每个预处理参数替换为其相应过滤函数的结果。 
              </div> </td> 
            </tr> 
            <tr id="i20" class="altColor"> 
             <td class="colFirst"><code>static <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#filterReturnValue(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)">filterReturnValue</a></span>​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;filter)</code></th> 
             <td class="colLast"> 
              <div class="block">
                通过使用过滤器（另一个方法句柄）对其返回值（如果有）进行后处理来调整目标方法句柄。 
              </div> </td> 
            </tr> 
            <tr id="i21" class="rowColor"> 
             <td class="colFirst"><code>static <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#foldArguments(java.lang.invoke.MethodHandle,int,java.lang.invoke.MethodHandle)">foldArguments</a></span>​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, int&nbsp;pos, <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;combiner)</code></th> 
             <td class="colLast"> 
              <div class="block">
                通过预处理某些参数来调整目标方法句柄，从给定位置开始，然后使用预处理的结果调用目标，插入到折叠参数之前的原始参数序列中。 
              </div> </td> 
            </tr> 
            <tr id="i22" class="altColor"> 
             <td class="colFirst"><code>static <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#foldArguments(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)">foldArguments</a></span>​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;combiner)</code></th> 
             <td class="colLast"> 
              <div class="block">
                通过预处理其某些参数来调整目标方法句柄，然后使用预处理的结果调用目标，并将其插入到原始参数序列中。 
              </div> </td> 
            </tr> 
            <tr id="i23" class="rowColor"> 
             <td class="colFirst"><code>static <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#guardWithTest(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)">guardWithTest</a></span>​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;test, <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;fallback)</code></th> 
             <td class="colLast"> 
              <div class="block">
                通过使用测试，布尔值方法句柄来保护目标方法句柄，使其适应目标方法句柄。 
              </div> </td> 
            </tr> 
            <tr id="i24" class="altColor"> 
             <td class="colFirst"><code>static <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#identity(java.lang.Class)">identity</a></span>​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;type)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成一个方法句柄，在调用时返回其唯一的参数。 
              </div> </td> 
            </tr> 
            <tr id="i25" class="rowColor"> 
             <td class="colFirst"><code>static <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#insertArguments(java.lang.invoke.MethodHandle,int,java.lang.Object...)">insertArguments</a></span>​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, int&nbsp;pos, <a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;values)</code></th> 
             <td class="colLast"> 
              <div class="block">
                在方法句柄调用之前提供带有一个或多个 
               <em>绑定参数</em>的目标方法句柄。 
              </div> </td> 
            </tr> 
            <tr id="i26" class="altColor"> 
             <td class="colFirst"><code>static <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#invoker(java.lang.invoke.MethodType)">invoker</a></span>​(<a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成一个特殊的 
               <em>调用者方法句柄</em> ，可以用来调用与给定类型兼容的任何方法句柄，就像 
               <a href="MethodHandle.html#invoke(java.lang.Object...)"><code>invoke</code>一样</a> 。 
              </div> </td> 
            </tr> 
            <tr id="i27" class="rowColor"> 
             <td class="colFirst"><code>static <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#iteratedLoop(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)">iteratedLoop</a></span>​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;iterator, <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;init, <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;body)</code></th> 
             <td class="colLast"> 
              <div class="block">
                构造一个范围超过 
               <code>Iterator&lt;T&gt;</code>生成的值的 
               <code>Iterator&lt;T&gt;</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i28" class="altColor"> 
             <td class="colFirst"><code>static <a href="MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#lookup()">lookup</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block"> 
               <span>返回<a href="MethodHandles.Lookup.html" title="java.lang.invoke中的类"><code>lookup object</code></a> ，具有模拟调用者所有支持的字节码行为的全部功能。</span> 
              </div> </td> 
            </tr> 
            <tr id="i29" class="rowColor"> 
             <td class="colFirst"><code>static <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#loop(java.lang.invoke.MethodHandle%5B%5D...)">loop</a></span>​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>[]...&nbsp;clauses)</code></th> 
             <td class="colLast"> 
              <div class="block">
                构造一个表示循环的方法句柄，该循环具有多个循环变量，每次迭代时都会更新和检查这些变量。 
              </div> </td> 
            </tr> 
            <tr id="i30" class="altColor"> 
             <td class="colFirst"><code>static <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#permuteArguments(java.lang.invoke.MethodHandle,java.lang.invoke.MethodType,int...)">permuteArguments</a></span>​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, <a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;newType, int...&nbsp;reorder)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成一个方法句柄，通过重新排序参数，使给定方法句柄的调用序列适应新类型。 
              </div> </td> 
            </tr> 
            <tr id="i31" class="rowColor"> 
             <td class="colFirst"><code>static <a href="MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#privateLookupIn(java.lang.Class,java.lang.invoke.MethodHandles.Lookup)">privateLookupIn</a></span>​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;targetClass, <a href="MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a>&nbsp;lookup)</code></th> 
             <td class="colLast"> 
              <div class="block"> 
               <span>返回<a href="MethodHandles.Lookup.html" title="java.lang.invoke中的类"><code>lookup object</code></a>全功能模拟所有支持的字节码的行为，包括<a href="MethodHandles.Lookup.html#privacc">private access</a> ，目标类。</span> 
              </div> </td> 
            </tr> 
            <tr id="i32" class="altColor"> 
             <td class="colFirst"><code>static <a href="MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#publicLookup()">publicLookup</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block"> 
               <span>返回最低限度受信任的<a href="MethodHandles.Lookup.html" title="java.lang.invoke中的类"><code>lookup object</code></a> 。</span> 
              </div> </td> 
            </tr> 
            <tr id="i33" class="rowColor"> 
             <td class="colFirst"><code>static &lt;T extends <a href="../reflect/Member.html" title="interface in java.lang.reflect">Member</a>&gt;<br>T</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#reflectAs(java.lang.Class,java.lang.invoke.MethodHandle)">reflectAs</a></span>​(<a href="../Class.html" title="class in java.lang">类</a>&lt;T&gt;&nbsp;expected, <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target)</code></th> 
             <td class="colLast"> 
              <div class="block">
                执行 
               <a href="MethodHandleInfo.html#directmh">direct method handle</a>的未经检查的“破解”。 
              </div> </td> 
            </tr> 
            <tr id="i34" class="altColor"> 
             <td class="colFirst"><code>static <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#spreadInvoker(java.lang.invoke.MethodType,int)">spreadInvoker</a></span>​(<a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type, int&nbsp;leadingArgCount)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成一个方法句柄，该句柄将调用给定 
               <code>type</code>任何方法句柄，并将给定数量的尾随参数替换为单个尾随 
               <code>Object[]</code>数组。 
              </div> </td> 
            </tr> 
            <tr id="i35" class="rowColor"> 
             <td class="colFirst"><code>static <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#throwException(java.lang.Class,java.lang.Class)">throwException</a></span>​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;returnType, <a href="../Class.html" title="class in java.lang">类</a>&lt;? extends <a href="../Throwable.html" title="class in java.lang">Throwable</a>&gt;&nbsp;exType)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成一个方法句柄，它会抛出给定的 
               <code>exType</code>异常。 
              </div> </td> 
            </tr> 
            <tr id="i36" class="altColor"> 
             <td class="colFirst"><code>static <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#tryFinally(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)">tryFinally</a></span>​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;cleanup)</code></th> 
             <td class="colLast"> 
              <div class="block">
                创建一个方法句柄，通过将其包装在 
               <code>try-finally</code>块中来调整 
               <code>target</code>方法句柄。 
              </div> </td> 
            </tr> 
            <tr id="i37" class="rowColor"> 
             <td class="colFirst"><code>static <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#varHandleExactInvoker(java.lang.invoke.VarHandle.AccessMode,java.lang.invoke.MethodType)">varHandleExactInvoker</a></span>​(<a href="VarHandle.AccessMode.html" title="enum in java.lang.invoke">VarHandle.AccessMode</a>&nbsp;accessMode, <a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成一个特殊的 
               <em>调用方法句柄</em> ，可用于在任何VarHandle上调用签名 - 多态访问模式方法，该方法的关联访问模式类型与给定类型兼容。 
              </div> </td> 
            </tr> 
            <tr id="i38" class="altColor"> 
             <td class="colFirst"><code>static <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#varHandleInvoker(java.lang.invoke.VarHandle.AccessMode,java.lang.invoke.MethodType)">varHandleInvoker</a></span>​(<a href="VarHandle.AccessMode.html" title="enum in java.lang.invoke">VarHandle.AccessMode</a>&nbsp;accessMode, <a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成一个特殊的 
               <em>调用方法句柄</em> ，可用于在任何VarHandle上调用签名 - 多态访问模式方法，该方法的关联访问模式类型与给定类型兼容。 
              </div> </td> 
            </tr> 
            <tr id="i39" class="rowColor"> 
             <td class="colFirst"><code>static <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#whileLoop(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)">whileLoop</a></span>​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;init, <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;pred, <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;body)</code></th> 
             <td class="colLast"> 
              <div class="block">
                从初始值设定项，正文和谓词构造一个 
               <code>while</code>循环。 
              </div> </td> 
            </tr> 
            <tr id="i40" class="altColor"> 
             <td class="colFirst"><code>static <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#zero(java.lang.Class)">zero</a></span>​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;type)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成所请求的返回类型的常量方法句柄，该句柄在每次调用时返回该类型的默认值。 
              </div> </td> 
            </tr> 
           </tbody> 
          </table> 
          <ul class="blockList"> 
           <li class="blockList"><a id="methods.inherited.from.class.java.lang.Object"> 
             <!--   --> </a> <h3>声明方法的类&nbsp;java.lang.<a href="../Object.html" title="class in java.lang">Object</a></h3> <code><a href="../Object.html#clone()">clone</a>, <a href="../Object.html#equals(java.lang.Object)">equals</a>, <a href="../Object.html#finalize()">finalize</a>, <a href="../Object.html#getClass()">getClass</a>, <a href="../Object.html#hashCode()">hashCode</a>, <a href="../Object.html#notify()">notify</a>, <a href="../Object.html#notifyAll()">notifyAll</a>, <a href="../Object.html#toString()">toString</a>, <a href="../Object.html#wait()">wait</a>, <a href="../Object.html#wait(long)">wait</a>, <a href="../Object.html#wait(long,int)">wait</a></code></li> 
          </ul> </li> 
        </ul> 
       </section> </li> 
     </ul> 
    </div> 
    <div class="details"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <!-- ============ METHOD DETAIL ========== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="method.detail"> 
           <!--   --> </a> <h3>方法详细信息</h3> <a id="lookup()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>lookup</h4> <pre class="methodSignature">public static&nbsp;<a href="MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a>&nbsp;lookup()</pre> 
            <div class="block"> 
             <span>返回<a href="MethodHandles.Lookup.html" title="java.lang.invoke中的类"><code>lookup object</code></a> ，具有模拟调用者所有支持的字节码行为的全部功能。</span> 
             <span>这些功能包括<a href="MethodHandles.Lookup.html#privacc">private access</a>给呼叫者。</span> 
             <span>查找对象上的工厂方法可以为调用者通过字节码访问的任何成员创建<a href="MethodHandleInfo.html#directmh">direct method handles</a> ，包括受保护和私有字段和方法。</span> 
             <span>该查找对象是可以被委托给可信代理的<em>能力</em> 。</span> 
             <span>不要将其存储在不受信任的代码可以访问它的位置。</span> 
             <p> <span>此方法对呼叫者敏感，这意味着它可以向不同的呼叫者返回不同的值。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此方法的调用者的查找对象，具有私有访问权限 
             </dd> 
            </dl> </li> 
          </ul> <a id="publicLookup()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>publicLookup</h4> <pre class="methodSignature">public static&nbsp;<a href="MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a>&nbsp;publicLookup()</pre> 
            <div class="block"> 
             <span>返回最低限度受信任的<a href="MethodHandles.Lookup.html" title="java.lang.invoke中的类"><code>lookup object</code></a> 。</span> 
             <span>查找具有<code>PUBLIC</code>和<code>UNCONDITIONAL</code>模式。</span> 
             <span>它只能用于为无条件导出的包中的公共类的公共成员创建方法句柄。</span> 
             <p> <span>作为纯惯例，此查找对象的<a href="MethodHandles.Lookup.html#lookupClass()">lookup class</a>将为<a href="../Object.html" title="java.lang中的类"><code>Object</code></a> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>Object的使用是常规的，并且因为查找模式是有限的，所以不向Object，其包或其模块的内部提供特殊访问。</span> 
              <span>因此，此查找对象的查找上下文将是引导类加载器，这意味着它无法找到用户类。</span> 
              <p style="font-size:smaller;"> <span><em>讨论：</em>该查找类可以被改变为任何其他类<code>C</code>使用形式的表达<a href="MethodHandles.Lookup.html#in(java.lang.Class)"><code>publicLookup().in(C.class)</code></a> 。</span> <span>但是可以通过更改类加载器来更改查找上下文。</span> <span>公共查找对象始终受<a href="MethodHandles.Lookup.html#secmgr">security manager checks的约束</a> 。</span> <span>此外，它无法访问<a href="MethodHandles.Lookup.html#callsens">caller sensitive methods</a> 。</span> </p> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               最低限度信任的查找对象 
             </dd> 
            </dl> </li> 
          </ul> <a id="privateLookupIn(java.lang.Class,java.lang.invoke.MethodHandles.Lookup)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>privateLookupIn</h4> <pre class="methodSignature">public static&nbsp;<a href="MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a>&nbsp;privateLookupIn​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;targetClass,
                                                   <a href="MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a>&nbsp;lookup)
                                            throws <a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre> 
            <div class="block"> 
             <span>返回<a href="MethodHandles.Lookup.html" title="java.lang.invoke中的类"><code>lookup object</code></a>全功能模拟所有支持的字节码的行为，包括<a href="MethodHandles.Lookup.html#privacc">private access</a> ，目标类。</span> 
             <span>此方法检查指定为<code>Lookup</code>对象的调用方是否允许对目标类进行<em>深度反射</em> 。</span> 
             <span>如果<code>m1</code>是包含模块<a href="MethodHandles.Lookup.html#lookupClass()"><code>lookup class</code></a> ，和<code>m2</code>是包含目标类的模块，则该检查可确保</span> 
             <ul> 
              <li> <span><code>m1</code> <a href="../Module.html#canRead(java.lang.Module)"><code>reads</code></a> <code>m2</code> 。</span> </li> 
              <li> <span><code>m2</code> <a href="../Module.html#isOpen(java.lang.String,java.lang.Module)"><code>opens</code></a>包含目标类的包至少为<code>m1</code> 。</span> </li> 
              <li> <span>查找具有<a href="MethodHandles.Lookup.html#MODULE"><code>模块</code></a>查找模式。</span> </li> 
             </ul> 
             <p> <span>如果有安全管理器，则调用其<code>checkPermission</code>方法以检查<code>ReflectPermission("suppressAccessChecks")</code> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span><code>模块</code>查找模式用于验证查找对象是由调用方模块中的代码创建的（或者是从调用方最初创建的查找对象派生的）。</span> 
              <span>具有<code>模块</code>查找模式的查找对象可以与受信任方共享，而不会向<code>PRIVATE</code>提供<code>PRIVATE</code>和<code>PACKAGE</code>访问权限。</span> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>targetClass</code> - 目标班级 
             </dd> 
             <dd> 
              <code>lookup</code> - 调用者查找对象 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               具有私有访问权限的目标类的查找对象 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
              <code>targetClass</code>是原始类型或数组类 
             </dd> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
              <code>targetClass</code>或 
              <code>caller</code>是 
              <code>null</code> 
             </dd> 
             <dd> 
              <code><a href="../IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code> - 如果上面指定的访问检查失败 
             </dd> 
             <dd> 
              <code><a href="../SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果安全经理拒绝 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="MethodHandles.Lookup.html#dropLookupMode(int)"><code>MethodHandles.Lookup.dropLookupMode(int)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="reflectAs(java.lang.Class,java.lang.invoke.MethodHandle)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>reflectAs</h4> <pre class="methodSignature">public static&nbsp;&lt;T extends <a href="../reflect/Member.html" title="interface in java.lang.reflect">Member</a>&gt;&nbsp;T&nbsp;reflectAs​(<a href="../Class.html" title="class in java.lang">类</a>&lt;T&gt;&nbsp;expected,
                                             <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target)</pre> 
            <div class="block"> 
             <span>执行<a href="MethodHandleInfo.html#directmh">direct method handle</a>的未经检查的“破解”。</span> 
             <span>结果就好像用户已经获得足够破坏目标方法句柄的查找对象，在目标上调用<a href="MethodHandles.Lookup.html#revealDirect(java.lang.invoke.MethodHandle)"><code>Lookup.revealDirect</code></a>来获取其符号引用，然后调用<a href="MethodHandleInfo.html#reflectAs(java.lang.Class,java.lang.invoke.MethodHandles.Lookup)"><code>MethodHandleInfo.reflectAs</code></a>来解析对成员的符号引用。</span> 
             <p> <span>如果有安全管理器，则使用<code>ReflectPermission("suppressAccessChecks")</code>权限调用其<code>checkPermission</code>方法。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <span><code>T</code> - 所需的结果类型， <a href="../reflect/Member.html" title="java.lang.reflect中的接口"><code>Member</code></a>或子类型</span> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>target</code> - 一个破解为符号引用组件的直接方法句柄 
             </dd> 
             <dd> 
              <code>expected</code> - 表示所需结果类型 
              <code>T</code>的类对象 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               对方法，构造函数或字段对象的引用 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果呼叫者没有权限呼叫 
              <code>setAccessible</code> 
             </dd> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任一参数为 
              <code>null</code> 
             </dd> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果目标不是直接方法句柄 
             </dd> 
             <dd> 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果该成员不是预期类型 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.8 
             </dd> 
            </dl> </li> 
          </ul> <a id="arrayConstructor(java.lang.Class)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>arrayConstructor</h4> <pre class="methodSignature">public static&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;arrayConstructor​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;arrayClass)
                                     throws <a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></pre> 
            <div class="block"> 
             <span>生成一个方法句柄，构造所需类型的数组，就好像通过<code>anewarray</code>字节码一样。</span> 
             <span>方法句柄的返回类型是数组类型。</span> 
             <span>其唯一参数的类型将为<code>int</code> ，它指定数组的大小。</span> 
             <p> <span>如果使用负数组大小调用返回的方法句柄，则将抛出<code>NegativeArraySizeException</code> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>arrayClass</code> - 数组类型 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个方法句柄，可以创建给定类型的数组 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果参数是 
              <code>null</code> 
             </dd> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
              <code>arrayClass</code>不是数组类型 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="../reflect/Array.html#newInstance(java.lang.Class,int)"><code>Array.newInstance(Class, int)</code></a> 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">See <cite>The Java™ Virtual Machine Specification</cite>:</span> 
             </dt> 
             <dd>
               6.5 
              <code>anewarray</code>说明 
             </dd> 
            </dl> </li> 
          </ul> <a id="arrayLength(java.lang.Class)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>arrayLength</h4> <pre class="methodSignature">public static&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;arrayLength​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;arrayClass)
                                throws <a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></pre> 
            <div class="block"> 
             <span>生成一个返回数组长度的方法句柄，就像<code>arraylength</code>字节码一样。</span> 
             <span>方法句柄的类型将具有<code>int</code>作为返回类型，并且其唯一参数将是数组类型。</span> 
             <p> <span>如果使用<code>null</code>数组引用调用返回的方法句柄，则将抛出<code>NullPointerException</code> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>arrayClass</code> - 数组类型 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个方法句柄，可以检索给定数组类型的数组的长度 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果参数是 
              <code>null</code> 
             </dd> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果arrayClass不是数组类型 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">See <cite>The Java™ Virtual Machine Specification</cite>:</span> 
             </dt> 
             <dd>
               6.5 
              <code>arraylength</code>说明 
             </dd> 
            </dl> </li> 
          </ul> <a id="arrayElementGetter(java.lang.Class)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>arrayElementGetter</h4> <pre class="methodSignature">public static&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;arrayElementGetter​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;arrayClass)
                                       throws <a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></pre> 
            <div class="block"> 
             <span>生成一个方法句柄，提供对数组元素的读访问，就像<code>aaload</code>字节码一样。</span> 
             <span>方法句柄的类型将具有数组元素类型的返回类型。</span> 
             <span>它的第一个参数是数组类型，第二个参数是<code>int</code> 。</span> 
             <p> <span>调用返回的方法句柄时，将检查数组引用和数组索引。</span> <span>甲<code>NullPointerException</code>将如果数组引用是被抛出<code>null</code>和<code>ArrayIndexOutOfBoundsException</code>如果索引是负将被抛出，或者如果它是大于或等于所述阵列的长度。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>arrayClass</code> - 数组类型 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个方法句柄，可以从给定的数组类型加载值 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果参数为null 
             </dd> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果arrayClass不是数组类型 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">See <cite>The Java™ Virtual Machine Specification</cite>:</span> 
             </dt> 
             <dd>
               6.5 
              <code>aaload</code>说明 
             </dd> 
            </dl> </li> 
          </ul> <a id="arrayElementSetter(java.lang.Class)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>arrayElementSetter</h4> <pre class="methodSignature">public static&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;arrayElementSetter​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;arrayClass)
                                       throws <a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></pre> 
            <div class="block"> 
             <span>生成一个方法句柄，提供对数组元素的写访问，就像<code>astore</code>字节码一样。</span> 
             <span>方法句柄的类型将具有void返回类型。</span> 
             <span>它的最后一个参数将是数组的元素类型。</span> 
             <span>第一个和第二个参数将是数组类型和int。</span> 
             <p> <span>调用返回的方法句柄时，将检查数组引用和数组索引。</span> <span>甲<code>NullPointerException</code>将如果数组引用是被抛出<code>null</code>和<code>ArrayIndexOutOfBoundsException</code>如果索引是负将被抛出，或者如果它是大于或等于所述阵列的长度。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>arrayClass</code> - 数组的类 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个方法句柄，可以将值存储到数组类型中 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果参数为null 
             </dd> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果arrayClass不是数组类型 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">See <cite>The Java™ Virtual Machine Specification</cite>:</span> 
             </dt> 
             <dd>
               6.5 
              <code>aastore</code>说明 
             </dd> 
            </dl> </li> 
          </ul> <a id="arrayElementVarHandle(java.lang.Class)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>arrayElementVarHandle</h4> <pre class="methodSignature">public static&nbsp;<a href="VarHandle.html" title="class in java.lang.invoke">VarHandle</a>&nbsp;arrayElementVarHandle​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;arrayClass)
                                       throws <a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></pre> 
            <div class="block"> 
             <span>产生VarHandle给予访问类型的数组的元素<code>arrayClass</code> 。</span> 
             <span>该VarHandle的变量类型是组件类型<code>arrayClass</code>和坐标类型的列表是<code>(arrayClass, int)</code> ，其中<code>int</code>坐标类型对应于一个索引到一个数组参数。</span> 
             <p> <span>在以下条件下，不支持返回的VarHandle的某些访问模式：</span> </p> 
             <ul> 
              <li> <span>如果组件类型以外的任何其他<code>byte</code> ， <code>short</code> ， <code>char</code> ， <code>int</code> ， <code>long</code> ， <code>float</code> ，或<code>double</code>然后数字原子更新的接入方式是不受支持的。</span> </li> 
              <li> <span>如果字段的类型是比其他任何<code>boolean</code> ， <code>byte</code> ， <code>short</code> ， <code>char</code> ， <code>int</code>或<code>long</code>然后按位原子更新的接入方式是不受支持的。</span> </li> 
             </ul> 
             <p> <span>如果组件类型为<code>float</code>或<code>double</code>则数字和原子更新访问模式使用其按位表示形式比较值（分别参见<a href="../Float.html#floatToRawIntBits(float)"><code>Float.floatToRawIntBits(float)</code></a>和<a href="../Double.html#doubleToRawLongBits(double)"><code>Double.doubleToRawLongBits(double)</code></a> ）。</span> </p> 
             <p> <span>调用返回的<code>VarHandle</code> ，将检查数组引用和数组索引。</span> <span>甲<code>NullPointerException</code>将如果数组引用是被抛出<code>null</code>和<code>ArrayIndexOutOfBoundsException</code>如果索引是负将被抛出，或者如果它是大于或等于所述阵列的长度。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>由数值和原子更新访问模式执行的<code>float</code>值或<code>double</code>值的按位比较与原始<code>==</code>运算符和<a href="../Float.html#equals(java.lang.Object)"><code>Float.equals(java.lang.Object)</code></a>和<a href="../Double.html#equals(java.lang.Object)"><code>Double.equals(java.lang.Object)</code></a>方法不同，特别是在比较NaN值或比较<code>-0.0</code>与<code>+0.0</code> 。</span> 
              <span>由于操作可能意外失败，因此在执行比较和设置或比较和交换操作时应小心这些值。</span> 
              <span>Java中有许多可能的NaN值被认为是<code>NaN</code> ，尽管Java提供的IEEE 754浮点运算不能区分它们。</span> 
              <span>如果预期值或见证值是NaN值并且它（可能以特定于平台的方式）转换为另一个NaN值，则可能发生操作失败，因此具有不同的按位表示（有关详细信息，请参阅<a href="../Float.html#intBitsToFloat(int)"><code>Float.intBitsToFloat(int)</code></a>或<a href="../Double.html#longBitsToDouble(long)"><code>Double.longBitsToDouble(long)</code></a> ）。</span> 
              <span>值<code>-0.0</code>和<code>+0.0</code>具有不同的按位表示，但在使用原语<code>==</code>运算符时被视为相等。</span> 
              <span>如果，例如，数字算法计算的预期值是说可能会出现操作故障<code>-0.0</code>和先前计算的见证价值被说<code>+0.0</code> 。</span> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>arrayClass</code> - 数组类，类型 
              <code>T[]</code> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个VarHandle，可以访问数组的元素 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果arrayClass为null 
             </dd> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果arrayClass不是数组类型 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
            </dl> </li> 
          </ul> <a id="byteArrayViewVarHandle(java.lang.Class,java.nio.ByteOrder)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>byteArrayViewVarHandle</h4> <pre class="methodSignature">public static&nbsp;<a href="VarHandle.html" title="class in java.lang.invoke">VarHandle</a>&nbsp;byteArrayViewVarHandle​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;viewArrayClass,
                                               <a href="../../nio/ByteOrder.html" title="class in java.nio">ByteOrder</a>&nbsp;byteOrder)
                                        throws <a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></pre> 
            <div class="block"> 
             <span>生成一个VarHandle，可以访问<code>byte[]</code>数组的元素，就像它是一个不同的原始数组类型一样，例如<code>int[]</code>或<code>long[]</code> 。</span> 
             <span>该VarHandle的变量类型是组件类型<code>viewArrayClass</code>和坐标类型的列表是<code>(byte[], int)</code> ，其中<code>int</code>坐标类型对应于一个索引到一个参数<code>byte[]</code>阵列。</span> 
             <span>返回的VarHandle访问<code>byte[]</code>数组中索引处的字节，根据给定的字节顺序将字节组合到组件类型<code>viewArrayClass</code>的值或从组件类型的值组成。</span> 
             <p> <span>支持的组件类型（变量类型）是<code>short</code> ， <code>char</code> ， <code>int</code> ， <code>long</code> ， <code>float</code>和<code>double</code> 。</span> </p> 
             <p> <span>一个给定的索引处的字节的访问将导致<code>IndexOutOfBoundsException</code>如果索引小于<code>0</code>比大于或<code>byte[]</code>的阵列长度减去的大小（以字节计） <code>T</code> 。</span> </p> 
             <p> <span>的指数下的字节访问可以对齐或不对齐为<code>T</code> ，相对于底层的存储器地址， <code>A</code>说，与所述阵列和索引相关联。</span> <span>如果访问未对齐，则访问<code>get</code>和<code>set</code>访问模式以外的任何内容将导致<code>IllegalStateException</code> 。</span> <span>在这种情况下，只能保证原子访问的最大功率为2，它将<code>A</code>的GCD和<code>A</code>的大小（以字节为单位） <code>T</code> 。</span> <span>如果访问已对齐，则支持以下访问模式，并保证支持原子访问：</span> </p> 
             <ul> 
              <li> <span>读取所有<code>T</code>写访问模式，但访问模式<code>get</code>和<code>set</code> （ <code>long</code>和<code>double</code>在32位平台上<code>double</code> 。</span> </li> 
              <li> <span>原子更新的接入方式为<code>int</code> ， <code>long</code> ， <code>float</code>或<code>double</code> 。</span> <span>（JDK的未来主要平台版本可能支持某些当前不支持的访问模式的其他类型。）</span> </li> 
              <li> <span><code>int</code>和<code>long</code>数字原子更新访问模式。</span> <span>（对于某些当前不支持的访问模式，JDK的未来主要平台版本可能支持其他数字类型。）</span> </li> 
              <li> <span><code>int</code>和<code>long</code>按位原子更新访问模式。</span> <span>（对于某些当前不支持的访问模式，JDK的未来主要平台版本可能支持其他数字类型。）</span> </li> 
             </ul> 
             <p> <span>可以针对<code>byte[]</code>阵列确定未对齐的访问，因此确定原子性保证，而无需在特定阵列上运行。</span> <span>给定一个<code>index</code> ， <code>T</code>和它的对应的盒装类型， <code>T_BOX</code> ，如下错位可以被确定：</span> </p> 
             <pre>  <span><code> int sizeOfT = T_BOX.BYTES; // size in bytes of T int misalignedAtZeroIndex = ByteBuffer.wrap(new byte[0]). alignmentOffset(0, sizeOfT); int misalignedAtIndex = (misalignedAtZeroIndex + index) % sizeOfT; boolean isMisaligned = misalignedAtIndex != 0; </code></span> </pre> 
             <p> <span>如果变量类型为<code>float</code>或<code>double</code>则原子更新访问模式使用其按位表示形式比较值（分别参见<a href="../Float.html#floatToRawIntBits(float)"><code>Float.floatToRawIntBits(float)</code></a>和<a href="../Double.html#doubleToRawLongBits(double)"><code>Double.doubleToRawLongBits(double)</code></a> ）。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>viewArrayClass</code> - 视图数组类，其类型为 
              <code>T</code> 
             </dd> 
             <dd> 
              <code>byteOrder</code> - 视图数组元素的字节顺序，存储在底层 
              <code>byte</code>数组中 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个VarHandle，可以访问 
              <code>byte[]</code>数组的元素， 
              <code>byte[]</code>查看对应于视图数组类的组件类型的元素一样 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果viewArrayClass或byteOrder为null 
             </dd> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果viewArrayClass不是数组类型 
             </dd> 
             <dd> 
              <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果不支持viewArrayClass的组件类型作为变量类型 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
            </dl> </li> 
          </ul> <a id="byteBufferViewVarHandle(java.lang.Class,java.nio.ByteOrder)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>byteBufferViewVarHandle</h4> <pre class="methodSignature">public static&nbsp;<a href="VarHandle.html" title="class in java.lang.invoke">VarHandle</a>&nbsp;byteBufferViewVarHandle​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;viewArrayClass,
                                                <a href="../../nio/ByteOrder.html" title="class in java.nio">ByteOrder</a>&nbsp;byteOrder)
                                         throws <a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></pre> 
            <div class="block"> 
             <span>生成一个VarHandle，可以访问ByteBuffer的元素，就像它是<code>ByteBuffer</code>的不同原始组件类型的元素数组<code>byte</code> ，例如<code>int[]</code>或<code>long[]</code> 。</span> 
             <span>该VarHandle的变量类型是组件类型<code>viewArrayClass</code>和坐标类型的列表是<code>(ByteBuffer, int)</code> ，其中<code>int</code>坐标类型对应于一个索引到一个参数<code>byte[]</code>阵列。</span> 
             <span>返回VarHandle的指数下访问以字节<code>ByteBuffer</code> ，构成字节或从的部件类型的值<code>viewArrayClass</code>根据给定的字节顺序。</span> 
             <p> <span>支持的组件类型（变量类型）是<code>short</code> ， <code>char</code> ， <code>int</code> ， <code>long</code> ， <code>float</code>和<code>double</code> 。</span> </p> 
             <p> <span>如果<code>ByteBuffer</code>是只读的，则访问将导致<code>ReadOnlyBufferException</code>以外的任何读取访问模式。</span> </p> 
             <p> <span>一个给定的索引处的字节的访问将导致<code>IndexOutOfBoundsException</code>如果索引小于<code>0</code>比大于或<code>ByteBuffer</code>的限值减去的大小（以字节计） <code>T</code> 。</span> </p> 
             <p> <span>对于<code>T</code> ，索引上的字节访问可以对齐或未对齐，相对于与<code>ByteBuffer</code>和索引相关联的基础内存地址<code>A</code> 。</span> <span>如果访问未对齐，则访问<code>get</code>和<code>set</code>访问模式以外的任何内容将导致<code>IllegalStateException</code> 。</span> <span>在这种情况下，原子访问仅保证相对于将<code>A</code>分为<code>A</code>和<code>A</code>的大小（以字节为单位）的<code>T</code> 。</span> <span>如果访问已对齐，则支持以下访问模式，并保证支持原子访问：</span> </p> 
             <ul> 
              <li> <span>读取所有<code>T</code>写访问模式，但访问模式<code>get</code>和<code>set</code> （ <code>long</code>和<code>double</code> （32位平台） <code>double</code> 。</span> </li> 
              <li> <span>原子更新的接入方式为<code>int</code> ， <code>long</code> ， <code>float</code>或<code>double</code> 。</span> <span>（JDK的未来主要平台版本可能支持某些当前不支持的访问模式的其他类型。）</span> </li> 
              <li> <span><code>int</code>和<code>long</code>数字原子更新访问模式。</span> <span>（对于某些当前不支持的访问模式，JDK的未来主要平台版本可能支持其他数字类型。）</span> </li> 
              <li> <span><code>int</code>和<code>long</code>按位原子更新访问模式。</span> <span>（对于某些当前不支持的访问模式，JDK的未来主要平台版本可能支持其他数字类型。）</span> </li> 
             </ul> 
             <p> <span>未对齐存取，因此原子性保证，可以为被确定<code>ByteBuffer</code> ， <code>bb</code> （直接或以其它方式），一个<code>index</code> ， <code>T</code>和它的对应的盒装类型， <code>T_BOX</code> ，如下所示：</span> </p> 
             <pre>  <span><code> int sizeOfT = T_BOX.BYTES; // size in bytes of T ByteBuffer bb = ... int misalignedAtIndex = bb.alignmentOffset(index, sizeOfT); boolean isMisaligned = misalignedAtIndex != 0; </code></span> </pre> 
             <p> <span>如果变量类型为<code>float</code>或<code>double</code>则原子更新访问模式使用其按位表示来比较值（分别参见<a href="../Float.html#floatToRawIntBits(float)"><code>Float.floatToRawIntBits(float)</code></a>和<a href="../Double.html#doubleToRawLongBits(double)"><code>Double.doubleToRawLongBits(double)</code></a> ）。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>viewArrayClass</code> - 视图数组类，其组件类型类型为 
              <code>T</code> 
             </dd> 
             <dd> 
              <code>byteOrder</code> - 视图数组元素的字节顺序，存储在底层 
              <code>ByteBuffer</code> （注意这将覆盖 
              <code>ByteBuffer</code>的字节顺序） 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个VarHandle，可以访问ByteBuffer的元素， 
              <code>ByteBuffer</code>查看对应于视图数组类的组件类型的元素一样 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果viewArrayClass或byteOrder为null 
             </dd> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果viewArrayClass不是数组类型 
             </dd> 
             <dd> 
              <code><a href="../UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果不支持viewArrayClass的组件类型作为变量类型 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
            </dl> </li> 
          </ul> <a id="spreadInvoker(java.lang.invoke.MethodType,int)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>spreadInvoker</h4> <pre class="methodSignature">public static&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;spreadInvoker​(<a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type,
                                         int&nbsp;leadingArgCount)</pre> 
            <div class="block"> 
             <span>生成一个方法句柄，该句柄将调用给定<code>type</code>任何方法句柄，并将给定数量的尾随参数替换为单个尾随<code>Object[]</code>数组。</span> 
             <span>生成的调用者将是一个带有以下参数的方法句柄：</span> 
             <ul> 
              <li> <span>单个<code>MethodHandle</code>目标</span> </li> 
              <li> <span>零个或多个主要值（由<code>leadingArgCount</code>计算）</span> </li> 
              <li> <span>包含尾随参数的<code>Object[]</code>数组</span> </li> 
             </ul> 
             <p> <span>调用者将调用其目标，如调用<a href="MethodHandle.html#invoke(java.lang.Object...)"><code>invoke</code></a> ，指示<code>type</code> 。</span> <span>也就是说，如果目标完全是给定的<code>type</code> ，它的行为就像<code>invokeExact</code> ;</span> <span>否则它的行为就好像<a href="MethodHandle.html#asType(java.lang.invoke.MethodType)"><code>asType</code></a>用于将目标转换为所需的<code>type</code> 。</span> </p> 
             <p> <span>返回的调用者的类型将不是给定的<code>type</code> ，而是将除了第一个<code>leadingArgCount</code>之外的所有参数替换为<code>Object[]</code>类型的单个数组，这将是最终参数。</span> </p> 
             <p> <span>在调用其目标之前，调用者将传播最终数组，根据需要应用引用强制转换，以及取消框和扩展原始参数。</span> <span>如果在调用调用者时，提供的数组参数没有正确数量的元素，调用者将抛出<a href="../IllegalArgumentException.html" title="java.lang中的类"><code>IllegalArgumentException</code></a>而不是调用目标。</span> </p> 
             <p> <span>此方法等效于以下代码（尽管它可能更有效）：</span> </p> 
             <blockquote> 
              <span><pre><code>
MethodHandle invoker = MethodHandles.invoker(type);
int spreadArgCount = type.parameterCount() - leadingArgCount;
invoker = invoker.asSpreader(Object[].class, spreadArgCount);
return invoker;
 </code></pre></span> 
             </blockquote> 
             <span>此方法不会引发反射或安全异常。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>type</code> - 所需的目标类型 
             </dd> 
             <dd> 
              <code>leadingArgCount</code> - 要保持不变地传递给目标的固定参数的数量 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               适合于调用给定类型的任何方法句柄的方法句柄 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
              <code>type</code>为空 
             </dd> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
              <code>leadingArgCount</code>不在0到 
              <code>type.parameterCount()</code>含）范围内，或者结果方法句柄的类型为 
              <a href="MethodHandle.html#maxarity">too many parameters</a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="exactInvoker(java.lang.invoke.MethodType)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>exactInvoker</h4> <pre class="methodSignature">public static&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;exactInvoker​(<a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)</pre> 
            <div class="block"> 
             <span>生成一个特殊的<em>调用者方法句柄</em> ，可以用来调用给定类型的任何方法句柄，就像<a href="MethodHandle.html#invokeExact(java.lang.Object...)"><code>invokeExact</code>一样</a> 。</span> 
             <span>生成的调用者将具有与所需类型完全相同的类型，除了它将接受类型为<code>MethodHandle</code>的其他前导参数。</span> 
             <p> <span>此方法等效于以下代码（尽管可能更有效）： <code>publicLookup().findVirtual(MethodHandle.class, "invokeExact", type)</code></span> </p> 
             <p style="font-size:smaller;"> <span><em>讨论：</em>使用未知类型的变量方法句柄时，Invoker方法句柄非常有用。</span> <span>例如，要模拟对变量方法句柄<code>M</code>的<code>invokeExact</code>调用，请提取其类型<code>T</code> ，查找调用方法<code>X</code>以获取<code>T</code> ，并调用调用方法，如<code>X.invoke(T, A...)</code> 。</span> <span>（调用<code>X.invokeExact</code> ，因为类型<code>T</code>是未知的。）如果需要传播，收集或其他参数转换，它们可以应用于调用程序<code>X</code>并重复使用许多<code>M</code>方法句柄值，只要它们与<code>X</code>的类型兼容。</span> </p> 
             <p style="font-size:smaller;"> <span><em>（注意：调用方法不能通过Core Reflection API获得。尝试在声明的<code>invokeExact</code>或<code>invoke</code>方法上调用<a href="../reflect/Method.html#invoke(java.lang.Object,java.lang.Object...)">java.lang.reflect.Method.invoke</a>将引发<a href="../UnsupportedOperationException.html" title="java.lang中的类"><code>UnsupportedOperationException</code>。</a> ）</em></span> </p> 
             <p> <span>此方法不会引发反射或安全异常。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>type</code> - 所需的目标类型 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               适合于调用给定类型的任何方法句柄的方法句柄 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果生成的方法句柄的类型为 
              <a href="MethodHandle.html#maxarity">too many parameters</a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="invoker(java.lang.invoke.MethodType)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>invoker</h4> <pre class="methodSignature">public static&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;invoker​(<a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)</pre> 
            <div class="block"> 
             <span>生成一个特殊的<em>调用者方法句柄</em> ，可以用来调用与给定类型兼容的任何方法句柄，就像<a href="MethodHandle.html#invoke(java.lang.Object...)"><code>invoke</code>一样</a> 。</span> 
             <span>生成的调用者将具有与所需类型完全相同的类型，除了它将接受类型为<code>MethodHandle</code>的其他前导参数。</span> 
             <p> <span>在调用目标之前，如果目标与预期类型不同，调用者将根据需要应用参考强制转换以及框，取消框或加宽原始值，就像<a href="MethodHandle.html#asType(java.lang.invoke.MethodType)"><code>asType</code>一样</a> 。</span> <span>同样，返回值将根据需要进行转换。</span> <span>如果目标是<a href="MethodHandle.html#asVarargsCollector(java.lang.Class)">variable arity method handle</a> ，则将再次进行所需的arity转换，就像<a href="MethodHandle.html#asType(java.lang.invoke.MethodType)"><code>asType</code>一样</a> 。</span> </p> 
             <p> <span>此方法等效于以下代码（尽管可能更有效）： <code>publicLookup().findVirtual(MethodHandle.class, "invoke", type)</code></span> </p> 
             <p style="font-size:smaller;"> <span><em>讨论：</em> A <a href="MethodType.html#genericMethodType(int,boolean)">general method type</a>是仅提及<code>Object</code>参数和返回值的一个。</span> <span>这种类型的调用者能够调用与常规类型相同的任何方法句柄。</span> </p> 
             <p style="font-size:smaller;"> <span><em>（注意：调用方法不能通过Core Reflection API获得。尝试在声明的<code>invokeExact</code>或<code>invoke</code>方法上调用<a href="../reflect/Method.html#invoke(java.lang.Object,java.lang.Object...)">java.lang.reflect.Method.invoke</a>将引发<a href="../UnsupportedOperationException.html" title="java.lang中的类"><code>UnsupportedOperationException</code>。</a> ）</em></span> </p> 
             <p> <span>此方法不会引发反射或安全异常。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>type</code> - 所需的目标类型 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个方法句柄，适用于调用可转换为给定类型的任何方法句柄 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果生成的方法句柄的类型为 
              <a href="MethodHandle.html#maxarity">too many parameters</a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="varHandleExactInvoker(java.lang.invoke.VarHandle.AccessMode,java.lang.invoke.MethodType)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>varHandleExactInvoker</h4> <pre class="methodSignature">public static&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;varHandleExactInvoker​(<a href="VarHandle.AccessMode.html" title="enum in java.lang.invoke">VarHandle.AccessMode</a>&nbsp;accessMode,
                                                 <a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)</pre> 
            <div class="block"> 
             <span>生成一个特殊的<em>调用方法句柄</em> ，可用于在任何VarHandle上调用签名 - 多态访问模式方法，该方法的关联访问模式类型与给定类型兼容。</span> 
             <span>生成的调用程序将具有与所需给定类型完全相同的类型，除了它将接受类型为<code>VarHandle</code>的其他前导参数。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>accessMode</code> - VarHandle访问模式 
             </dd> 
             <dd> 
              <code>type</code> - 所需的目标类型 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个方法句柄，适用于调用其访问模式类型为给定类型的任何VarHandle的访问模式方法。 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
            </dl> </li> 
          </ul> <a id="varHandleInvoker(java.lang.invoke.VarHandle.AccessMode,java.lang.invoke.MethodType)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>varHandleInvoker</h4> <pre class="methodSignature">public static&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;varHandleInvoker​(<a href="VarHandle.AccessMode.html" title="enum in java.lang.invoke">VarHandle.AccessMode</a>&nbsp;accessMode,
                                            <a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)</pre> 
            <div class="block"> 
             <span>生成一个特殊的<em>调用方法句柄</em> ，可用于在任何VarHandle上调用签名 - 多态访问模式方法，该方法的关联访问模式类型与给定类型兼容。</span> 
             <span>生成的调用者将具有与所需给定类型完全相同的类型，除了它将接受类型为<code>VarHandle</code>的其他前导参数。</span> 
             <p> <span>在调用其目标之前，如果访问模式类型与所需的给定类型不同，则调用者将根据需要应用引用强制转换以及框，取消框或加宽原始值，就像<a href="MethodHandle.html#asType(java.lang.invoke.MethodType)"><code>asType</code>一样</a> 。</span> <span>同样，返回值将根据需要进行转换。</span> </p> 
             <p> <span>此方法等效于以下代码（尽管可能更有效）： <code>publicLookup().findVirtual(VarHandle.class, accessMode.name(), type)</code></span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>accessMode</code> - VarHandle访问模式 
             </dd> 
             <dd> 
              <code>type</code> - 所需的目标类型 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个方法句柄，适用于调用其访问模式类型可转换为给定类型的任何VarHandle的访问模式方法。 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
            </dl> </li> 
          </ul> <a id="explicitCastArguments(java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>explicitCastArguments</h4> <pre class="methodSignature">public static&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;explicitCastArguments​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                                 <a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;newType)</pre> 
            <div class="block"> 
             <span>生成一个方法句柄，通过成对参数和返回类型转换使给定方法句柄的类型适应新类型。</span> 
             <span>原始类型和新类型必须具有相同数量的参数。</span> 
             <span>保证生成的方法句柄报告一个等于所需新类型的类型。</span> 
             <p> <span>如果原始类型和新类型相等，则返回target。</span> </p> 
             <p> <span>允许使用与<a href="MethodHandle.html#asType(java.lang.invoke.MethodType)"><code>MethodHandle.asType</code></a>相同的转化，如果转化失败，也会应用一些其他转化。</span> <span>给定类型<em>T0</em> ， <em>T1</em> ，如果可能，在<code>asType</code>完成任何转换之前或之后应用以下转换<code>asType</code> ：</span> </p> 
             <ul> 
              <li> <span>如果<em>T0</em>和<em>T1</em>是引用，并且<em>T1</em>是接口类型，那么类型<em>T0</em>的值作为<em>T1</em>传递而没有强制转换。</span> <span>（接口的这种处理遵循字节码验证器的使用。）</span> </li> 
              <li> <span>如果<em>T0</em>是布尔值而<em>T1</em>是另一个基元，则布尔值转换为字节值，1表示true，0表示false。</span> <span>（此处理遵循字节码验证程序的使用。）</span> </li> 
              <li> <span>如果<em>T1</em>是布尔值而<em>T0</em>是另一个基元，则通过Java转换（JLS 5.5）将<em>T0</em>转换为字节，并测试结果的低位，就好像是<code>(x &amp; 1) != 0</code> 。</span> </li> 
              <li> <span>如果<em>T0</em>和<em>T1</em>是布尔值以外的基元，则应用Java转换（JLS 5.5）。</span> <span>（具体来说， <em>T0</em>将通过加宽和/或缩小转换为<em>T1</em> 。）</span> </li> 
              <li> <span>如果<em>T0</em>是引用而<em>T1</em>是原语，则将在运行时应用取消装箱转换，之后可能会对原始值进行Java转换（JLS 5.5），之后可能会通过测试低位从字节转换为布尔值位。</span> </li> 
              <li> <span>如果<em>T0</em>是引用而<em>T1</em>是基元，并且如果引用在运行时为空，则引入零值。</span> </li> 
             </ul> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>target</code> - 重新输入参数后调用的方法句柄 
             </dd> 
             <dd> 
              <code>newType</code> - 新方法句柄的预期类型 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个方法句柄，在执行任何必要的参数转换后委托给目标，并安排任何必要的返回值转换 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任一参数为null 
             </dd> 
             <dd> 
              <code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果无法进行转换 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="MethodHandle.html#asType(java.lang.invoke.MethodType)"><code>MethodHandle.asType(java.lang.invoke.MethodType)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="permuteArguments(java.lang.invoke.MethodHandle,java.lang.invoke.MethodType,int...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>permuteArguments</h4> <pre class="methodSignature">public static&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;permuteArguments​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                            <a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;newType,
                                            int...&nbsp;reorder)</pre> 
            <div class="block"> 
             <span>生成一个方法句柄，通过重新排序参数，使给定方法句柄的调用序列适应新类型。</span> 
             <span>保证生成的方法句柄报告一个等于所需新类型的类型。</span> 
             <p> <span>给定的数组控制重新排序。</span> <span>调用<code>#I</code>传入参数的数量（值<code>newType.parameterCount()</code> ，并调用<code>#O</code>传出参数的数量（值<code>target.type().parameterCount()</code> ）。然后重新排序数组的长度必须为<code>#O</code> ，并且每个元素必须是小于<code>#I</code>的非负数。对于每<code>N</code>少于<code>#O</code> <code>N</code>传出参数将取自<code>I</code> -th传入参数，其中<code>I</code>为<code>reorder[N]</code> 。</span> </p> 
             <p> <span>不应用参数或返回值转换。</span> <span>由<code>newType</code>确定的每个传入参数的类型必须与目标方法句柄中相应传出参数或参数的类型相同。</span> <span>返回类型<code>newType</code>必须与原始目标的返回类型相同。</span> </p> 
             <p> <span>重排序数组不需要指定实际排列。</span> <span>如果传入参数的索引在数组中出现多次，则传入参数将被复制，如果其索引未出现在数组中，则传入参数将被删除。</span> <span>与<a href="#dropArguments(java.lang.invoke.MethodHandle,int,java.util.List)"><code>dropArguments</code></a>的情况<a href="#dropArguments(java.lang.invoke.MethodHandle,int,java.util.List)">一样</a> ，重新排序数组中未提及的传入参数可以是任何类型，仅由<code>newType</code>确定。</span> </p> 
             <blockquote> 
              <span><pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodType intfn1 = methodType(int.class, int.class);
MethodType intfn2 = methodType(int.class, int.class, int.class);
MethodHandle sub = ... (int x, int y) -&gt; (x-y) ...;
assert(sub.type().equals(intfn2));
MethodHandle sub1 = permuteArguments(sub, intfn2, 0, 1);
MethodHandle rsub = permuteArguments(sub, intfn2, 1, 0);
assert((int)rsub.invokeExact(1, 100) == 99);
MethodHandle add = ... (int x, int y) -&gt; (x+y) ...;
assert(add.type().equals(intfn2));
MethodHandle twice = permuteArguments(add, intfn1, 0, 0);
assert(twice.type().equals(intfn1));
assert((int)twice.invokeExact(21) == 42);
 </code></pre></span> 
             </blockquote> 
             <p> <span><em>注意：</em>生成的适配器永远不会是<a href="MethodHandle.html#asVarargsCollector(java.lang.Class)">variable-arity method handle</a> ，即使原始目标方法句柄是。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>target</code> - 重新排序参数后调用的方法句柄 
             </dd> 
             <dd> 
              <code>newType</code> - 新方法句柄的预期类型 
             </dd> 
             <dd> 
              <code>reorder</code> - 控制重新排序的索引数组 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个方法句柄，它在删除未使用的参数并移动和/或复制其他参数后委托给目标 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任何参数为null 
             </dd> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果索引数组长度不等于目标的arity，或者如果任何索引数组元素不是参数 
              <code>newType</code>的有效索引，或者 
              <code>target.type()</code>和 
              <code>newType</code>中的两个相应参数类型不相同， 
             </dd> 
            </dl> </li> 
          </ul> <a id="constant(java.lang.Class,java.lang.Object)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>constant</h4> <pre class="methodSignature">public static&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;constant​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;type,
                                    <a href="../Object.html" title="class in java.lang">Object</a>&nbsp;value)</pre> 
            <div class="block"> 
             <span>生成请求的返回类型的方法句柄，每次调用它时都返回给定的常量值。</span> 
             <p> <span>在返回方法句柄之前，传入的值将转换为请求的类型。</span> <span>如果请求的类型是原始的，则尝试扩展原始转换，否则尝试引用转换。</span> </p> 
             <p> <span>返回的方法句柄相当于<code>identity(type).bindTo(value)</code> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>type</code> - 所需方法句柄的返回类型 
             </dd> 
             <dd> 
              <code>value</code> - 要返回的值 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               给定返回类型的方法句柄，没有参数，它总是返回给定的值 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
              <code>type</code>参数为null 
             </dd> 
             <dd> 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果值无法转换为所需的返回类型 
             </dd> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果给定的类型是 
              <code>void.class</code> 
             </dd> 
            </dl> </li> 
          </ul> <a id="identity(java.lang.Class)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>identity</h4> <pre class="methodSignature">public static&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;identity​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;type)</pre> 
            <div class="block">
              生成一个方法句柄，在调用时返回其唯一的参数。 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>type</code> - 唯一参数的类型和所需方法句柄的返回值 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一元方法句柄，它接受并返回给定的类型 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果参数为null 
             </dd> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果给定的类型是 
              <code>void.class</code> 
             </dd> 
            </dl> </li> 
          </ul> <a id="zero(java.lang.Class)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>zero</h4> <pre class="methodSignature">public static&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;zero​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;type)</pre> 
            <div class="block"> 
             <span>生成所请求的返回类型的常量方法句柄，该句柄在每次调用时返回该类型的默认值。</span> 
             <span>生成的常量方法句柄没有副作用。</span> 
             <p> <span>返回的方法句柄相当于<code>empty(methodType(type))</code> 。</span> <span>它也相当于<code>explicitCastArguments(constant(Object.class, null), methodType(type))</code> ，因为<code>explicitCastArguments</code>将<code>null</code>转换为默认值。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>type</code> - 所需方法句柄的预期返回类型 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个常量方法句柄，它不接受任何参数并返回给定类型的默认值（如果类型为void，则返回void） 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果参数为null 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#constant(java.lang.Class,java.lang.Object)"><code>constant(java.lang.Class&lt;?&gt;, java.lang.Object)</code></a> ， 
              <a href="#empty(java.lang.invoke.MethodType)"><code>empty(java.lang.invoke.MethodType)</code></a> ， 
              <a href="#explicitCastArguments(java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)"><code>explicitCastArguments(java.lang.invoke.MethodHandle, java.lang.invoke.MethodType)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="empty(java.lang.invoke.MethodType)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>empty</h4> <pre class="methodSignature">public static&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;empty​(<a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)</pre> 
            <div class="block"> 
             <span>生成所请求类型的方法句柄，该句柄忽略任何参数，不执行任何操作，并根据返回类型返回合适的默认值。</span> 
             <span>也就是说，它返回零原始值， <code>null</code>或<code>void</code> 。</span> 
             <p> <span>返回的方法句柄相当于<code>dropArguments(zero(type.returnType()), 0, type.parameterList())</code> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd>
               给定谓词和目标，可以产生有用的“if-then”构造作为 
              <code>guardWithTest(pred, target, empty(target.type())</code> 。 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>type</code> - 所需方法句柄的类型 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               给定类型的常量方法句柄，它返回给定返回类型的默认值 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果参数为null 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#zero(java.lang.Class)"><code>zero(java.lang.Class&lt;?&gt;)</code></a> ， 
              <a href="#constant(java.lang.Class,java.lang.Object)"><code>constant(java.lang.Class&lt;?&gt;, java.lang.Object)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="insertArguments(java.lang.invoke.MethodHandle,int,java.lang.Object...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>insertArguments</h4> <pre class="methodSignature">public static&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;insertArguments​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                           int&nbsp;pos,
                                           <a href="../Object.html" title="class in java.lang">Object</a>...&nbsp;values)</pre> 
            <div class="block"> 
             <span>在方法句柄调用之前提供带有一个或多个<em>绑定参数</em>的目标方法句柄。</span> 
             <span>与绑定参数对应的目标的形式参数称为<em>绑定参数</em> 。</span> 
             <span>返回一个新的方法句柄，它保存绑定的参数。</span> 
             <span>调用它时，它接收任何非绑定参数的参数，将保存的参数绑定到其相应的参数，并调用原始目标。</span> 
             <p> <span>新方法句柄的类型将从原始目标类型中删除绑定参数的类型，因为新方法句柄将不再需要其调用者提供这些参数。</span> </p> 
             <p> <span>每个给定的参数对象必须与相应的绑定参数类型匹配。</span> <span>如果绑定参数类型是基元，则参数对象必须是包装器，并且将取消装箱以生成基元值。</span> </p> 
             <p> <span><code>pos</code>参数选择要绑定的参数。</span> <span>它可以介于0和<i>NL</i>之间（包含），其中<i>N</i>是目标方法句柄的arity， <i>L</i>是values数组的长度。</span> </p> 
             <p> <span><em>注意：</em>生成的适配器永远不会是<a href="MethodHandle.html#asVarargsCollector(java.lang.Class)">variable-arity method handle</a> ，即使原始目标方法句柄是。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>target</code> - 插入参数后要调用的方法句柄 
             </dd> 
             <dd> 
              <code>pos</code> - 插入参数的位置（第一个为零） 
             </dd> 
             <dd> 
              <code>values</code> - 要插入的一系列参数 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               在调用原始方法句柄之前插入附加参数的方法句柄 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果目标或 
              <code>values</code>数组为空 
             </dd> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if（@code pos）小于 
              <code>0</code>或大于 
              <code>N - L</code> ，其中 
              <code>N</code>是目标方法句柄的arity， 
              <code>L</code>是values数组的长度。 
             </dd> 
             <dd> 
              <code><a href="../ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果参数与相应的绑定参数类型不匹配。 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="MethodHandle.html#bindTo(java.lang.Object)"><code>MethodHandle.bindTo(java.lang.Object)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="dropArguments(java.lang.invoke.MethodHandle,int,java.util.List)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>dropArguments</h4> <pre class="methodSignature">public static&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;dropArguments​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                         int&nbsp;pos,
                                         <a href="../../util/List.html" title="interface in java.util">List</a>&lt;<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&gt;&nbsp;valueTypes)</pre> 
            <div class="block"> 
             <span>生成一个方法句柄，它会在调用其他指定的<i>目标</i>方法句柄之前丢弃一些伪参数。</span> 
             <span>新方法句柄的类型将与目标的类型相同，除了在某个给定位置还包括伪参数类型。</span> 
             <p> <span><code>pos</code>参数的范围可以介于0和<i>N</i>之间，其中<i>N</i>是目标的arity。</span> <span>如果<code>pos</code>为零，则伪参数将位于目标的实参数之前;</span> <span>如果<code>pos</code>是<i>N，</i>他们会来。</span> </p> 
             <p> <span><b>例：</b></span> </p> 
             <blockquote> 
              <span><pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle cat = lookup().findVirtual(String.class,
  "concat", methodType(String.class, String.class));
assertEquals("xy", (String) cat.invokeExact("x", "y"));
MethodType bigType = cat.type().insertParameterTypes(0, int.class, String.class);
MethodHandle d0 = dropArguments(cat, 0, bigType.parameterList().subList(0,2));
assertEquals(bigType, d0.type());
assertEquals("yz", (String) d0.invokeExact(123, "x", "y", "z"));
 </code></pre></span> 
             </blockquote> 
             <p> <span>此方法也等效于以下代码：</span> </p> 
             <blockquote> 
              <span><pre>
 <a href="#dropArguments(java.lang.invoke.MethodHandle,int,java.lang.Class...)"><code>dropArguments</code></a><code>(target, pos, valueTypes.toArray(new Class[0]))</code>
 </pre></span> 
             </blockquote> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>target</code> - 删除参数后要调用的方法句柄 
             </dd> 
             <dd> 
              <code>valueTypes</code> - 要删除的参数的类型 
             </dd> 
             <dd> 
              <code>pos</code> - 放下第一个参数的位置（最左边为零） 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               在调用原始方法句柄之前删除给定类型的参数的方法句柄 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果目标为null，或者 
              <code>valueTypes</code>列表或其任何元素为null 
             </dd> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果任何元素 
              <code>valueTypes</code>为 
              <code>void.class</code> ，或者如果 
              <code>pos</code>比目标的元数负或更大，或者如果新的方法处理的类型将有太多的参数 
             </dd> 
            </dl> </li> 
          </ul> <a id="dropArguments(java.lang.invoke.MethodHandle,int,java.lang.Class...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>dropArguments</h4> <pre class="methodSignature">public static&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;dropArguments​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                         int&nbsp;pos,
                                         <a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;...&nbsp;valueTypes)</pre> 
            <div class="block"> 
             <span>生成一个方法句柄，它会在调用其他指定的<i>目标</i>方法句柄之前丢弃一些伪参数。</span> 
             <span>新方法句柄的类型将与目标的类型相同，除了在某个给定位置还包括伪参数类型。</span> 
             <p> <span><code>pos</code>参数的范围可以介于0和<i>N</i>之间，其中<i>N</i>是目标的arity。</span> <span>如果<code>pos</code>为零，则伪参数将位于目标的实参数之前;</span> <span>如果<code>pos</code>是<i>N，</i>他们会来。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <blockquote> 
               <span><pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle cat = lookup().findVirtual(String.class,
  "concat", methodType(String.class, String.class));
assertEquals("xy", (String) cat.invokeExact("x", "y"));
MethodHandle d0 = dropArguments(cat, 0, String.class);
assertEquals("yz", (String) d0.invokeExact("x", "y", "z"));
MethodHandle d1 = dropArguments(cat, 1, String.class);
assertEquals("xz", (String) d1.invokeExact("x", "y", "z"));
MethodHandle d2 = dropArguments(cat, 2, String.class);
assertEquals("xy", (String) d2.invokeExact("x", "y", "z"));
MethodHandle d12 = dropArguments(cat, 1, int.class, boolean.class);
assertEquals("xz", (String) d12.invokeExact("x", 12, true, "z"));
 </code></pre></span> 
              </blockquote> 
              <p> <span>此方法也等效于以下代码：</span> </p> 
              <blockquote> 
               <span><pre>
 <a href="#dropArguments(java.lang.invoke.MethodHandle,int,java.util.List)"><code>dropArguments</code></a><code>(target, pos, Arrays.asList(valueTypes))</code>
 </pre></span> 
              </blockquote> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>target</code> - 删除参数后要调用的方法句柄 
             </dd> 
             <dd> 
              <code>valueTypes</code> - 要删除的参数的类型 
             </dd> 
             <dd> 
              <code>pos</code> - 放下第一个参数的位置（最左边为零） 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               在调用原始方法句柄之前删除给定类型的参数的方法句柄 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果目标为null，或者 
              <code>valueTypes</code>数组或其任何元素为null 
             </dd> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果任何元素 
              <code>valueTypes</code>为 
              <code>void.class</code> ，或者如果 
              <code>pos</code>比目标的元数负或更大，或者如果新的方法处理的类型必须 
              <a href="MethodHandle.html#maxarity">too many parameters</a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="dropArgumentsToMatch(java.lang.invoke.MethodHandle,int,java.util.List,int)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>dropArgumentsToMatch</h4> <pre class="methodSignature">public static&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;dropArgumentsToMatch​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                                int&nbsp;skip,
                                                <a href="../../util/List.html" title="interface in java.util">List</a>&lt;<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&gt;&nbsp;newTypes,
                                                int&nbsp;pos)</pre> 
            <div class="block"> 
             <span>调整目标方法句柄以匹配给定的参数类型列表。</span> 
             <span>如有必要，添加伪参数。</span> 
             <span>在匹配开始之前可以跳过一些前导参数。</span> 
             <span><code>target</code>的参数类型列表中的其余类型必须是起始位置<code>pos</code>处的<code>newTypes</code>类型列表的子列表。</span> 
             <span>生成的句柄将具有目标句柄的参数类型列表，其中任何非匹配的参数类型（在匹配的子列表之前或之后）插入目标的原始参数的相应位置，就像<a href="#dropArguments(java.lang.invoke.MethodHandle,int,java.lang.Class...)"><code>dropArguments(MethodHandle, int, Class[])</code>一样</a> 。</span> 
             <p> <span>生成的句柄将具有与目标句柄相同的返回类型。</span> </p> 
             <p> <span>在更正式的术语中，假设这两个类型列表：</span> </p> 
             <ul> 
              <li> <span>目标句柄具有参数类型列表<code>S..., M...</code> ，在<code>S</code>具有尽可能多的类型，如<code>skip</code> 。</span> <span><code>M</code>类型是那些应该与给定类型列表的一部分匹配的类型， <code>newTypes</code> 。</span> </li> 
              <li> <span><code>newTypes</code>列表包含类型<code>P..., M..., A...</code> ，在<code>P</code>中具有<code>P</code>所示的<code>pos</code> 。</span> <span><code>M</code>类型正是目标句柄的参数类型列表中的<code>M</code>类型应该匹配的类型。</span> <span><code>A</code>中的类型是在匹配的子列表之后找到的其他类型。</span> </li> 
             </ul> 
             <span>给定这些假设，调用<code>dropArgumentsToMatch</code>的结果将具有参数类型列表<code>S..., P..., M..., A...</code> ，插入<code>P</code>和<code>A</code>类型，就像<a href="#dropArguments(java.lang.invoke.MethodHandle,int,java.lang.Class...)"><code>dropArguments(MethodHandle, int, Class[])</code>一样</a> 。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>两个方法句柄的参数列表“实际上相同”（即，在公共前缀中相同）可以通过两次调用<code>dropArgumentsToMatch</code>相互转换为公共类型，如下所示：</span> 
              <blockquote> 
               <span><pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
...
MethodHandle h0 = constant(boolean.class, true);
MethodHandle h1 = lookup().findVirtual(String.class, "concat", methodType(String.class, String.class));
MethodType bigType = h1.type().insertParameterTypes(1, String.class, int.class);
MethodHandle h2 = dropArguments(h1, 0, bigType.parameterList());
if (h1.type().parameterCount() &lt; h2.type().parameterCount())
    h1 = dropArgumentsToMatch(h1, 0, h2.type().parameterList(), 0);  // lengthen h1
else
    h2 = dropArgumentsToMatch(h2, 0, h1.type().parameterList(), 0);    // lengthen h2
MethodHandle h3 = guardWithTest(h0, h1, h2);
assertEquals("xy", h3.invoke("x", "y", 1, "a", "b", "c"));
 </code></pre></span> 
              </blockquote> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>target</code> - 适应的方法句柄 
             </dd> 
             <dd> 
              <code>skip</code> - 要忽略的目标参数数量（它们将保持不变） 
             </dd> 
             <dd> 
              <code>newTypes</code> - 要匹配 
              <code>target</code>的参数类型列表的类型列表 
             </dd> 
             <dd> 
              <code>pos</code> - 放置在 
              <code>newTypes</code> ，其中必须出现未跳过的目标参数 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个可能适应的方法句柄 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任一参数为null 
             </dd> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果任何元件 
              <code>newTypes</code>是 
              <code>void.class</code> ，或者如果 
              <code>skip</code>比目标的元数负或更大，或者如果 
              <code>pos</code>比newTypes列表尺寸负或更大，或者如果 
              <code>newTypes</code>不包含 
              <code>target</code>的非跳过位置 
              <code>pos</code>参数类型。 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
            </dl> </li> 
          </ul> <a id="filterArguments(java.lang.invoke.MethodHandle,int,java.lang.invoke.MethodHandle...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>filterArguments</h4> <pre class="methodSignature">public static&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;filterArguments​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                           int&nbsp;pos,
                                           <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>...&nbsp;filters)</pre> 
            <div class="block"> 
             <span>通过预处理一个或多个参数来调整目标方法句柄，每个参数都有自己的一元过滤函数，然后调用目标，每个预处理参数替换为其相应过滤函数的结果。</span> 
             <p> <span>预处理由<code>filters</code>数组的元素中指定的一个或多个方法句柄执行。</span> <span>过滤器数组的第一个元素对应于目标的<code>pos</code>参数，依此类推。</span> <span>过滤器函数按从左到右的顺序调用。</span> </p> 
             <p> <span>数组中的空参数被视为标识函数，相应的参数保持不变。</span> <span>（如果数组中没有非null元素，则返回原始目标。）每个过滤器都应用于适配器的相应参数。</span> </p> 
             <p> <span>如果过滤器<code>F</code>适用于目标的<code>N</code>参数，则<code>F</code>必须是一个只接受一个参数的方法句柄。</span> <span><code>F</code>的唯一参数类型替换了生成的自适应方法句柄中目标的相应参数类型。</span> <span>返回类型<code>F</code>必须与目标的相应参数类型相同。</span> </p> 
             <p> <span>如果有<code>filters</code> （null或not）的元素与目标中的参数位置不对应，则会出错。</span> </p> 
             <p> <span><b>例：</b></span> </p> 
             <blockquote> 
              <span><pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle cat = lookup().findVirtual(String.class,
  "concat", methodType(String.class, String.class));
MethodHandle upcase = lookup().findVirtual(String.class,
  "toUpperCase", methodType(String.class));
assertEquals("xy", (String) cat.invokeExact("x", "y"));
MethodHandle f0 = filterArguments(cat, 0, upcase);
assertEquals("Xy", (String) f0.invokeExact("x", "y")); // Xy
MethodHandle f1 = filterArguments(cat, 1, upcase);
assertEquals("xY", (String) f1.invokeExact("x", "y")); // xY
MethodHandle f2 = filterArguments(cat, 0, upcase, upcase);
assertEquals("XY", (String) f2.invokeExact("x", "y")); // XY
 </code></pre></span> 
             </blockquote> 
             <p> <span>这是生成的适配器的伪代码。</span> <span>在代码中， <code>T</code>表示<code>target</code>和生成的适配器的返回类型。</span> <span><code>P</code> / <code>p</code>和<code>B</code> / <code>b</code>表示之前和之后过滤器位置的参数和变量的类型和值<code>pos</code> ，分别。</span> <span><code>A[i]</code> / <code>a[i]</code>代表经滤波的参数和参数的类型和值;</span> <span>它们还代表<code>filter[i]</code>句柄的返回类型。</span> <span>后者接受参数<code>v[i]</code>类型的<code>V[i]</code> ，这也出现在最终的适配器的签名。</span> </p> 
             <blockquote> 
              <span><pre><code>
 T target(P... p, A[i]... a[i], B... b);
 A[i] filter[i](V[i]);
 T adapter(P... p, V[i]... v[i], B... b) {
   return target(p..., filter[i](v[i])..., b...);
 }
 </code></pre></span> 
             </blockquote> 
             <p> <span><em>注意：</em>生成的适配器永远不会是<a href="MethodHandle.html#asVarargsCollector(java.lang.Class)">variable-arity method handle</a> ，即使原始目标方法句柄是。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>target</code> - 过滤参数后调用的方法句柄 
             </dd> 
             <dd> 
              <code>pos</code> - 要过滤的第一个参数的位置 
             </dd> 
             <dd> 
              <code>filters</code> - 最初在筛选参数上调用的方法句柄 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               方法句柄，它包含指定的参数过滤逻辑 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果目标为null或 
              <code>filters</code>数组为null 
             </dd> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果非空元件 
              <code>filters</code>如上所述不匹配目标的对应的参数类型，或者如果 
              <code>pos+filters.length</code>大于 
              <code>target.type().parameterCount()</code> ，或者如果产生的方法手柄的类型将具有 
              <a href="MethodHandle.html#maxarity">too many parameters</a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="collectArguments(java.lang.invoke.MethodHandle,int,java.lang.invoke.MethodHandle)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>collectArguments</h4> <pre class="methodSignature">public static&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;collectArguments​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                            int&nbsp;pos,
                                            <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;filter)</pre> 
            <div class="block"> 
             <span>通过使用过滤器（另一个方法句柄）预处理其参数的子序列来调整目标方法句柄。</span> 
             <span>预处理的参数由过滤函数的结果（如果有）替换。</span> 
             <span>然后在修改的（通常缩短的）参数列表上调用目标。</span> 
             <p> <span>如果过滤器返回一个值，则目标必须接受该值作为其位置<code>pos</code>参数，前面和/或后面跟未传递给过滤器的任何参数。</span> <span>如果过滤器返回void，则目标必须接受未传递给过滤器的所有参数。</span> <span>没有参数被重新排序，并且从过滤器返回的结果替换（按顺序）最初传递给适配器的参数的整个子序列。</span> </p> 
             <p> <span>过滤器的参数类型（如果有）在生成的自适应方法句柄中的位置<code>pos</code>处替换目标的零个或一个参数类型。</span> <span>过滤器的返回类型（如果有）必须与位置<code>pos</code>处的目标的参数类型相同，并且该目标参数由过滤器的返回值提供。</span> </p> 
             <p> <span>在所有情况下， <code>pos</code>必须大于或等于零，并且<code>pos</code>也必须小于或等于目标的arity。</span> </p> 
             <p> <span><b>例：</b></span> </p> 
             <blockquote> 
              <span><pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle deepToString = publicLookup()
  .findStatic(Arrays.class, "deepToString", methodType(String.class, Object[].class));

MethodHandle ts1 = deepToString.asCollector(String[].class, 1);
assertEquals("[strange]", (String) ts1.invokeExact("strange"));

MethodHandle ts2 = deepToString.asCollector(String[].class, 2);
assertEquals("[up, down]", (String) ts2.invokeExact("up", "down"));

MethodHandle ts3 = deepToString.asCollector(String[].class, 3);
MethodHandle ts3_ts2 = collectArguments(ts3, 1, ts2);
assertEquals("[top, [up, down], strange]",
             (String) ts3_ts2.invokeExact("top", "up", "down", "strange"));

MethodHandle ts3_ts2_ts1 = collectArguments(ts3_ts2, 3, ts1);
assertEquals("[top, [up, down], [strange]]",
             (String) ts3_ts2_ts1.invokeExact("top", "up", "down", "strange"));

MethodHandle ts3_ts2_ts3 = collectArguments(ts3_ts2, 1, ts3);
assertEquals("[top, [[up, down, strange], charm], bottom]",
             (String) ts3_ts2_ts3.invokeExact("top", "up", "down", "strange", "charm", "bottom"));
 </code></pre></span> 
             </blockquote> 
             <p> <span>这是生成的适配器的伪代码。</span> <span>在代码中， <code>T</code>表示<code>target</code>及生成的适配器的返回类型。</span> <span><code>V</code> / <code>v</code>代表的的返回类型和值<code>filter</code> ，它们也在的签名和参数发现<code>target</code>分别，除非<code>V</code>是<code>void</code> 。</span> <span><code>A</code> / <code>a</code>和<code>C</code> / <code>c</code>代表参数的类型和值之前和之后的收集位置， <code>pos</code> ，在<code>target</code>的签名。</span> <span>他们所得到的适配器的签名和论据，在那里他们还围绕转动起来<code>B</code> / <code>b</code> ，它代表的参数类型和参数到<code>filter</code> （如果有的话）。</span> </p> 
             <blockquote> 
              <span><pre><code>
 T target(A...,V,C...);
 V filter(B...);
 T adapter(A... a,B... b,C... c) {
   V v = filter(b...);
   return target(a...,v,c...);
 }
 // and if the filter has no arguments:
 T target2(A...,V,C...);
 V filter2();
 T adapter2(A... a,C... c) {
   V v = filter2();
   return target2(a...,v,c...);
 }
 // and if the filter has a void return:
 T target3(A...,C...);
 void filter3(B...);
 T adapter3(A... a,B... b,C... c) {
   filter3(b...);
   return target3(a...,c...);
 }
 </code></pre></span> 
             </blockquote> 
             <p> <span>集合适配器<code>collectArguments(mh, 0, coll)</code>等同于首先“折叠”受影响的参数，然后将其删除，如下所示：</span> </p> 
             <blockquote> 
              <span><pre><code>
 mh = MethodHandles.dropArguments(mh, 1, coll.type().parameterList()); //step 2
 mh = MethodHandles.foldArguments(mh, coll); //step 1
 </code></pre></span> 
             </blockquote> 
             <span>如果目标方法句柄除了过滤器<code>coll</code>的结果（如果有）之外不使用任何参数，则<code>collectArguments(mh, 0, coll)</code>等效于<code>filterReturnValue(coll, mh)</code> 。</span> 
             <span>如果过滤器方法句柄<code>coll</code>一个参数并产生非void结果，则<code>collectArguments(mh, N, coll)</code>等效于<code>filterArguments(mh, N, coll)</code> 。</span> 
             <span>其他等价是可能的，但需要参数置换。</span> 
             <p> <span><em>注意：</em>生成的适配器永远不会是<a href="MethodHandle.html#asVarargsCollector(java.lang.Class)">variable-arity method handle</a> ，即使原始目标方法句柄是。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>target</code> - 过滤参数子序列后调用的方法句柄 
             </dd> 
             <dd> 
              <code>pos</code> - 要传递给过滤器的第一个适配器参数的位置，和/或接收过滤器结果的目标参数 
             </dd> 
             <dd> 
              <code>filter</code> - 调用参数子序列的方法句柄 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               方法句柄，它包含指定的参数子序列过滤逻辑 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任一参数为null 
             </dd> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果返回类型 
              <code>filter</code>是非void且与目标的 
              <code>pos</code>参数不同，或者 
              <code>pos</code>不在0和目标的arity之间（包括），或者结果方法句柄的类型将具有 
              <a href="MethodHandle.html#maxarity">too many parameters</a> 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#foldArguments(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)"><code>foldArguments(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle)</code></a> ， 
              <a href="#filterArguments(java.lang.invoke.MethodHandle,int,java.lang.invoke.MethodHandle...)"><code>filterArguments(java.lang.invoke.MethodHandle, int, java.lang.invoke.MethodHandle...)</code></a> ， 
              <a href="#filterReturnValue(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)"><code>filterReturnValue(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="filterReturnValue(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>filterReturnValue</h4> <pre class="methodSignature">public static&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;filterReturnValue​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                             <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;filter)</pre> 
            <div class="block"> 
             <span>通过使用过滤器（另一个方法句柄）对其返回值（如果有）进行后处理来调整目标方法句柄。</span> 
             <span>过滤器的结果从适配器返回。</span> 
             <p> <span>如果目标返回值，则过滤器必须接受该值作为其唯一参数。</span> <span>如果目标返回void，则过滤器必须不接受任何参数。</span> </p> 
             <p> <span>过滤器的返回类型替换了生成的自适应方法句柄中的目标的返回类型。</span> <span>过滤器的参数类型（如果有）必须与目标的返回类型相同。</span> </p> 
             <p> <span><b>例：</b></span> </p> 
             <blockquote> 
              <span><pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle cat = lookup().findVirtual(String.class,
  "concat", methodType(String.class, String.class));
MethodHandle length = lookup().findVirtual(String.class,
  "length", methodType(int.class));
System.out.println((String) cat.invokeExact("x", "y")); // xy
MethodHandle f0 = filterReturnValue(cat, length);
System.out.println((int) f0.invokeExact("x", "y")); // 2
 </code></pre></span> 
             </blockquote> 
             <p> <span>这是生成的适配器的伪代码。</span> <span>中的代码， <code>T</code> / <code>t</code>表示的结果类型和值<code>target</code> ;</span> <span><code>V</code> ，结果类型为<code>filter</code> ;</span> <span>和<code>A</code> / <code>a</code> ，类型和所述参数和所述参数的值<code>target</code>以及所得到的适配器。</span> </p> 
             <blockquote> 
              <span><pre><code>
 T target(A...);
 V filter(T);
 V adapter(A... a) {
   T t = target(a...);
   return filter(t);
 }
 // and if the target has a void return:
 void target2(A...);
 V filter2();
 V adapter2(A... a) {
   target2(a...);
   return filter2();
 }
 // and if the filter has a void return:
 T target3(A...);
 void filter3(V);
 void adapter3(A... a) {
   T t = target3(a...);
   filter3(t);
 }
 </code></pre></span> 
             </blockquote> 
             <p> <span><em>注意：</em>生成的适配器永远不会是<a href="MethodHandle.html#asVarargsCollector(java.lang.Class)">variable-arity method handle</a> ，即使原始目标方法句柄是。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>target</code> - 在过滤返回值之前调用的方法句柄 
             </dd> 
             <dd> 
              <code>filter</code> - 调用返回值的方法句柄 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               方法句柄，它包含指定的返回值过滤逻辑 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任一参数为null 
             </dd> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果参数列表 
              <code>filter</code>与目标的返回类型不匹配，如上所述 
             </dd> 
            </dl> </li> 
          </ul> <a id="foldArguments(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>foldArguments</h4> <pre class="methodSignature">public static&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;foldArguments​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                         <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;combiner)</pre> 
            <div class="block"> 
             <span>通过预处理其某些参数来调整目标方法句柄，然后使用预处理的结果调用目标，并将其插入到原始参数序列中。</span> 
             <p> <span>预处理由第二个方法句柄<code>combiner</code>执行。</span> <span>在传递给适配器的参数中，第一个<code>N</code>参数被复制到组合器，然后被调用。</span> <span>（此处， <code>N</code>被定义为组合器的参数计数。）此后，控制传递给目标，在原始<code>N</code>传入参数之前插入组合器的任何结果。</span> </p> 
             <p> <span>如果组合器返回一个值，则目标的第一个参数类型必须与组合器的返回类型相同，并且目标的下一个<code>N</code>参数类型必须与组合器的参数完全匹配。</span> </p> 
             <p> <span>如果组合<code>N</code>返回，则不会插入任何结果，并且目标的第一个<code>N</code>参数类型必须与组合器的参数完全匹配。</span> </p> 
             <p> <span>生成的适配器与目标类型相同，除了第一个参数类型被删除，如果它对应于组合器的结果。</span> </p> 
             <p> <span>（注意， <a href="#dropArguments(java.lang.invoke.MethodHandle,int,java.util.List)"><code>dropArguments</code></a>可用于删除组合器或目标不希望接收的任何参数。如果某些传入参数仅用于组合器，请考虑使用<a href="MethodHandle.html#asCollector(java.lang.Class,int)"><code>asCollector</code></a> ，因为这些参数不需要是在进入目标时生活在堆栈上。）</span> </p> 
             <p> <span><b>例：</b></span> </p> 
             <blockquote> 
              <span><pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle trace = publicLookup().findVirtual(java.io.PrintStream.class,
  "println", methodType(void.class, String.class))
    .bindTo(System.out);
MethodHandle cat = lookup().findVirtual(String.class,
  "concat", methodType(String.class, String.class));
assertEquals("boojum", (String) cat.invokeExact("boo", "jum"));
MethodHandle catTrace = foldArguments(cat, trace);
// also prints "boo":
assertEquals("boojum", (String) catTrace.invokeExact("boo", "jum"));
 </code></pre></span> 
             </blockquote> 
             <p> <span>这是生成的适配器的伪代码。</span> <span>在代码中， <code>T</code>表示<code>target</code>及生成的适配器的结果类型。</span> <span><code>V</code> / <code>v</code>代表类型和所述参数和参数的值<code>target</code>先于折叠位置;</span> <span><code>V</code>也就是结果类型<code>combiner</code> 。</span> <span><code>A</code> / <code>a</code>表示的类型和值<code>N</code>参数和变量在折叠位置。</span> <span><code>B</code> / <code>b</code>表示的类型和值<code>target</code>参数和变量的随后的折叠参数和参数。</span> </p> 
             <blockquote> 
              <span><pre><code>
 // there are N arguments in A...
 T target(V, A[N]..., B...);
 V combiner(A...);
 T adapter(A... a, B... b) {
   V v = combiner(a...);
   return target(v, a..., b...);
 }
 // and if the combiner has a void return:
 T target2(A[N]..., B...);
 void combiner2(A...);
 T adapter2(A... a, B... b) {
   combiner2(a...);
   return target2(a..., b...);
 }
 </code></pre></span> 
             </blockquote> 
             <p> <span><em>注意：</em>生成的适配器永远不会是<a href="MethodHandle.html#asVarargsCollector(java.lang.Class)">variable-arity method handle</a> ，即使原始目标方法句柄是。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>target</code> - 组合参数后调用的方法句柄 
             </dd> 
             <dd> 
              <code>combiner</code> - 最初在传入参数上调用的方法句柄 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               包含指定参数折叠逻辑的方法句柄 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任一参数为null 
             </dd> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
              <code>combiner</code>的返回类型为非void且与目标的第一个参数类型不同，或者目标的初始 
              <code>N</code>参数类型（跳过与 
              <code>combiner</code>的返回类型匹配的 
              <code>combiner</code> ）与参数类型为 
              <code>combiner</code> 
             </dd> 
            </dl> </li> 
          </ul> <a id="foldArguments(java.lang.invoke.MethodHandle,int,java.lang.invoke.MethodHandle)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>foldArguments</h4> <pre class="methodSignature">public static&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;foldArguments​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                         int&nbsp;pos,
                                         <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;combiner)</pre> 
            <div class="block"> 
             <span>通过预处理某些参数来调整目标方法句柄，从给定位置开始，然后使用预处理的结果调用目标，插入到折叠参数之前的原始参数序列中。</span> 
             <p> <span>此方法与<a href="#foldArguments(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)"><code>foldArguments(MethodHandle, MethodHandle)</code></a>密切相关，但允许控制参数列表中发生折叠的位置。</span> <span>控制它的参数<code>pos</code>是一个从零开始的索引。</span> <span>上述方法<a href="#foldArguments(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)"><code>foldArguments(MethodHandle, MethodHandle)</code></a>假定位置0。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>例：</span> 
              <blockquote> 
               <span><pre><code>
    import static java.lang.invoke.MethodHandles.*;
    import static java.lang.invoke.MethodType.*;
    ...
    MethodHandle trace = publicLookup().findVirtual(java.io.PrintStream.class,
    "println", methodType(void.class, String.class))
    .bindTo(System.out);
    MethodHandle cat = lookup().findVirtual(String.class,
    "concat", methodType(String.class, String.class));
    assertEquals("boojum", (String) cat.invokeExact("boo", "jum"));
    MethodHandle catTrace = foldArguments(cat, 1, trace);
    // also prints "jum":
    assertEquals("boojum", (String) catTrace.invokeExact("boo", "jum"));
 </code></pre></span> 
              </blockquote> 
              <p> <span>这是生成的适配器的伪代码。</span> <span>在代码中， <code>T</code>表示<code>target</code>及生成的适配器的结果类型。</span> <span><code>V</code> / <code>v</code>代表类型和所述参数和参数的值<code>target</code>先于折叠位置;</span> <span><code>V</code>也就是结果类型<code>combiner</code> 。</span> <span><code>A</code> / <code>a</code>表示的类型和值<code>N</code>参数和变量在折叠位置。</span> <span><code>Z</code> / <code>z</code>和<code>B</code> / <code>b</code>表示的类型和值<code>target</code>参数和自变量之前和之后的折叠参数和自变量开始<code>pos</code>分别。</span> </p> 
              <blockquote> 
               <span><pre><code>
 // there are N arguments in A...
 T target(Z..., V, A[N]..., B...);
 V combiner(A...);
 T adapter(Z... z, A... a, B... b) {
   V v = combiner(a...);
   return target(z..., v, a..., b...);
 }
 // and if the combiner has a void return:
 T target2(Z..., A[N]..., B...);
 void combiner2(A...);
 T adapter2(Z... z, A... a, B... b) {
   combiner2(a...);
   return target2(z..., a..., b...);
 }
 </code></pre></span> 
              </blockquote> 
              <p> <span><em>注意：</em>生成的适配器永远不会是<a href="MethodHandle.html#asVarargsCollector(java.lang.Class)">variable-arity method handle</a> ，即使原始目标方法句柄是。</span> </p> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>target</code> - 组合参数后调用的方法句柄 
             </dd> 
             <dd> 
              <span><code>pos</code> - 开始折叠的位置以及插入折叠结果的位置;</span> 
              <span>如果这是<code>0</code> ，则效果与<a href="#foldArguments(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)"><code>foldArguments(MethodHandle, MethodHandle)</code></a>相同。</span> 
             </dd> 
             <dd> 
              <code>combiner</code> - 最初在传入参数上调用的方法句柄 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               包含指定参数折叠逻辑的方法句柄 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任一参数为null 
             </dd> 
             <dd> 
              <span><code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果满足以下两个条件成立：（1） <code>combiner</code>的返回类型是非<code>void</code>和不一样在位置参数类型<code>pos</code>目标签名的;</span> 
              <span>（2）目标签名位置<code>pos</code>处的<code>N</code>参数类型（跳过与<code>combiner</code>的返回类型匹配的一个）与参数类型<code>combiner</code> 。</span> 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#foldArguments(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)"><code>foldArguments(MethodHandle, MethodHandle)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="guardWithTest(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>guardWithTest</h4> <pre class="methodSignature">public static&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;guardWithTest​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;test,
                                         <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                         <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;fallback)</pre> 
            <div class="block"> 
             <span>通过使用测试，布尔值方法句柄来保护目标方法句柄，使其适应目标方法句柄。</span> 
             <span>如果防护失败，则调用后备句柄。</span> 
             <span>除了测试的返回类型必须是boolean之外，所有三个方法句柄必须具有相同的对应参数和返回类型，并且允许测试具有比其他两个方法句柄更少的参数。</span> 
             <p> <span>这是生成的适配器的伪代码。</span> <span>在代码中， <code>T</code>表示三个涉及句柄的统一结果类型;</span> <span><code>A</code> / <code>a</code> ，类型和值<code>target</code>参数和参数是由消耗<code>test</code> ;</span> <span>和<code>B</code> / <code>b</code> ，这些类型和值<code>target</code>参数和自变量不是由消耗<code>test</code> 。</span> </p> 
             <blockquote> 
              <span><pre><code>
 boolean test(A...);
 T target(A...,B...);
 T fallback(A...,B...);
 T adapter(A... a,B... b) {
   if (test(a...))
     return target(a..., b...);
   else
     return fallback(a..., b...);
 }
 </code></pre></span> 
             </blockquote> 
             <span>请注意，测试参数（伪代码中的<code>a...</code> ）不能通过执行测试来修改，因此会根据需要从调用者传递到目标或回退。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>test</code> - 用于测试的方法句柄，必须返回boolean 
             </dd> 
             <dd> 
              <code>target</code> - 测试通过时调用的方法句柄 
             </dd> 
             <dd> 
              <code>fallback</code> - 如果测试失败则调用的方法句柄 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               方法句柄，它包含指定的if / then / else逻辑 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任何参数为null 
             </dd> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
              <code>test</code>未返回布尔值，或者所有三种方法类型都不匹配（返回类型 
              <code>test</code>更改为与目标的匹配）。 
             </dd> 
            </dl> </li> 
          </ul> <a id="catchException(java.lang.invoke.MethodHandle,java.lang.Class,java.lang.invoke.MethodHandle)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>catchException</h4> <pre class="methodSignature">public static&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;catchException​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                          <a href="../Class.html" title="class in java.lang">类</a>&lt;? extends <a href="../Throwable.html" title="class in java.lang">Throwable</a>&gt;&nbsp;exType,
                                          <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;handler)</pre> 
            <div class="block"> 
             <span>通过在异常处理程序中运行，使方法句柄适应目标方法句柄。</span> 
             <span>如果目标正常返回，则适配器返回该值。</span> 
             <span>如果抛出与指定类型匹配的异常，则会在异常和原始参数上调用回退句柄。</span> 
             <p> <span>目标和处理程序必须具有相同的对应参数和返回类型，但处理程序可能省略尾随参数（类似于<a href="#guardWithTest(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)"><code>guardWithTest</code>中</a>的谓词）。</span> <span>此外，处理程序必须具有额外的前导参数<code>exType</code>或超类型。</span> </p> 
             <p> <span>这是生成的适配器的伪代码。</span> <span>在代码中， <code>T</code>表示<code>target</code>和<code>handler</code>的返回类型，并且相应地生成适配器的返回类型;</span> <span><code>A</code> / <code>a</code> ，类型和参数，以通过所消耗的所得句柄值<code>handler</code> ;</span> <span>和<code>B</code> / <code>b</code> ，那些参数，以通过丢弃所产生的手柄<code>handler</code> 。</span> </p> 
             <blockquote> 
              <span><pre><code>
 T target(A..., B...);
 T handler(ExType, A...);
 T adapter(A... a, B... b) {
   try {
     return target(a..., b...);
   } catch (ExType ex) {
     return handler(ex, a...);
   }
 }
 </code></pre></span> 
             </blockquote> 
             <span>请注意，保存的参数（伪代码中的<code>a...</code> ）无法通过执行目标来修改，因此如果调用处理程序，则会从调用方传递给处理程序。</span> 
             <p> <span>目标和处理程序必须返回相同的类型，即使处理程序始终抛出也是如此。</span> <span>（例如，这可能发生，因为处理程序正在模拟<code>finally</code>子句）。</span> <span>要创建这样的抛出处理程序，请使用<a href="#throwException(java.lang.Class,java.lang.Class)"><code>throwException</code></a>组成处理程序创建逻辑，以便创建正确返回类型的方法句柄。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>target</code> - 要调用的方法句柄 
             </dd> 
             <dd> 
              <code>exType</code> - 处理程序将捕获的异常类型 
             </dd> 
             <dd> 
              <code>handler</code> - 如果抛出匹配的异常，则调用的方法句柄 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               包含指定的try / catch逻辑的方法句柄 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任何参数为null 
             </dd> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
              <code>handler</code>不接受给定的异常类型，或者方法句柄类型的返回类型及其相应参数不匹配 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#tryFinally(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)"><code>tryFinally(MethodHandle, MethodHandle)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="throwException(java.lang.Class,java.lang.Class)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>throwException</h4> <pre class="methodSignature">public static&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;throwException​(<a href="../Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;returnType,
                                          <a href="../Class.html" title="class in java.lang">类</a>&lt;? extends <a href="../Throwable.html" title="class in java.lang">Throwable</a>&gt;&nbsp;exType)</pre> 
            <div class="block"> 
             <span>生成一个方法句柄，它会抛出给定的<code>exType</code>异常。</span> 
             <span>方法句柄将接受<code>exType</code>的单个参数，并立即将其作为异常抛出。</span> 
             <span>方法类型名义上将指定返回<code>returnType</code> 。</span> 
             <span>返回类型可能是方便的：它与方法句柄的行为无关，因为它永远不会正常返回。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>returnType</code> - 所需方法句柄的返回类型 
             </dd> 
             <dd> 
              <code>exType</code> - 所需方法句柄的参数类型 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               方法句柄，可以抛出给定的异常 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任一参数为null 
             </dd> 
            </dl> </li> 
          </ul> <a id="loop(java.lang.invoke.MethodHandle[]...)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>loop</h4> <pre class="methodSignature">public static&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;loop​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>[]...&nbsp;clauses)</pre> 
            <div class="block"> 
             <span>构造一个表示循环的方法句柄，该循环具有多个循环变量，每次迭代时都会更新和检查这些变量。</span> 
             <span>在由于其中一个谓词而终止循环时，运行相应的终结器并传递循环结果，该结果是结果句柄的返回值。</span> 
             <p> <span>直观地，每个循环由一个或多个“子句”形成，每个“子句”指定局部<em>迭代变量</em>和/或循环出口。</span> <span>循环的每次迭代按顺序执行每个子句。</span> <span>子句可以选择更新其迭代变量;</span> <span>它还可以选择执行测试和条件循环退出。</span> <span>为了根据方法句柄表达这个逻辑，每个子句将指定最多四个独立的动作：</span> </p> 
             <ul> 
              <li> <span><em>初始化：</em>在循环执行之前，一个迭代变量的初始化<code>v</code>类型的<code>V</code> 。</span> </li> 
              <li> <span><em>step：</em>当子句执行时，迭代变量<code>v</code>的更新步骤。</span> </li> 
              <li> <span><em>pred：</em>当子句执行时，执行谓词执行以测试循环退出。</span> </li> 
              <li> <span><em>fini：</em>如果一个子句导致循环退出，则终结器执行以计算循环的返回值。</span> </li> 
             </ul> 
             <span>按子句顺序排列的所有迭代变量类型的完整序列将标记为<code>(V...)</code> 。</span> 
             <span>值本身将是<code>(v...)</code> 。</span> 
             <span>当我们谈到“参数列表”时，我们通常会引用类型，但在某些情况下（描述执行），列表将具有实际值。</span> 
             <p> <span>根据某些规则可以省略这些子句中的一些部分，并且在这种情况下提供有用的默认行为。</span> <span>请参阅下面的详细说明。</span> </p> 
             <p> <span><em>参数可选无处不在：</em>允许每个子句函数但不需要接受每个迭代变量<code>v</code>的参数。</span> <span>作为例外，init函数不能采用任何<code>v</code>参数，因为执行init函数时尚未计算这些值。</span> <span>任何子句函数都可以忽略采用它有权采用的参数的任何尾随子序列。</span> <span>实际上，任何子句函数都可以完全不参数。</span> </p> 
             <p> <span><em>循环参数：</em>子句函数可以获取它有权获得的所有迭代变量值，在这种情况下，它也可能需要更多的尾随参数。</span> <span>这些额外值称为<em>循环参数</em> ，其类型和值标记为<code>(A...)</code>和<code>(a...)</code> 。</span> <span>这些成为生成的循环句柄的参数，在执行循环时提供。</span> <span>（由于init函数不接受迭代变量<code>v</code> ，因此init函数的任何参数都自动为循环参数<code>a</code> ）与迭代变量一样，允许子句函数但不需要接受循环参数。</span> <span>这些循环参数充当整个循环中可见的循环不变值。</span> </p> 
             <p> <span><em>在任何地方</em>都<em>可见的参数：</em>允许每个非init子句函数观察整个循环状态，因为它可以传递当前迭代变量值和传入循环参数的完整列表<code>(v... a...)</code> 。</span> <span>init函数可以以<code>(a...)</code>的形式观察初始预循环状态。</span> <span>大多数子句函数不需要所有这些信息，但它们将正式连接到它，就像<a href="#dropArguments(java.lang.invoke.MethodHandle,int,java.util.List)"><code>dropArguments(java.lang.invoke.MethodHandle, int, java.util.List&lt;java.lang.Class&lt;?&gt;&gt;)</code>一样</a> 。</span> <span><a id="astar"></a>更具体地说，我们将使用符号<code>(V*)</code>来表达一个完整序列的任意前缀<code>(V...)</code> （且同样<code>(v*)</code> ， <code>(A*)</code> ， <code>(a*)</code> ）。</span> <span>在该表示法中，init函数参数列表的一般形式是<code>(A*)</code> ，非初始函数参数列表的一般形式是<code>(V*)</code>或<code>(V... A*)</code> 。</span> </p> 
             <p> <span><em>检查子句结构：</em>给定一组子句，执行了许多检查和调整以连接循环的所有部分。</span> <span>它们在下面的步骤中详细说明。</span> <span>在这些步骤中，如果循环组合器的输入未满足所需的约束，则“必须”一词的每次出现都对应于将抛出<a href="../IllegalArgumentException.html" title="java.lang中的类"><code>IllegalArgumentException</code></a>的位置。</span> </p> 
             <p> <span><em>有效相同的序列：</em> <a id="effid"></a>如果<code>A</code>和<code>B</code>相同，或者如果<code>A</code>较短并且与正确的前缀<code>B</code>相同，则参数列表<code>A</code>被定义为<em>与</em>另一个参数列表<code>B</code> <em>有效相同</em> 。</span> <span>当谈到一组无序的参数列表时，我们说如果集合包含最长的列表，则集合“整体上是完全相同的”，并且集合的所有成员实际上与该最长列表相同。</span> <span>例如， <code>(V*)</code>形式的任何一组类型序列<code>(V*)</code>是相同的，并且如果添加<code>(V... A*)</code>形式的更多序列，则同样如此。</span> </p> 
             <p> <span><em>第0步：确定子句结构。</em></span> </p> 
             <ol type="a"> 
              <li> <span>子句数组（类型<code>MethodHandle[][]</code> ）必须为非<code>null</code>且至少包含一个元素。</span> </li> 
              <li> <span>子句数组可能不包含<code>null</code>或超过四个元素的子数组。</span> </li> 
              <li> <span>短于四个元素的条款被视为由<code>null</code>元素填充到长度为4的元素。</span> <span>通过将元素附加到数组来进行填充。</span> </li> 
              <li> <span>所有<code>null</code>的条款均被忽略。</span> </li> 
              <li> <span>每个子句被视为四元组函数，称为“init”，“step”，“pred”和“fini”。</span> </li> 
             </ol> 
             <p> <span><em>步骤1A：确定迭代变量类型<code>(V...)</code> 。</em></span> </p> 
             <ol type="a"> 
              <li> <span>每个子句的迭代变量类型使用子句的init和step返回类型来确定。</span> </li> 
              <li> <span>如果省略这两个函数，则没有相应子句的迭代变量（ <code>void</code>用作指示该类型的类型）。</span> <span>如果省略其中一个，则另一个的返回类型定义子句的迭代变量类型。</span> <span>如果两者都给出，则公共返回类型（它们必须相同）定义子句的迭代变量类型。</span> </li> 
              <li> <span>形成返回类型列表（按子句顺序），省略所有出现的<code>void</code> 。</span> </li> 
              <li> <span>此类型列表称为“迭代变量类型”（ <code>(V...)</code> ）。</span> </li> 
             </ol> 
             <p> <span><em>步骤1B：确定循环参数<code>(A...)</code> 。</em></span> </p> 
             <ul> 
              <li> <span>检查并收集init函数参数列表（格式为<code>(A*)</code> ）。</span> </li> 
              <li> <span>删除迭代变量类型后，检查并收集step，pred和fini参数列表的后缀。</span> <span>（它们的格式必须为<code>(V... A*)</code> ;仅收集<code>(A*)</code>部件。）</span> </li> 
              <li> <span>不要从step，pred和fini参数列表中收集不以所有迭代变量类型开头的后缀。</span> <span>（这些类型将在步骤2中与所有子句函数类型一起检查。）</span> </li> 
              <li> <span>省略了省略的子句函数。</span> <span>（等效地，它们被视为具有空参数列表。）</span> </li> 
              <li> <span>所有收集的参数列表必须完全相同。</span> </li> 
              <li> <span>最长的参数列表（必须是唯一的）称为“外部参数列表”（ <code>(A...)</code> ）。</span> </li> 
              <li> <span>如果没有这样的参数列表，则外部参数列表被视为空序列。</span> </li> 
              <li> <span>由迭代变量类型和外部参数类型组成的组合列表称为“内部参数列表”。</span> </li> 
             </ul> 
             <p> <span><em>步骤1C：确定循环返回类型。</em></span> </p> 
             <ol type="a"> 
              <li> <span>检查fini函数返回类型，忽略省略的fini函数。</span> </li> 
              <li> <span>如果没有fini函数，则循环返回类型为<code>void</code> 。</span> </li> 
              <li> <span>否则，fini函数的公共返回类型<code>R</code> （它们的返回类型必须相同）定义循环返回类型。</span> </li> 
             </ol> 
             <p> <span><em>步骤1D：检查其他类型。</em></span> </p> 
             <ol type="a"> 
              <li> <span>必须至少有一个未省略的pred函数。</span> </li> 
              <li> <span>每个未省略的pred函数必须具有<code>boolean</code>返回类型。</span> </li> 
             </ol> 
             <p> <span><em>第2步：确定参数列表。</em></span> </p> 
             <ol type="a"> 
              <li> <span>结果循环句柄的参数列表将是外部参数列表<code>(A...)</code> 。</span> </li> 
              <li> <span>init函数的参数列表将调整为外部参数列表。</span> <span>（请注意，它们的参数列表已经与此列表完全相同。）</span> </li> 
              <li> <span>每个非省略的非初始（step，pred和fini）函数的参数列表必须与内部参数列表<code>(V... A...)</code>有效相同。</span> </li> 
             </ol> 
             <p> <span><em>第3步：填写省略的功能。</em></span> </p> 
             <ol type="a"> 
              <li> <span>如果省略init函数，请使用<a href="#empty(java.lang.invoke.MethodType)">default value</a>作为子句的迭代变量类型。</span> </li> 
              <li> <span>如果省略步进函数，则使用子句的迭代变量类型的<a href="#identity(java.lang.Class)">identity function</a> ;</span> <span>在前面子句的非<code>void</code>迭代变量的identity function参数之前插入丢弃的参数参数。</span> <span>（这会将循环变量转换为本地循环不变量。）</span> </li> 
              <li> <span>如果省略pred函数，请使用常量<code>true</code>函数。</span> <span>（就这个子句而言，这将保持循环继续。请注意，在这种情况下，相应的fini函数是不可达的。）</span> </li> 
              <li> <span>如果省略fini函数，请使用<a href="#empty(java.lang.invoke.MethodType)">default value</a>作为循环返回类型。</span> </li> 
             </ol> 
             <p> <span><em>第4步：填写缺少的参数类型。</em></span> </p> 
             <ol type="a"> 
              <li> <span>此时，每个init函数参数列表实际上与外部参数列表<code>(A...)</code>相同，但某些列表可能更短。</span> <span>对于具有短参数列表的每个init函数，填充列表的末尾。</span> </li> 
              <li> <span>此时，每个非初始函数参数列表实际上与内部参数列表<code>(V... A...)</code>相同，但某些列表可能更短。</span> <span>对于具有短参数列表的每个非初始化函数，填充列表的末尾。</span> </li> 
              <li> <span>参数列表由<a href="#dropArgumentsToMatch(java.lang.invoke.MethodHandle,int,java.util.List,int)">dropping unused trailing arguments</a>填充。</span> </li> 
             </ol> 
             <p> <span><em>最后的观察。</em></span> </p> 
             <ol type="a"> 
              <li> <span>完成这些步骤后，所有子句都通过提供省略的函数和参数进行了调整。</span> </li> 
              <li> <span>所有init函数都有一个共同的参数类型列表<code>(A...)</code> ，最终的循环句柄也将具有。</span> </li> 
              <li> <span>所有fini函数都有一个共同的返回类型<code>R</code> ，最终的循环句柄也将具有。</span> </li> 
              <li> <span>所有非初始函数具有公共参数类型列表<code>(V... A...)</code> ，（非<code>void</code> ）迭代变量<code>V</code>其后是循环参数。</span> </li> 
              <li> <span>每对init和step函数在它们的返回类型<code>V</code> 。</span> </li> 
              <li> <span>每个非初始函数将能够观察所有迭代变量的当前值<code>(v...)</code> 。</span> </li> 
              <li> <span>每个函数都能够观察到所有循环参数的输入值<code>(a...)</code> 。</span> </li> 
             </ol> 
             <p> <span><em>例。</em></span> <span>作为上述步骤1A的结果， <code>loop</code>组合器具有以下属性：</span> </p> 
             <ul> 
              <li> <span>鉴于<code>N</code>条款<code>Cn = {null, Sn, Pn}</code>和<code>n = 1..N</code> 。</span> </li> 
              <li> <span>假设谓词句柄<code>Pn</code>是<code>null</code>或没有参数。</span> <span>（只有一个<code>Pn</code>必须是非<code>null</code> ）</span> </li> 
              <li> <span>假设步骤句柄<code>Sn</code>具有签名<code>(B1..BX)Rn</code> ，对于某些常数<code>X&gt;=N</code> 。</span> </li> 
              <li> <span>假设<code>Q</code>是非空类型<code>Rn</code>的计数，而<code>(V1...VQ)</code>是这些类型的序列。</span> </li> 
              <li> <span>它必须是<code>Vn == Bn</code>为<code>n = 1..min(X,Q)</code> 。</span> </li> 
              <li> <span>参数类型<code>Vn</code>将被解释为循环本地状态元素<code>(V...)</code> 。</span> </li> 
              <li> <span>任何剩余的类型<code>BQ+1..BX</code> （如果<code>Q&lt;X</code> ）将确定结果循环句柄的参数类型<code>(A...)</code> 。</span> </li> 
             </ul> 
             <span>在此示例中，循环句柄参数<code>(A...)</code>是从步骤函数派生的，如果大多数循环计算在步骤中发生，这是很自然的。</span> 
             <span>对于某些循环，计算负担在pred函数中可能最重，因此pred函数可能需要接受循环参数值。</span> 
             <span>对于具有复杂退出逻辑的循环，fini函数可能需要接受循环参数，同样对于具有复杂条目逻辑的循环，其中init函数将需要额外的参数。</span> 
             <span>由于这些原因，确定这些参数的规则在所有子句部分中尽可能对称。</span> 
             <span>通常，循环参数在整个循环中用作公共不变值，而迭代变量用作公共变量值，或者（如果没有步进函数）用作内部循环不变的临时值。</span> 
             <p> <span><em>循环执行。</em></span> </p> 
             <ol type="a"> 
              <li> <span>调用循环时，循环输入值将保存在本地，以传递给每个子句函数。</span> <span>这些本地人是循环不变的。</span> </li> 
              <li> <span>每个init函数按子句顺序执行（传递外部参数<code>(a...)</code> ），非<code>void</code>值保存（作为迭代变量<code>(v...)</code> ）到本地。</span> <span>这些局部变量将是循环变化的（除非它们的步骤表现为身份函数，如上所述）。</span> </li> 
              <li> <span>所有函数执行（init函数除外）都将传递内部参数列表，包括非<code>void</code>迭代值<code>(v...)</code> （按子句顺序），然后循环输入<code>(a...)</code> （按参数顺序）。</span> </li> 
              <li> <span>然后以子句顺序（在pred之前的步骤）执行step和pred函数，直到pred函数返回<code>false</code> 。</span> </li> 
              <li> <span>步进函数调用的非<code>void</code>结果用于更新循环变量序列<code>(v...)</code>中的相应值。</span> <span>所有后续函数调用都会立即看到更新后的值。</span> </li> 
              <li> <span>如果pred函数返回<code>false</code> ，则调用相应的fini函数，并从循环中返回结果值（类型为<code>R</code> ）。</span> </li> 
              <li> <span>如果所有pred函数总是返回true，则不会调用任何fini函数，并且除了抛出异常外，循环不能退出。</span> </li> 
             </ol> 
             <p> <span><em>使用提示。</em></span> </p> 
             <ul> 
              <li> <span>尽管每个步骤函数都将接收<em>所有</em>循环变量的当前值，但有时步进函数只需要观察其自身变量的当前值。</span> <span>在这种情况下，步骤函数可能需要明确<a href="#dropArguments(java.lang.invoke.MethodHandle,int,java.util.List)">drop all preceding loop variables</a> 。</span> <span>这需要在<code>dropArguments(step, 0, V0.class, ...)</code>类的表达式中提及它们的类型。</span> </li> 
              <li> <span>循环变量不需要变化;</span> <span>它们可以是循环不变的。</span> <span>子句可以通过合适的init函数创建循环不变量，而不使用step，pred或fini函数。</span> <span>这可能有助于将传入的循环参数“连接”到相邻循环变量的step或pred函数中。</span> </li> 
              <li> <span>如果某些子句函数是实例上的虚方法，则可以使用初始子句（如<code>new MethodHandle[]{identity(ObjType.class)}</code>将实例本身方便地放置在初始不变循环“变量”中。</span> <span>在这种情况下，实例引用将是第一个迭代变量值，并且很容易将虚方法用作子句部分，因为它们都将采用与该值匹配的前导实例引用。</span> </li> 
             </ul> 
             <p> <span>这是生成的循环句柄的伪代码。</span> <span>如上所述， <code>V</code>和<code>v</code>表示循环变量的类型和值;</span> <span><code>A</code>和<code>a</code>表示传递给整个循环的参数;</span> <span>和<code>R</code>是所有终结器的常见结果类型以及生成的循环。</span> </p> 
             <blockquote> 
              <span><pre><code>
 V... init...(A...);
 boolean pred...(V..., A...);
 V... step...(V..., A...);
 R fini...(V..., A...);
 R loop(A... a) {
   V... v... = init...(a...);
   for (;;) {
     for ((v, p, s, f) in (v..., pred..., step..., fini...)) {
       v = s(v..., a...);
       if (!p(v..., a...)) {
         return f(v..., a...);
       }
     }
   }
 }
 </code></pre></span> 
             </blockquote> 
             <span>请注意，参数类型列表<code>(V...)</code>和<code>(A...)</code>已经扩展到它们的全长，即使单个子句函数可能忽略了全部。</span> 
             <span>如上所述，缺少的参数如同<a href="#dropArgumentsToMatch(java.lang.invoke.MethodHandle,int,java.util.List,int)"><code>dropArgumentsToMatch(MethodHandle, int, List, int)</code>一样填写</a> 。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>例：</span> 
              <blockquote> 
               <span><pre><code>
 // iterative implementation of the factorial function as a loop handle
 static int one(int k) { return 1; }
 static int inc(int i, int acc, int k) { return i + 1; }
 static int mult(int i, int acc, int k) { return i * acc; }
 static boolean pred(int i, int acc, int k) { return i &lt; k; }
 static int fin(int i, int acc, int k) { return acc; }
 // assume MH_one, MH_inc, MH_mult, MH_pred, and MH_fin are handles to the above methods
 // null initializer for counter, should initialize to 0
 MethodHandle[] counterClause = new MethodHandle[]{null, MH_inc};
 MethodHandle[] accumulatorClause = new MethodHandle[]{MH_one, MH_mult, MH_pred, MH_fin};
 MethodHandle loop = MethodHandles.loop(counterClause, accumulatorClause);
 assertEquals(120, loop.invoke(5));
 </code></pre></span> 
              </blockquote> 
              <span>相同的例子，删除参数和使用组合器：</span> 
              <blockquote> 
               <span><pre><code>
 // simplified implementation of the factorial function as a loop handle
 static int inc(int i) { return i + 1; } // drop acc, k
 static int mult(int i, int acc) { return i * acc; } //drop k
 static boolean cmp(int i, int k) { return i &lt; k; }
 // assume MH_inc, MH_mult, and MH_cmp are handles to the above methods
 // null initializer for counter, should initialize to 0
 MethodHandle MH_one = MethodHandles.constant(int.class, 1);
 MethodHandle MH_pred = MethodHandles.dropArguments(MH_cmp, 1, int.class); // drop acc
 MethodHandle MH_fin = MethodHandles.dropArguments(MethodHandles.identity(int.class), 0, int.class); // drop i
 MethodHandle[] counterClause = new MethodHandle[]{null, MH_inc};
 MethodHandle[] accumulatorClause = new MethodHandle[]{MH_one, MH_mult, MH_pred, MH_fin};
 MethodHandle loop = MethodHandles.loop(counterClause, accumulatorClause);
 assertEquals(720, loop.invoke(6));
 </code></pre></span> 
              </blockquote> 
              <span>一个类似的例子，使用辅助对象来保存循环参数：</span> 
              <blockquote> 
               <span><pre><code>
 // instance-based implementation of the factorial function as a loop handle
 static class FacLoop {
   final int k;
   FacLoop(int k) { this.k = k; }
   int inc(int i) { return i + 1; }
   int mult(int i, int acc) { return i * acc; }
   boolean pred(int i) { return i &lt; k; }
   int fin(int i, int acc) { return acc; }
 }
 // assume MH_FacLoop is a handle to the constructor
 // assume MH_inc, MH_mult, MH_pred, and MH_fin are handles to the above methods
 // null initializer for counter, should initialize to 0
 MethodHandle MH_one = MethodHandles.constant(int.class, 1);
 MethodHandle[] instanceClause = new MethodHandle[]{MH_FacLoop};
 MethodHandle[] counterClause = new MethodHandle[]{null, MH_inc};
 MethodHandle[] accumulatorClause = new MethodHandle[]{MH_one, MH_mult, MH_pred, MH_fin};
 MethodHandle loop = MethodHandles.loop(instanceClause, counterClause, accumulatorClause);
 assertEquals(5040, loop.invoke(7));
 </code></pre></span> 
              </blockquote> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <span><code>clauses</code> - 符合上述规则的<a href="MethodHandle.html" title="java.lang.invoke中的类"><code>MethodHandle</code></a>的阵列（4元组）阵列。</span> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个方法句柄，体现了由参数定义的循环行为。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果违反了上述任何约束。 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#whileLoop(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)"><code>whileLoop(MethodHandle, MethodHandle, MethodHandle)</code></a> ， 
              <a href="#doWhileLoop(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)"><code>doWhileLoop(MethodHandle, MethodHandle, MethodHandle)</code></a> ， 
              <a href="#countedLoop(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)"><code>countedLoop(MethodHandle, MethodHandle, MethodHandle)</code></a> ， 
              <a href="#iteratedLoop(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)"><code>iteratedLoop(MethodHandle, MethodHandle, MethodHandle)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="whileLoop(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>whileLoop</h4> <pre class="methodSignature">public static&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;whileLoop​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;init,
                                     <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;pred,
                                     <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;body)</pre> 
            <div class="block"> 
             <span>从初始值设定项，正文和谓词构造一个<code>while</code>循环。</span> 
             <span>这是<a href="#loop(java.lang.invoke.MethodHandle%5B%5D...)">generic loop combinator</a>的便利包装。</span> 
             <p> <span><code>pred</code>句柄描述了循环条件;</span> <span>和它的身体<code>body</code> 。</span> <span>在每次迭代中，由此方法产生的循环将首先评估谓词，然后执行其主体（如果谓词的计算结果为<code>true</code> ）。</span> <span>一旦谓词的计算结果为<code>false</code> （在这种情况下不会执行正文），循环将终止。</span> </p> 
             <p> <span><code>init</code>句柄描述了另一个可选的循环局部变量的初始值。</span> <span>在每次迭代中，此循环局部变量（如果存在）将传递给<code>body</code>并使用其调用返回的值进行更新。</span> <span>循环执行的结果将是附加的循环局部变量（如果存在）的最终值。</span> </p> 
             <p> <span>以下规则适用于这些参数句柄：</span> </p> 
             <ul> 
              <li> <span><code>body</code>句柄不得为<code>null</code> ;</span> <span>其类型必须为<code>(V A...)V</code> ，其中<code>V</code>为非<code>void</code> ，否则为<code>(A...)void</code> 。</span> <span>（在<code>void</code>情况下，我们将类型<code>void</code>分配给名称<code>V</code> ，我们将编写<code>(V A...)V</code> ，并理解<code>void</code>类型<code>V</code>从参数列表中安静地删除，留下<code>(A...)V</code> ）</span> </li> 
              <li> <span>正文的参数列表<code>(V A...)</code>称为<em>内部参数列表</em> 。</span> <span>它将约束其他循环部分的参数列表。</span> </li> 
              <li> <span>如果从内部参数列表中删除了迭代变量类型<code>V</code> ，则生成的较短列表<code>(A...)</code>称为<em>外部参数列表</em> 。</span> </li> 
              <li> <span>主体返回类型<code>V</code> ，如果<code>void</code> ，则确定循环的附加状态变量的类型。</span> <span>正文必须接受并返回此类型的值<code>V</code> 。</span> </li> 
              <li> <span>如果<code>init</code>不是<code>null</code> ，则它必须具有返回类型<code>V</code> 。</span> <span>（它的一些参数列表<a href="MethodHandles.html#astar">form <code>(A*)</code></a> ）必须<a href="MethodHandles.html#effid">effectively identical</a>的外部参数列表<code>(A...)</code> 。</span> </li> 
              <li> <span>如果<code>init</code>是<code>null</code> ，则循环变量将初始化为其<a href="#empty(java.lang.invoke.MethodType)">default value</a> 。</span> </li> 
              <li> <span><code>pred</code>句柄不能是<code>null</code> 。</span> <span>它必须具有<code>boolean</code>作为其返回类型。</span> <span>其参数列表（空或<code>(V A*)</code>形式）必须与内部参数列表有效相同。</span> </li> 
             </ul> 
             <p> <span>生成的循环句柄的结果类型和参数签名确定如下：</span> </p> 
             <ul> 
              <li> <span>循环句柄的结果类型是正文的结果类型<code>V</code> 。</span> </li> 
              <li> <span>循环句柄的参数类型是外部参数列表中的类型<code>(A...)</code> 。</span> </li> 
             </ul> 
             <p> <span>这是生成的循环句柄的伪代码。</span> <span>在代码中， <code>V</code> / <code>v</code>表示唯一循环变量的类型/值以及循环的结果类型;</span> <span>和<code>A</code> / <code>a</code> ，该参数传递给循环。</span> </p> 
             <blockquote> 
              <span><pre><code>
 V init(A...);
 boolean pred(V, A...);
 V body(V, A...);
 V whileLoop(A... a...) {
   V v = init(a...);
   while (pred(v, a...)) {
     v = body(v, a...);
   }
   return v;
 }
 </code></pre></span> 
             </blockquote> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>例：</span> 
              <blockquote> 
               <span><pre><code>
 // implement the zip function for lists as a loop handle
 static List&lt;String&gt; initZip(Iterator&lt;String&gt; a, Iterator&lt;String&gt; b) { return new ArrayList&lt;&gt;(); }
 static boolean zipPred(List&lt;String&gt; zip, Iterator&lt;String&gt; a, Iterator&lt;String&gt; b) { return a.hasNext() &amp;&amp; b.hasNext(); }
 static List&lt;String&gt; zipStep(List&lt;String&gt; zip, Iterator&lt;String&gt; a, Iterator&lt;String&gt; b) {
   zip.add(a.next());
   zip.add(b.next());
   return zip;
 }
 // assume MH_initZip, MH_zipPred, and MH_zipStep are handles to the above methods
 MethodHandle loop = MethodHandles.whileLoop(MH_initZip, MH_zipPred, MH_zipStep);
 List&lt;String&gt; a = Arrays.asList("a", "b", "c", "d");
 List&lt;String&gt; b = Arrays.asList("e", "f", "g", "h");
 List&lt;String&gt; zipped = Arrays.asList("a", "e", "b", "f", "c", "g", "d", "h");
 assertEquals(zipped, (List&lt;String&gt;) loop.invoke(a.iterator(), b.iterator()));
 </code></pre></span> 
              </blockquote> 
              <span>，这种方法的实现可以表示如下：</span> 
              <blockquote> 
               <span><pre><code>
 MethodHandle whileLoop(MethodHandle init, MethodHandle pred, MethodHandle body) {
     MethodHandle fini = (body.type().returnType() == void.class
                         ? null : identity(body.type().returnType()));
     MethodHandle[]
         checkExit = { null, null, pred, fini },
         varBody   = { init, body };
     return loop(checkExit, varBody);
 }
 </code></pre></span> 
              </blockquote> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <span><code>init</code> - 可选的初始值设定项，提供循环变量的初始值。</span> 
              <span>可能是<code>null</code> ，暗示默认初始值。</span> 
              <span>请参阅上面的其他约束。</span> 
             </dd> 
             <dd> 
              <span><code>pred</code> - 循环的条件，可能不是<code>null</code> 。</span> 
              <span>其结果类型必须为<code>boolean</code> 。</span> 
              <span>请参阅上面的其他约束。</span> 
             </dd> 
             <dd> 
              <span><code>body</code> - 循环体，可能不是<code>null</code> 。</span> 
              <span>它控制循环参数和结果类型。</span> 
              <span>请参阅上面的其他约束。</span> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个方法句柄实现 
              <code>while</code>循环，如参数所述。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果违反了参数规则。 
             </dd> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
              <code>pred</code>或 
              <code>body</code>是 
              <code>null</code> 。 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#loop(java.lang.invoke.MethodHandle%5B%5D...)"><code>loop(MethodHandle[][])</code></a> ， 
              <a href="#doWhileLoop(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)"><code>doWhileLoop(MethodHandle, MethodHandle, MethodHandle)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="doWhileLoop(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>doWhileLoop</h4> <pre class="methodSignature">public static&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;doWhileLoop​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;init,
                                       <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;body,
                                       <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;pred)</pre> 
            <div class="block"> 
             <span>从初始值设定项，正文和谓词构造一个<code>do-while</code>循环。</span> 
             <span>这是<a href="#loop(java.lang.invoke.MethodHandle%5B%5D...)">generic loop combinator</a>的便利包装器。</span> 
             <p> <span><code>pred</code>句柄描述了循环条件;</span> <span>和它的身体<code>body</code> 。</span> <span>此方法产生的循环将在每次迭代中首先执行其主体，然后评估谓词。</span> <span>一旦执行主体后谓词的计算结果为<code>false</code> ，循环将终止。</span> </p> 
             <p> <span><code>init</code>句柄描述了另一个可选的循环局部变量的初始值。</span> <span>在每次迭代中，此循环局部变量（如果存在）将传递给<code>body</code>并使用其调用返回的值进行更新。</span> <span>循环执行的结果将是附加的循环局部变量（如果存在）的最终值。</span> </p> 
             <p> <span>以下规则适用于这些参数句柄：</span> </p> 
             <ul> 
              <li> <span><code>body</code>句柄不能是<code>null</code> ;</span> <span>其类型必须为<code>(V A...)V</code> ，其中<code>V</code>为非<code>void</code> ，否则为<code>(A...)void</code> 。</span> <span>（在<code>void</code>情况下，我们将类型<code>void</code>分配给名称<code>V</code> ，我们将编写<code>(V A...)V</code> ，并了解<code>void</code>类型<code>V</code>从参数列表中安静地删除，留下<code>(A...)V</code> ）</span> </li> 
              <li> <span>正文的参数列表<code>(V A...)</code>称为<em>内部参数列表</em> 。</span> <span>它将约束其他循环部分的参数列表。</span> </li> 
              <li> <span>如果从内部参数列表中删除了迭代变量类型<code>V</code> ，则生成的较短列表<code>(A...)</code>称为<em>外部参数列表</em> 。</span> </li> 
              <li> <span>主体返回类型<code>V</code> （如果非<code>void</code> ）确定循环的其他状态变量的类型。</span> <span>正文必须接受并返回此类型的值<code>V</code> 。</span> </li> 
              <li> <span>如果<code>init</code>是非<code>null</code> ，则它必须具有返回类型<code>V</code> 。</span> <span>其参数列表（部分<a href="MethodHandles.html#astar">form <code>(A*)</code></a> ）必须为<a href="MethodHandles.html#effid">effectively identical</a>到外部参数列表<code>(A...)</code> 。</span> </li> 
              <li> <span>如果<code>init</code>是<code>null</code> ，则循环变量将初始化为其<a href="#empty(java.lang.invoke.MethodType)">default value</a> 。</span> </li> 
              <li> <span><code>pred</code>句柄不能是<code>null</code> 。</span> <span>它的返回类型必须为<code>boolean</code> 。</span> <span>其参数列表（空或<code>(V A*)</code>形式）必须与内部参数列表有效相同。</span> </li> 
             </ul> 
             <p> <span>生成的循环句柄的结果类型和参数签名确定如下：</span> </p> 
             <ul> 
              <li> <span>循环句柄的结果类型是正文的结果类型<code>V</code> 。</span> </li> 
              <li> <span>循环句柄的参数类型是外部参数列表中的类型<code>(A...)</code> 。</span> </li> 
             </ul> 
             <p> <span>这是生成的循环句柄的伪代码。</span> <span>在代码中， <code>V</code> / <code>v</code>表示唯一循环变量的类型/值以及循环的结果类型;</span> <span>和<code>A</code> / <code>a</code> ，该参数传递给循环。</span> </p> 
             <blockquote> 
              <span><pre><code>
 V init(A...);
 boolean pred(V, A...);
 V body(V, A...);
 V doWhileLoop(A... a...) {
   V v = init(a...);
   do {
     v = body(v, a...);
   } while (pred(v, a...));
   return v;
 }
 </code></pre></span> 
             </blockquote> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>例：</span> 
              <blockquote> 
               <span><pre><code>
 // int i = 0; while (i &lt; limit) { ++i; } return i; =&gt; limit
 static int zero(int limit) { return 0; }
 static int step(int i, int limit) { return i + 1; }
 static boolean pred(int i, int limit) { return i &lt; limit; }
 // assume MH_zero, MH_step, and MH_pred are handles to the above methods
 MethodHandle loop = MethodHandles.doWhileLoop(MH_zero, MH_step, MH_pred);
 assertEquals(23, loop.invoke(23));
 </code></pre></span> 
              </blockquote> 
              <span>，这种方法的实现可以表示如下：</span> 
              <blockquote> 
               <span><pre><code>
 MethodHandle doWhileLoop(MethodHandle init, MethodHandle body, MethodHandle pred) {
     MethodHandle fini = (body.type().returnType() == void.class
                         ? null : identity(body.type().returnType()));
     MethodHandle[] clause = { init, body, pred, fini };
     return loop(clause);
 }
 </code></pre></span> 
              </blockquote> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <span><code>init</code> - 可选的初始值设定项，提供循环变量的初始值。</span> 
              <span>可能是<code>null</code> ，暗示默认初始值。</span> 
              <span>请参阅上面的其他约束。</span> 
             </dd> 
             <dd> 
              <span><code>body</code> - 循环体，可能不是<code>null</code> 。</span> 
              <span>它控制循环参数和结果类型。</span> 
              <span>请参阅上面的其他约束。</span> 
             </dd> 
             <dd> 
              <span><code>pred</code> - 循环的条件，可能不是<code>null</code> 。</span> 
              <span>其结果类型必须为<code>boolean</code> 。</span> 
              <span>请参阅上面的其他约束。</span> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个方法句柄实现 
              <code>while</code>循环，如参数所述。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果违反了参数规则。 
             </dd> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
              <code>pred</code>或 
              <code>body</code>是 
              <code>null</code> 。 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#loop(java.lang.invoke.MethodHandle%5B%5D...)"><code>loop(MethodHandle[][])</code></a> ， 
              <a href="#whileLoop(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)"><code>whileLoop(MethodHandle, MethodHandle, MethodHandle)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="countedLoop(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>countedLoop</h4> <pre class="methodSignature">public static&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;countedLoop​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;iterations,
                                       <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;init,
                                       <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;body)</pre> 
            <div class="block"> 
             <span>构造一个运行给定迭代次数的循环。</span> 
             <span>这是<a href="#loop(java.lang.invoke.MethodHandle%5B%5D...)">generic loop combinator</a>的便利包装。</span> 
             <p> <span>迭代次数由<code>iterations</code>句柄评估结果确定。</span> <span>循环计数器<code>i</code>是类型<code>int</code>的额外循环迭代变量。</span> <span>它将被初始化为0并在每次迭代中递增1。</span> </p> 
             <p> <span>如果<code>body</code>句柄返回非<code>void</code>类型<code>V</code> ，则还存在该类型的前导循环迭代变量。</span> <span>这个变量是使用初始化的可选<code>init</code>手柄，或到<a href="#empty(java.lang.invoke.MethodType)">default value</a>类型的<code>V</code>如果该句柄是<code>null</code> 。</span> </p> 
             <p> <span>在每次迭代中，迭代变量都会传递给<code>body</code>句柄的调用。</span> <span>从正文（ <code>V</code>类型）返回的非<code>void</code>值更新前导迭代变量。</span> <span>环形手柄执行的结果将是最终<code>V</code>该变量的值（或<code>void</code>如果没有<code>V</code>变量）。</span> </p> 
             <p> <span>以下规则适用于参数句柄：</span> </p> 
             <ul> 
              <li> <span><code>iterations</code>句柄不能是<code>null</code> ，并且必须返回类型<code>int</code> ，在此处称为参数类型列表中的<code>I</code> 。</span> </li> 
              <li> <span><code>body</code>句柄不能是<code>null</code> ;</span> <span>其类型必须为<code>(V I A...)V</code> ，其中<code>V</code>为非<code>void</code> ，否则为<code>(I A...)void</code> 。</span> <span>（在<code>void</code>情况下，我们将类型<code>void</code>分配给名称<code>V</code> ，我们将编写<code>(V I A...)V</code> ，并理解<code>void</code>类型<code>V</code>从参数列表中悄然删除，留下<code>(I A...)V</code> ）</span> </li> 
              <li> <span>正文的参数列表<code>(V I A...)</code>提供了一个称为<em>内部参数列表</em>的类型<em>列表</em> 。</span> <span>它将约束其他循环部分的参数列表。</span> </li> 
              <li> <span>作为特殊情况，如果正文仅提供<code>V</code>和<code>I</code>类型，而没有其他<code>A</code>类型，则内部参数列表将通过<code>iterations</code>句柄的参数类型<code>A...</code>进行<code>iterations</code> 。</span> </li> 
              <li> <span>如果从内部参数列表中删除迭代变量类型<code>(V I)</code> ，则生成的较短列表<code>(A...)</code>称为<em>外部参数列表</em> 。</span> </li> 
              <li> <span>正文返回类型<code>V</code> （如果为非<code>void</code> ）确定循环的其他状态变量的类型。</span> <span>正文必须都接受一个前导参数并返回此类型的值<code>V</code> 。</span> </li> 
              <li> <span>如果<code>init</code>是非<code>null</code> ，则它必须具有返回类型<code>V</code> 。</span> <span>其参数列表（部分<a href="MethodHandles.html#astar">form <code>(A*)</code></a> ）必须为<a href="MethodHandles.html#effid">effectively identical</a>到外部参数列表<code>(A...)</code> 。</span> </li> 
              <li> <span>如果<code>init</code>是<code>null</code> ，则循环变量将初始化为其<a href="#empty(java.lang.invoke.MethodType)">default value</a> 。</span> </li> 
              <li> <span>参数列表<code>iterations</code> （某种形式为<code>(A*)</code> ）必须与外部参数列表<code>(A...)</code>有效相同。</span> </li> 
             </ul> 
             <p> <span>生成的循环句柄的结果类型和参数签名确定如下：</span> </p> 
             <ul> 
              <li> <span>循环句柄的结果类型是正文的结果类型<code>V</code> 。</span> </li> 
              <li> <span>循环句柄的参数类型是外部参数列表中的类型<code>(A...)</code> 。</span> </li> 
             </ul> 
             <p> <span>这是生成的循环句柄的伪代码。</span> <span>在代码中， <code>V</code> / <code>v</code>表示第二个循环变量的类型/值以及循环的结果类型;</span> <span>和<code>A...</code> / <code>a...</code>代表传递给循环论证。</span> </p> 
             <blockquote> 
              <span><pre><code>
 int iterations(A...);
 V init(A...);
 V body(V, int, A...);
 V countedLoop(A... a...) {
   int end = iterations(a...);
   V v = init(a...);
   for (int i = 0; i &lt; end; ++i) {
     v = body(v, i, a...);
   }
   return v;
 }
 </code></pre></span> 
             </blockquote> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>具有完全一致的body方法的示例：</span> 
              <blockquote> 
               <span><pre><code>
 // String s = "Lambdaman!"; for (int i = 0; i &lt; 13; ++i) { s = "na " + s; } return s;
 // =&gt; a variation on a well known theme
 static String step(String v, int counter, String init) { return "na " + v; }
 // assume MH_step is a handle to the method above
 MethodHandle fit13 = MethodHandles.constant(int.class, 13);
 MethodHandle start = MethodHandles.identity(String.class);
 MethodHandle loop = MethodHandles.countedLoop(fit13, start, MH_step);
 assertEquals("na na na na na na na na na na na na na Lambdaman!", loop.invoke("Lambdaman!"));
 </code></pre></span> 
              </blockquote> 
              <span>，使用最简单的body方法类型的示例，并将迭代次数传递给循环调用：</span> 
              <blockquote> 
               <span><pre><code>
 // String s = "Lambdaman!"; for (int i = 0; i &lt; 13; ++i) { s = "na " + s; } return s;
 // =&gt; a variation on a well known theme
 static String step(String v, int counter ) { return "na " + v; }
 // assume MH_step is a handle to the method above
 MethodHandle count = MethodHandles.dropArguments(MethodHandles.identity(int.class), 1, String.class);
 MethodHandle start = MethodHandles.dropArguments(MethodHandles.identity(String.class), 0, int.class);
 MethodHandle loop = MethodHandles.countedLoop(count, start, MH_step);  // (v, i) -&gt; "na " + v
 assertEquals("na na na na na na na na na na na na na Lambdaman!", loop.invoke(13, "Lambdaman!"));
 </code></pre></span> 
              </blockquote> 
              <span>，处理迭代次数的示例，要追加的字符串，以及追加为循环参数的字符串：</span> 
              <blockquote> 
               <span><pre><code>
 // String s = "Lambdaman!", t = "na"; for (int i = 0; i &lt; 13; ++i) { s = t + " " + s; } return s;
 // =&gt; a variation on a well known theme
 static String step(String v, int counter, int iterations_, String pre, String start_) { return pre + " " + v; }
 // assume MH_step is a handle to the method above
 MethodHandle count = MethodHandles.identity(int.class);
 MethodHandle start = MethodHandles.dropArguments(MethodHandles.identity(String.class), 0, int.class, String.class);
 MethodHandle loop = MethodHandles.countedLoop(count, start, MH_step);  // (v, i, _, pre, _) -&gt; pre + " " + v
 assertEquals("na na na na na na na na na na na na na Lambdaman!", loop.invoke(13, "na", "Lambdaman!"));
 </code></pre></span> 
              </blockquote> 
              <span>，示例说明了使用<a href="#dropArgumentsToMatch(java.lang.invoke.MethodHandle,int,java.util.List,int)"><code>dropArgumentsToMatch(MethodHandle, int, List, int)</code></a>强制执行循环类型：</span> 
              <blockquote> 
               <span><pre><code>
 // String s = "Lambdaman!", t = "na"; for (int i = 0; i &lt; 13; ++i) { s = t + " " + s; } return s;
 // =&gt; a variation on a well known theme
 static String step(String v, int counter, String pre) { return pre + " " + v; }
 // assume MH_step is a handle to the method above
 MethodType loopType = methodType(String.class, String.class, int.class, String.class);
 MethodHandle count = MethodHandles.dropArgumentsToMatch(MethodHandles.identity(int.class),    0, loopType.parameterList(), 1);
 MethodHandle start = MethodHandles.dropArgumentsToMatch(MethodHandles.identity(String.class), 0, loopType.parameterList(), 2);
 MethodHandle body  = MethodHandles.dropArgumentsToMatch(MH_step,                              2, loopType.parameterList(), 0);
 MethodHandle loop = MethodHandles.countedLoop(count, start, body);  // (v, i, pre, _, _) -&gt; pre + " " + v
 assertEquals("na na na na na na na na na na na na na Lambdaman!", loop.invoke("na", 13, "Lambdaman!"));
 </code></pre></span> 
              </blockquote> 
              <span>，这种方法的实现可以表示如下：</span> 
              <blockquote> 
               <span><pre><code>
 MethodHandle countedLoop(MethodHandle iterations, MethodHandle init, MethodHandle body) {
     return countedLoop(empty(iterations.type()), iterations, init, body);
 }
 </code></pre></span> 
              </blockquote> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <span><code>iterations</code> - 非<code>null</code>句柄，用于返回此循环应运行的迭代次数。</span> 
              <span>句柄的结果类型必须为<code>int</code> 。</span> 
              <span>请参阅上面的其他约束。</span> 
             </dd> 
             <dd> 
              <span><code>init</code> - 可选的初始值设定项，提供循环变量的初始值。</span> 
              <span>可能是<code>null</code> ，暗示默认初始值。</span> 
              <span>请参阅上面的其他约束。</span> 
             </dd> 
             <dd> 
              <span><code>body</code> - 循环体，可能不是<code>null</code> 。</span> 
              <span>它控制标准情况下的循环参数和结果类型（详见上文）。</span> 
              <span>它必须接受自己的返回类型（如果是非void）加上<code>int</code>参数（对于计数器），并且可以接受任意数量的其他类型。</span> 
              <span>请参阅上面的其他约束。</span> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               表示循环的方法句柄。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
              <code>iterations</code>或 
              <code>body</code>处理中的任何一个是 
              <code>null</code> 。 
             </dd> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果有任何论点违反上述规则。 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#countedLoop(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)"><code>countedLoop(MethodHandle, MethodHandle, MethodHandle, MethodHandle)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="countedLoop(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>countedLoop</h4> <pre class="methodSignature">public static&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;countedLoop​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;start,
                                       <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;end,
                                       <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;init,
                                       <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;body)</pre> 
            <div class="block"> 
             <span>构造一个计算一系列数字的循环。</span> 
             <span>这是<a href="#loop(java.lang.invoke.MethodHandle%5B%5D...)">generic loop combinator</a>的便利包装。</span> 
             <p> <span>循环计数器<code>i</code>是类型<code>int</code>的循环迭代变量。</span> <span><code>start</code>和<code>end</code>句柄确定循环计数器的起始值（包含）和结束（独占）值。</span> <span>循环计数器将初始化为从<code>start</code>句柄的<code>int</code>值返回的<code>int</code>值，并运行到从步长为1的<code>end</code> （排他性）返回的值。</span> </p> 
             <p> <span>如果<code>body</code>句柄返回非<code>void</code>类型<code>V</code> ，则还存在该类型的前导循环迭代变量。</span> <span>如果该句柄为<code>null</code> ，则使用可选的<code>init</code>句柄初始化此变量，或者使用<a href="#empty(java.lang.invoke.MethodType)">V</a>类型的<code>V</code>初始化此变量。</span> </p> 
             <p> <span>在每次迭代中，迭代变量都会传递给<code>body</code>句柄的调用。</span> <span>从正文返回的非<code>void</code>值（类型为<code>V</code> ）更新前导迭代变量。</span> <span>环形手柄执行的结果将是最终<code>V</code>该变量的值（或<code>void</code>如果没有<code>V</code>变量）。</span> </p> 
             <p> <span>以下规则适用于参数句柄：</span> </p> 
             <ul> 
              <li> <span><code>start</code>和<code>end</code>句柄不能是<code>null</code> ，并且必须同时返回公共类型<code>int</code> ，在此处称为参数类型列表中的<code>I</code> 。</span> </li> 
              <li> <span><code>body</code>句柄不能是<code>null</code> ;</span> <span>其类型必须为<code>(V I A...)V</code> ，其中<code>V</code>为非<code>void</code> ，否则为<code>(I A...)void</code> 。</span> <span>（在<code>void</code>情况下，我们将类型<code>void</code>分配给名称<code>V</code> ，我们将编写<code>(V I A...)V</code> ，并理解<code>void</code>类型<code>V</code>从参数列表中安静地删除，留下<code>(I A...)V</code> ）</span> </li> 
              <li> <span>正文的参数列表<code>(V I A...)</code>提供了称为<em>内部参数列表</em>的类型<em>列表</em> 。</span> <span>它将约束其他循环部分的参数列表。</span> </li> 
              <li> <span>作为特殊情况，如果正文仅提供<code>V</code>和<code>I</code>类型，而没有其他<code>A</code>类型，则内部参数列表将通过<code>end</code>句柄的参数类型<code>A...</code>进行<code>end</code> 。</span> </li> 
              <li> <span>如果从内部参数列表中删除迭代变量类型<code>(V I)</code> ，则生成的较短列表<code>(A...)</code>称为<em>外部参数列表</em> 。</span> </li> 
              <li> <span>主体返回类型<code>V</code> （如果<code>void</code> ）确定循环的附加状态变量的类型。</span> <span>正文必须都接受一个前导参数并返回此类型的值<code>V</code> 。</span> </li> 
              <li> <span>如果<code>init</code>不是<code>null</code> ，则它必须具有返回类型<code>V</code> 。</span> <span>其参数列表（部分<a href="MethodHandles.html#astar">form <code>(A*)</code></a> ）必须为<a href="MethodHandles.html#effid">effectively identical</a>到外部参数列表<code>(A...)</code> 。</span> </li> 
              <li> <span>如果<code>init</code>是<code>null</code> ，则循环变量将初始化为其<a href="#empty(java.lang.invoke.MethodType)">default value</a> 。</span> </li> 
              <li> <span>参数列表<code>start</code> （某种形式为<code>(A*)</code> ）必须与外部参数列表<code>(A...)</code>有效相同。</span> </li> 
              <li> <span>同样，参数列表<code>end</code>必须与外部参数列表有效相同。</span> </li> 
             </ul> 
             <p> <span>生成的循环句柄的结果类型和参数签名确定如下：</span> </p> 
             <ul> 
              <li> <span>循环句柄的结果类型是正文的结果类型<code>V</code> 。</span> </li> 
              <li> <span>循环句柄的参数类型是外部参数列表中的类型<code>(A...)</code> 。</span> </li> 
             </ul> 
             <p> <span>这是生成的循环句柄的伪代码。</span> <span>在代码中， <code>V</code> / <code>v</code>表示第二个循环变量的类型/值以及循环的结果类型;</span> <span>和<code>A...</code> / <code>a...</code>代表传递给循环论证。</span> </p> 
             <blockquote> 
              <span><pre><code>
 int start(A...);
 int end(A...);
 V init(A...);
 V body(V, int, A...);
 V countedLoop(A... a...) {
   int e = end(a...);
   int s = start(a...);
   V v = init(a...);
   for (int i = s; i &lt; e; ++i) {
     v = body(v, i, a...);
   }
   return v;
 }
 </code></pre></span> 
             </blockquote> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>该方法的实现可表示如下：</span> 
              <blockquote> 
               <span><pre><code>
 MethodHandle countedLoop(MethodHandle start, MethodHandle end, MethodHandle init, MethodHandle body) {
     MethodHandle returnVar = dropArguments(identity(init.type().returnType()), 0, int.class, int.class);
     // assume MH_increment and MH_predicate are handles to implementation-internal methods with
     // the following semantics:
     // MH_increment: (int limit, int counter) -&gt; counter + 1
     // MH_predicate: (int limit, int counter) -&gt; counter &lt; limit
     Class&lt;?&gt; counterType = start.type().returnType();  // int
     Class&lt;?&gt; returnType = body.type().returnType();
     MethodHandle incr = MH_increment, pred = MH_predicate, retv = null;
     if (returnType != void.class) {  // ignore the V variable
         incr = dropArguments(incr, 1, returnType);  // (limit, v, i) =&gt; (limit, i)
         pred = dropArguments(pred, 1, returnType);  // ditto
         retv = dropArguments(identity(returnType), 0, counterType); // ignore limit
     }
     body = dropArguments(body, 0, counterType);  // ignore the limit variable
     MethodHandle[]
         loopLimit  = { end, null, pred, retv }, // limit = end(); i &lt; limit || return v
         bodyClause = { init, body },            // v = init(); v = body(v, i)
         indexVar   = { start, incr };           // i = start(); i = i + 1
     return loop(loopLimit, bodyClause, indexVar);
 }
 </code></pre></span> 
              </blockquote> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <span><code>start</code> - 非<code>null</code>句柄，用于返回循环计数器的起始值，该值必须为<code>int</code> 。</span> 
              <span>请参阅上面的其他约束。</span> 
             </dd> 
             <dd> 
              <span><code>end</code> - 非<code>null</code>句柄，用于返回循环计数器的结束值（循环将运行到<code>end-1</code> ）。</span> 
              <span>结果类型必须为<code>int</code> 。</span> 
              <span>请参阅上面的其他约束。</span> 
             </dd> 
             <dd> 
              <span><code>init</code> - 可选的初始值设定项，提供循环变量的初始值。</span> 
              <span>可能是<code>null</code> ，表示默认初始值。</span> 
              <span>请参阅上面的其他约束。</span> 
             </dd> 
             <dd> 
              <span><code>body</code> - 循环体，可能不是<code>null</code> 。</span> 
              <span>它控制标准情况下的循环参数和结果类型（详见上文）。</span> 
              <span>它必须接受自己的返回类型（如果非void）加上<code>int</code>参数（对于计数器），并且可以接受任意数量的其他类型。</span> 
              <span>请参阅上面的其他约束。</span> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               表示循环的方法句柄。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果任何的 
              <code>start</code> ， 
              <code>end</code> ，或 
              <code>body</code>手柄是 
              <code>null</code> 。 
             </dd> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果有任何论点违反上述规则。 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#countedLoop(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)"><code>countedLoop(MethodHandle, MethodHandle, MethodHandle)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="iteratedLoop(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>iteratedLoop</h4> <pre class="methodSignature">public static&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;iteratedLoop​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;iterator,
                                        <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;init,
                                        <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;body)</pre> 
            <div class="block"> 
             <span>构造一个范围超过<code>Iterator&lt;T&gt;</code>生成的值的<code>Iterator&lt;T&gt;</code> 。</span> 
             <span>这是<a href="#loop(java.lang.invoke.MethodHandle%5B%5D...)">generic loop combinator</a>的便利包装。</span> 
             <p> <span>迭代器本身将由<code>iterator</code>句柄的评估决定。</span> <span>它产生的每个值都将存储在<code>T</code>类型的循环迭代变量中。</span> </p> 
             <p> <span>如果<code>body</code>句柄返回非<code>void</code>类型<code>V</code> ，则还存在该类型的前导循环迭代变量。</span> <span>如果该句柄为<code>null</code> ，则使用可选的<code>init</code>句柄初始化此变量，或者使用<a href="#empty(java.lang.invoke.MethodType)">V</a>类型的<code>V</code>初始化此变量。</span> </p> 
             <p> <span>在每次迭代中，迭代变量都会传递给<code>body</code>句柄的调用。</span> <span>从正文返回的非<code>void</code>值（类型<code>V</code> ）更新前导迭代变量。</span> <span>环形手柄执行的结果将是最终<code>V</code>该变量的值（或<code>void</code>如果没有<code>V</code>变量）。</span> </p> 
             <p> <span>以下规则适用于参数句柄：</span> </p> 
             <ul> 
              <li> <span><code>body</code>句柄不得为<code>null</code> ;</span> <span>其类型必须为<code>(V T A...)V</code> ，其中<code>V</code>为非<code>void</code> ，否则为<code>(T A...)void</code> 。</span> <span>（在<code>void</code>情况下，我们将类型<code>void</code>分配给名称<code>V</code> ，我们将编写<code>(V T A...)V</code> ，并了解<code>void</code>类型<code>V</code>从参数列表中安静地删除，留下<code>(T A...)V</code> ）</span> </li> 
              <li> <span>正文的参数列表<code>(V T A...)</code>提供了一个称为<em>内部参数列表</em>的类型<em>列表</em> 。</span> <span>它将约束其他循环部分的参数列表。</span> </li> 
              <li> <span>作为特殊情况，如果正文仅贡献<code>V</code>和<code>T</code>类型，而没有额外的<code>A</code>类型，则内部参数列表由<code>iterator</code>句柄的参数类型<code>A...</code>扩展;</span> <span>如果是<code>null</code> ，则添加单一类型<code>Iterable</code>并构成<code>A...</code>列表。</span> </li> 
              <li> <span>如果从内部参数列表中删除了迭代变量类型<code>(V T)</code> ，则生成的较短列表<code>(A...)</code>称为<em>外部参数列表</em> 。</span> </li> 
              <li> <span>主体返回类型<code>V</code> （如果<code>void</code> ）确定循环的其他状态变量的类型。</span> <span>正文必须都接受一个前导参数并返回此类型的值<code>V</code> 。</span> </li> 
              <li> <span>如果<code>init</code>不是<code>null</code> ，则它必须具有返回类型<code>V</code> 。</span> <span>其参数列表（部分<a href="MethodHandles.html#astar">form <code>(A*)</code></a> ）必须为<a href="MethodHandles.html#effid">effectively identical</a>到外部参数列表<code>(A...)</code> 。</span> </li> 
              <li> <span>如果<code>init</code>是<code>null</code> ，则循环变量将初始化为其<a href="#empty(java.lang.invoke.MethodType)">default value</a> 。</span> </li> 
              <li> <span>如果<code>iterator</code>句柄为非<code>null</code> ，则它必须具有返回类型<code>java.util.Iterator</code>或其子类型。</span> <span>执行循环时它产生的迭代器将被假定为产生可转换为类型<code>T</code> 。</span> </li> 
              <li> <span>一个的参数列表<code>iterator</code>即非<code>null</code> （的某种形式的<code>(A*)</code> ）必须有效地等同于外部参数列表<code>(A...)</code> 。</span> </li> 
              <li> <span>如果<code>iterator</code>是<code>null</code>则默认为方法句柄，其行为类似于<a href="../Iterable.html#iterator()"><code>Iterable.iterator()</code></a> 。</span> <span>在这种情况下，内部参数列表<code>(V T A...)</code>必须至少具有一个<code>A</code>类型，并且调整默认迭代器句柄参数以接受前导<code>A</code>类型，就像通过<a href="MethodHandle.html#asType(java.lang.invoke.MethodType)"><code>asType</code></a>转换方法一样。</span> <span>领先的<code>A</code>类型必须是<code>Iterable</code>或其子类型。</span> <span>在循环构造时完成的转换步骤不得抛出<code>WrongMethodTypeException</code> 。</span> </li> 
             </ul> 
             <p> <span>类型<code>T</code>可以是基元或引用。</span> <span>由于类型<code>Iterator&lt;T&gt;</code>的方法手柄表示被擦除到原始类型<code>Iterator</code> ，所述<code>iteratedLoop</code>组合子调整为主导参数类型<code>body</code>到<code>Object</code>仿佛由<a href="MethodHandle.html#asType(java.lang.invoke.MethodType)"><code>asType</code></a>转换方法。</span> <span>因此，如果在执行循环时出现错误类型的迭代器，则由于<a href="MethodHandle.html#asType(java.lang.invoke.MethodType)"><code>MethodHandle.asType(MethodType)</code></a>执行动态转换，可能会发生运行时异常。</span> </p> 
             <p> <span>生成的循环句柄的结果类型和参数签名确定如下：</span> </p> 
             <ul> 
              <li> <span>循环句柄的结果类型是正文的结果类型<code>V</code> 。</span> </li> 
              <li> <span>循环句柄的参数类型是外部参数列表中的类型<code>(A...)</code> 。</span> </li> 
             </ul> 
             <p> <span>这是生成的循环句柄的伪代码。</span> <span>在代码中， <code>V</code> / <code>v</code>表示循环变量的类型/值以及循环的结果类型;</span> <span><code>T</code> / <code>t</code> ，该结构的循环迭代的元素，和<code>A...</code> / <code>a...</code>表示传递给循环参数。</span> </p> 
             <blockquote> 
              <span><pre><code>
 Iterator&lt;T&gt; iterator(A...);  // defaults to Iterable::iterator
 V init(A...);
 V body(V,T,A...);
 V iteratedLoop(A... a...) {
   Iterator&lt;T&gt; it = iterator(a...);
   V v = init(a...);
   while (it.hasNext()) {
     T t = it.next();
     v = body(v, t, a...);
   }
   return v;
 }
 </code></pre></span> 
             </blockquote> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>例：</span> 
              <blockquote> 
               <span><pre><code>
 // get an iterator from a list
 static List&lt;String&gt; reverseStep(List&lt;String&gt; r, String e) {
   r.add(0, e);
   return r;
 }
 static List&lt;String&gt; newArrayList() { return new ArrayList&lt;&gt;(); }
 // assume MH_reverseStep and MH_newArrayList are handles to the above methods
 MethodHandle loop = MethodHandles.iteratedLoop(null, MH_newArrayList, MH_reverseStep);
 List&lt;String&gt; list = Arrays.asList("a", "b", "c", "d", "e");
 List&lt;String&gt; reversedList = Arrays.asList("e", "d", "c", "b", "a");
 assertEquals(reversedList, (List&lt;String&gt;) loop.invoke(list));
 </code></pre></span> 
              </blockquote> 
              <span>，这种方法的实现大致可以表达如下：</span> 
              <blockquote> 
               <span><pre><code>
 MethodHandle iteratedLoop(MethodHandle iterator, MethodHandle init, MethodHandle body) {
     // assume MH_next, MH_hasNext, MH_startIter are handles to methods of Iterator/Iterable
     Class&lt;?&gt; returnType = body.type().returnType();
     Class&lt;?&gt; ttype = body.type().parameterType(returnType == void.class ? 0 : 1);
     MethodHandle nextVal = MH_next.asType(MH_next.type().changeReturnType(ttype));
     MethodHandle retv = null, step = body, startIter = iterator;
     if (returnType != void.class) {
         // the simple thing first:  in (I V A...), drop the I to get V
         retv = dropArguments(identity(returnType), 0, Iterator.class);
         // body type signature (V T A...), internal loop types (I V A...)
         step = swapArguments(body, 0, 1);  // swap V &lt;-&gt; T
     }
     if (startIter == null)  startIter = MH_getIter;
     MethodHandle[]
         iterVar    = { startIter, null, MH_hasNext, retv }, // it = iterator; while (it.hasNext())
         bodyClause = { init, filterArguments(step, 0, nextVal) };  // v = body(v, t, a)
     return loop(iterVar, bodyClause);
 }
 </code></pre></span> 
              </blockquote> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <span><code>iterator</code> - 一个可选的句柄，用于返回迭代器以启动循环。</span> 
              <span>如果为非<code>null</code> ，则句柄必须返回<a href="../../util/Iterator.html" title="java.util中的接口"><code>Iterator</code></a>或子类型。</span> 
              <span>请参阅上面的其他约束。</span> 
             </dd> 
             <dd> 
              <span><code>init</code> - 可选的初始值设定项，提供循环变量的初始值。</span> 
              <span>可能是<code>null</code> ，暗示默认初始值。</span> 
              <span>请参阅上面的其他约束。</span> 
             </dd> 
             <dd> 
              <span><code>body</code> - 循环体，可能不是<code>null</code> 。</span> 
              <span>它控制标准情况下的循环参数和结果类型（详见上文）。</span> 
              <span>它必须接受自己的返回类型（如果是非void）加上<code>T</code>参数（对于迭代值），并且可以接受任意数量的其他类型。</span> 
              <span>请参阅上面的其他约束。</span> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个体现迭代循环功能的方法句柄。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
              <code>body</code>句柄是 
              <code>null</code> 。 
             </dd> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果任何参数违反上述要求。 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
            </dl> </li> 
          </ul> <a id="tryFinally(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)"> 
           <!--   --> </a> 
          <ul class="blockListLast"> 
           <li class="blockList"> <h4>tryFinally</h4> <pre class="methodSignature">public static&nbsp;<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;tryFinally​(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                      <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;cleanup)</pre> 
            <div class="block"> 
             <span>创建一个方法句柄，通过将其包装在<code>try-finally</code>块中来调整<code>target</code>方法句柄。</span> 
             <span>另一个方法句柄<code>cleanup</code>表示<code>finally</code>块的功能。</span> 
             <span>执行<code>target</code>句柄期间抛出的任何异常都将传递给<code>cleanup</code>句柄。</span> 
             <span>除非<code>cleanup</code>句柄首先抛出异常，否则将重新抛出该异常。</span> 
             <span>从返回的值<code>cleanup</code>手柄的执行将是执行的结果<code>try-finally</code>手柄。</span> 
             <p> <span><code>cleanup</code>句柄将传递一个或两个额外的主要参数。</span> <span>第一个是执行<code>target</code>句柄时抛出的异常，如果没有抛出异常则抛出<code>null</code> 。</span> <span>第二个是执行<code>target</code>句柄的结果，或者，如果它抛出异常，则提供所需类型的<code>null</code> ，零或<code>false</code>值作为占位符。</span> <span>如果<code>target</code>句柄具有<code>void</code>返回类型，则第二个参数不存在。</span> <span>（注意，除参数类型转换外，组合<code>void</code>通过省略相应的自相矛盾参数表示参数列表中的<code>void</code>值，而不是通过插入<code>null</code>或零值。）</span> </p> 
             <p> <span><code>target</code>和<code>cleanup</code>句柄必须具有相同的对应参数和返回类型，但<code>cleanup</code>句柄可能会省略尾随参数。</span> <span>此外， <code>cleanup</code>句柄必须具有一个或两个额外的前导参数：</span> </p> 
             <ul> 
              <li> <span>a <code>Throwable</code> ，它将携带<code>target</code>句柄抛出的异常（如果有的话）;</span> <span>和</span> </li> 
              <li> <span>与<code>target</code>和<code>cleanup</code>的返回类型相同类型的参数，它将携带执行<code>target</code>句柄的结果。</span> <span>如果<code>target</code>返回<code>void</code> ，则此参数不存在。</span> </li> 
             </ul> 
             <p> <span>生成的适配器的伪代码如下所示。</span> <span>在代码中， <code>V</code>表示<code>try/finally</code>构造的结果类型;</span> <span><code>A</code> / <code>a</code> ，类型和参数，以由所述的清理消耗所得句柄值;</span> <span>和<code>B</code> / <code>b</code> ，那些参数，以由清理丢弃所得到的句柄。</span> </p> 
             <blockquote> 
              <span><pre><code>
 V target(A..., B...);
 V cleanup(Throwable, V, A...);
 V adapter(A... a, B... b) {
   V result = (zero value for V);
   Throwable throwable = null;
   try {
     result = target(a..., b...);
   } catch (Throwable t) {
     throwable = t;
     throw t;
   } finally {
     result = cleanup(throwable, result, a...);
   }
   return result;
 }
 </code></pre></span> 
             </blockquote> 
             <p> <span>请注意，保存的参数（伪代码中的<code>a...</code> ）无法通过执行目标来修改，因此如果调用它，则会从调用方传递给清理。</span> </p> 
             <p> <span>目标和清理必须返回相同的类型，即使总是抛出清理。</span> <span>要创建这样的抛出清理，请使用<a href="#throwException(java.lang.Class,java.lang.Class)"><code>throwException</code></a>组成清理逻辑，以便创建正确返回类型的方法句柄。</span> </p> 
             <p> <span>请注意， <code>tryFinally</code>永远不会将异常转换为正常返回。</span> <span>在必须以这种方式转换异常的极少数情况下，首先使用<a href="#catchException(java.lang.invoke.MethodHandle,java.lang.Class,java.lang.invoke.MethodHandle)"><code>catchException(MethodHandle, Class, MethodHandle)</code></a>包装目标以捕获传出异常，然后使用<code>tryFinally</code>进行换<code>tryFinally</code> 。</span> </p> 
             <p> <span>建议将第一个参数类型<code>cleanup</code>声明为<code>Throwable</code>而不是更窄的子类型。</span> <span>这确保<code>cleanup</code>将始终与任何异常调用<code>target</code>抛出。</span> <span>声明一个较窄的类型可能会导致<code>ClassCastException</code>由被抛出<code>try-finally</code>手柄如果由抛出的异常的类型<code>target</code>不能分配到所述第一参数类型的<code>cleanup</code> 。</span> <span>需要注意的是各种异常类型的<code>VirtualMachineError</code> ， <code>LinkageError</code>和<code>RuntimeException</code>原则上可以通过几乎任何类型的Java代码，只有最后条款映入（说）抛出<code>IOException</code>会掩盖任何其他人的后面<code>ClassCastException</code> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>target</code> - 将执行包装在 
              <code>try</code>块中的 
              <code>try</code> 。 
             </dd> 
             <dd> 
              <code>cleanup</code> - finally块中调用的句柄。 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个方法句柄，体现了由两个参数组成的 
              <code>try-finally</code>块。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任何参数为null 
             </dd> 
             <dd> 
              <code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
              <code>cleanup</code>不接受所需的前导参数，或者方法句柄类型的返回类型与其对应的尾随参数不匹配 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#catchException(java.lang.invoke.MethodHandle,java.lang.Class,java.lang.invoke.MethodHandle)"><code>catchException(MethodHandle, Class, MethodHandle)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> </li> 
        </ul> 
       </section> </li> 
     </ul> 
    </div> 
   </div> 
  </main> 
  <!-- ========= END OF CLASS DATA ========= --> 
  <footer role="contentinfo"> 
   <nav role="navigation"> 
    <!-- ======= START OF BOTTOM NAVBAR ====== --> 
    <div class="bottomNav"> 
     <a id="navbar.bottom"> 
      <!--   --> </a> 
     <div class="skipNav"> 
      <a href="#skip.navbar.bottom" title="Skip navigation links">跳过导航</a> 
     </div> 
     <a id="navbar.bottom.firstrow"> 
      <!--   --> </a> 
     <ul class="navList" title="Navigation"> 
      <li><a href="../../../../index.html">概述</a></li> 
      <li><a href="../../../module-summary.html">模块</a></li> 
      <li><a href="package-summary.html">软件包</a></li> 
      <li class="navBarCell1Rev">类</li> 
      <li><a href="class-use/MethodHandles.html">使用</a></li> 
      <li><a href="package-tree.html">树</a></li> 
      <li><a href="../../../../deprecated-list.html">已过时的</a></li> 
      <li><a href="../../../../index-files/index-1.html">索引</a></li> 
      <li><a href="../../../../help-doc.html">帮助</a></li> 
     </ul> 
     <div class="aboutLanguage"> 
      <div style="margin-top: 14px;"> 
       <strong>Java SE 11 &amp; JDK 11</strong> 
      </div> 
     </div> 
    </div> 
    <div class="subNav"> 
     <ul class="navList" id="allclasses_navbar_bottom"> 
      <li><a href="../../../../allclasses.html">所有类</a></li> 
     </ul> 
     <div> 
      <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
      <noscript> 
       <div>
         JavaScript is disabled on your browser. 
       </div> 
      </noscript> 
     </div> 
     <div> 
      <ul class="subNavList"> 
       <li>概要：&nbsp;</li> 
       <li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li> 
       <li>字段&nbsp;|&nbsp;</li> 
       <li>构造方法&nbsp;|&nbsp;</li> 
       <li><a href="#method.summary">方法</a></li> 
      </ul> 
      <ul class="subNavList"> 
       <li>详细信息：&nbsp;</li> 
       <li>字段&nbsp;|&nbsp;</li> 
       <li>构造方法&nbsp;|&nbsp;</li> 
       <li><a href="#method.detail">方法</a></li> 
      </ul> 
     </div> 
     <a id="skip.navbar.bottom"> 
      <!--   --> </a> 
    </div> 
    <!-- ======== END OF BOTTOM NAVBAR ======= --> 
   </nav> 
   <p class="legalCopy"><small><a href="http://bugreport.java.com/bugreport/">Report a bug or suggest an enhancement</a><br> For further API reference and developer documentation see the <a href="http://www.oracle.com/pls/topic/lookup?ctx=javase11.0.1&amp;id=homepage" target="_blank">Java SE Documentation</a>, which contains more detailed, developer-targeted descriptions with conceptual overviews, definitions of terms, workarounds, and working code examples.<br> Java is a trademark or registered trademark of Oracle and/or its affiliates in the US and other countries.<br> <a href="../../../../../legal/copyright.html">Copyright</a> © 1993, 2018, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.<br>All rights reserved. Use is subject to <a href="http://www.oracle.com/technetwork/java/javase/terms/license/java11.0.1speclicense.html">license terms</a> and the <a href="http://www.oracle.com/technetwork/java/redist-137594.html">documentation redistribution policy</a>. 
     <!-- Version 11.0.1+13-LTS --></small></p> 
  </footer>  
 </body>
</html>