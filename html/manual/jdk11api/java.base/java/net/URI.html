<!doctype html>
<!-- NewPage -->
<html lang="en">
 <head> 
  <!-- Generated by javadoc --> 
  <title>URI</title> 
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> 
  <meta name="keywords" content="java.net.URI class"> 
  <meta name="keywords" content="create()"> 
  <meta name="keywords" content="parseServerAuthority()"> 
  <meta name="keywords" content="normalize()"> 
  <meta name="keywords" content="resolve()"> 
  <meta name="keywords" content="relativize()"> 
  <meta name="keywords" content="toURL()"> 
  <meta name="keywords" content="getScheme()"> 
  <meta name="keywords" content="isAbsolute()"> 
  <meta name="keywords" content="isOpaque()"> 
  <meta name="keywords" content="getRawSchemeSpecificPart()"> 
  <meta name="keywords" content="getSchemeSpecificPart()"> 
  <meta name="keywords" content="getRawAuthority()"> 
  <meta name="keywords" content="getAuthority()"> 
  <meta name="keywords" content="getRawUserInfo()"> 
  <meta name="keywords" content="getUserInfo()"> 
  <meta name="keywords" content="getHost()"> 
  <meta name="keywords" content="getPort()"> 
  <meta name="keywords" content="getRawPath()"> 
  <meta name="keywords" content="getPath()"> 
  <meta name="keywords" content="getRawQuery()"> 
  <meta name="keywords" content="getQuery()"> 
  <meta name="keywords" content="getRawFragment()"> 
  <meta name="keywords" content="getFragment()"> 
  <meta name="keywords" content="equals()"> 
  <meta name="keywords" content="hashCode()"> 
  <meta name="keywords" content="compareTo()"> 
  <meta name="keywords" content="toString()"> 
  <meta name="keywords" content="toASCIIString()"> 
  <link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style"> 
  <link rel="stylesheet" type="text/css" href="../../../jquery/jquery-ui.css" title="Style"> 
  <script type="text/javascript" src="../../../script.js"></script> 
  <script type="text/javascript" src="../../../jquery/jszip/dist/jszip.js"></script> 
  <script type="text/javascript" src="../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script> 
  <!--[if IE]>
<script type="text/javascript" src="../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]--> 
  <script type="text/javascript" src="../../../jquery/jquery-1.10.2.js"></script> 
  <script type="text/javascript" src="../../../jquery/jquery-migrate-1.2.1.js"></script> 
  <script type="text/javascript" src="../../../jquery/jquery-ui.js"></script> 
 </head> 
 <body> <SCRIPT LANGUAGE="JavaScript"><!-- Hide  
   function ResumeError() {     return true;}window.onerror = ResumeError;// --></SCRIPT>
  <script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="URI (Java SE 11 & JDK 11 )";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":10,"i1":9,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10,"i24":10,"i25":10,"i26":10,"i27":10,"i28":10};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script> 
  <noscript> 
   <div>
     JavaScript is disabled on your browser. 
   </div> 
  </noscript> 
  <header role="banner"> 
   <nav role="navigation"> 
    <div class="fixedNav"> 
     <!-- ========= START OF TOP NAVBAR ======= --> 
     <div class="topNav"> 
      <a id="navbar.top"> 
       <!--   --> </a> 
      <div class="skipNav"> 
       <a href="#skip.navbar.top" title="Skip navigation links">跳过导航</a> 
      </div> 
      <a id="navbar.top.firstrow"> 
       <!--   --> </a> 
      <ul class="navList" title="Navigation"> 
       <li><a href="../../../index.html">概述</a></li> 
       <li><a href="../../module-summary.html">模块</a></li> 
       <li><a href="package-summary.html">软件包</a></li> 
       <li class="navBarCell1Rev">类</li> 
       <li><a href="class-use/URI.html">使用</a></li> 
       <li><a href="package-tree.html">树</a></li> 
       <li><a href="../../../deprecated-list.html">已过时的</a></li> 
       <li><a href="../../../index-files/index-1.html">索引</a></li> 
       <li><a href="../../../help-doc.html">帮助</a></li> 
      </ul> 
      <div class="aboutLanguage"> 
       <div style="margin-top: 14px;"> 
        <strong>Java SE 11 &amp; JDK 11</strong> 
       </div> 
      </div> 
     </div> 
     <div class="subNav"> 
      <ul class="navList" id="allclasses_navbar_top"> 
       <li><a href="../../../allclasses.html">所有类</a></li> 
      </ul> 
      <ul class="navListSearch"> 
       <li><label for="search">SEARCH:</label> <input type="text" id="search" value="search" disabled> <input type="reset" id="reset" value="reset" disabled> </li> 
      </ul> 
      <div> 
       <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
       <noscript> 
        <div>
          JavaScript is disabled on your browser. 
        </div> 
       </noscript> 
      </div> 
       <div class="fixedNav">
       <ul class="subNavList"> 
        <li>概要：&nbsp;</li> 
        <li>嵌套&nbsp;|&nbsp;</li> 
        <li>字段&nbsp;|&nbsp;</li> 
        <li><a href="#constructor.summary">构造方法</a>&nbsp;|&nbsp;</li> 
        <li><a href="#method.summary">方法</a></li> 
       </ul> 
       <ul class="subNavList"> 
        <li>详细信息：&nbsp;</li> 
        <li>字段&nbsp;|&nbsp;</li> 
        <li><a href="#constructor.detail">构造方法</a>&nbsp;|&nbsp;</li> 
        <li><a href="#method.detail">方法</a></li> 
       </ul> 
      </div> 
      <a id="skip.navbar.top"> 
       <!--   --> </a> 
     </div> 
     <!-- ========= END OF TOP NAVBAR ========= --> 
    </div> 
    <div class="navPadding">
      &nbsp; 
    </div> 
    <script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script> 
   </nav> 
  </header> 
  <!-- ======== START OF CLASS DATA ======== --> 
  <main role="main"> 
   <div class="header"> 
    <div class="subTitle"> 
     <span class="moduleLabelInType">模块</span>&nbsp; 
     <a href="../../module-summary.html">java.base</a> 
    </div> 
    <div class="subTitle"> 
     <span class="packageLabelInType">软件包</span>&nbsp; 
     <a href="package-summary.html">java.net</a> 
    </div> 
    <h2 title="Class URI" class="title">Class URI</h2> 
   </div> 
   <div class="contentContainer"> 
    <ul class="inheritance"> 
     <li><a href="../lang/Object.html" title="class in java.lang">java.lang.Object</a></li> 
     <li> 
      <ul class="inheritance"> 
       <li>java.net.URI</li> 
      </ul> </li> 
    </ul> 
    <div class="description"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <dl> 
        <dt>
          实现的所有接口
        </dt> 
        <dd> 
         <code><a href="../io/Serializable.html" title="interface in java.io">Serializable</a></code> ， 
         <code><a href="../lang/Comparable.html" title="interface in java.lang">Comparable</a>&lt;<a href="URI.html" title="class in java.net">URI</a>&gt;</code> 
        </dd> 
       </dl> 
       <hr> <pre>public final class <span class="typeNameLabel">URI</span>
extends <a href="../lang/Object.html" title="class in java.lang">Object</a>
implements <a href="../lang/Comparable.html" title="interface in java.lang">Comparable</a>&lt;<a href="URI.html" title="class in java.net">URI</a>&gt;, <a href="../io/Serializable.html" title="interface in java.io">Serializable</a></pre> 
       <div class="block"> 
        <span>表示统一资源标识符（URI）引用。</span> 
        <p> <span>除了下面指出的一些微小偏差，这个类的一个实例表示由所定义的URI引用<a href="http://www.ietf.org/rfc/rfc2396.txt"><i>RFC&nbsp;2396: Uniform Resource Identifiers (URI): Generic Syntax</i></a> ，通过修正<a href="http://www.ietf.org/rfc/rfc2732.txt"><i>RFC&nbsp;2732: Format for Literal IPv6 Addresses in URLs</i></a> 。</span> <span>Literal IPv6地址格式也支持scope_ids。</span> <span>scope_ids的语法和用法描述于<a href="Inet6Address.html#scoped">here</a> 。</span> <span>此类提供构造函数，用于从其组件创建URI实例，或者通过解析其字符串形式，访问实例的各个组件的方法以及规范化，解析和重新激活URI实例的方法。</span> <span>此类的实例是不可变的。</span> </p> 
        <h3> <span>URI语法和组件</span> </h3> 
        <span>在最高级别，字符串形式的URI引用（下文中简称为“URI”）具有语法</span> 
        <blockquote> 
         <span>[ <i>scheme</i> <b><code>:</code></b>] <i>scheme-specific-part</i>[ <b><code>#</code></b> <i>fragment</i>]</span> 
        </blockquote> 
        <span>方括号[...]描绘可选组件，字符<b><code>:</code></b>和<b><code>#</code></b>代表自己。</span> 
        <p> <span><i>绝对</i> URI指定方案;</span> <span>一个非绝对的URI被认为是<i>相对的</i> 。</span> <span>URI也根据它们是<i>不透明</i>还是<i>分层</i>来分类。</span> </p> 
        <p> <span><i>不透明</i> URI是绝对URI，其特定于方案的部分不以斜杠字符开头（ <code>'/'</code> ）。</span> <span>不透明的URI不需要进一步解析。</span> <span>不透明URI的一些示例是：</span> </p> 
        <blockquote> 
         <span>
          <ul style="list-style-type:none"> 
           <li><code>mailto:java-net@java.sun.com</code></li> 
           <li><code>news:comp.lang.java</code></li> 
           <li><code>urn:isbn:096139210x</code></li> 
          </ul></span> 
        </blockquote> 
        <p> <span><i>分层</i> URI是绝对URI，其特定于方案的部分以斜杠字符开头，或者是相对URI，即不指定方案的URI。</span> <span>分层URI的一些示例是：</span> </p> 
        <blockquote> 
         <span><code>http://example.com/languages/java/</code> <br> <code>sample/a/index.html#28</code> <br> <code>../../demo/b/index.html</code> <br> <code>file:///~/calendar</code></span> 
        </blockquote> 
        <p> <span>分层URI根据语法进行进一步解析</span> </p> 
        <blockquote> 
         <span>[ <i>scheme</i> <b><code>:</code></b>][ <b><code>//</code></b> <i>authority</i>][ <i>path</i>][ <b><code>?</code></b> <i>query</i>][ <b><code>#</code></b> <i>fragment</i>]</span> 
        </blockquote> 
        <span>里的人物<b><code>:</code></b> ， <b><code>/</code></b> ， <b><code>?</code></b>和<b><code>#</code></b>代表它们自身。</span> 
        <span>分层URI的特定于方案的部分由方案和片段组件之间的字符组成。</span> 
        <p> <span>如果指定，则分层URI的授权组件可以是<i>基于服务器的</i> ，也可以是<i>基于</i> <i>注册表的</i> 。</span> <span>基于服务器的权限根据熟悉的语法进行解析</span> </p> 
        <blockquote> 
         <span>[ <i>user-info</i> <b><code>@</code></b>] <i>host</i>[ <b><code>:</code></b> <i>port</i>]</span> 
        </blockquote> 
        <span>其中人物<b><code>@</code></b>和<b><code>:</code></b>代表自己。</span> 
        <span>目前使用的几乎所有URI方案都是基于服务器的。</span> 
        <span>不以这种方式解析的权限组件被认为是基于注册表的。</span> 
        <p> <span>如果以斜杠字符开头，则分层URI的路径组件本身被认为是绝对的（ <code>'/'</code> ）;</span> <span>否则它是相对的。</span> <span>绝对或分配权限的分层URI的路径始终是绝对的。</span> </p> 
        <p> <span>总而言之，URI实例具有以下九个组件：</span> </p> 
        <span> Describes the components of a URI:scheme,scheme-specific-part,authority,user-info,host,port,path,query,fragment    Component Type     scheme <code>String</code>   scheme-specific-part <code>String</code>   authority <code>String</code>   user-info <code>String</code>   host <code>String</code>   port <code>int</code>   path <code>String</code>   query <code>String</code>   fragment <code>String</code>  </span> 
        <table class="striped" style="margin-left:2em"> 
        </table> 
        <span>在给定的实例中，任何特定组件<i>未定义</i>或使用不同的值<i>定义</i> 。</span> 
        <span>未定义的字符串组件由<code>null</code>表示，而未定义的整数组件由<code>-1</code>表示。</span> 
        <span>可以将字符串组件定义为将空字符串作为其值;</span> 
        <span>这不等于未定义的组件。</span> 
        <p> <span>是否在实例中定义特定组件取决于所表示的URI的类型。</span> <span>绝对URI具有方案组件。</span> <span>不透明URI具有方案，方案特定部分，可能还有片段，但没有其他组件。</span> <span>分层URI总是具有路径（尽管它可以是空的）和特定于方案的部分（至少包含路径），并且可以具有任何其他组件。</span> <span>如果授权组件存在且基于服务器，则将定义主机组件并且可以定义用户信息和端口组件。</span> </p> 
        <h4> <span>URI实例的操作</span> </h4> 
        <span>此类支持的关键操作是<i>规范化</i> ， <i>解析</i>和<i>相对化</i> 。</span> 
        <p> <span><i>规范化</i>是从分层URI的路径组件中删除不必要的<code>"."</code>和<code>".."</code>段的过程。</span> <span>每个<code>"."</code>段都被删除。</span> <span>甲<code>".."</code>如果它是由非前面段仅除去<code>".."</code>段。</span> <span>规范化对不透明URI没有影响。</span> </p> 
        <p> <span><i>解决方案</i>是将一个URI与另一个<i>基本</i> URI解析的过程。</span> <span>生成的URI以RFC 2396指定的方式从两个URI的组件构造，从基URI中获取未在原始URI中指定的组件。</span> <span>对于分层URI，原始路径将根据基础路径进行解析，然后进行规范化。</span> <span>结果，例如，解决</span> </p> 
        <blockquote> 
         <span><code>sample/a/index.html#28</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;(1)</span> 
        </blockquote> 
        <span>对基础URI <code>http://example.com/languages/java/</code>是结果URI</span> 
        <blockquote> 
         <span><code>http://example.com/languages/java/sample/a/index.html#28</code></span> 
        </blockquote> 
        <span>解析相对URI</span> 
        <blockquote> 
         <span><code>../../demo/b/index.html</code>&nbsp;&nbsp;&nbsp;&nbsp;(2)</span> 
        </blockquote> 
        <span>反对这个结果，反过来，</span> 
        <blockquote> 
         <span><code>http://example.com/languages/java/demo/b/index.html</code></span> 
        </blockquote> 
        <span>支持绝对和相对URI的解析，以及分层URI的绝对和相对路径的解析。</span> 
        <span>针对任何其他URI解析URI <code>file:///~calendar</code>只会产生原始URI，因为它是绝对的。</span> 
        <span>根据相对基URI（1）解析上面的相对URI（2）会产生规范化但仍然相对的URI</span> 
        <blockquote> 
         <span><code>demo/b/index.html</code></span> 
        </blockquote> 
        <p> <span>最后， <i>相对化</i>是解决方案的反转：对于任何两个规范化的URI <i>u</i>和<i>v</i> ，</span> </p> 
        <blockquote> 
         <span><i>u</i> <code>.relativize(</code> <i>u</i> <code>.resolve(</code> <i>v</i> <code>)).equals(</code> <i>v</i> <code>)</code>&nbsp;&nbsp;and <br> <i>u</i> <code>.resolve(</code> <i>u</i> <code>.relativize(</code> <i>v</i> <code>)).equals(</code> <i>v</i> <code>)</code>&nbsp;&nbsp;. <br></span> 
        </blockquote> 
        <span>在构造包含必须相对于文档的基URI的URI的文档时，此操作通常很有用。</span> 
        <span>例如，重新激活URI</span> 
        <blockquote> 
         <span><code>http://example.com/languages/java/sample/a/index.html#28</code></span> 
        </blockquote> 
        <span>针对基URI</span> 
        <blockquote> 
         <span><code>http://example.com/languages/java/</code></span> 
        </blockquote> 
        <span>产生相对URI <code>sample/a/index.html#28</code> 。</span> 
        <h4> <span>人物类别</span> </h4> 
        <span>RFC 2396精确指定URI引用的各个组件中允许哪些字符。</span> 
        <span>以下类别（大部分取自该规范）在下面用于描述这些约束：</span> 
        <span> Describes categories alpha,digit,alphanum,unreserved,punct,reserved,escaped,and other    Category Description     alpha The US-ASCII alphabetic characters, <code>'A'</code>&nbsp;through&nbsp;<code>'Z'</code> and <code>'a'</code>&nbsp;through&nbsp;<code>'z'</code>   digit The US-ASCII decimal digit characters, <code>'0'</code>&nbsp;through&nbsp;<code>'9'</code>   alphanum All <i>alpha</i> and <i>digit</i> characters   unreserved All <i>alphanum</i> characters together with those in the string <code>"_-!.~'()*"</code>   punct The characters in the string <code>",;:$&amp;+="</code>   reserved All <i>punct</i> characters together with those in the string <code>"?/[]@"</code>   escaped Escaped octets, that is, triplets consisting of the percent character (<code>'%'</code>) followed by two hexadecimal digits (<code>'0'</code>-<code>'9'</code>, <code>'A'</code>-<code>'F'</code>, and <code>'a'</code>-<code>'f'</code>)   other The Unicode characters that are not in the US-ASCII character set, are not control characters (according to the <a href="../lang/Character.html#isISOControl(char)"><code>Character.isISOControl</code></a> method), and are not space characters (according to the <a href="../lang/Character.html#isSpaceChar(char)"><code>Character.isSpaceChar</code></a> method)&nbsp;&nbsp;<i>(<b>Deviation from RFC 2396</b>, which is limited to US-ASCII)</i>  </span> 
        <table class="striped" style="margin-left:2em"> 
        </table> 
        <p> <span><a id="legal-chars"></a>所有合法URI字符集由<i>未保留</i> ， <i>保留</i> ， <i>转义</i>和<i>其他</i>字符组成。</span> </p> 
        <h4> <span>转义的八位字节，引用，编码和解码</span> </h4> 
        <span>RFC 2396允许转义的八位字节出现在用户信息，路径，查询和片段组件中。</span> 
        <span>转义在URI中有两个用途：</span> 
        <ul> 
         <li><p> <span>当需要URI严格遵守RFC 2396而不包含任何<i>其他</i>字符时，要<i>编码</i>非US-ASCII字符。</span> </p></li> 
         <li><p> <span><i>引用</i>组件中非法的字符。</span> <span>用户信息，路径，查询和片段组件在哪些字符被视为合法和非法时略有不同。</span> </p></li> 
        </ul> 
        <span>这一目的在本课程中由三个相关操作提供：</span> 
        <ul> 
         <li><p> <span><a id="encode"></a>的字符通过用转义八位组表示在UTF-8字符集的字符的序列替换它<i>编码</i> 。</span> <span>例如，欧元货币符号（ <code>'\u20AC'</code> ）编码为<code>"%E2%82%AC"</code> 。</span> <span><i>（ <b>与RFC 2396的偏差</b> ，它没有指定任何特定的字符集。）</i></span> </p></li> 
         <li><p> <span><a id="quote"></a>简单地通过编码来<i>引用</i>非法字符。</span> <span>例如，空格字符通过将其替换为<code>"%20"</code>来引用。</span> <span>UTF-8包含US-ASCII，因此对于US-ASCII字符，此转换具有RFC 2396所要求的效果。</span> </p></li> 
         <li><p> <span><a id="decode"></a>转义的八位字节序列通过将其替换为UTF-8字符集中表示的字符序列进行<i>解码</i> 。</span> <span>UTF-8包含US-ASCII，因此解码具有取消引用任何引用的US-ASCII字符以及解码任何编码的非US-ASCII字符的效果。</span> <span>如果<a href="../nio/charset/CharsetDecoder.html#ce">decoding error</a>解码转义八位组，则错误的八位位组被更换时发生<code>'\uFFFD'</code> ，Unicode替换字符。</span> </p></li> 
        </ul> 
        <span>这些操作在此类的构造函数和方法中公开，如下所示：</span> 
        <ul> 
         <li><p> <span><a href="#%3Cinit%3E(java.lang.String)">single-argument constructor</a>要求引用其参数中的任何非法字符，并保留任何转义的八位字节和<i>其他</i>存在的字符。</span> </p></li> 
         <li><p> <span><a href="#%3Cinit%3E(java.lang.String,java.lang.String,java.lang.String,int,java.lang.String,java.lang.String,java.lang.String)">multi-argument constructors</a>引用它们出现的组件所需的非法字符。</span> <span>百分比字符（ <code>'%'</code> ）始终由这些构造函数引用。</span> <span>保留任何<i>其他</i>字符。</span> </p></li> 
         <li><p> <span>的<a href="#getRawUserInfo()"><code>getRawUserInfo</code></a> ， <a href="#getRawPath()"><code>getRawPath</code></a> ， <a href="#getRawQuery()"><code>getRawQuery</code></a> ， <a href="#getRawFragment()"><code>getRawFragment</code></a> ， <a href="#getRawAuthority()"><code>getRawAuthority</code></a> ，和<a href="#getRawSchemeSpecificPart()"><code>getRawSchemeSpecificPart</code></a>方法返回原始形式及其相应的分量的值，而不用解释任何转义八位组。</span> <span>这些方法返回的字符串可能包含转义的八位字节和<i>其他</i>字符，并且不包含任何非法字符。</span> </p></li> 
         <li><p> <span>的<a href="#getUserInfo()"><code>getUserInfo</code></a> ， <a href="#getPath()"><code>getPath</code></a> ， <a href="#getQuery()"><code>getQuery</code></a> ， <a href="#getFragment()"><code>getFragment</code></a> ， <a href="#getAuthority()"><code>getAuthority</code></a> ，和<a href="#getSchemeSpecificPart()"><code>getSchemeSpecificPart</code></a>方法解码任何逃脱在它们的对应部件的八位字节。</span> <span>这些方法返回的字符串可能包含<i>其他</i>字符和非法字符，并且不包含任何转义的八位字节。</span> </p></li> 
         <li><p> <span><a href="#toString()"><code>toString</code></a>方法返回一个URI字符串，其中包含所有必需的引号，但可能包含<i>其他</i>字符。</span> </p></li> 
         <li><p> <span><a href="#toASCIIString()"><code>toASCIIString</code></a>方法返回一个完全引用并编码的URI字符串，该字符串不包含任何<i>其他</i>字符。</span> </p></li> 
        </ul> 
        <h4> <span>身份</span> </h4> 
        <span>对于任何URI <i>U，</i>它始终是情况</span> 
        <blockquote> 
         <span><code>new URI(</code> <i>u</i> <code>.toString()).equals(</code> <i>u</i> <code>)</code>&nbsp;.</span> 
        </blockquote> 
        <span>对于任何<i>URIÜ</i>不包含一个空的机构（如在之前的冗余语法如两个斜杠<code>file:///tmp/</code>以下一个主机名，但没有端口（如在）或冒号<code>http://java.sun.com:</code> ），并且不除了那些必须是字符进行编码引用，以下身份也有：</span> 
        <pre>  <span>new URI(<i>u</i>.getScheme(),
             <i>u</i>.getSchemeSpecificPart(),
             <i>u</i>.getFragment())
     .equals(<i>u</i>)</span> </pre> 
        <span>在所有情况下，</span> 
        <pre>  <span>new URI(<i>u</i>.getScheme(),
             <i>u</i>.getAuthority(),
             <i>u</i>.getPath(), <i>u</i>.getQuery(),
             <i>u</i>.getFragment())
     .equals(<i>u</i>)</span> </pre> 
        <span>如果<i>你</i>是等级的，</span> 
        <pre>  <span>new URI(<i>u</i>.getScheme(),
             <i>u</i>.getUserInfo(), <i>u</i>.getHost(), <i>u</i>.getPort(),
             <i>u</i>.getPath(), <i>u</i>.getQuery(),
             <i>u</i>.getFragment())
     .equals(<i>u</i>)</span> </pre> 
        <span>如果<i>你</i>是分层的，没有权限或基于服务器的权限。</span> 
        <h4> <span>URI，URL和URN</span> </h4> 
        <span>URI是统一资源<i>标识符，</i>而URL是统一资源<i>定位符</i> 。</span> 
        <span>因此，抽象地说，每个URL都是一个URI，但不是每个URI都是一个URL。</span> 
        <span>这是因为URI的另一个子类别，统一资源<i>名称</i> （URN），它们命名资源但不指定如何定位它们。</span> 
        <span>的<code>mailto</code> ， <code>news</code> ，和<code>isbn</code>上面所示URI是的URN的例子。</span> 
        <p> <span>URI和URL之间的概念区别反映在此类与<a href="URL.html" title="java.net中的类"><code>URL</code></a>类之间的差异中。</span> </p> 
        <p> <span>此类的实例表示RFC 2396定义的语法意义上的URI引用.URI可以是绝对的或相对的。</span> <span>根据通用语法解析URI字符串，而不考虑它指定的方案（如果有的话）。</span> <span>不执行主机查找（如果有），并且不构造依赖于方案的流处理程序。</span> <span>严格按照实例的字符内容定义等同，散列和比较。</span> <span>换句话说，URI实例只不过是一个结构化字符串，它支持比较，规范化，解析和相对化的语法，与方案无关的操作。</span> </p> 
        <p> <span>相比之下， <a href="URL.html" title="java.net中的类"><code>URL</code></a>类的实例表示URL的语法组件以及访问其描述的资源所需的一些信息。</span> <span>URL必须是绝对的，也就是说，它必须始终指定方案。</span> <span>根据其方案解析URL字符串。</span> <span>始终为URL建立流处理程序，实际上，无法为没有可用处理程序的方案创建URL实例。</span> <span>平等和散列取决于主机的方案和互联网地址，如果有的话;</span> <span>比较没有定义。</span> <span>换句话说，URL是一种结构化字符串，它支持解析的语法操作以及查找主机和打开与指定资源的连接的网络I / O操作。</span> </p> 
       </div> 
       <dl> 
        <dt> 
         <span class="simpleTagLabel">从以下版本开始：</span> 
        </dt> 
        <dd>
          1.4 
        </dd> 
        <dt> 
         <span class="seeLabel">另请参见：</span> 
        </dt> 
        <dd> 
         <span><a href="http://www.ietf.org/rfc/rfc2279.txt"><i>RFC&nbsp;2279: UTF-8, a transformation format of ISO 10646</i></a> ，</span> 
         <br> 
         <span><a href="http://www.ietf.org/rfc/rfc2373.txt"><i>RFC&nbsp;2373: IPv6 Addressing Architecture</i></a> ，</span> 
         <br> 
         <span><a href="http://www.ietf.org/rfc/rfc2396.txt"><i>RFC&nbsp;2396: Uniform Resource Identifiers (URI): Generic Syntax</i></a> ，</span> 
         <br> 
         <span><a href="http://www.ietf.org/rfc/rfc2732.txt"><i>RFC&nbsp;2732: Format for Literal IPv6 Addresses in URLs</i></a> ，</span> 
         <br> 
         <span><a href="URISyntaxException.html">URISyntaxException</a> ， <a href="../../../serialized-form.html#java.net.URI">Serialized Form</a></span> 
        </dd> 
       </dl> </li> 
     </ul> 
    </div> 
    <div class="summary"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <!-- ======== CONSTRUCTOR SUMMARY ======== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="constructor.summary"> 
           <!--   --> </a> <h3>构造方法摘要</h3> 
          <table class="memberSummary"> 
           <caption> 
            <span>构造方法</span> 
            <span class="tabEnd">&nbsp;</span> 
           </caption> 
           <tbody> 
            <tr> 
             <th class="colFirst" scope="col">构造器</th> 
             <th class="colLast" scope="col">描述</th> 
            </tr> 
            <tr class="altColor"> 
             <th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E(java.lang.String)">URI</a></span>​(<a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;str)</code></th> 
             <td class="colLast"> 
              <div class="block">
                通过解析给定的字符串构造URI。 
              </div> </td> 
            </tr> 
            <tr class="rowColor"> 
             <th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E(java.lang.String,java.lang.String,java.lang.String)">URI</a></span>​(<a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;scheme, <a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;ssp, <a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;fragment)</code></th> 
             <td class="colLast"> 
              <div class="block">
                根据给定的组件构造URI。 
              </div> </td> 
            </tr> 
            <tr class="altColor"> 
             <th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E(java.lang.String,java.lang.String,java.lang.String,int,java.lang.String,java.lang.String,java.lang.String)">URI</a></span>​(<a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;scheme, <a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;userInfo, <a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;host, int&nbsp;port, <a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;path, <a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;query, <a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;fragment)</code></th> 
             <td class="colLast"> 
              <div class="block">
                根据给定组件构造分层URI。 
              </div> </td> 
            </tr> 
            <tr class="rowColor"> 
             <th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E(java.lang.String,java.lang.String,java.lang.String,java.lang.String)">URI</a></span>​(<a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;scheme, <a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;host, <a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;path, <a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;fragment)</code></th> 
             <td class="colLast"> 
              <div class="block">
                根据给定组件构造分层URI。 
              </div> </td> 
            </tr> 
            <tr class="altColor"> 
             <th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)">URI</a></span>​(<a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;scheme, <a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;authority, <a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;path, <a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;query, <a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;fragment)</code></th> 
             <td class="colLast"> 
              <div class="block">
                根据给定组件构造分层URI。 
              </div> </td> 
            </tr> 
           </tbody> 
          </table> </li> 
        </ul> 
       </section> 
       <!-- ========== METHOD SUMMARY =========== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="method.summary"> 
           <!--   --> </a> <h3>方法摘要</h3> 
          <table class="memberSummary"> 
           <caption> 
           <span id="t0" class="activeTableTab"><span>所有方法</span><span class="tabEnd">&nbsp;</span>
            <span id="t1" class="tableTab"><span><a href="javascript:show(1);">静态方法</a></span><span class="tabEnd">&nbsp;</span></span> 
             <span id="t2" class="tableTab"><span><a href="javascript:show(2);">实例方法</a>  </span></span> 
            <span id="t4" class="tableTab"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd">&nbsp;</span></span> 
           </caption> 
           <tbody> 
            <tr> 
             <th class="colFirst" scope="col">变量和类型</th> 
             <th class="colSecond" scope="col">方法</th> 
             <th class="colLast" scope="col">描述</th> 
            </tr> 
            <tr id="i0" class="altColor"> 
             <td class="colFirst"><code>int</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#compareTo(java.net.URI)">compareTo</a></span>​(<a href="URI.html" title="class in java.net">URI</a>&nbsp;that)</code></th> 
             <td class="colLast"> 
              <div class="block">
                将此URI与另一个对象进行比较，该对象必须是URI。 
              </div> </td> 
            </tr> 
            <tr id="i1" class="rowColor"> 
             <td class="colFirst"><code>static <a href="URI.html" title="class in java.net">URI</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#create(java.lang.String)">create</a></span>​(<a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;str)</code></th> 
             <td class="colLast"> 
              <div class="block">
                通过解析给定的字符串来创建URI。 
              </div> </td> 
            </tr> 
            <tr id="i2" class="altColor"> 
             <td class="colFirst"><code>boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#equals(java.lang.Object)">equals</a></span>​(<a href="../lang/Object.html" title="class in java.lang">Object</a>&nbsp;ob)</code></th> 
             <td class="colLast"> 
              <div class="block">
                测试此URI与另一个对象的相等性。 
              </div> </td> 
            </tr> 
            <tr id="i3" class="rowColor"> 
             <td class="colFirst"><code><a href="../lang/String.html" title="class in java.lang">String</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getAuthority()">getAuthority</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回此URI的已解码授权组件。 
              </div> </td> 
            </tr> 
            <tr id="i4" class="altColor"> 
             <td class="colFirst"><code><a href="../lang/String.html" title="class in java.lang">String</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getFragment()">getFragment</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回此URI的已解码片段组件。 
              </div> </td> 
            </tr> 
            <tr id="i5" class="rowColor"> 
             <td class="colFirst"><code><a href="../lang/String.html" title="class in java.lang">String</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getHost()">getHost</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回此URI的主机组件。 
              </div> </td> 
            </tr> 
            <tr id="i6" class="altColor"> 
             <td class="colFirst"><code><a href="../lang/String.html" title="class in java.lang">String</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getPath()">getPath</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回此URI的已解码路径组件。 
              </div> </td> 
            </tr> 
            <tr id="i7" class="rowColor"> 
             <td class="colFirst"><code>int</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getPort()">getPort</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回此URI的端口号。 
              </div> </td> 
            </tr> 
            <tr id="i8" class="altColor"> 
             <td class="colFirst"><code><a href="../lang/String.html" title="class in java.lang">String</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getQuery()">getQuery</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回此URI的已解码查询组件。 
              </div> </td> 
            </tr> 
            <tr id="i9" class="rowColor"> 
             <td class="colFirst"><code><a href="../lang/String.html" title="class in java.lang">String</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getRawAuthority()">getRawAuthority</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回此URI的原始授权组件。 
              </div> </td> 
            </tr> 
            <tr id="i10" class="altColor"> 
             <td class="colFirst"><code><a href="../lang/String.html" title="class in java.lang">String</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getRawFragment()">getRawFragment</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回此URI的原始片段组件。 
              </div> </td> 
            </tr> 
            <tr id="i11" class="rowColor"> 
             <td class="colFirst"><code><a href="../lang/String.html" title="class in java.lang">String</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getRawPath()">getRawPath</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回此URI的原始路径组件。 
              </div> </td> 
            </tr> 
            <tr id="i12" class="altColor"> 
             <td class="colFirst"><code><a href="../lang/String.html" title="class in java.lang">String</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getRawQuery()">getRawQuery</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回此URI的原始查询组件。 
              </div> </td> 
            </tr> 
            <tr id="i13" class="rowColor"> 
             <td class="colFirst"><code><a href="../lang/String.html" title="class in java.lang">String</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getRawSchemeSpecificPart()">getRawSchemeSpecificPart</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回此URI的原始方案特定部分。 
              </div> </td> 
            </tr> 
            <tr id="i14" class="altColor"> 
             <td class="colFirst"><code><a href="../lang/String.html" title="class in java.lang">String</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getRawUserInfo()">getRawUserInfo</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回此URI的原始用户信息组件。 
              </div> </td> 
            </tr> 
            <tr id="i15" class="rowColor"> 
             <td class="colFirst"><code><a href="../lang/String.html" title="class in java.lang">String</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getScheme()">getScheme</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回此URI的scheme组件。 
              </div> </td> 
            </tr> 
            <tr id="i16" class="altColor"> 
             <td class="colFirst"><code><a href="../lang/String.html" title="class in java.lang">String</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getSchemeSpecificPart()">getSchemeSpecificPart</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回此URI的已解码方案特定部分。 
              </div> </td> 
            </tr> 
            <tr id="i17" class="rowColor"> 
             <td class="colFirst"><code><a href="../lang/String.html" title="class in java.lang">String</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getUserInfo()">getUserInfo</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回此URI的已解码用户信息组件。 
              </div> </td> 
            </tr> 
            <tr id="i18" class="altColor"> 
             <td class="colFirst"><code>int</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hashCode()">hashCode</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回此URI的哈希码值。 
              </div> </td> 
            </tr> 
            <tr id="i19" class="rowColor"> 
             <td class="colFirst"><code>boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isAbsolute()">isAbsolute</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                判断此URI是否是绝对的。 
              </div> </td> 
            </tr> 
            <tr id="i20" class="altColor"> 
             <td class="colFirst"><code>boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isOpaque()">isOpaque</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                判断此URI是否不透明。 
              </div> </td> 
            </tr> 
            <tr id="i21" class="rowColor"> 
             <td class="colFirst"><code><a href="URI.html" title="class in java.net">URI</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#normalize()">normalize</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                规范化此URI的路径。 
              </div> </td> 
            </tr> 
            <tr id="i22" class="altColor"> 
             <td class="colFirst"><code><a href="URI.html" title="class in java.net">URI</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#parseServerAuthority()">parseServerAuthority</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                尝试将此URI的权限组件（如果已定义）解析为用户信息，主机和端口组件。 
              </div> </td> 
            </tr> 
            <tr id="i23" class="rowColor"> 
             <td class="colFirst"><code><a href="URI.html" title="class in java.net">URI</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#relativize(java.net.URI)">relativize</a></span>​(<a href="URI.html" title="class in java.net">URI</a>&nbsp;uri)</code></th> 
             <td class="colLast"> 
              <div class="block">
                根据此URI重新激活给定的URI。 
              </div> </td> 
            </tr> 
            <tr id="i24" class="altColor"> 
             <td class="colFirst"><code><a href="URI.html" title="class in java.net">URI</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#resolve(java.lang.String)">resolve</a></span>​(<a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;str)</code></th> 
             <td class="colLast"> 
              <div class="block">
                通过解析给定的字符串然后针对此URI解析它来构造新的URI。 
              </div> </td> 
            </tr> 
            <tr id="i25" class="rowColor"> 
             <td class="colFirst"><code><a href="URI.html" title="class in java.net">URI</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#resolve(java.net.URI)">resolve</a></span>​(<a href="URI.html" title="class in java.net">URI</a>&nbsp;uri)</code></th> 
             <td class="colLast"> 
              <div class="block">
                根据此URI解析给定的URI。 
              </div> </td> 
            </tr> 
            <tr id="i26" class="altColor"> 
             <td class="colFirst"><code><a href="../lang/String.html" title="class in java.lang">String</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toASCIIString()">toASCIIString</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                以US-ASCII字符串形式返回此URI的内容。 
              </div> </td> 
            </tr> 
            <tr id="i27" class="rowColor"> 
             <td class="colFirst"><code><a href="../lang/String.html" title="class in java.lang">String</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toString()">toString</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                以字符串形式返回此URI的内容。 
              </div> </td> 
            </tr> 
            <tr id="i28" class="altColor"> 
             <td class="colFirst"><code><a href="URL.html" title="class in java.net">URL</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toURL()">toURL</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                根据此URI构造URL。 
              </div> </td> 
            </tr> 
           </tbody> 
          </table> 
          <ul class="blockList"> 
           <li class="blockList"><a id="methods.inherited.from.class.java.lang.Object"> 
             <!--   --> </a> <h3>声明方法的类&nbsp;java.lang.<a href="../lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../lang/Object.html#clone()">clone</a>, <a href="../lang/Object.html#finalize()">finalize</a>, <a href="../lang/Object.html#getClass()">getClass</a>, <a href="../lang/Object.html#notify()">notify</a>, <a href="../lang/Object.html#notifyAll()">notifyAll</a>, <a href="../lang/Object.html#wait()">wait</a>, <a href="../lang/Object.html#wait(long)">wait</a>, <a href="../lang/Object.html#wait(long,int)">wait</a></code></li> 
          </ul> </li> 
        </ul> 
       </section> </li> 
     </ul> 
    </div> 
    <div class="details"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <!-- ========= CONSTRUCTOR DETAIL ======== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="constructor.detail"> 
           <!--   --> </a> <h3>构造方法详细信息</h3> <a id="<init>(java.lang.String)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>URI</h4> <pre>public&nbsp;URI​(<a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;str)
    throws <a href="URISyntaxException.html" title="class in java.net">URISyntaxException</a></pre> 
            <div class="block"> 
             <span>通过解析给定的字符串构造URI。</span> 
             <p> <span>此构造函数完全按照<a href="http://www.ietf.org/rfc/rfc2396.txt">RFC&nbsp;2396</a>附录A中的语法指定解析给定字符串， <b><i>但以下偏差除外：</i></b></span> </p> 
             <ul> 
              <li><p> <span>只要后面跟着非空路径，查询组件或片段组件，就允许空权限组件。</span> <span>这允许解析URI，例如<code>"file:///foo/bar"</code> ，这似乎是RFC 2396的意图，尽管语法不允许它。</span> <span>如果权限组件为空，则用户信息，主机和端口组件未定义。</span> </p></li> 
              <li><p> <span>允许空的相对路径;</span> <span>这似乎是RFC 2396的意图，尽管语法不允许它。</span> <span>这种偏差的主要后果是，诸如<code>"#foo"</code>的独立片段作为具有空路径和给定片段的相对URI进行解析，并且对于基URI可以是有用的<a href="#resolve-frag">resolved</a> 。</span> </p></li> 
              <li><p> <span>主机组件中的IPv4地址严格解析，如<a href="http://www.ietf.org/rfc/rfc2732.txt">RFC&nbsp;2732</a>所指定：虚线四元组地址的每个元素必须包含不超过三个十进制数字。</span> <span>每个元素进一步约束为具有不大于255的值。</span> </p></li> 
              <li><p> <span>仅包含单个域标签的主机组件中的主机名允许以<i>字母</i>字符开头。</span> <span>这似乎是<a href="http://www.ietf.org/rfc/rfc2396.txt">RFC&nbsp;2396</a>第3.2.2节的意图，尽管语法不允许它。</span> <span>这种偏差的后果是分层URI的权限组件（如<code>s://123</code> ）将作为基于服务器的权限进行解析。</span> </p></li> 
              <li><p> <span>主机组件允许使用IPv6地址。</span> <span>IPv6地址必须用<code>']'</code>指定的方括号（ <code>'['</code>和<code>']'</code> ） <a href="http://www.ietf.org/rfc/rfc2732.txt">括起来</a> 。</span> <span>IPv6地址本身必须根据<a href="http://www.ietf.org/rfc/rfc2373.txt">RFC&nbsp;2373进行</a>解析。</span> <span>IPv6地址进一步受限于描述不超过16个字节的地址信息，这是RFC 2373中隐含但在语法中不可表达的约束。</span> </p></li> 
              <li><p> <span>RFC 2396允许<i>转义的</i>八位字节，即用户信息，路径，查询和片段组件，以及权限是基于注册表的权限组件中允许的是<i>其他</i>类别中的字符。</span> <span>这允许URI包含超出US-ASCII字符集中的Unicode字符。</span> </p></li> 
             </ul> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>str</code> - 要解析为URI的字符串 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
              <code>str</code>是 
              <code>null</code> 
             </dd> 
             <dd> 
              <code><a href="URISyntaxException.html" title="class in java.net">URISyntaxException</a></code> - 如果给定的字符串违反RFC 2396， 
              <code><a href="URISyntaxException.html" title="class in java.net">URISyntaxException</a></code>因上述偏差而增加 
             </dd> 
            </dl> </li> 
          </ul> <a id="<init>(java.lang.String,java.lang.String,java.lang.String,int,java.lang.String,java.lang.String,java.lang.String)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>URI</h4> <pre>public&nbsp;URI​(<a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;scheme,
           <a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;userInfo,
           <a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;host,
           int&nbsp;port,
           <a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;path,
           <a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;query,
           <a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;fragment)
    throws <a href="URISyntaxException.html" title="class in java.net">URISyntaxException</a></pre> 
            <div class="block"> 
             <span>根据给定组件构造分层URI。</span> 
             <p> <span>如果给出了一个方案，那么路径（如果也是给定的话）必须为空或以斜杠字符开头（ <code>'/'</code> ）。</span> <span>否则，新的URI的一个部件可以被留下通过使未定义<code>null</code>对于相应的参数，或者在所述的情况下<code>port</code>参数，通过使<code>-1</code> 。</span> </p> 
             <p> <span>此构造函数首先根据<a href="http://www.ietf.org/rfc/rfc2396.txt">RFC&nbsp;2396</a> ，第5.2节，第7步中指定的规则从给定组件构建URI字符串：</span> </p> 
             <ol> 
              <li><p> <span>最初，结果字符串为空。</span> </p></li> 
              <li><p> <span>如果给出了一个方案，那么它将附加到结果中，后跟一个冒号字符（ <code>':'</code> ）。</span> </p></li> 
              <li><p> <span>如果给出用户信息，主机或端口，则附加字符串<code>"//"</code> 。</span> </p></li> 
              <li><p> <span>如果给出了用户信息，则附加它，然后是商业广告字符（ <code>'@'</code> ）。</span> <span>任何不在非<i>保留</i> ， <i>突破</i> ， <i>转义</i>或<i>其他</i>类别中的<a href="#quote">字符</a>是<a href="#quote">quoted</a> 。</span> </p></li> 
              <li><p> <span>如果给出主机，则附加主机。</span> <span>如果主机是文字IPv6地址但未包含在方括号（ <code>'['</code>和<code>']'</code> ）中，则会添加方括号。</span> </p></li> 
              <li><p> <span>如果给出了端口号，则附加一个冒号字符（ <code>':'</code> ），后跟十进制的端口号。</span> </p></li> 
              <li><p> <span>如果给出了路径，则附加路径。</span> <span>引用任何不在<i>未保留</i> ， <i>突破</i> ， <i>转义</i>或<i>其他</i>类别中且不等于斜杠字符（ <code>'/'</code> ）或商业广告字符（ <code>'@'</code> ）的字符。</span> </p></li> 
              <li><p> <span>如果给出查询，则追加问号字符（ <code>'?'</code> ），然后追加查询。</span> <span>引用任何不是<a href="#legal-chars">legal URI character的</a>字符。</span> </p></li> 
              <li><p> <span>最后，如果给出片段，则附加散列字符（ <code>'#'</code> ），然后是片段。</span> <span>引用任何非合法URI字符的字符。</span> </p></li> 
             </ol> 
             <p> <span>然后通过调用<a href="#%3Cinit%3E(java.lang.String)"><code>URI(String)</code></a>构造函数然后在结果上调用<a href="#parseServerAuthority()"><code>parseServerAuthority()</code></a>方法来解析生成的URI字符串;</span> <span>这可能会导致<a href="URISyntaxException.html" title="java.net中的类"><code>URISyntaxException</code></a>被抛出。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>scheme</code> - 方案名称 
             </dd> 
             <dd> 
              <code>userInfo</code> - 用户名和授权信息 
             </dd> 
             <dd> 
              <code>host</code> - 主机名 
             </dd> 
             <dd> 
              <code>port</code> - 端口号 
             </dd> 
             <dd> 
              <code>path</code> - 路径 
             </dd> 
             <dd> 
              <code>query</code> - 查询 
             </dd> 
             <dd> 
              <code>fragment</code> - 片段 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="URISyntaxException.html" title="class in java.net">URISyntaxException</a></code> - 如果同时给出了方案和路径，但路径是相对的，如果从给定组件构造的URI字符串违反RFC 2396，或者字符串的权限组件存在但无法解析为基于服务器的权限 
             </dd> 
            </dl> </li> 
          </ul> <a id="<init>(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>URI</h4> <pre>public&nbsp;URI​(<a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;scheme,
           <a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;authority,
           <a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;path,
           <a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;query,
           <a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;fragment)
    throws <a href="URISyntaxException.html" title="class in java.net">URISyntaxException</a></pre> 
            <div class="block"> 
             <span>根据给定组件构造分层URI。</span> 
             <p> <span>如果给出了一个方案，那么路径（如果也是给定的话）必须为空或以斜杠字符开头（ <code>'/'</code> ）。</span> <span>否则，通过传递<code>null</code>作为相应参数，可以保留新URI的组件未定义。</span> </p> 
             <p> <span>此构造函数首先根据<a href="http://www.ietf.org/rfc/rfc2396.txt">RFC&nbsp;2396</a>第5.2节第7步中指定的规则从给定组件构建URI字符串：</span> </p> 
             <ol> 
              <li><p> <span>最初，结果字符串为空。</span> </p></li> 
              <li><p> <span>如果给出了一个方案，那么它将附加到结果中，后跟一个冒号字符（ <code>':'</code> ）。</span> </p></li> 
              <li><p> <span>如果给出了<code>"//"</code>则附加字符串<code>"//"</code> ，然后是权限。</span> <span>如果权限包含文字IPv6地址，则地址必须用方括号括起来（ <code>'['</code>和<code>']'</code> ）。</span> <span>任何不属于<i>无保留</i> ， <i>被盗</i> ， <i>逃脱</i>或<i>其他</i>类别且不等于商业角色（ <code>'@'</code> ）的角色是<a href="#quote">quoted</a> 。</span> </p></li> 
              <li><p> <span>如果给出了路径，则附加路径。</span> <span>引用任何不在<i>未保留</i> ， <i>突破</i> ， <i>转义</i>或<i>其他</i>类别中且不等于斜杠字符（ <code>'/'</code> ）或商业广告字符（ <code>'@'</code> ）的字符。</span> </p></li> 
              <li><p> <span>如果给出查询，则追加问号字符（ <code>'?'</code> ），然后追加查询。</span> <span>引用任何不是<a href="#legal-chars">legal URI character的</a>字符。</span> </p></li> 
              <li><p> <span>最后，如果给出了片段，则附加散列字符（ <code>'#'</code> ），然后是片段。</span> <span>引用任何非合法URI字符的字符。</span> </p></li> 
             </ol> 
             <p> <span>然后通过调用<a href="#%3Cinit%3E(java.lang.String)"><code>URI(String)</code></a>构造函数然后在结果上调用<a href="#parseServerAuthority()"><code>parseServerAuthority()</code></a>方法来解析生成的URI字符串;</span> <span>这可能导致<a href="URISyntaxException.html" title="java.net中的类"><code>URISyntaxException</code></a>被抛出。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>scheme</code> - 方案名称 
             </dd> 
             <dd> 
              <code>authority</code> - 权威 
             </dd> 
             <dd> 
              <code>path</code> - 路径 
             </dd> 
             <dd> 
              <code>query</code> - 查询 
             </dd> 
             <dd> 
              <code>fragment</code> - 片段 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="URISyntaxException.html" title="class in java.net">URISyntaxException</a></code> - 如果同时给出了方案和路径，但路径是相对的，如果从给定组件构造的URI字符串违反RFC 2396，或者字符串的权限组件存在但无法解析为基于服务器的权限 
             </dd> 
            </dl> </li> 
          </ul> <a id="<init>(java.lang.String,java.lang.String,java.lang.String,java.lang.String)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>URI</h4> <pre>public&nbsp;URI​(<a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;scheme,
           <a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;host,
           <a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;path,
           <a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;fragment)
    throws <a href="URISyntaxException.html" title="class in java.net">URISyntaxException</a></pre> 
            <div class="block"> 
             <span>根据给定组件构造分层URI。</span> 
             <p> <span>通过传递<code>null</code>可能未定义组件。</span> </p> 
             <p> <span>这个便捷构造函数就好像通过调用七参数构造函数一样工作，如下所示：</span> </p> 
             <blockquote> 
              <span><code>new</code> <a href="#%3Cinit%3E(java.lang.String,java.lang.String,java.lang.String,int,java.lang.String,java.lang.String,java.lang.String)"><code>URI</code></a> <code>(scheme, null, host, -1, path, null, fragment);</code></span> 
             </blockquote> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>scheme</code> - 方案名称 
             </dd> 
             <dd> 
              <code>host</code> - 主机名 
             </dd> 
             <dd> 
              <code>path</code> - 路径 
             </dd> 
             <dd> 
              <code>fragment</code> - 碎片 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="URISyntaxException.html" title="class in java.net">URISyntaxException</a></code> - 如果从给定组件构造的URI字符串违反RFC 2396 
             </dd> 
            </dl> </li> 
          </ul> <a id="<init>(java.lang.String,java.lang.String,java.lang.String)"> 
           <!--   --> </a> 
          <ul class="blockListLast"> 
           <li class="blockList"> <h4>URI</h4> <pre>public&nbsp;URI​(<a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;scheme,
           <a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;ssp,
           <a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;fragment)
    throws <a href="URISyntaxException.html" title="class in java.net">URISyntaxException</a></pre> 
            <div class="block"> 
             <span>根据给定的组件构造URI。</span> 
             <p> <span>通过<code>null</code>可能未定义组件。</span> </p> 
             <p> <span>此构造函数首先使用给定的组件以字符串形式构建URI，如下所示：</span> </p> 
             <ol> 
              <li><p> <span>最初，结果字符串为空。</span> </p></li> 
              <li><p> <span>如果给出了一个方案，那么它将被附加到结果中，后跟一个冒号字符（ <code>':'</code> ）。</span> </p></li> 
              <li><p> <span>如果给出了特定于方案的部分，则附加它。</span> <span>任何不是<a href="#legal-chars">legal URI character的字符</a>都是<a href="#quote">quoted</a> 。</span> </p></li> 
              <li><p> <span>最后，如果给出一个片段，则将一个散列字符（ <code>'#'</code> ）附加到该字符串，然后是该片段。</span> <span>引用任何非合法URI字符的字符。</span> </p></li> 
             </ol> 
             <p> <span>然后解析生成的URI字符串，以便通过调用<a href="#%3Cinit%3E(java.lang.String)"><code>URI(String)</code></a>构造函数来创建新的URI实例;</span> <span>这可能会导致<a href="URISyntaxException.html" title="java.net中的类"><code>URISyntaxException</code></a>被抛出。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>scheme</code> - 方案名称 
             </dd> 
             <dd> 
              <code>ssp</code> - 特定于方案的部分 
             </dd> 
             <dd> 
              <code>fragment</code> - 片段 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="URISyntaxException.html" title="class in java.net">URISyntaxException</a></code> - 如果从给定组件构造的URI字符串违反RFC 2396 
             </dd> 
            </dl> </li> 
          </ul> </li> 
        </ul> 
       </section> 
       <!-- ============ METHOD DETAIL ========== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="method.detail"> 
           <!--   --> </a> <h3>方法详细信息</h3> <a id="create(java.lang.String)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>create</h4> <pre class="methodSignature">public static&nbsp;<a href="URI.html" title="class in java.net">URI</a>&nbsp;create​(<a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;str)</pre> 
            <div class="block"> 
             <span>通过解析给定的字符串来创建URI。</span> 
             <p> <span>这个便利工厂方法就好像通过调用<a href="#%3Cinit%3E(java.lang.String)"><code>URI(String)</code></a>构造函数一样工作;</span> <span>构造函数抛出的任何<a href="URISyntaxException.html" title="java.net中的类"><code>URISyntaxException</code></a>被捕获并包装在一个新的<a href="../lang/IllegalArgumentException.html" title="java.lang中的类"><code>IllegalArgumentException</code></a>对象中，然后抛出该对象。</span> </p> 
             <p> <span>提供此方法是为了在已知给定字符串是合法URI的情况下使用，例如对于在程序中声明的URI常量，因此将其视为不能解析的字符串的编程错误。</span> <span>直接抛出<a href="URISyntaxException.html" title="java.net中的类"><code>URISyntaxException</code></a>的构造函数应该用于从用户输入或可能容易出错的其他源构造URI的情况。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>str</code> - 要解析为URI的字符串 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               新的URI 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
              <code>str</code>是 
              <code>null</code> 
             </dd> 
             <dd> 
              <code><a href="../lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果给定的字符串违反RFC 2396 
             </dd> 
            </dl> </li> 
          </ul> <a id="parseServerAuthority()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>parseServerAuthority</h4> <pre class="methodSignature">public&nbsp;<a href="URI.html" title="class in java.net">URI</a>&nbsp;parseServerAuthority()
                         throws <a href="URISyntaxException.html" title="class in java.net">URISyntaxException</a></pre> 
            <div class="block"> 
             <span>尝试将此URI的权限组件（如果已定义）解析为用户信息，主机和端口组件。</span> 
             <p> <span>如果此URI的权限组件已被识别为基于服务器，则它已经被解析为用户信息，主机和端口组件。</span> <span>在这种情况下，或者如果此URI没有权限组件，此方法只返回此URI。</span> </p> 
             <p> <span>否则，此方法再次尝试将权限组件解析为用户信息，主机和端口组件，并抛出异常，描述无法以这种方式解析权限组件的原因。</span> </p> 
             <p> <span>提供此方法是因为<a href="http://www.ietf.org/rfc/rfc2396.txt">RFC&nbsp;2396中</a>指定的通用URI语法无法始终将基于服务器的格式错误的权限与基于合法注册表的权限区分开来。</span> <span>因此，它必须将前者的一些实例视为后者的实例。</span> <span>例如，URI字符串<code>"//foo:bar"</code>的授权组件不是基于合法服务器的授权，但作为基于注册表的授权是合法的。</span> </p> 
             <p> <span>在许多常见情况下，例如，当处理已知为URN或URL的URI时，使用的分层URI将始终基于服务器。</span> <span>因此，它们必须要么被解析，要么被视为错误。</span> <span>在这些情况下的声明如</span> </p> 
             <blockquote> 
              <span><code>URI </code> <i>u</i> <code> = new URI(str).parseServerAuthority();</code></span> 
             </blockquote> 
             <p> <span>可用于确保<i>u</i>始终引用URI，如果URI具有权限组件，则具有基于服务器的权限，该权限具有适当的用户信息，主机和端口组件。</span> <span>调用此方法还可确保如果无法以此方式解析权限，则可以根据引发的异常发出相应的诊断消息。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个URI，其权限字段已被解析为基于服务器的权限 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="URISyntaxException.html" title="class in java.net">URISyntaxException</a></code> - 如果定义了此URI的授权组件，但根据RFC 2396无法将其解析为基于服务器的授权 
             </dd> 
            </dl> </li> 
          </ul> <a id="normalize()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>normalize</h4> <pre class="methodSignature">public&nbsp;<a href="URI.html" title="class in java.net">URI</a>&nbsp;normalize()</pre> 
            <div class="block"> 
             <span>规范化此URI的路径。</span> 
             <p> <span>如果此URI不透明，或者其路径已经是正常形式，则返回此URI。</span> <span>否则，构造一个与此URI相同的新URI，除了通过以与<a href="http://www.ietf.org/rfc/rfc2396.txt">RFC&nbsp;2396</a> ，第5.2节，第6步，子步骤c到f一致的方式规范化该URI的路径来计算其路径;</span> <span>那是：</span> </p> 
             <ol> 
              <li><p> <span>所有<code>"."</code>段都已删除。</span> </p></li> 
              <li><p> <span>如果<code>".."</code>段前面有非<code>".."</code>段，则会删除这两个段。</span> <span>重复该步骤直到不再适用。</span> </p></li> 
              <li><p> <span>如果路径是相对路径，并且其第一个段包含冒号字符（ <code>':'</code> ），则会预先添加<code>"."</code>段。</span> <span>这防止相对URI与诸如路径<code>"a:b/c/d"</code>从后来被重新解析为一个不透明带URI的方案<code>"a"</code>和的一个具体方案的部分<code>"b/c/d"</code> 。</span> <span><b><i>（与RFC 2396的偏差）</i></b></span> </p></li> 
             </ol> 
             <p> <span>如果在它们之前没有足够的非<code>".."</code>段以允许它们被移除，则标准化路径将以一个或多个<code>".."</code>段开始。</span> <span>如果在上面的步骤3中插入一个段，则标准化路径将以<code>"."</code>段开始。</span> <span>否则，规范化路径将不包含任何<code>"."</code>或<code>".."</code>段。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               与此URI等效的URI，但其路径为正常形式 
             </dd> 
            </dl> </li> 
          </ul> <a id="resolve(java.net.URI)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>resolve</h4> <pre class="methodSignature">public&nbsp;<a href="URI.html" title="class in java.net">URI</a>&nbsp;resolve​(<a href="URI.html" title="class in java.net">URI</a>&nbsp;uri)</pre> 
            <div class="block"> 
             <span>根据此URI解析给定的URI。</span> 
             <p> <span>如果给定的URI已经是绝对的，或者此URI是不透明的，则返回给定的URI。</span> </p> 
             <p> <span><a id="resolve-frag"></a>如果定义了给定URI的片段组件，其路径组件为空，并且其方案，权限和查询组件未定义，则返回具有给定片段但所有其他组件等于此URI的URI的URI。</span> <span>这允许表示独立片段引用的URI（例如<code>"#foo"</code>针对基URI进行有用的解析。</span> </p> 
             <p> <span>否则，此方法以与<a href="http://www.ietf.org/rfc/rfc2396.txt">RFC&nbsp;2396</a> ，第5.2节一致的方式构造新的分层URI;</span> <span>那是：</span> </p> 
             <ol> 
              <li><p> <span>使用此URI方案和给定URI的查询和片段组件构造新URI。</span> </p></li> 
              <li><p> <span>如果给定的URI具有权限组件，那么新URI的权限和路径将从给定的URI中获取。</span> </p></li> 
              <li><p> <span>否则，将从此URI复制新URI的权限组件，并按如下方式计算其路径：</span> </p> 
               <ol> 
                <li><p> <span>如果给定URI的路径是绝对路径，那么新URI的路径将从给定的URI中获取。</span> </p></li> 
                <li><p> <span>否则，给定URI的路径是相对的，因此通过根据此URI的路径解析给定URI的路径来计算新URI的路径。</span> <span>这是通过连接此URI路径的最后一段（如果有）与给定URI的路径，然后将结果标准化，就好像通过调用<a href="#normalize()"><code>normalize</code></a>方法来完成的。</span> </p></li> 
               </ol></li> 
             </ol> 
             <p> <span>当且仅当此URI是绝对的或给定的URI是绝对的时，此方法的结果才是绝对的。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>uri</code> - 要针对此URI解析的URI 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               生成的URI 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
              <code>uri</code>是 
              <code>null</code> 
             </dd> 
            </dl> </li> 
          </ul> <a id="resolve(java.lang.String)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>resolve</h4> <pre class="methodSignature">public&nbsp;<a href="URI.html" title="class in java.net">URI</a>&nbsp;resolve​(<a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;str)</pre> 
            <div class="block"> 
             <span>通过解析给定的字符串然后针对此URI解析它来构造新的URI。</span> 
             <p> <span>这种方便的方法就好像调用它等同于评估表达式<a href="#resolve(java.net.URI)"><code>resolve</code></a> <code>(URI.</code> <a href="#create(java.lang.String)"><code>create</code></a> <code>(str))</code> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>str</code> - 要解析为URI的字符串 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               生成的URI 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
              <code>str</code>是 
              <code>null</code> 
             </dd> 
             <dd> 
              <code><a href="../lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果给定的字符串违反RFC 2396 
             </dd> 
            </dl> </li> 
          </ul> <a id="relativize(java.net.URI)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>relativize</h4> <pre class="methodSignature">public&nbsp;<a href="URI.html" title="class in java.net">URI</a>&nbsp;relativize​(<a href="URI.html" title="class in java.net">URI</a>&nbsp;uri)</pre> 
            <div class="block"> 
             <span>根据此URI重新激活给定的URI。</span> 
             <p> <span>给定URI对此URI的相对化计算如下：</span> </p> 
             <ol> 
              <li><p> <span>如果此URI或给定的URI不透明，或者两个URI的方案和权限组件不相同，或者此URI的路径不是给定URI的路径的前缀，则给定的URI是回。</span> </p></li> 
              <li><p> <span>否则，使用从给定URI获取的查询和片段组件以及通过从给定URI的路径的开头移除该URI路径计算的路径组件来构造新的相对分层URI。</span> </p></li> 
             </ol> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>uri</code> - 要针对此URI进行相对化的URI 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               生成的URI 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
              <code>uri</code>是 
              <code>null</code> 
             </dd> 
            </dl> </li> 
          </ul> <a id="toURL()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>toURL</h4> <pre class="methodSignature">public&nbsp;<a href="URL.html" title="class in java.net">URL</a>&nbsp;toURL()
          throws <a href="MalformedURLException.html" title="class in java.net">MalformedURLException</a></pre> 
            <div class="block"> 
             <span>根据此URI构造URL。</span> 
             <p> <span>这种方便的方法就好像调用它等同于在首次检查此URI是绝对的之后计算表达式<code>new URL(this.toString())</code> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               从此URI构造的URL 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果此URL不是绝对的 
             </dd> 
             <dd> 
              <code><a href="MalformedURLException.html" title="class in java.net">MalformedURLException</a></code> - 如果找不到URL的协议处理程序，或者在构造URL时发生了其他错误 
             </dd> 
            </dl> </li> 
          </ul> <a id="getScheme()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getScheme</h4> <pre class="methodSignature">public&nbsp;<a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;getScheme()</pre> 
            <div class="block"> 
             <span>返回此URI的scheme组件。</span> 
             <p> <span>URI的scheme组件（如果已定义）仅包含<i>alphanum</i>类别和字符串<code>"-.+"</code>中的字符。</span> <span>方案始终以<i>字母</i>字符开头。</span> </p> 
             <p> <span>URI的方案组件不能包含转义的八位字节，因此此方法不执行任何解码。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此URI的方案组件，如果方案未定义， 
              <code>null</code> 
             </dd> 
            </dl> </li> 
          </ul> <a id="isAbsolute()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>isAbsolute</h4> <pre class="methodSignature">public&nbsp;boolean&nbsp;isAbsolute()</pre> 
            <div class="block"> 
             <span>判断此URI是否是绝对的。</span> 
             <p> <span>当且仅当它具有方案组件时，URI才是绝对的。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>true</code> if且仅当此URI是绝对的 
             </dd> 
            </dl> </li> 
          </ul> <a id="isOpaque()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>isOpaque</h4> <pre class="methodSignature">public&nbsp;boolean&nbsp;isOpaque()</pre> 
            <div class="block"> 
             <span>判断此URI是否不透明。</span> 
             <p> <span>如果且仅当它是绝对的并且其特定于方案的部分不以斜杠字符（'/'）开头时，URI是不透明的。</span> <span>不透明的URI有一个方案，一个方案特定的部分，可能还有一个片段;</span> <span>所有其他组件都未定义。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>true</code>当且仅当此URI不透明时 
             </dd> 
            </dl> </li> 
          </ul> <a id="getRawSchemeSpecificPart()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getRawSchemeSpecificPart</h4> <pre class="methodSignature">public&nbsp;<a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;getRawSchemeSpecificPart()</pre> 
            <div class="block"> 
             <span>返回此URI的原始方案特定部分。</span> 
             <span>特定于方案的部分永远不会被定义，尽管它可能是空的。</span> 
             <p> <span>URI的特定于方案的部分仅包含合法的URI字符。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此URI的原始方案特定部分（从不 
              <code>null</code> ） 
             </dd> 
            </dl> </li> 
          </ul> <a id="getSchemeSpecificPart()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getSchemeSpecificPart</h4> <pre class="methodSignature">public&nbsp;<a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;getSchemeSpecificPart()</pre> 
            <div class="block"> 
             <span>返回此URI的已解码方案特定部分。</span> 
             <p> <span>此方法返回的字符串等于<a href="#getRawSchemeSpecificPart()"><code>getRawSchemeSpecificPart</code></a>方法返回的<a href="#getRawSchemeSpecificPart()">字符串，</a>但所有转义八位字节序列均为<a href="#decode">decoded</a> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此URI的解码方案特定部分（从不 
              <code>null</code> ） 
             </dd> 
            </dl> </li> 
          </ul> <a id="getRawAuthority()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getRawAuthority</h4> <pre class="methodSignature">public&nbsp;<a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;getRawAuthority()</pre> 
            <div class="block"> 
             <span>返回此URI的原始授权组件。</span> 
             <p> <span>URI的权限组件（如果已定义）仅包含商业广告字符（ <code>'@'</code> ）以及<i>未保留</i> ， <i>删节</i> ， <i>转义</i>和<i>其他</i>类别中的字符。</span> <span>如果权限是基于服务器的，则进一步限制为具有有效的用户信息，主机和端口组件。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此URI的原始授权组件，如果未定义权限， 
              <code>null</code> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getAuthority()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getAuthority</h4> <pre class="methodSignature">public&nbsp;<a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;getAuthority()</pre> 
            <div class="block"> 
             <span>返回此URI的已解码授权组件。</span> 
             <p> <span>此方法返回的字符串等于<a href="#getRawAuthority()"><code>getRawAuthority</code></a>方法返回的<a href="#getRawAuthority()">字符串，</a>但所有转义八位字节序列均为<a href="#decode">decoded</a> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此URI的已解码权限组件，如果未定义权限， 
              <code>null</code> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getRawUserInfo()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getRawUserInfo</h4> <pre class="methodSignature">public&nbsp;<a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;getRawUserInfo()</pre> 
            <div class="block"> 
             <span>返回此URI的原始用户信息组件。</span> 
             <p> <span>URI的用户信息组成部分，如果所定义，只包含在<i>未保留</i> ，字符<i>PUNCT，</i> <i>躲过</i> ，和<i>其他</i>类别。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此URI的原始用户信息组件，如果未定义用户信息， 
              <code>null</code> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getUserInfo()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getUserInfo</h4> <pre class="methodSignature">public&nbsp;<a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;getUserInfo()</pre> 
            <div class="block"> 
             <span>返回此URI的已解码用户信息组件。</span> 
             <p> <span>此方法返回的字符串等于<a href="#getRawUserInfo()"><code>getRawUserInfo</code></a>方法返回的<a href="#getRawUserInfo()">字符串，</a>但所有转义八位字节序列均为<a href="#decode">decoded</a> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此URI的已解码用户信息组件，如果未定义用户信息， 
              <code>null</code> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getHost()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getHost</h4> <pre class="methodSignature">public&nbsp;<a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;getHost()</pre> 
            <div class="block"> 
             <span>返回此URI的主机组件。</span> 
             <p> <span>URI的主机组件（如果已定义）将具有以下形式之一：</span> </p> 
             <ul> 
              <li><p> <span>由一个或多个以句点字符（ <code>'.'</code> ）分隔的<i>标签</i>组成的域名，可选地后跟句点字符。</span> <span>每个标签由<i>字母</i>字符和连字符（ <code>'-'</code> ）组成，但连字符不会作为标签中的第一个或最后一个字符出现。</span> <span>由两个或多个标签组成的域名最右边的标签以<i>字母</i>字符开头。</span> </p></li> 
              <li><p> <span>形式<i>的数字</i>的点分IPv4地址<code>+.</code> <i>数字</i> <code>+.</code> <i>数字</i> <code>+.</code> <i>数字</i> <code>+</code> ，其中没有<i>数字</i>序列长于三个字符并且没有序列具有值大于255。</span> </p></li> 
              <li><p> <span>包含在方括号（ <code>'['</code>和<code>']'</code> ）中的IPv6地址，由十六进制数字，冒号字符（ <code>':'</code> ）和可能的嵌入式IPv4地址组成。</span> <span>IPv6地址的完整语法在<a href="http://www.ietf.org/rfc/rfc2373.txt"><i>RFC&nbsp;2373: IPv6 Addressing Architecture</i>中</a>指定。</span> </p></li> 
             </ul> 
             <span>URI的主机组件不能包含转义的八位字节，因此此方法不执行任何解码。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此URI的主机组件，如果主机未定义， 
              <code>null</code> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getPort()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getPort</h4> <pre class="methodSignature">public&nbsp;int&nbsp;getPort()</pre> 
            <div class="block"> 
             <span>返回此URI的端口号。</span> 
             <p> <span>URI的端口组件（如果已定义）是非负整数。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此URI的端口组件，如果端口未定义， 
              <code>-1</code> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getRawPath()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getRawPath</h4> <pre class="methodSignature">public&nbsp;<a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;getRawPath()</pre> 
            <div class="block"> 
             <span>返回此URI的原始路径组件。</span> 
             <p> <span>URI的路径组件（如果已定义）仅包含斜杠字符（ <code>'/'</code> ），商业广告字符（ <code>'@'</code> ）以及<i>未保留</i> ， <i>删节</i> ， <i>转义</i>和<i>其他</i>类别中的字符。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此URI的路径组件，如果路径未定义， 
              <code>null</code> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getPath()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getPath</h4> <pre class="methodSignature">public&nbsp;<a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;getPath()</pre> 
            <div class="block"> 
             <span>返回此URI的已解码路径组件。</span> 
             <p> <span>此方法返回的字符串等于<a href="#getRawPath()"><code>getRawPath</code></a>方法返回的<a href="#getRawPath()">字符串，</a>但所有转义八位字节序列均为<a href="#decode">decoded</a> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此URI的已解码路径组件，如果路径未定义， 
              <code>null</code> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getRawQuery()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getRawQuery</h4> <pre class="methodSignature">public&nbsp;<a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;getRawQuery()</pre> 
            <div class="block"> 
             <span>返回此URI的原始查询组件。</span> 
             <p> <span>URI的查询组件（如果已定义）仅包含合法的URI字符。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此URI的原始查询组件，如果查询未定义， 
              <code>null</code> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getQuery()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getQuery</h4> <pre class="methodSignature">public&nbsp;<a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;getQuery()</pre> 
            <div class="block"> 
             <span>返回此URI的已解码查询组件。</span> 
             <p> <span>此方法返回的字符串等于<a href="#getRawQuery()"><code>getRawQuery</code></a>方法返回的<a href="#getRawQuery()">字符串，</a>但所有转义八位字节序列均为<a href="#decode">decoded</a> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此URI的已解码查询组件，如果查询未定义， 
              <code>null</code> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getRawFragment()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getRawFragment</h4> <pre class="methodSignature">public&nbsp;<a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;getRawFragment()</pre> 
            <div class="block"> 
             <span>返回此URI的原始片段组件。</span> 
             <p> <span>URI的片段组件（如果已定义）仅包含合法的URI字符。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此URI的原始片段组件，如果片段未定义， 
              <code>null</code> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getFragment()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getFragment</h4> <pre class="methodSignature">public&nbsp;<a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;getFragment()</pre> 
            <div class="block"> 
             <span>返回此URI的已解码片段组件。</span> 
             <p> <span>此方法返回的字符串等于<a href="#getRawFragment()"><code>getRawFragment</code></a>方法返回的<a href="#getRawFragment()">字符串，</a>但转义八位字节的所有序列均为<a href="#decode">decoded</a> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此URI的已解码片段组件，如果片段未定义， 
              <code>null</code> 
             </dd> 
            </dl> </li> 
          </ul> <a id="equals(java.lang.Object)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>equals</h4> <pre class="methodSignature">public&nbsp;boolean&nbsp;equals​(<a href="../lang/Object.html" title="class in java.lang">Object</a>&nbsp;ob)</pre> 
            <div class="block"> 
             <span>测试此URI与另一个对象的相等性。</span> 
             <p> <span>如果给定对象不是URI，则此方法立即返回<code>false</code> 。</span> </p> 
             <p> <span>要使两个URI相等，要求两者都是不透明的，或者两者都是分层的。</span> <span>他们的计划要么两者都不明确，要么在不考虑案件的情况下是平等的。</span> <span>他们的片段既可以是未定义的，也可以是相同的。</span> </p> 
             <p> <span>要使两个不透明的URI相等，它们的特定于方案的部分必须相等。</span> </p> 
             <p> <span>要使两个分层URI相等，它们的路径必须相等，并且它们的查询必须都是未定义的，否则必须相等。</span> <span>他们的权限既可以是未定义的，也可以是基于注册表的，或者都是基于服务器的。</span> <span>如果他们的权限是定义的并且是基于注册表的，那么它们必须是平等的。</span> <span>如果它们的权限是定义的并且是基于服务器的，那么它们的主机必须相等而不考虑大小写，它们的端口号必须相等，并且它们的用户信息组件必须相等。</span> </p> 
             <p> <span>在测试两个URI的用户信息，路径，查询，片段，权限或方案特定部分是否相等时，比较原始表单而不是这些组件的编码形式，并且比较转义八位字节的十六进制数字而不考虑案件。</span> </p> 
             <p> <span>该方法满足<a href="../lang/Object.html#equals(java.lang.Object)"><code>Object.equals</code></a>方法的一般合同。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="overrideSpecifyLabel">重写：</span> 
             </dt> 
             <dd> 
              <code><a href="../lang/Object.html#equals(java.lang.Object)">equals</a></code>在类 
              <code><a href="../lang/Object.html" title="class in java.lang">Object</a></code> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>ob</code> - 要与此对象进行比较的对象 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>true</code>当且仅当给定对象是与此URI相同的URI时 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <span><a href="../lang/Object.html#hashCode()"><code>Object.hashCode()</code></a> ， <a href="../util/HashMap.html" title="java.util中的类"><code>HashMap</code></a></span> 
             </dd> 
            </dl> </li> 
          </ul> <a id="hashCode()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>hashCode</h4> <pre class="methodSignature">public&nbsp;int&nbsp;hashCode()</pre> 
            <div class="block"> 
             <span>返回此URI的哈希码值。</span> 
             <span>哈希码基于所有URI的组件，并且满足<a href="../lang/Object.html#hashCode()"><code>Object.hashCode</code></a>方法的一般契约。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="overrideSpecifyLabel">重写：</span> 
             </dt> 
             <dd> 
              <code><a href="../lang/Object.html#hashCode()">hashCode</a></code>在类 
              <code><a href="../lang/Object.html" title="class in java.lang">Object</a></code> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此URI的哈希码值 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="../lang/Object.html#equals(java.lang.Object)"><code>Object.equals(java.lang.Object)</code></a> ， 
              <a href="../lang/System.html#identityHashCode(java.lang.Object)"><code>System.identityHashCode(java.lang.Object)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="compareTo(java.net.URI)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>compareTo</h4> <pre class="methodSignature">public&nbsp;int&nbsp;compareTo​(<a href="URI.html" title="class in java.net">URI</a>&nbsp;that)</pre> 
            <div class="block"> 
             <span>将此URI与另一个对象进行比较，该对象必须是URI。</span> 
             <p> <span>当比较两个URI的相应组件时，如果一个组件未定义但另一个组件已定义，则第一个组件被认为小于第二个组件。</span> <span>除非另有说明，否则字符串组件按照<a href="../lang/Comparable.html#compareTo(T)"><code>String.compareTo</code></a>方法定义的自然区分大小写排序。</span> <span>通过比较它们的原始形式而不是它们的编码形式来比较要进行编码的字符串组件。</span> </p> 
             <p> <span>URI的排序定义如下：</span> </p> 
             <ul> 
              <li><p> <span>根据其方案的顺序对具有不同方案的两个URI进行排序，而不考虑大小写。</span> </p></li> 
              <li><p> <span>分层URI被认为小于具有相同方案的不透明URI。</span> </p></li> 
              <li><p> <span>具有相同方案的两个不透明URI根据其方案特定部分的顺序排序。</span> </p></li> 
              <li><p> <span>具有相同方案和方案特定部分的两个不透明URI根据其片段的顺序排序。</span> </p></li> 
              <li><p> <span>具有相同方案的两个分层URI根据其权限组件的顺序排序：</span> </p> 
               <ul> 
                <li><p> <span>如果两个权限组件都是基于服务器的，那么URI将根据其用户信息组件进行排序;</span> <span>如果这些组件是相同的，则根据其主机的顺序对URI进行排序，而不考虑大小写;</span> <span>如果主机相同，则根据其端口的顺序对URI进行排序。</span> </p></li> 
                <li><p> <span>如果一个或两个授权组件是基于注册表的，那么URI将根据其授权组件的顺序进行排序。</span> </p></li> 
               </ul></li> 
              <li><p> <span>最后，根据路径的顺序对具有相同方案和权限组件的两个分层URI进行排序;</span> <span>如果他们的路径相同，那么他们会根据他们的查询顺序排序;</span> <span>如果查询相同，则根据其片段的顺序对它们进行排序。</span> </p></li> 
             </ul> 
             <p> <span>该方法满足<a href="../lang/Comparable.html#compareTo(T)"><code>Comparable.compareTo</code></a>方法的一般合同。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="overrideSpecifyLabel">Specified by:</span> 
             </dt> 
             <dd> 
              <code><a href="../lang/Comparable.html#compareTo(T)">compareTo</a></code>在界面 
              <code><a href="../lang/Comparable.html" title="interface in java.lang">Comparable</a>&lt;<a href="URI.html" title="class in java.net">URI</a>&gt;</code> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>that</code> - 要与此URI进行比较的对象 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个负整数，零或正整数，因为此URI小于，等于或大于给定的URI 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果给定对象不是URI 
             </dd> 
            </dl> </li> 
          </ul> <a id="toString()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>toString</h4> <pre class="methodSignature">public&nbsp;<a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;toString()</pre> 
            <div class="block"> 
             <span>以字符串形式返回此URI的内容。</span> 
             <p> <span>如果此URI是通过调用此类中的一个构造函数创建的，则返回等效于原始输入字符串的字符串，或者根据需要返回从最初给定的组件计算的字符串。</span> <span>否则，此URI是通过规范化，解析或相对化创建的，因此根据<a href="http://www.ietf.org/rfc/rfc2396.txt">RFC&nbsp;2396</a>第5.2节第7步中指定的规则从此URI的组件构造字符串。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="overrideSpecifyLabel">重写：</span> 
             </dt> 
             <dd> 
              <code><a href="../lang/Object.html#toString()">toString</a></code>在类 
              <code><a href="../lang/Object.html" title="class in java.lang">Object</a></code> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此URI的字符串形式 
             </dd> 
            </dl> </li> 
          </ul> <a id="toASCIIString()"> 
           <!--   --> </a> 
          <ul class="blockListLast"> 
           <li class="blockList"> <h4>toASCIIString</h4> <pre class="methodSignature">public&nbsp;<a href="../lang/String.html" title="class in java.lang">String</a>&nbsp;toASCIIString()</pre> 
            <div class="block"> 
             <span>以US-ASCII字符串形式返回此URI的内容。</span> 
             <p> <span>如果此URI不包含<i>其他</i>类别中的任何字符，则调用此方法将返回与调用<a href="#toString()"><code>toString</code></a>方法相同的值。</span> <span>否则此方法的工作方式就像调用该方法然后<a href="#encode">encoding</a>结果一样。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此URI的字符串形式，根据需要进行编码，以便它只包含US-ASCII字符集中的字符 
             </dd> 
            </dl> </li> 
          </ul> </li> 
        </ul> 
       </section> </li> 
     </ul> 
    </div> 
   </div> 
  </main> 
  <!-- ========= END OF CLASS DATA ========= --> 
  <footer role="contentinfo"> 
   <nav role="navigation"> 
    <!-- ======= START OF BOTTOM NAVBAR ====== --> 
    <div class="bottomNav"> 
     <a id="navbar.bottom"> 
      <!--   --> </a> 
     <div class="skipNav"> 
      <a href="#skip.navbar.bottom" title="Skip navigation links">跳过导航</a> 
     </div> 
     <a id="navbar.bottom.firstrow"> 
      <!--   --> </a> 
     <ul class="navList" title="Navigation"> 
      <li><a href="../../../index.html">概述</a></li> 
      <li><a href="../../module-summary.html">模块</a></li> 
      <li><a href="package-summary.html">软件包</a></li> 
      <li class="navBarCell1Rev">类</li> 
      <li><a href="class-use/URI.html">使用</a></li> 
      <li><a href="package-tree.html">树</a></li> 
      <li><a href="../../../deprecated-list.html">已过时的</a></li> 
      <li><a href="../../../index-files/index-1.html">索引</a></li> 
      <li><a href="../../../help-doc.html">帮助</a></li> 
     </ul> 
     <div class="aboutLanguage"> 
      <div style="margin-top: 14px;"> 
       <strong>Java SE 11 &amp; JDK 11</strong> 
      </div> 
     </div> 
    </div> 
    <div class="subNav"> 
     <ul class="navList" id="allclasses_navbar_bottom"> 
      <li><a href="../../../allclasses.html">所有类</a></li> 
     </ul> 
     <div> 
      <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
      <noscript> 
       <div>
         JavaScript is disabled on your browser. 
       </div> 
      </noscript> 
     </div> 
     <div> 
      <ul class="subNavList"> 
       <li>概要：&nbsp;</li> 
       <li>嵌套&nbsp;|&nbsp;</li> 
       <li>字段&nbsp;|&nbsp;</li> 
       <li><a href="#constructor.summary">构造方法</a>&nbsp;|&nbsp;</li> 
       <li><a href="#method.summary">方法</a></li> 
      </ul> 
      <ul class="subNavList"> 
       <li>详细信息：&nbsp;</li> 
       <li>字段&nbsp;|&nbsp;</li> 
       <li><a href="#constructor.detail">构造方法</a>&nbsp;|&nbsp;</li> 
       <li><a href="#method.detail">方法</a></li> 
      </ul> 
     </div> 
     <a id="skip.navbar.bottom"> 
      <!--   --> </a> 
    </div> 
    <!-- ======== END OF BOTTOM NAVBAR ======= --> 
   </nav> 
   <p class="legalCopy"><small><a href="http://bugreport.java.com/bugreport/">Report a bug or suggest an enhancement</a><br> For further API reference and developer documentation see the <a href="http://www.oracle.com/pls/topic/lookup?ctx=javase11.0.1&amp;id=homepage" target="_blank">Java SE Documentation</a>, which contains more detailed, developer-targeted descriptions with conceptual overviews, definitions of terms, workarounds, and working code examples.<br> Java is a trademark or registered trademark of Oracle and/or its affiliates in the US and other countries.<br> <a href="../../../../legal/copyright.html">Copyright</a> © 1993, 2018, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.<br>All rights reserved. Use is subject to <a href="http://www.oracle.com/technetwork/java/javase/terms/license/java11.0.1speclicense.html">license terms</a> and the <a href="http://www.oracle.com/technetwork/java/redist-137594.html">documentation redistribution policy</a>. 
     <!-- Version 11.0.1+13-LTS --></small></p> 
  </footer>  
 </body>
</html>