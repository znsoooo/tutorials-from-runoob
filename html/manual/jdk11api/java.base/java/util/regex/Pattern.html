<!doctype html>
<!-- NewPage -->
<html lang="en">
 <head> 
  <!-- Generated by javadoc --> 
  <title>Pattern</title> 
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> 
  <meta name="keywords" content="java.util.regex.Pattern class"> 
  <meta name="keywords" content="UNIX_LINES"> 
  <meta name="keywords" content="CASE_INSENSITIVE"> 
  <meta name="keywords" content="COMMENTS"> 
  <meta name="keywords" content="MULTILINE"> 
  <meta name="keywords" content="LITERAL"> 
  <meta name="keywords" content="DOTALL"> 
  <meta name="keywords" content="UNICODE_CASE"> 
  <meta name="keywords" content="CANON_EQ"> 
  <meta name="keywords" content="UNICODE_CHARACTER_CLASS"> 
  <meta name="keywords" content="compile()"> 
  <meta name="keywords" content="pattern()"> 
  <meta name="keywords" content="toString()"> 
  <meta name="keywords" content="matcher()"> 
  <meta name="keywords" content="flags()"> 
  <meta name="keywords" content="matches()"> 
  <meta name="keywords" content="split()"> 
  <meta name="keywords" content="quote()"> 
  <meta name="keywords" content="asPredicate()"> 
  <meta name="keywords" content="asMatchPredicate()"> 
  <meta name="keywords" content="splitAsStream()"> 
  <link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style"> 
  <link rel="stylesheet" type="text/css" href="../../../../jquery/jquery-ui.css" title="Style"> 
  <script type="text/javascript" src="../../../../script.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jszip/dist/jszip.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script> 
  <!--[if IE]>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]--> 
  <script type="text/javascript" src="../../../../jquery/jquery-1.10.2.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jquery-migrate-1.2.1.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jquery-ui.js"></script> 
 </head> 
 <body> <SCRIPT LANGUAGE="JavaScript"><!-- Hide  
   function ResumeError() {     return true;}window.onerror = ResumeError;// --></SCRIPT>
  <script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Pattern (Java SE 11 & JDK 11 )";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":10,"i1":10,"i2":9,"i3":9,"i4":10,"i5":10,"i6":9,"i7":10,"i8":9,"i9":10,"i10":10,"i11":10,"i12":10};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script> 
  <noscript> 
   <div>
     JavaScript is disabled on your browser. 
   </div> 
  </noscript> 
  <header role="banner"> 
   <nav role="navigation"> 
    <div class="fixedNav"> 
     <!-- ========= START OF TOP NAVBAR ======= --> 
     <div class="topNav"> 
      <a id="navbar.top"> 
       <!--   --> </a> 
      <div class="skipNav"> 
       <a href="#skip.navbar.top" title="Skip navigation links">跳过导航</a> 
      </div> 
      <a id="navbar.top.firstrow"> 
       <!--   --> </a> 
      <ul class="navList" title="Navigation"> 
       <li><a href="../../../../index.html">概述</a></li> 
       <li><a href="../../../module-summary.html">模块</a></li> 
       <li><a href="package-summary.html">软件包</a></li> 
       <li class="navBarCell1Rev">类</li> 
       <li><a href="class-use/Pattern.html">使用</a></li> 
       <li><a href="package-tree.html">树</a></li> 
       <li><a href="../../../../deprecated-list.html">已过时的</a></li> 
       <li><a href="../../../../index-files/index-1.html">索引</a></li> 
       <li><a href="../../../../help-doc.html">帮助</a></li> 
      </ul> 
      <div class="aboutLanguage"> 
       <div style="margin-top: 14px;"> 
        <strong>Java SE 11 &amp; JDK 11</strong> 
       </div> 
      </div> 
     </div> 
     <div class="subNav"> 
      <ul class="navList" id="allclasses_navbar_top"> 
       <li><a href="../../../../allclasses.html">所有类</a></li> 
      </ul> 
      <ul class="navListSearch"> 
       <li><label for="search">SEARCH:</label> <input type="text" id="search" value="search" disabled> <input type="reset" id="reset" value="reset" disabled> </li> 
      </ul> 
      <div> 
       <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
       <noscript> 
        <div>
          JavaScript is disabled on your browser. 
        </div> 
       </noscript> 
      </div> 
       <div class="fixedNav">
       <ul class="subNavList"> 
        <li>概要：&nbsp;</li> 
        <li>嵌套&nbsp;|&nbsp;</li> 
        <li><a href="#field.summary">字段</a>&nbsp;|&nbsp;</li> 
        <li>构造方法&nbsp;|&nbsp;</li> 
        <li><a href="#method.summary">方法</a></li> 
       </ul> 
       <ul class="subNavList"> 
        <li>详细信息：&nbsp;</li> 
        <li><a href="#field.detail">字段</a>&nbsp;|&nbsp;</li> 
        <li>构造方法&nbsp;|&nbsp;</li> 
        <li><a href="#method.detail">方法</a></li> 
       </ul> 
      </div> 
      <a id="skip.navbar.top"> 
       <!--   --> </a> 
     </div> 
     <!-- ========= END OF TOP NAVBAR ========= --> 
    </div> 
    <div class="navPadding">
      &nbsp; 
    </div> 
    <script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script> 
   </nav> 
  </header> 
  <!-- ======== START OF CLASS DATA ======== --> 
  <main role="main"> 
   <div class="header"> 
    <div class="subTitle"> 
     <span class="moduleLabelInType">模块</span>&nbsp; 
     <a href="../../../module-summary.html">java.base</a> 
    </div> 
    <div class="subTitle"> 
     <span class="packageLabelInType">软件包</span>&nbsp; 
     <a href="package-summary.html">java.util.regex</a> 
    </div> 
    <h2 title="Class Pattern" class="title">Class Pattern</h2> 
   </div> 
   <div class="contentContainer"> 
    <ul class="inheritance"> 
     <li><a href="../../lang/Object.html" title="class in java.lang">java.lang.Object</a></li> 
     <li> 
      <ul class="inheritance"> 
       <li>java.util.regex.Pattern</li> 
      </ul> </li> 
    </ul> 
    <div class="description"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <dl> 
        <dt>
          实现的所有接口
        </dt> 
        <dd> 
         <code><a href="../../io/Serializable.html" title="interface in java.io">Serializable</a></code> 
        </dd> 
       </dl> 
       <hr> <pre>public final class <span class="typeNameLabel">Pattern</span>
extends <a href="../../lang/Object.html" title="class in java.lang">Object</a>
implements <a href="../../io/Serializable.html" title="interface in java.io">Serializable</a></pre> 
       <div class="block"> 
        <span>正则表达式的编译表示。</span> 
        <p> <span>必须首先将指定为字符串的正则表达式编译为此类的实例。</span> <span>然后，可以使用生成的模式创建<a href="Matcher.html" title="java.util.regex中的类"><code>Matcher</code></a>对象，该对象可以将任意<a href="../../lang/CharSequence.html" title="java.lang中的接口">character sequences</a>与正则表达式进行匹配。</span> <span>参与执行匹配的所有状态都驻留在匹配器中，因此许多匹配器可以共享相同的模式。</span> </p> 
        <p> <span>因此，典型的调用序列</span> </p> 
        <blockquote> 
         <span><pre>
 Pattern p = Pattern.<a href="#compile(java.lang.String)"><code>compile</code></a>("a*b");
 Matcher m = p.<a href="#matcher(java.lang.CharSequence)"><code>matcher</code></a>("aaaaab");
 boolean b = m.<a href="Matcher.html#matches()"><code>matches</code></a>();</pre></span> 
        </blockquote> 
        <p> <span><a href="#matches(java.lang.String,java.lang.CharSequence)"><code>matches</code></a>方法由此类定义，以便在正则表达式仅使用一次时方便。</span> <span>此方法编译表达式并在单个调用中将输入序列与其匹配。</span> <span>该声明</span> </p> 
        <blockquote> 
         <span><pre>
 boolean b = Pattern.matches("a*b", "aaaaab");</pre></span> 
        </blockquote> 
        <span>相当于上面的三个语句，但是对于重复匹配，它效率较低，因为它不允许重用已编译的模式。</span> 
        <p> <span>此类的实例是不可变的，并且可以安全地供多个并发线程使用。</span> <span><a href="Matcher.html" title="java.util.regex中的类"><code>Matcher</code></a>类的实例不适合此类使用。</span> </p> 
        <h3> <span><a id="sum">Summary of regular-expression constructs</a></span> </h3> 
        <span> Regular expression constructs, and what they match    Construct Matches     Characters   <i>x</i> The character <i>x</i>   <code>\\</code> The backslash character   <code>\0</code><i>n</i> The character with octal value <code>0</code><i>n</i> (0&nbsp;<code>&lt;=</code>&nbsp;<i>n</i>&nbsp;<code>&lt;=</code>&nbsp;7)   <code>\0</code><i>nn</i> The character with octal value <code>0</code><i>nn</i> (0&nbsp;<code>&lt;=</code>&nbsp;<i>n</i>&nbsp;<code>&lt;=</code>&nbsp;7)   <code>\0</code><i>mnn</i> The character with octal value <code>0</code><i>mnn</i> (0&nbsp;<code>&lt;=</code>&nbsp;<i>m</i>&nbsp;<code>&lt;=</code>&nbsp;3, 0&nbsp;<code>&lt;=</code>&nbsp;<i>n</i>&nbsp;<code>&lt;=</code>&nbsp;7)   <code>\x</code><i>hh</i> The character with hexadecimal value <code>0x</code><i>hh</i>   <code>\u</code><i>hhhh</i> The character with hexadecimal&nbsp;value&nbsp;<code>0x</code><i>hhhh</i>   <code>\x</code><i>{h...h}</i> The character with hexadecimal value <code>0x</code><i>h...h</i> (<a href="../../lang/Character.html#MIN_CODE_POINT"><code>Character.MIN_CODE_POINT</code></a> &nbsp;&lt;=&nbsp;<code>0x</code><i>h...h</i>&nbsp;&lt;=&nbsp; <a href="../../lang/Character.html#MAX_CODE_POINT"><code>Character.MAX_CODE_POINT</code></a>)   <code>\N{</code><i>name</i><code>}</code> The character with Unicode character name <i>'name'</i>   <code>\t</code> The tab character (<code>'\u0009'</code>)   <code>\n</code> The newline (line feed) character (<code>'\u000A'</code>)   <code>\r</code> The carriage-return character (<code>'\u000D'</code>)   <code>\f</code> The form-feed character (<code>'\u000C'</code>)   <code>\a</code> The alert (bell) character (<code>'\u0007'</code>)   <code>\e</code> The escape character (<code>'\u001B'</code>)   <code>\c</code><i>x</i> The control character corresponding to <i>x</i>   Character classes   <code>[abc]</code> <code>a</code>, <code>b</code>, or <code>c</code> (simple class)   <code>[^abc]</code> Any character except <code>a</code>, <code>b</code>, or <code>c</code> (negation)   <code>[a-zA-Z]</code> <code>a</code> through <code>z</code> or <code>A</code> through <code>Z</code>, inclusive (range)   <code>[a-d[m-p]]</code> <code>a</code> through <code>d</code>, or <code>m</code> through <code>p</code>: <code>[a-dm-p]</code> (union)   <code>[a-z&amp;&amp;[def]]</code> <code>d</code>, <code>e</code>, or <code>f</code> (intersection)   <code>[a-z&amp;&amp;[^bc]]</code> <code>a</code> through <code>z</code>, except for <code>b</code> and <code>c</code>: <code>[ad-z]</code> (subtraction)   <code>[a-z&amp;&amp;[^m-p]]</code> <code>a</code> through <code>z</code>, and not <code>m</code> through <code>p</code>: <code>[a-lq-z]</code>(subtraction)   Predefined character classes   <code>.</code> Any character (may or may not match <a href="#lt">line terminators</a>)   <code>\d</code> A digit: <code>[0-9]</code>   <code>\D</code> A non-digit: <code>[^0-9]</code>   <code>\h</code> A horizontal whitespace character: <code>[ \t\xA0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000]</code>   <code>\H</code> A non-horizontal whitespace character: <code>[^\h]</code>   <code>\s</code> A whitespace character: <code>[ \t\n\x0B\f\r]</code>   <code>\S</code> A non-whitespace character: <code>[^\s]</code>   <code>\v</code> A vertical whitespace character: <code>[\n\x0B\f\r\x85\u2028\u2029]</code>    <code>\V</code> A non-vertical whitespace character: <code>[^\v]</code>   <code>\w</code> A word character: <code>[a-zA-Z_0-9]</code>   <code>\W</code> A non-word character: <code>[^\w]</code>   <b>POSIX character classes (US-ASCII only)</b>   <code>\p{Lower}</code> A lower-case alphabetic character: <code>[a-z]</code>   <code>\p{Upper}</code> An upper-case alphabetic character:<code>[A-Z]</code>   <code>\p{ASCII}</code> All ASCII:<code>[\x00-\x7F]</code>   <code>\p{Alpha}</code> An alphabetic character:<code>[\p{Lower}\p{Upper}]</code>   <code>\p{Digit}</code> A decimal digit: <code>[0-9]</code>   <code>\p{Alnum}</code> An alphanumeric character:<code>[\p{Alpha}\p{Digit}]</code>   <code>\p{Punct}</code> Punctuation: One of <code>!"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\]^_`{|}~</code>  
         <!-- {@code [\!"#\$%&'\(\)\*\+,\-\./:;\<=\>\?@\[\\\]\^_`\{\|\}~]}
          {@code [\X21-\X2F\X31-\X40\X5B-\X60\X7B-\X7E]} -->  <code>\p{Graph}</code> A visible character: <code>[\p{Alnum}\p{Punct}]</code>   <code>\p{Print}</code> A printable character: <code>[\p{Graph}\x20]</code>   <code>\p{Blank}</code> A space or a tab: <code>[ \t]</code>   <code>\p{Cntrl}</code> A control character: <code>[\x00-\x1F\x7F]</code>   <code>\p{XDigit}</code> A hexadecimal digit: <code>[0-9a-fA-F]</code>   <code>\p{Space}</code> A whitespace character: <code>[ \t\n\x0B\f\r]</code>   java.lang.Character classes (simple <a href="#jcc">java character type</a>)   <code>\p{javaLowerCase}</code> Equivalent to java.lang.Character.isLowerCase()   <code>\p{javaUpperCase}</code> Equivalent to java.lang.Character.isUpperCase()   <code>\p{javaWhitespace}</code> Equivalent to java.lang.Character.isWhitespace()   <code>\p{javaMirrored}</code> Equivalent to java.lang.Character.isMirrored()   Classes for Unicode scripts, blocks, categories and binary properties   <code>\p{IsLatin}</code> A Latin&nbsp;script character (<a href="#usc">script</a>)   <code>\p{InGreek}</code> A character in the Greek&nbsp;block (<a href="#ubc">block</a>)   <code>\p{Lu}</code> An uppercase letter (<a href="#ucc">category</a>)   <code>\p{IsAlphabetic}</code> An alphabetic character (<a href="#ubpc">binary property</a>)   <code>\p{Sc}</code> A currency symbol   <code>\P{InGreek}</code> Any character except one in the Greek block (negation)   <code>[\p{L}&amp;&amp;[^\p{Lu}]]</code> Any letter except an uppercase letter (subtraction)   Boundary matchers   <code>^</code> The beginning of a line   <code>$</code> The end of a line   <code>\b</code> A word boundary   <code>\b{g}</code> A Unicode extended grapheme cluster boundary   <code>\B</code> A non-word boundary   <code>\A</code> The beginning of the input   <code>\G</code> The end of the previous match   <code>\Z</code> The end of the input but for the final <a href="#lt">terminator</a>, if&nbsp;any   <code>\z</code> The end of the input   Linebreak matcher   <code>\R</code> Any Unicode linebreak sequence, is equivalent to <code>\u000D\u000A|[\u000A\u000B\u000C\u000D\u0085\u2028\u2029] </code>   Unicode Extended Grapheme matcher   <code>\X</code> Any Unicode extended grapheme cluster   Greedy quantifiers   <i>X</i><code>?</code> <i>X</i>, once or not at all   <i>X</i><code>*</code> <i>X</i>, zero or more times   <i>X</i><code>+</code> <i>X</i>, one or more times   <i>X</i><code>{</code><i>n</i><code>}</code> <i>X</i>, exactly <i>n</i> times   <i>X</i><code>{</code><i>n</i><code>,</code>} <i>X</i>, at least <i>n</i> times   <i>X</i><code>{</code><i>n</i><code>,</code><i>m</i><code>}</code> <i>X</i>, at least <i>n</i> but not more than <i>m</i> times   Reluctant quantifiers   <i>X</i><code>??</code> <i>X</i>, once or not at all   <i>X</i><code>*?</code> <i>X</i>, zero or more times   <i>X</i><code>+?</code> <i>X</i>, one or more times   <i>X</i><code>{</code><i>n</i><code>}?</code> <i>X</i>, exactly <i>n</i> times   <i>X</i><code>{</code><i>n</i><code>,}?</code> <i>X</i>, at least <i>n</i> times   <i>X</i><code>{</code><i>n</i><code>,</code><i>m</i><code>}?</code> <i>X</i>, at least <i>n</i> but not more than <i>m</i> times   Possessive quantifiers   <i>X</i><code>?+</code> <i>X</i>, once or not at all   <i>X</i><code>*+</code> <i>X</i>, zero or more times   <i>X</i><code>++</code> <i>X</i>, one or more times   <i>X</i><code>{</code><i>n</i><code>}+</code> <i>X</i>, exactly <i>n</i> times   <i>X</i><code>{</code><i>n</i><code>,}+</code> <i>X</i>, at least <i>n</i> times   <i>X</i><code>{</code><i>n</i><code>,</code><i>m</i><code>}+</code> <i>X</i>, at least <i>n</i> but not more than <i>m</i> times   Logical operators   <i>XY</i> <i>X</i> followed by <i>Y</i>   <i>X</i><code>|</code><i>Y</i> Either <i>X</i> or <i>Y</i>   <code>(</code><i>X</i><code>)</code> X, as a <a href="#cg">capturing group</a>   Back references   <code>\</code><i>n</i> Whatever the <i>n</i><sup>th</sup> <a href="#cg">capturing group</a> matched   <code>\</code><i>k</i>&lt;<i>name</i>&gt; Whatever the <a href="#groupname">named-capturing group</a> "name" matched   Quotation   <code>\</code> Nothing, but quotes the following character   <code>\Q</code> Nothing, but quotes all characters until <code>\E</code>   <code>\E</code> Nothing, but ends quoting started by <code>\Q</code>  
         <!-- Metachars: !$()*+.<>?[\]^{|} -->  Special constructs (named-capturing and non-capturing)   <code>(?&lt;<a href="#groupname">name</a>&gt;</code><i>X</i><code>)</code> <i>X</i>, as a named-capturing group   <code>(?:</code><i>X</i><code>)</code> <i>X</i>, as a non-capturing group   <code>(?idmsuxU-idmsuxU)&nbsp;</code> Nothing, but turns match flags <a href="#CASE_INSENSITIVE">i</a> <a href="#UNIX_LINES">d</a> <a href="#MULTILINE">m</a> <a href="#DOTALL">s</a> <a href="#UNICODE_CASE">u</a> <a href="#COMMENTS">x</a> <a href="#UNICODE_CHARACTER_CLASS">U</a> on - off   <code>(?idmsux-idmsux:</code><i>X</i><code>)</code>&nbsp;&nbsp; <i>X</i>, as a <a href="#cg">non-capturing group</a> with the given flags <a href="#CASE_INSENSITIVE">i</a> <a href="#UNIX_LINES">d</a> <a href="#MULTILINE">m</a> <a href="#DOTALL">s</a> <a href="#UNICODE_CASE">u</a> <a href="#COMMENTS">x</a> on - off   <code>(?=</code><i>X</i><code>)</code> <i>X</i>, via zero-width positive lookahead   <code>(?!</code><i>X</i><code>)</code> <i>X</i>, via zero-width negative lookahead   <code>(?&lt;=</code><i>X</i><code>)</code> <i>X</i>, via zero-width positive lookbehind   <code>(?&lt;!</code><i>X</i><code>)</code> <i>X</i>, via zero-width negative lookbehind   <code>(?&gt;</code><i>X</i><code>)</code> <i>X</i>, as an independent, non-capturing group  </span> 
        <table class="borderless"> 
        </table> 
        <hr> 
        <h3> <span><a id="bs">Backslashes, escapes, and quoting</a></span> </h3> 
        <p> <span>反斜杠字符（ <code>'\'</code> ）用于引入如上表中定义的转义构造，以及引用否则将被解释为非转义构造的字符。</span> <span>因此，表达式<code>\\</code>匹配单个反斜杠， <code>\{</code>匹配左括号。</span> </p> 
        <p> <span>在任何不表示转义构造的字母字符之前使用反斜杠是错误的;</span> <span>这些保留用于将来对正则表达式语言的扩展。</span> <span>无论该字符是否是未转义构造的一部分，都可以在非字母字符之前使用反斜杠。</span> </p> 
        <p> <span>Java源代码中字符串文字中的反斜杠被<cite>The Java™ Language Specification</cite>解释为Unicode转义（第3.3节）或其他字符转义（第3.10.6节）。因此，必须在表示正则表达式的字符串文字中加倍反斜杠以保护它们免受由Java字节码编译器解释。</span> <span>例如，字符串文字<code>"\b"</code>在解释为正则表达式时匹配单个退格字符，而<code>"\\b"</code>与单词边界匹配。</span> <span>字符串文字<code>"\(hello\)"</code>是非法的，并导致编译时错误;</span> <span>为了匹配字符串<code>(hello)</code> ，必须使用字符串文字<code>"\\(hello\\)"</code> 。</span> </p> 
        <h3> <span><a id="cc">Character Classes</a></span> </h3> 
        <p> <span>字符类可以出现在其他字符类中，并且可以由union运算符（隐式）和交集运算符（ <code>&amp;&amp;</code> ）组成。</span> <span>union运算符表示一个类，它包含至少一个操作数类中的每个字符。</span> <span>交集运算符表示一个类，它包含两个操作数类中的每个字符。</span> </p> 
        <p> <span>字符类运算符的优先级如下，从最高到最低：</span> </p> 
        <span> Precedence of character class operators.    Precedence Name Example      1 Literal escape&nbsp;&nbsp;&nbsp;&nbsp; <code>\x</code>   2 Grouping <code>[...]</code>   3 Range <code>a-z</code>   4 Union <code>[a-e][i-u]</code>   5 Intersection <code>[a-z&amp;&amp;[aeiou]]</code>  </span> 
        <table class="striped" style="margin-left: 2em;"> 
        </table> 
        <p> <span>请注意，字符类中的一组不同的元字符在字符类外部有效。</span> <span>例如，正则表达式<code>.</code>在字符类中失去其特殊含义，而表达式<code>-</code>变为形成元字符的范围。</span> </p> 
        <h3> <span><a id="lt">Line terminators</a></span> </h3> 
        <p> <span><i>行终止符</i>是一个或两个字符的序列，用于标记输入字符序列的一行的结尾。</span> <span>以下被认为是行终止符：</span> </p> 
        <ul> 
         <li> <span>换行符（换行符）（ <code>'\n'</code> ），</span> </li> 
         <li> <span>一个回车符后面跟一个换行符（ <code>"\r\n"</code> ），</span> </li> 
         <li> <span>一个独立的回车符（ <code>'\r'</code> ），</span> </li> 
         <li> <span>下一行字符（ <code>'\u0085'</code> ），</span> </li> 
         <li> <span>行分隔符（ <code>'\u2028'</code> ），或</span> </li> 
         <li> <span>段落分隔符（ <code>'\u2029'</code> ）。</span> </li> 
        </ul> 
        <p> <span>如果激活<a href="#UNIX_LINES"><code>UNIX_LINES</code></a>模式，则识别的唯一行终止符是换行符。</span> </p> 
        <p> <span>除非指定了<a href="#DOTALL"><code>DOTALL</code></a>标志，否则正则表达式<code>.</code>匹配除行终止符之外的任何字符。</span> </p> 
        <p> <span>默认情况下，正则表达式<code>^</code>和<code>$</code>忽略行终止符，并且仅分别匹配整个输入序列的开头和结尾。</span> <span>如果激活<a href="#MULTILINE"><code>MULTILINE</code></a>模式，则<code>^</code>在输入开始时和任何行终止符之后匹配，但输入结束时除外。</span> <span>当处于<a href="#MULTILINE"><code>MULTILINE</code></a>模式时， <code>$</code>匹配在行终止符之前或输入序列的结尾。</span> </p> 
        <h3> <span><a id="cg">Groups and capturing</a></span> </h3> 
        <h4> <span><a id="gnumber">Group number</a></span> </h4> 
        <p> <span>捕获组通过从左到右计算它们的左括号来编号。</span> <span>例如，在表达式<code>((A)(B(C)))</code> ，有四个这样的组：</span> </p> 
        <ol style="margin-left:2em;"> 
         <li> <code>((A)(B(C)))</code> </li> 
         <li> <code>(A)</code> </li> 
         <li> <code>(B(C))</code> </li> 
         <li> <code>(C)</code> </li> 
        </ol> 
        <p> <span>组零始终代表整个表达式。</span> </p> 
        <p> <span>捕获组是如此命名的，因为在匹配期间，保存与该组匹配的输入序列的每个子序列。</span> <span>捕获的子序列可以稍后在表达式中通过后向引用使用，并且一旦匹配操作完成，也可以从匹配器中检索。</span> </p> 
        <h4> <span><a id="groupname">Group name</a></span> </h4> 
        <p> <span>还可以为捕获组分配“名称”， <code>named-capturing group</code> ，然后通过“名称”对其进行反向引用。</span> <span>组名由以下字符组成。</span> <span>第一个字符必须是<code>letter</code> 。</span> </p> 
        <ul> 
         <li> <span>大写字母<code>'A'</code>到<code>'Z'</code> （ <code>'\u0041'</code>到<code>'\u005a'</code> ），</span> </li> 
         <li> <span>小写字母<code>'a'</code>到<code>'z'</code> （ <code>'\u0061'</code>到<code>'\u007a'</code> ），</span> </li> 
         <li> <span>数字<code>'0'</code>至<code>'9'</code> （ <code>'\u0030'</code>至<code>'\u0039'</code> ），</span> </li> 
        </ul> 
        <p> <span>甲<code>named-capturing group</code>如描述仍然编号<a href="#gnumber">Group number</a> 。</span> </p> 
        <p> <span>与组关联的捕获输入始终是该组最近匹配的子序列。</span> <span>如果由于量化而第二次评估组，则如果第二次评估失败，则将保留其先前捕获的值（如果有的话）。</span> <span>例如，将字符串<code>"aba"</code>与表达式<code>(a(b)?)+</code>匹配，将第二组设置为<code>"b"</code> 。</span> <span>在每次比赛开始时丢弃所有捕获的输入。</span> </p> 
        <p> <span>以<code>(?</code>开头的组是纯<i>捕获</i>组，不捕获文本且不计入组总数或<i>命名捕获</i>组。</span> </p> 
        <h3> <span>Unicode支持</span> </h3> 
        <p> <span>本课程符合第1级<a href="http://www.unicode.org/reports/tr18/"><i>Unicode Technical Standard #18: Unicode Regular Expression</i></a> ，加上RL2.1规范等效。</span> </p> 
        <p> <span>如<b>Unicode转义序列</b> <code>\u2014</code>在Java源代码作为的<cite>The Java™ Language Specification</cite>第3.3节描述的进行处理。</span> <span>这种转义序列也可以由正则表达式解析器直接实现，这样Unicode转义就可以用在从文件或键盘读取的表达式中。</span> <span>因此，字符串<code>"\u2014"</code>和<code>"\\u2014"</code>虽然不相等，但是编译成相同的模式，其匹配具有十六进制值<code>0x2014</code>的字符。</span> </p> 
        <p> <span>Unicode字符也可以通过使用其<b>十六进制表示法</b> （十六进制代码点值）直接表示，如构造<code>\x{...}</code> ，例如，补充字符U + 2011F可以指定为<code>\x{2011F}</code> ，而不是代理对的两个连续Unicode转义序列<code>\uD840</code> <code>\uDD1F</code> 。</span> </p> 
        <p> <span>命名字符构造<code>\N{</code> ... <code>}</code>支持<b>Unicode字符名称</b> ，例如， <code>\N{WHITE SMILING FACE}</code>指定字符<code>\u263A</code> 。</span> <span>此类支持的字符名称是由<a href="../../lang/Character.html#codePointOf(java.lang.String)"><code>Character.codePointOf(name)</code></a>匹配的有效Unicode字符名称。</span> </p> 
        <p> <span><a href="http://www.unicode.org/reports/tr18/#Default_Grapheme_Clusters"><b>Unicode extended grapheme clusters</b></a>由字形簇匹配器支持<code>\X</code>和相应的边界匹配<code>\b{g}</code> 。</span> </p> 
        <p> <span>Unicode脚本，块，类别和二进制属性使用Perl中的<code>\p</code>和<code>\P</code>结构编写。</span> <span><code>\p{</code> <i>prop</i> <code>}</code>匹配，如果输入具有属性<i>prop</i> ，而<code>\P{</code> <i>prop</i> <code>}</code>匹配，如果输入具有该属性。</span> </p> 
        <p> <span>脚本，块，类别和二进制属性可以在字符类的内部和外部使用。</span> </p> 
        <p> <span><b><a id="usc">Scripts</a></b>使用前缀<code>Is</code>指定，如<code>IsHiragana</code> ，或使用<code>script</code>关键字（或其简称<code>sc</code> ），如<code>script=Hiragana</code>或<code>sc=Hiragana</code> 。</span> </p> 
        <p> <span>所支持的脚本名称<code>Pattern</code>是接受和定义的有效脚本名称<a href="../../lang/Character.UnicodeScript.html#forName(java.lang.String)"><code>UnicodeScript.forName</code></a> 。</span> </p> 
        <p> <span><b><a id="ubc">Blocks</a></b>使用前缀<code>In</code>指定，如<code>InMongolian</code> ，或使用关键字<code>block</code> （或其缩写形式<code>blk</code> ），如<code>block=Mongolian</code>或<code>blk=Mongolian</code> 。</span> </p> 
        <p> <span>受支持的块名称<code>Pattern</code>是接受和定义的有效块名称<a href="../../lang/Character.UnicodeBlock.html#forName(java.lang.String)"><code>UnicodeBlock.forName</code></a> 。</span> </p> 
        <p> <span><b><a id="ucc">Categories</a></b>可以使用可选前缀<code>Is</code>指定： <code>\p{L}</code>和<code>\p{IsL}</code>表示Unicode字母的类别。</span> <span>与脚本和块相同，也可以使用关键字<code>general_category</code> （或其简称<code>gc</code> ）指定类别，如<code>general_category=Lu</code>或<code>gc=Lu</code> 。</span> </p> 
        <p> <span>支持的类别是那些<a href="http://www.unicode.org/unicode/standard/standard.html"><i>The Unicode Standard</i></a>由指定的版本<a href="../../lang/Character.html" title="java.lang中的类"><code>Character</code></a>类。</span> <span>类别名称是标准中定义的类别，包括规范性和信息性。</span> </p> 
        <p> <span><b><a id="ubpc">Binary properties</a></b>使用前缀<code>Is</code>指定，如<code>IsAlphabetic</code> 。</span> <span>由<code>Pattern</code>支持的二进制属性是</span> </p> 
        <ul> 
         <li> <span>拼音</span> </li> 
         <li> <span>表意的</span> </li> 
         <li> <span>信件</span> </li> 
         <li> <span>小写</span> </li> 
         <li> <span>大写</span> </li> 
         <li> <span>首字母大写</span> </li> 
         <li> <span>标点</span> </li> 
         <li> <span>控制</span> </li> 
         <li> <span>White_Space</span> </li> 
         <li> <span>数字</span> </li> 
         <li> <span>16进制数字</span> </li> 
         <li> <span>Join_Control</span> </li> 
         <li> <span>Noncharacter_Code_Point</span> </li> 
         <li> <span>分配</span> </li> 
        </ul> 
        <p> <span>以下<b>预定义字符类</b>和<b>POSIX字符类</b>符合<i>附录C</i>的建议<i>：</i> <a href="http://www.unicode.org/reports/tr18/"><i>Unicode Regular Expression </i>的</a> <i>兼容性属性</i> ，当指定<a href="#UNICODE_CHARACTER_CLASS"><code>UNICODE_CHARACTER_CLASS</code></a>标志时。</span> </p> 
        <span> predefined and posix character classes in Unicode mode    Classes Matches     <code>\p{Lower}</code> A lowercase character:<code>\p{IsLowercase}</code>   <code>\p{Upper}</code> An uppercase character:<code>\p{IsUppercase}</code>   <code>\p{ASCII}</code> All ASCII:<code>[\x00-\x7F]</code>   <code>\p{Alpha}</code> An alphabetic character:<code>\p{IsAlphabetic}</code>   <code>\p{Digit}</code> A decimal digit character:<code>\p{IsDigit}</code>   <code>\p{Alnum}</code> An alphanumeric character:<code>[\p{IsAlphabetic}\p{IsDigit}]</code>   <code>\p{Punct}</code> A punctuation character:<code>\p{IsPunctuation}</code>   <code>\p{Graph}</code> A visible character: <code>[^\p{IsWhite_Space}\p{gc=Cc}\p{gc=Cs}\p{gc=Cn}]</code>   <code>\p{Print}</code> A printable character: <code>[\p{Graph}\p{Blank}&amp;&amp;[^\p{Cntrl}]]</code>   <code>\p{Blank}</code> A space or a tab: <code>[\p{IsWhite_Space}&amp;&amp;[^\p{gc=Zl}\p{gc=Zp}\x0a\x0b\x0c\x0d\x85]]</code>   <code>\p{Cntrl}</code> A control character: <code>\p{gc=Cc}</code>   <code>\p{XDigit}</code> A hexadecimal digit: <code>[\p{gc=Nd}\p{IsHex_Digit}]</code>   <code>\p{Space}</code> A whitespace character:<code>\p{IsWhite_Space}</code>   <code>\d</code> A digit: <code>\p{IsDigit}</code>   <code>\D</code> A non-digit: <code>[^\d]</code>   <code>\s</code> A whitespace character: <code>\p{IsWhite_Space}</code>   <code>\S</code> A non-whitespace character: <code>[^\s]</code>   <code>\w</code> A word character: <code>[\p{Alpha}\p{gc=Mn}\p{gc=Me}\p{gc=Mc}\p{Digit}\p{gc=Pc}\p{IsJoin_Control}]</code>   <code>\W</code> A non-word character: <code>[^\w]</code>  </span> 
        <table class="striped"> 
        </table> 
        <p> <span><a id="jcc">Categories that behave like the java.lang.Character boolean is<i>methodname</i> methods (except for the deprecated ones) are available through the same <code>\p{</code><i>prop</i><code>}</code> syntax where the specified property has the name <code>java<i>methodname</i></code></a> 。</span> </p> 
        <h3> <span>与Perl 5的比较</span> </h3> 
        <p> <span><code>Pattern</code>引擎执行传统的基于NFA的匹配，具有Perl 5中的有序交替。</span> </p> 
        <p> <span>此类不支持的Perl构造：</span> </p> 
        <ul> 
         <li><p> <span>反向引用构造， <code>\g{</code> <i>ñ</i> <code>}</code> <sup>第</sup> <i>n</i> <sup>个</sup> <a href="#cg">capturing group</a>和<code>\g{</code> <i>名</i> <code>}</code>为<a href="#groupname">named-capturing group</a> 。</span> </p></li> 
         <li><p> <span>条件构造<code>(?(</code> <i>条件</i> <code>)</code> <i>X</i> <code>)</code>和<code>(?(</code> <i>条件</i> <code>)</code> <i>X</i> <code>|</code> <i>Y</i> <code>)</code> ，</span> </p></li> 
         <li><p> <span>嵌入代码构造<code>(?{</code> <i>代码</i> <code>})</code>和<code>(??{</code> <i>代码</i> <code>})</code> ，</span> </p></li> 
         <li><p> <span>嵌入式注释语法<code>(?#comment)</code> ，和</span> </p></li> 
         <li><p> <span>预处理操作<code>\l</code> <code>\u</code> ， <code>\L</code>和<code>\U</code> 。</span> </p></li> 
        </ul> 
        <p> <span>此类支持的构造，但不是Perl支持的构造：</span> </p> 
        <ul> 
         <li><p> <span>如<a href="#cc">above</a>所述的字符级联合和交集。</span> </p></li> 
        </ul> 
        <p> <span>与Perl的显着差异：</span> </p> 
        <ul> 
         <li><p> <span>在Perl中， <code>\1</code>到<code>\9</code>始终被解释为后向引用;</span> <span>如果存在至少那么多子表达式，则大于<code>9</code>的反斜杠转义数被视为后引用，否则如果可能，将其解释为八进制转义。</span> <span>在这个类中，八进制转义必须始终以零开头。</span> <span>在此类中， <code>\1</code>到<code>\9</code>始终被解释为后向引用，并且如果正则表达式中的那个点处至少存在多个子表达式，则接受较大的数字作为后向引用，否则解析器将丢弃数字直到该数字较小或等于现有的组数或一位数。</span> </p></li> 
         <li><p> <span>Perl使用<code>g</code>标志来请求在最后一场比赛停止的地方恢复的比赛。</span> <span>此功能由<a href="Matcher.html" title="java.util.regex中的类"><code>Matcher</code></a>类隐式提供： <a href="Matcher.html#find()"><code>find</code></a>方法的重复调用将在最后一个匹配停止的位置恢复，除非重置匹配器。</span> </p></li> 
         <li><p> <span>在Perl中，表达式顶层的嵌入式标志会影响整个表达式。</span> <span>在这个类中，嵌入的标志总是在它们出现的位置生效，无论它们是在顶层还是在组内;</span> <span>在后一种情况下，标记在组的末尾恢复，就像在Perl中一样。</span> </p></li> 
        </ul> 
        <p> <span>有关正则表达式构造行为的更精确描述，请参阅<a href="http://www.oreilly.com/catalog/regex3/"><i>Mastering Regular Expressions, 3nd Edition</i>, Jeffrey E. F. Friedl, O'Reilly and Associates, 2006.</a></span> </p> 
       </div> 
       <dl> 
        <dt> 
         <span class="simpleTagLabel">从以下版本开始：</span> 
        </dt> 
        <dd>
          1.4 
        </dd> 
        <dt> 
         <span class="seeLabel">另请参见：</span> 
        </dt> 
        <dd> 
         <a href="../../lang/String.html#split(java.lang.String,int)"><code>String.split(String, int)</code></a> ， 
         <a href="../../lang/String.html#split(java.lang.String)"><code>String.split(String)</code></a> ， 
         <a href="../../../../serialized-form.html#java.util.regex.Pattern">Serialized Form</a> 
        </dd> 
       </dl> </li> 
     </ul> 
    </div> 
    <div class="summary"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <!-- =========== FIELD SUMMARY =========== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="field.summary"> 
           <!--   --> </a> <h3>字段汇总</h3> 
          <table class="memberSummary"> 
           <caption> 
            <span>字段</span> 
            <span class="tabEnd">&nbsp;</span> 
           </caption> 
           <tbody> 
            <tr> 
             <th class="colFirst" scope="col">变量和类型</th> 
             <th class="colSecond" scope="col">字段</th> 
             <th class="colLast" scope="col">描述</th> 
            </tr> 
            <tr class="altColor"> 
             <td class="colFirst"><code>static int</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#CANON_EQ">CANON_EQ</a></span></code></th> 
             <td class="colLast"> 
              <div class="block">
                启用规范等效。 
              </div> </td> 
            </tr> 
            <tr class="rowColor"> 
             <td class="colFirst"><code>static int</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#CASE_INSENSITIVE">CASE_INSENSITIVE</a></span></code></th> 
             <td class="colLast"> 
              <div class="block">
                启用不区分大小写的匹配。 
              </div> </td> 
            </tr> 
            <tr class="altColor"> 
             <td class="colFirst"><code>static int</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#COMMENTS">COMMENTS</a></span></code></th> 
             <td class="colLast"> 
              <div class="block">
                以模式允许空格和注释。 
              </div> </td> 
            </tr> 
            <tr class="rowColor"> 
             <td class="colFirst"><code>static int</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#DOTALL">DOTALL</a></span></code></th> 
             <td class="colLast"> 
              <div class="block">
                启用dotall模式。 
              </div> </td> 
            </tr> 
            <tr class="altColor"> 
             <td class="colFirst"><code>static int</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#LITERAL">LITERAL</a></span></code></th> 
             <td class="colLast"> 
              <div class="block">
                启用模式的文字解析。 
              </div> </td> 
            </tr> 
            <tr class="rowColor"> 
             <td class="colFirst"><code>static int</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#MULTILINE">MULTILINE</a></span></code></th> 
             <td class="colLast"> 
              <div class="block">
                启用多线模式。 
              </div> </td> 
            </tr> 
            <tr class="altColor"> 
             <td class="colFirst"><code>static int</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#UNICODE_CASE">UNICODE_CASE</a></span></code></th> 
             <td class="colLast"> 
              <div class="block">
                启用支持Unicode的案例折叠。 
              </div> </td> 
            </tr> 
            <tr class="rowColor"> 
             <td class="colFirst"><code>static int</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#UNICODE_CHARACTER_CLASS">UNICODE_CHARACTER_CLASS</a></span></code></th> 
             <td class="colLast"> 
              <div class="block">
                启用Unicode版本的 
               <i>预定义字符类</i>和 
               <i>POSIX字符类</i> 。 
              </div> </td> 
            </tr> 
            <tr class="altColor"> 
             <td class="colFirst"><code>static int</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#UNIX_LINES">UNIX_LINES</a></span></code></th> 
             <td class="colLast"> 
              <div class="block">
                启用Unix线路模式。 
              </div> </td> 
            </tr> 
           </tbody> 
          </table> </li> 
        </ul> 
       </section> 
       <!-- ========== METHOD SUMMARY =========== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="method.summary"> 
           <!--   --> </a> <h3>方法摘要</h3> 
          <table class="memberSummary"> 
           <caption> 
           <span id="t0" class="activeTableTab"><span>所有方法</span><span class="tabEnd">&nbsp;</span>
            <span id="t1" class="tableTab"><span><a href="javascript:show(1);">静态方法</a></span><span class="tabEnd">&nbsp;</span></span> 
             <span id="t2" class="tableTab"><span><a href="javascript:show(2);">实例方法</a>  </span></span> 
            <span id="t4" class="tableTab"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd">&nbsp;</span></span> 
           </caption> 
           <tbody> 
            <tr> 
             <th class="colFirst" scope="col">变量和类型</th> 
             <th class="colSecond" scope="col">方法</th> 
             <th class="colLast" scope="col">描述</th> 
            </tr> 
            <tr id="i0" class="altColor"> 
             <td class="colFirst"><code><a href="../function/Predicate.html" title="interface in java.util.function">Predicate</a>&lt;<a href="../../lang/String.html" title="class in java.lang">String</a>&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#asMatchPredicate()">asMatchPredicate</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                创建一个谓词，测试此模式是否与给定的输入字符串匹配。 
              </div> </td> 
            </tr> 
            <tr id="i1" class="rowColor"> 
             <td class="colFirst"><code><a href="../function/Predicate.html" title="interface in java.util.function">Predicate</a>&lt;<a href="../../lang/String.html" title="class in java.lang">String</a>&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#asPredicate()">asPredicate</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                创建一个谓词，测试是否在给定的输入字符串中找到此模式。 
              </div> </td> 
            </tr> 
            <tr id="i2" class="altColor"> 
             <td class="colFirst"><code>static <a href="Pattern.html" title="class in java.util.regex">Pattern</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#compile(java.lang.String)">compile</a></span>​(<a href="../../lang/String.html" title="class in java.lang">String</a>&nbsp;regex)</code></th> 
             <td class="colLast"> 
              <div class="block">
                将给定的正则表达式编译为模式。 
              </div> </td> 
            </tr> 
            <tr id="i3" class="rowColor"> 
             <td class="colFirst"><code>static <a href="Pattern.html" title="class in java.util.regex">Pattern</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#compile(java.lang.String,int)">compile</a></span>​(<a href="../../lang/String.html" title="class in java.lang">String</a>&nbsp;regex, int&nbsp;flags)</code></th> 
             <td class="colLast"> 
              <div class="block">
                将给定的正则表达式编译为具有给定标志的模式。 
              </div> </td> 
            </tr> 
            <tr id="i4" class="altColor"> 
             <td class="colFirst"><code>int</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#flags()">flags</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回此模式的匹配标志。 
              </div> </td> 
            </tr> 
            <tr id="i5" class="rowColor"> 
             <td class="colFirst"><code><a href="Matcher.html" title="class in java.util.regex">Matcher</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#matcher(java.lang.CharSequence)">matcher</a></span>​(<a href="../../lang/CharSequence.html" title="interface in java.lang">CharSequence</a>&nbsp;input)</code></th> 
             <td class="colLast"> 
              <div class="block">
                创建一个匹配此模式的给定输入的匹配器。 
              </div> </td> 
            </tr> 
            <tr id="i6" class="altColor"> 
             <td class="colFirst"><code>static boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#matches(java.lang.String,java.lang.CharSequence)">matches</a></span>​(<a href="../../lang/String.html" title="class in java.lang">String</a>&nbsp;regex, <a href="../../lang/CharSequence.html" title="interface in java.lang">CharSequence</a>&nbsp;input)</code></th> 
             <td class="colLast"> 
              <div class="block">
                编译给定的正则表达式并尝试将给定的输入与其匹配。 
              </div> </td> 
            </tr> 
            <tr id="i7" class="rowColor"> 
             <td class="colFirst"><code><a href="../../lang/String.html" title="class in java.lang">String</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#pattern()">pattern</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回编译此模式的正则表达式。 
              </div> </td> 
            </tr> 
            <tr id="i8" class="altColor"> 
             <td class="colFirst"><code>static <a href="../../lang/String.html" title="class in java.lang">String</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#quote(java.lang.String)">quote</a></span>​(<a href="../../lang/String.html" title="class in java.lang">String</a>&nbsp;s)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回面值模式 
               <code>String</code>指定的 
               <code>String</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i9" class="rowColor"> 
             <td class="colFirst"><code><a href="../../lang/String.html" title="class in java.lang">String</a>[]</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#split(java.lang.CharSequence)">split</a></span>​(<a href="../../lang/CharSequence.html" title="interface in java.lang">CharSequence</a>&nbsp;input)</code></th> 
             <td class="colLast"> 
              <div class="block">
                围绕此模式的匹配拆分给定的输入序列。 
              </div> </td> 
            </tr> 
            <tr id="i10" class="altColor"> 
             <td class="colFirst"><code><a href="../../lang/String.html" title="class in java.lang">String</a>[]</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#split(java.lang.CharSequence,int)">split</a></span>​(<a href="../../lang/CharSequence.html" title="interface in java.lang">CharSequence</a>&nbsp;input, int&nbsp;limit)</code></th> 
             <td class="colLast"> 
              <div class="block">
                围绕此模式的匹配拆分给定的输入序列。 
              </div> </td> 
            </tr> 
            <tr id="i11" class="rowColor"> 
             <td class="colFirst"><code><a href="../stream/Stream.html" title="interface in java.util.stream">Stream</a>&lt;<a href="../../lang/String.html" title="class in java.lang">String</a>&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#splitAsStream(java.lang.CharSequence)">splitAsStream</a></span>​(<a href="../../lang/CharSequence.html" title="interface in java.lang">CharSequence</a>&nbsp;input)</code></th> 
             <td class="colLast"> 
              <div class="block">
                围绕此模式的匹配从给定输入序列创建流。 
              </div> </td> 
            </tr> 
            <tr id="i12" class="altColor"> 
             <td class="colFirst"><code><a href="../../lang/String.html" title="class in java.lang">String</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toString()">toString</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回此模式的字符串表示形式。 
              </div> </td> 
            </tr> 
           </tbody> 
          </table> 
          <ul class="blockList"> 
           <li class="blockList"><a id="methods.inherited.from.class.java.lang.Object"> 
             <!--   --> </a> <h3>声明方法的类&nbsp;java.lang.<a href="../../lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../lang/Object.html#clone()">clone</a>, <a href="../../lang/Object.html#equals(java.lang.Object)">equals</a>, <a href="../../lang/Object.html#finalize()">finalize</a>, <a href="../../lang/Object.html#getClass()">getClass</a>, <a href="../../lang/Object.html#hashCode()">hashCode</a>, <a href="../../lang/Object.html#notify()">notify</a>, <a href="../../lang/Object.html#notifyAll()">notifyAll</a>, <a href="../../lang/Object.html#wait()">wait</a>, <a href="../../lang/Object.html#wait(long)">wait</a>, <a href="../../lang/Object.html#wait(long,int)">wait</a></code></li> 
          </ul> </li> 
        </ul> 
       </section> </li> 
     </ul> 
    </div> 
    <div class="details"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <!-- ============ FIELD DETAIL =========== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="field.detail"> 
           <!--   --> </a> <h3>字段详细信息</h3> <a id="UNIX_LINES"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>UNIX_LINES</h4> <pre>public static final&nbsp;int UNIX_LINES</pre> 
            <div class="block"> 
             <span>启用Unix线路模式。</span> 
             <p> <span>在这种模式下，只有<code>'\n'</code>行结束在行为认可<code>.</code> ， <code>^</code>和<code>$</code> 。</span> </p> 
             <p> <span>Unix行模式也可以通过嵌入式标志表达式<code>(?d)</code>启用。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="../../../../constant-values.html#java.util.regex.Pattern.UNIX_LINES">常数字段值</a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="CASE_INSENSITIVE"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>CASE_INSENSITIVE</h4> <pre>public static final&nbsp;int CASE_INSENSITIVE</pre> 
            <div class="block"> 
             <span>启用不区分大小写的匹配。</span> 
             <p> <span>默认情况下，不区分大小写的匹配假定只匹配US-ASCII字符集中的字符。</span> <span>通过将<a href="#UNICODE_CASE"><code>UNICODE_CASE</code></a>标志与此标志一起指定，可以启用Unicode感知的不区分大小写的匹配。</span> </p> 
             <p> <span>也可以通过嵌入式标志表达式<code>(?i)</code>启用不区分大小写的匹配。</span> </p> 
             <p> <span>指定此标志可能会略微降低性能。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="../../../../constant-values.html#java.util.regex.Pattern.CASE_INSENSITIVE">常数字段值</a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="COMMENTS"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>COMMENTS</h4> <pre>public static final&nbsp;int COMMENTS</pre> 
            <div class="block"> 
             <span>以模式允许空格和注释。</span> 
             <p> <span>在此模式下，将忽略空格，并且忽略以<code>#</code>开头的嵌入式注释，直到行结束。</span> </p> 
             <p> <span>注释模式也可以通过嵌入式标志表达式<code>(?x)</code>启用。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="../../../../constant-values.html#java.util.regex.Pattern.COMMENTS">常数字段值</a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="MULTILINE"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>MULTILINE</h4> <pre>public static final&nbsp;int MULTILINE</pre> 
            <div class="block"> 
             <span>启用多线模式。</span> 
             <p> <span>在多线模式中，表达式<code>^</code>和<code>$</code>分别在行终止符之后或之前或输入序列的末尾匹配。</span> <span>默认情况下，这些表达式仅在整个输入序列的开头和结尾处匹配。</span> </p> 
             <p> <span>也可以通过嵌入式标志表达式<code>(?m)</code>启用多行模式。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="../../../../constant-values.html#java.util.regex.Pattern.MULTILINE">常数字段值</a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="LITERAL"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>LITERAL</h4> <pre>public static final&nbsp;int LITERAL</pre> 
            <div class="block"> 
             <span>启用模式的文字解析。</span> 
             <p> <span>指定此标志后，指定模式的输入字符串将被视为文字字符序列。</span> <span>输入序列中的元字符或转义序列将没有特殊含义。</span> </p> 
             <p> <span>当与此标志一起使用时，标志CASE_INSENSITIVE和UNICODE_CASE将保持对匹配的影响。</span> <span>其他标志变得多余。</span> </p> 
             <p> <span>没有用于启用文字解析的嵌入标志字符。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.5 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="../../../../constant-values.html#java.util.regex.Pattern.LITERAL">常数字段值</a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="DOTALL"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>DOTALL</h4> <pre>public static final&nbsp;int DOTALL</pre> 
            <div class="block"> 
             <span>启用dotall模式。</span> 
             <p> <span>在dotall模式下，表达式<code>.</code>匹配任何字符，包括行终止符。</span> <span>默认情况下，此表达式与行终止符不匹配。</span> </p> 
             <p> <span>也可以通过嵌入式标志表达式<code>(?s)</code>启用Dotall模式。</span> <span>（ <code>s</code>是“单行”模式的助记符，这是在Perl中调用的。）</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="../../../../constant-values.html#java.util.regex.Pattern.DOTALL">常数字段值</a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="UNICODE_CASE"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>UNICODE_CASE</h4> <pre>public static final&nbsp;int UNICODE_CASE</pre> 
            <div class="block"> 
             <span>启用支持Unicode的案例折叠。</span> 
             <p> <span>指定此标志时，由<a href="#CASE_INSENSITIVE"><code>CASE_INSENSITIVE</code></a>标志启用时，不区分大小写的匹配<a href="#CASE_INSENSITIVE">将以</a>与Unicode标准一致的方式完成。</span> <span>默认情况下，不区分大小写的匹配假定只匹配US-ASCII字符集中的字符。</span> </p> 
             <p> <span>也可以通过嵌入式标志表达式<code>(?u)</code>启用支持Unicode的案例折叠。</span> </p> 
             <p> <span>指定此标志可能会造成性能损失。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="../../../../constant-values.html#java.util.regex.Pattern.UNICODE_CASE">常数字段值</a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="CANON_EQ"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>CANON_EQ</h4> <pre>public static final&nbsp;int CANON_EQ</pre> 
            <div class="block"> 
             <span>启用规范等效。</span> 
             <p> <span>指定此标志时，如果且仅当它们的完整规范分解匹配时，将认为两个字符匹配。</span> <span>例如，当指定此标志时，表达式<code>"a\u030A"</code>将匹配字符串<code>"\u00E5"</code> 。</span> <span>默认情况下，匹配不会将规范等效性考虑在内。</span> </p> 
             <p> <span>没有用于启用规范等价的嵌入标志字符。</span> </p> 
             <p> <span>指定此标志可能会造成性能损失。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="../../../../constant-values.html#java.util.regex.Pattern.CANON_EQ">常数字段值</a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="UNICODE_CHARACTER_CLASS"> 
           <!--   --> </a> 
          <ul class="blockListLast"> 
           <li class="blockList"> <h4>UNICODE_CHARACTER_CLASS</h4> <pre>public static final&nbsp;int UNICODE_CHARACTER_CLASS</pre> 
            <div class="block"> 
             <span>启用Unicode版本的<i>预定义字符类</i>和<i>POSIX字符类</i> 。</span> 
             <p> <span>指定此标志后，（仅限US-ASCII） <i>预定义字符类</i>和<i>POSIX字符类</i>符合<a href="http://www.unicode.org/reports/tr18/"><i>Unicode Technical Standard #18: Unicode Regular Expression</i></a> <i>附录C：兼容性属性</i> 。</span> </p> 
             <p> <span>也可以通过嵌入式标志表达式<code>(?U)</code>启用UNICODE_CHARACTER_CLASS模式。</span> </p> 
             <p> <span>该标志意味着UNICODE_CASE，也就是说，它启用了Unicode感知的案例折叠。</span> </p> 
             <p> <span>指定此标志可能会造成性能损失。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.7 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="../../../../constant-values.html#java.util.regex.Pattern.UNICODE_CHARACTER_CLASS">常数字段值</a> 
             </dd> 
            </dl> </li> 
          </ul> </li> 
        </ul> 
       </section> 
       <!-- ============ METHOD DETAIL ========== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="method.detail"> 
           <!--   --> </a> <h3>方法详细信息</h3> <a id="compile(java.lang.String)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>compile</h4> <pre class="methodSignature">public static&nbsp;<a href="Pattern.html" title="class in java.util.regex">Pattern</a>&nbsp;compile​(<a href="../../lang/String.html" title="class in java.lang">String</a>&nbsp;regex)</pre> 
            <div class="block">
              将给定的正则表达式编译为模式。 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>regex</code> - 要编译的表达式 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               将给定的正则表达式编译成模式 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="PatternSyntaxException.html" title="class in java.util.regex">PatternSyntaxException</a></code> - 如果表达式的语法无效 
             </dd> 
            </dl> </li> 
          </ul> <a id="compile(java.lang.String,int)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>compile</h4> <pre class="methodSignature">public static&nbsp;<a href="Pattern.html" title="class in java.util.regex">Pattern</a>&nbsp;compile​(<a href="../../lang/String.html" title="class in java.lang">String</a>&nbsp;regex,
                              int&nbsp;flags)</pre> 
            <div class="block">
              将给定的正则表达式编译为具有给定标志的模式。 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>regex</code> - 要编译的表达式 
             </dd> 
             <dd> 
              <code>flags</code> -匹配标志，一个位掩码，可能包括 
              <a href="#CASE_INSENSITIVE"><code>CASE_INSENSITIVE</code></a> ， 
              <a href="#MULTILINE"><code>MULTILINE</code></a> ， 
              <a href="#DOTALL"><code>DOTALL</code></a> ， 
              <a href="#UNICODE_CASE"><code>UNICODE_CASE</code></a> ， 
              <a href="#CANON_EQ"><code>CANON_EQ</code></a> ， 
              <a href="#UNIX_LINES"><code>UNIX_LINES</code></a> ， 
              <a href="#LITERAL"><code>LITERAL</code></a> ， 
              <a href="#UNICODE_CHARACTER_CLASS"><code>UNICODE_CHARACTER_CLASS</code></a>和 
              <a href="#COMMENTS"><code>COMMENTS</code></a> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               给定的正则表达式编译成具有给定标志的模式 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果在 
              <code>flags</code>中设置了与定义的匹配标志对应的位值以外的位值 
             </dd> 
             <dd> 
              <code><a href="PatternSyntaxException.html" title="class in java.util.regex">PatternSyntaxException</a></code> - 如果表达式的语法无效 
             </dd> 
            </dl> </li> 
          </ul> <a id="pattern()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>pattern</h4> <pre class="methodSignature">public&nbsp;<a href="../../lang/String.html" title="class in java.lang">String</a>&nbsp;pattern()</pre> 
            <div class="block">
              返回编译此模式的正则表达式。 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               这种模式的来源 
             </dd> 
            </dl> </li> 
          </ul> <a id="toString()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>toString</h4> <pre class="methodSignature">public&nbsp;<a href="../../lang/String.html" title="class in java.lang">String</a>&nbsp;toString()</pre> 
            <div class="block"> 
             <p> <span>返回此模式的字符串表示形式。</span> <span>这是编译此模式的正则表达式。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="overrideSpecifyLabel">重写：</span> 
             </dt> 
             <dd> 
              <code><a href="../../lang/Object.html#toString()">toString</a></code>在类 
              <code><a href="../../lang/Object.html" title="class in java.lang">Object</a></code> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               此模式的字符串表示形式 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.5 
             </dd> 
            </dl> </li> 
          </ul> <a id="matcher(java.lang.CharSequence)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>matcher</h4> <pre class="methodSignature">public&nbsp;<a href="Matcher.html" title="class in java.util.regex">Matcher</a>&nbsp;matcher​(<a href="../../lang/CharSequence.html" title="interface in java.lang">CharSequence</a>&nbsp;input)</pre> 
            <div class="block">
              创建一个匹配此模式的给定输入的匹配器。 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>input</code> - 要匹配的字符序列 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               这种模式的新匹配器 
             </dd> 
            </dl> </li> 
          </ul> <a id="flags()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>flags</h4> <pre class="methodSignature">public&nbsp;int&nbsp;flags()</pre> 
            <div class="block">
              返回此模式的匹配标志。 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               编译此模式时指定的匹配标志 
             </dd> 
            </dl> </li> 
          </ul> <a id="matches(java.lang.String,java.lang.CharSequence)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>matches</h4> <pre class="methodSignature">public static&nbsp;boolean&nbsp;matches​(<a href="../../lang/String.html" title="class in java.lang">String</a>&nbsp;regex,
                              <a href="../../lang/CharSequence.html" title="interface in java.lang">CharSequence</a>&nbsp;input)</pre> 
            <div class="block"> 
             <span>编译给定的正则表达式并尝试将给定的输入与其匹配。</span> 
             <p> <span>调用表单的这种方便方法</span> </p> 
             <blockquote> 
              <span><pre>
 Pattern.matches(regex, input);</pre></span> 
             </blockquote> 
             <span>行为与表达式完全相同</span> 
             <blockquote> 
              <span><pre>
 Pattern.compile(regex).matcher(input).matches()</pre></span> 
             </blockquote> 
             <p> <span>如果要多次使用模式，则对其进行一次编译并重新使用它将比每次调用此方法更有效。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>regex</code> - 要编译的表达式 
             </dd> 
             <dd> 
              <code>input</code> - 要匹配的字符序列 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               正则表达式是否与输入匹配 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="PatternSyntaxException.html" title="class in java.util.regex">PatternSyntaxException</a></code> - 如果表达式的语法无效 
             </dd> 
            </dl> </li> 
          </ul> <a id="split(java.lang.CharSequence,int)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>split</h4> <pre class="methodSignature">public&nbsp;<a href="../../lang/String.html" title="class in java.lang">String</a>[]&nbsp;split​(<a href="../../lang/CharSequence.html" title="interface in java.lang">CharSequence</a>&nbsp;input,
                      int&nbsp;limit)</pre> 
            <div class="block"> 
             <span>围绕此模式的匹配拆分给定的输入序列。</span> 
             <p> <span>此方法返回的数组包含输入序列的每个子字符串，该子字符串由与此模式匹配的另一个子序列终止，或者由输入序列的末尾终止。</span> <span>数组中的子串按它们在输入中出现的顺序排列。</span> <span>如果此模式与输入的任何子序列都不匹配，则生成的数组只有一个元素，即字符串形式的输入序列。</span> </p> 
             <p> <span>当在输入序列的开头存在正宽度匹配时，在结果数组的开头包括空的前导子串。</span> <span>然而，开头的零宽度匹配从不会产生这样的空前导子串。</span> </p> 
             <p> <span><code>limit</code>参数控制应用模式的次数，因此会影响结果数组的长度。</span> </p> 
             <ul> 
              <li><p> <span>如果<i>限制</i>为正，则模式将应用最多<i>限制</i> - 1次，数组的长度不会超过<i>限制</i> ，并且数组的最后一个条目将包含超出最后一个匹配分隔符的所有输入。</span> </p></li> 
              <li><p> <span>如果<i>限制</i>为零，则模式将尽可能多地应用，数组可以具有任何长度，并且将丢弃尾随空字符串。</span> </p></li> 
              <li><p> <span>如果<i>限制</i>为负，则模式将尽可能多地应用，并且数组可以具有任何长度。</span> </p></li> 
             </ul> 
             <p> <span>例如，输入<code>"boo:and:foo"</code>使用以下参数产生以下结果：</span> </p> 
             <span> Split example showing regex, limit, and result    Regex Limit Result     : 2 <code>{ "boo", "and:foo" }</code>   
              <!-- : --> 5 <code>{ "boo", "and", "foo" }</code>   
              <!-- : --> -2 <code>{ "boo", "and", "foo" }</code>   o 5 <code>{ "b", "", ":and:f", "", "" }</code>   
              <!-- o --> -2 <code>{ "b", "", ":and:f", "", "" }</code>   
              <!-- o --> 0 <code>{ "b", "", ":and:f" }</code>  </span> 
             <table class="plain" style="margin-left:2em;"> 
             </table> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>input</code> - 要拆分的字符序列 
             </dd> 
             <dd> 
              <code>limit</code> - 结果阈值，如上所述 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               通过围绕此模式的匹配拆分输入来计算的字符串数组 
             </dd> 
            </dl> </li> 
          </ul> <a id="split(java.lang.CharSequence)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>split</h4> <pre class="methodSignature">public&nbsp;<a href="../../lang/String.html" title="class in java.lang">String</a>[]&nbsp;split​(<a href="../../lang/CharSequence.html" title="interface in java.lang">CharSequence</a>&nbsp;input)</pre> 
            <div class="block"> 
             <span>围绕此模式的匹配拆分给定的输入序列。</span> 
             <p> <span>此方法的工作方式就像调用具有给定输入序列和limit参数为零的双参数<a href="#split(java.lang.CharSequence,int)"><code>split</code></a>方法一样。</span> <span>因此，结尾的空字符串不包含在结果数组中。</span> </p> 
             <p> <span>例如，输入<code>"boo:and:foo"</code>使用以下表达式产生以下结果：</span> </p> 
             <span> Split examples showing regex and result    Regex Result     : <code>{ "boo", "and", "foo" }</code>   o <code>{ "b", "", ":and:f" }</code>  </span> 
             <table class="plain" style="margin-left:2em"> 
             </table> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>input</code> - 要拆分的字符序列 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               通过围绕此模式的匹配拆分输入来计算的字符串数组 
             </dd> 
            </dl> </li> 
          </ul> <a id="quote(java.lang.String)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>quote</h4> <pre class="methodSignature">public static&nbsp;<a href="../../lang/String.html" title="class in java.lang">String</a>&nbsp;quote​(<a href="../../lang/String.html" title="class in java.lang">String</a>&nbsp;s)</pre> 
            <div class="block"> 
             <span>返回面值模式<code>String</code>指定的<code>String</code> 。</span> 
             <p> <span>此方法生成<code>String</code> ，可用于创建<code>Pattern</code> ，该字符串与字符串<code>s</code>匹配，就像它是文字模式一样。</span> </p> 
             <span>输入序列中的元字符或转义序列将没有特殊含义。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>s</code> - 要文字化的字符串 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               文字字符串替换 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.5 
             </dd> 
            </dl> </li> 
          </ul> <a id="asPredicate()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>asPredicate</h4> <pre class="methodSignature">public&nbsp;<a href="../function/Predicate.html" title="interface in java.util.function">Predicate</a>&lt;<a href="../../lang/String.html" title="class in java.lang">String</a>&gt;&nbsp;asPredicate()</pre> 
            <div class="block">
              创建一个谓词，测试是否在给定的输入字符串中找到此模式。 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>此方法创建一个谓词，其行为就像从输入序列创建匹配器，然后调用<code>find</code> ，例如表单的谓词：</span> 
              <pre>  <span><code> s -&gt; matcher(s).find(); </code></span> </pre> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               可用于在字符串的子序列中查找匹配的谓词 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.8 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="Matcher.html#find()"><code>Matcher.find()</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="asMatchPredicate()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>asMatchPredicate</h4> <pre class="methodSignature">public&nbsp;<a href="../function/Predicate.html" title="interface in java.util.function">Predicate</a>&lt;<a href="../../lang/String.html" title="class in java.lang">String</a>&gt;&nbsp;asMatchPredicate()</pre> 
            <div class="block">
              创建一个谓词，测试此模式是否与给定的输入字符串匹配。 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>此方法创建一个谓词，其行为就像从输入序列创建匹配器，然后调用<code>matches</code> ，例如表单的谓词：</span> 
              <pre>  <span><code> s -&gt; matcher(s).matches(); </code></span> </pre> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               可用于将输入字符串与此模式进行匹配的谓词。 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               11 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="Matcher.html#matches()"><code>Matcher.matches()</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="splitAsStream(java.lang.CharSequence)"> 
           <!--   --> </a> 
          <ul class="blockListLast"> 
           <li class="blockList"> <h4>splitAsStream</h4> <pre class="methodSignature">public&nbsp;<a href="../stream/Stream.html" title="interface in java.util.stream">Stream</a>&lt;<a href="../../lang/String.html" title="class in java.lang">String</a>&gt;&nbsp;splitAsStream​(<a href="../../lang/CharSequence.html" title="interface in java.lang">CharSequence</a>&nbsp;input)</pre> 
            <div class="block"> 
             <span>围绕此模式的匹配从给定输入序列创建流。</span> 
             <p> <span>此方法返回的流包含输入序列的每个子字符串，该子字符串由与此模式匹配的另一个子序列终止，或者由输入序列的末尾终止。</span> <span>流中的子串按它们在输入中出现的顺序排列。</span> <span>尾随空字符串将被丢弃，并且不会在流中遇到。</span> </p> 
             <p> <span>如果此模式与输入的任何子序列都不匹配，则生成的流只有一个元素，即字符串形式的输入序列。</span> </p> 
             <p> <span>当在输入序列的开头存在正宽度匹配时，在流的开头包括空的前导子串。</span> <span>然而，开头的零宽度匹配从不会产生这样的空前导子串。</span> </p> 
             <p> <span>如果输入序列是可变的，则在执行终端流操作期间它必须保持不变。</span> <span>否则，终端流操作的结果是未定义的。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>input</code> - 要拆分的字符序列 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               通过在该模式的匹配周围分割输入来计算的字符串流 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.8 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#split(java.lang.CharSequence)"><code>split(CharSequence)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> </li> 
        </ul> 
       </section> </li> 
     </ul> 
    </div> 
   </div> 
  </main> 
  <!-- ========= END OF CLASS DATA ========= --> 
  <footer role="contentinfo"> 
   <nav role="navigation"> 
    <!-- ======= START OF BOTTOM NAVBAR ====== --> 
    <div class="bottomNav"> 
     <a id="navbar.bottom"> 
      <!--   --> </a> 
     <div class="skipNav"> 
      <a href="#skip.navbar.bottom" title="Skip navigation links">跳过导航</a> 
     </div> 
     <a id="navbar.bottom.firstrow"> 
      <!--   --> </a> 
     <ul class="navList" title="Navigation"> 
      <li><a href="../../../../index.html">概述</a></li> 
      <li><a href="../../../module-summary.html">模块</a></li> 
      <li><a href="package-summary.html">软件包</a></li> 
      <li class="navBarCell1Rev">类</li> 
      <li><a href="class-use/Pattern.html">使用</a></li> 
      <li><a href="package-tree.html">树</a></li> 
      <li><a href="../../../../deprecated-list.html">已过时的</a></li> 
      <li><a href="../../../../index-files/index-1.html">索引</a></li> 
      <li><a href="../../../../help-doc.html">帮助</a></li> 
     </ul> 
     <div class="aboutLanguage"> 
      <div style="margin-top: 14px;"> 
       <strong>Java SE 11 &amp; JDK 11</strong> 
      </div> 
     </div> 
    </div> 
    <div class="subNav"> 
     <ul class="navList" id="allclasses_navbar_bottom"> 
      <li><a href="../../../../allclasses.html">所有类</a></li> 
     </ul> 
     <div> 
      <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
      <noscript> 
       <div>
         JavaScript is disabled on your browser. 
       </div> 
      </noscript> 
     </div> 
     <div> 
      <ul class="subNavList"> 
       <li>概要：&nbsp;</li> 
       <li>嵌套&nbsp;|&nbsp;</li> 
       <li><a href="#field.summary">字段</a>&nbsp;|&nbsp;</li> 
       <li>构造方法&nbsp;|&nbsp;</li> 
       <li><a href="#method.summary">方法</a></li> 
      </ul> 
      <ul class="subNavList"> 
       <li>详细信息：&nbsp;</li> 
       <li><a href="#field.detail">字段</a>&nbsp;|&nbsp;</li> 
       <li>构造方法&nbsp;|&nbsp;</li> 
       <li><a href="#method.detail">方法</a></li> 
      </ul> 
     </div> 
     <a id="skip.navbar.bottom"> 
      <!--   --> </a> 
    </div> 
    <!-- ======== END OF BOTTOM NAVBAR ======= --> 
   </nav> 
   <p class="legalCopy"><small><a href="http://bugreport.java.com/bugreport/">Report a bug or suggest an enhancement</a><br> For further API reference and developer documentation see the <a href="http://www.oracle.com/pls/topic/lookup?ctx=javase11.0.1&amp;id=homepage" target="_blank">Java SE Documentation</a>, which contains more detailed, developer-targeted descriptions with conceptual overviews, definitions of terms, workarounds, and working code examples.<br> Java is a trademark or registered trademark of Oracle and/or its affiliates in the US and other countries.<br> <a href="../../../../../legal/copyright.html">Copyright</a> © 1993, 2018, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.<br>All rights reserved. Use is subject to <a href="http://www.oracle.com/technetwork/java/javase/terms/license/java11.0.1speclicense.html">license terms</a> and the <a href="http://www.oracle.com/technetwork/java/redist-137594.html">documentation redistribution policy</a>. 
     <!-- Version 11.0.1+13-LTS --></small></p> 
  </footer>  
 </body>
</html>