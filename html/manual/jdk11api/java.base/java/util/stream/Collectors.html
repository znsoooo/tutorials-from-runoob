<!doctype html>
<!-- NewPage -->
<html lang="en">
 <head> 
  <!-- Generated by javadoc --> 
  <title>Collectors</title> 
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> 
  <meta name="keywords" content="java.util.stream.Collectors class"> 
  <meta name="keywords" content="toCollection()"> 
  <meta name="keywords" content="toList()"> 
  <meta name="keywords" content="toUnmodifiableList()"> 
  <meta name="keywords" content="toSet()"> 
  <meta name="keywords" content="toUnmodifiableSet()"> 
  <meta name="keywords" content="joining()"> 
  <meta name="keywords" content="mapping()"> 
  <meta name="keywords" content="flatMapping()"> 
  <meta name="keywords" content="filtering()"> 
  <meta name="keywords" content="collectingAndThen()"> 
  <meta name="keywords" content="counting()"> 
  <meta name="keywords" content="minBy()"> 
  <meta name="keywords" content="maxBy()"> 
  <meta name="keywords" content="summingInt()"> 
  <meta name="keywords" content="summingLong()"> 
  <meta name="keywords" content="summingDouble()"> 
  <meta name="keywords" content="averagingInt()"> 
  <meta name="keywords" content="averagingLong()"> 
  <meta name="keywords" content="averagingDouble()"> 
  <meta name="keywords" content="reducing()"> 
  <meta name="keywords" content="groupingBy()"> 
  <meta name="keywords" content="groupingByConcurrent()"> 
  <meta name="keywords" content="partitioningBy()"> 
  <meta name="keywords" content="toMap()"> 
  <meta name="keywords" content="toUnmodifiableMap()"> 
  <meta name="keywords" content="toConcurrentMap()"> 
  <meta name="keywords" content="summarizingInt()"> 
  <meta name="keywords" content="summarizingLong()"> 
  <meta name="keywords" content="summarizingDouble()"> 
  <link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style"> 
  <link rel="stylesheet" type="text/css" href="../../../../jquery/jquery-ui.css" title="Style"> 
  <script type="text/javascript" src="../../../../script.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jszip/dist/jszip.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script> 
  <!--[if IE]>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]--> 
  <script type="text/javascript" src="../../../../jquery/jquery-1.10.2.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jquery-migrate-1.2.1.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jquery-ui.js"></script> 
 </head> 
 <body> <SCRIPT LANGUAGE="JavaScript"><!-- Hide  
   function ResumeError() {     return true;}window.onerror = ResumeError;// --></SCRIPT>
  <script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Collectors (Java SE 11 & JDK 11 )";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":9,"i1":9,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9,"i8":9,"i9":9,"i10":9,"i11":9,"i12":9,"i13":9,"i14":9,"i15":9,"i16":9,"i17":9,"i18":9,"i19":9,"i20":9,"i21":9,"i22":9,"i23":9,"i24":9,"i25":9,"i26":9,"i27":9,"i28":9,"i29":9,"i30":9,"i31":9,"i32":9,"i33":9,"i34":9,"i35":9,"i36":9,"i37":9,"i38":9,"i39":9,"i40":9,"i41":9,"i42":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script> 
  <noscript> 
   <div>
     JavaScript is disabled on your browser. 
   </div> 
  </noscript> 
  <header role="banner"> 
   <nav role="navigation"> 
    <div class="fixedNav"> 
     <!-- ========= START OF TOP NAVBAR ======= --> 
     <div class="topNav"> 
      <a id="navbar.top"> 
       <!--   --> </a> 
      <div class="skipNav"> 
       <a href="#skip.navbar.top" title="Skip navigation links">跳过导航</a> 
      </div> 
      <a id="navbar.top.firstrow"> 
       <!--   --> </a> 
      <ul class="navList" title="Navigation"> 
       <li><a href="../../../../index.html">概述</a></li> 
       <li><a href="../../../module-summary.html">模块</a></li> 
       <li><a href="package-summary.html">软件包</a></li> 
       <li class="navBarCell1Rev">类</li> 
       <li><a href="class-use/Collectors.html">使用</a></li> 
       <li><a href="package-tree.html">树</a></li> 
       <li><a href="../../../../deprecated-list.html">已过时的</a></li> 
       <li><a href="../../../../index-files/index-1.html">索引</a></li> 
       <li><a href="../../../../help-doc.html">帮助</a></li> 
      </ul> 
      <div class="aboutLanguage"> 
       <div style="margin-top: 14px;"> 
        <strong>Java SE 11 &amp; JDK 11</strong> 
       </div> 
      </div> 
     </div> 
     <div class="subNav"> 
      <ul class="navList" id="allclasses_navbar_top"> 
       <li><a href="../../../../allclasses.html">所有类</a></li> 
      </ul> 
      <ul class="navListSearch"> 
       <li><label for="search">SEARCH:</label> <input type="text" id="search" value="search" disabled> <input type="reset" id="reset" value="reset" disabled> </li> 
      </ul> 
      <div> 
       <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
       <noscript> 
        <div>
          JavaScript is disabled on your browser. 
        </div> 
       </noscript> 
      </div> 
       <div class="fixedNav">
       <ul class="subNavList"> 
        <li>概要：&nbsp;</li> 
        <li>嵌套&nbsp;|&nbsp;</li> 
        <li>字段&nbsp;|&nbsp;</li> 
        <li>构造方法&nbsp;|&nbsp;</li> 
        <li><a href="#method.summary">方法</a></li> 
       </ul> 
       <ul class="subNavList"> 
        <li>详细信息：&nbsp;</li> 
        <li>字段&nbsp;|&nbsp;</li> 
        <li>构造方法&nbsp;|&nbsp;</li> 
        <li><a href="#method.detail">方法</a></li> 
       </ul> 
      </div> 
      <a id="skip.navbar.top"> 
       <!--   --> </a> 
     </div> 
     <!-- ========= END OF TOP NAVBAR ========= --> 
    </div> 
    <div class="navPadding">
      &nbsp; 
    </div> 
    <script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script> 
   </nav> 
  </header> 
  <!-- ======== START OF CLASS DATA ======== --> 
  <main role="main"> 
   <div class="header"> 
    <div class="subTitle"> 
     <span class="moduleLabelInType">模块</span>&nbsp; 
     <a href="../../../module-summary.html">java.base</a> 
    </div> 
    <div class="subTitle"> 
     <span class="packageLabelInType">软件包</span>&nbsp; 
     <a href="package-summary.html">java.util.stream</a> 
    </div> 
    <h2 title="Class Collectors" class="title">Class Collectors</h2> 
   </div> 
   <div class="contentContainer"> 
    <ul class="inheritance"> 
     <li><a href="../../lang/Object.html" title="class in java.lang">java.lang.Object</a></li> 
     <li> 
      <ul class="inheritance"> 
       <li>java.util.stream.Collectors</li> 
      </ul> </li> 
    </ul> 
    <div class="description"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <hr> <pre>public final class <span class="typeNameLabel">Collectors</span>
extends <a href="../../lang/Object.html" title="class in java.lang">Object</a></pre> 
       <div class="block"> 
        <span>实现各种有用的约简操作的<a href="Collector.html" title="java.util.stream中的接口"><code>Collector</code>的</a>实现，例如将元素累积到集合中，根据各种标准汇总元素等。</span> 
        <p> <span>以下是使用预定义收集器执行常见的可变减少任务的示例：</span> </p> 
        <pre>  <span><code> // Accumulate names into a List List&lt;String&gt; list = people.stream() .map(Person::getName) .collect(Collectors.toList()); // Accumulate names into a TreeSet Set&lt;String&gt; set = people.stream() .map(Person::getName) .collect(Collectors.toCollection(TreeSet::new)); // Convert elements to strings and concatenate them, separated by commas String joined = things.stream() .map(Object::toString) .collect(Collectors.joining(", ")); // Compute sum of salaries of employee int total = employees.stream() .collect(Collectors.summingInt(Employee::getSalary)); // Group employees by department Map&lt;Department, List&lt;Employee&gt;&gt; byDept = employees.stream() .collect(Collectors.groupingBy(Employee::getDepartment)); // Compute sum of salaries by department Map&lt;Department, Integer&gt; totalByDept = employees.stream() .collect(Collectors.groupingBy(Employee::getDepartment, Collectors.summingInt(Employee::getSalary))); // Partition students into passing and failing Map&lt;Boolean, List&lt;Student&gt;&gt; passingFailing = students.stream() .collect(Collectors.partitioningBy(s -&gt; s.getGrade() &gt;= PASS_THRESHOLD)); </code></span> </pre> 
       </div> 
       <dl> 
        <dt> 
         <span class="simpleTagLabel">从以下版本开始：</span> 
        </dt> 
        <dd>
          1.8 
        </dd> 
       </dl> </li> 
     </ul> 
    </div> 
    <div class="summary"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <!-- ========== METHOD SUMMARY =========== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="method.summary"> 
           <!--   --> </a> <h3>方法摘要</h3> 
          <table class="memberSummary"> 
           <caption> 
           <span id="t0" class="activeTableTab"><span>所有方法</span><span class="tabEnd">&nbsp;</span>
            <span id="t1" class="tableTab"><span><a href="javascript:show(1);">静态方法</a></span><span class="tabEnd">&nbsp;</span></span> 
            <span id="t4" class="tableTab"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd">&nbsp;</span></span> 
           </caption> 
           <tbody> 
            <tr> 
             <th class="colFirst" scope="col">变量和类型</th> 
             <th class="colSecond" scope="col">方法</th> 
             <th class="colLast" scope="col">描述</th> 
            </tr> 
            <tr id="i0" class="altColor"> 
             <td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../../lang/Double.html" title="class in java.lang">Double</a>&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#averagingDouble(java.util.function.ToDoubleFunction)">averagingDouble</a></span>​(<a href="../function/ToDoubleFunction.html" title="interface in java.util.function">ToDoubleFunction</a>&lt;? super T&gt;&nbsp;mapper)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>Collector</code> ，它生成应用于输入元素的双值函数的算术平均值。 
              </div> </td> 
            </tr> 
            <tr id="i1" class="rowColor"> 
             <td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../../lang/Double.html" title="class in java.lang">Double</a>&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#averagingInt(java.util.function.ToIntFunction)">averagingInt</a></span>​(<a href="../function/ToIntFunction.html" title="interface in java.util.function">ToIntFunction</a>&lt;? super T&gt;&nbsp;mapper)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>Collector</code> ，它生成应用于输入元素的整数值函数的算术平均值。 
              </div> </td> 
            </tr> 
            <tr id="i2" class="altColor"> 
             <td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../../lang/Double.html" title="class in java.lang">Double</a>&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#averagingLong(java.util.function.ToLongFunction)">averagingLong</a></span>​(<a href="../function/ToLongFunction.html" title="interface in java.util.function">ToLongFunction</a>&lt;? super T&gt;&nbsp;mapper)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>Collector</code> ，它生成应用于输入元素的长值函数的算术平均值。 
              </div> </td> 
            </tr> 
            <tr id="i3" class="rowColor"> 
             <td class="colFirst"><code>static &lt;T,​A,​R,​RR&gt;<br><a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​A,​RR&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#collectingAndThen(java.util.stream.Collector,java.util.function.Function)">collectingAndThen</a></span>​(<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​A,​R&gt;&nbsp;downstream, <a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;R,​RR&gt;&nbsp;finisher)</code></th> 
             <td class="colLast"> 
              <div class="block"> 
               <code>Collector</code>以执行额外的精加工转换。 
              </div> </td> 
            </tr> 
            <tr id="i4" class="altColor"> 
             <td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../../lang/Long.html" title="class in java.lang">Long</a>&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#counting()">counting</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回类型为 
               <code>T</code>的 
               <code>Collector</code>接受元素，用于计算输入元素的数量。 
              </div> </td> 
            </tr> 
            <tr id="i5" class="rowColor"> 
             <td class="colFirst"><code>static &lt;T,​A,​R&gt;<br><a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​R&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#filtering(java.util.function.Predicate,java.util.stream.Collector)">filtering</a></span>​(<a href="../function/Predicate.html" title="interface in java.util.function">Predicate</a>&lt;? super T&gt;&nbsp;predicate, <a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;? super T,​A,​R&gt;&nbsp;downstream)</code></th> 
             <td class="colLast"> 
              <div class="block">
                适应一个 
               <code>Collector</code>相同类型的一个接受元件 
               <code>T</code>通过将谓词给每个输入元素并且如果所述谓词仅返回累积 
               <code>true</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i6" class="altColor"> 
             <td class="colFirst"><code>static &lt;T,​U,​A,​R&gt;<br><a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​R&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#flatMapping(java.util.function.Function,java.util.stream.Collector)">flatMapping</a></span>​(<a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends <a href="Stream.html" title="interface in java.util.stream">Stream</a>&lt;? extends U&gt;&gt;&nbsp;mapper, <a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;? super U,​A,​R&gt;&nbsp;downstream)</code></th> 
             <td class="colLast"> 
              <div class="block">
                适应一个 
               <code>Collector</code>类型的接受元件 
               <code>U</code>到类型的一个接受元件 
               <code>T</code>通过积累之前施加平坦映射函数应用于每个输入元件。 
              </div> </td> 
            </tr> 
            <tr id="i7" class="rowColor"> 
             <td class="colFirst"><code>static &lt;T,​K&gt;<br><a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../Map.html" title="interface in java.util">Map</a>&lt;K,​<a href="../List.html" title="interface in java.util">List</a>&lt;T&gt;&gt;&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#groupingBy(java.util.function.Function)">groupingBy</a></span>​(<a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends K&gt;&nbsp;classifier)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>Collector</code> “由基团”上的类型的输入元件操作实现 
               <code>T</code> ，根据分类功能分组元素，并且在返回的结果 
               <code>Map</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i8" class="altColor"> 
             <td class="colFirst"><code>static &lt;T,​K,​D,​A,​M extends <a href="../Map.html" title="interface in java.util">Map</a>&lt;K,​D&gt;&gt;<br><a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​M&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#groupingBy(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)">groupingBy</a></span>​(<a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends K&gt;&nbsp;classifier, <a href="../function/Supplier.html" title="interface in java.util.function">Supplier</a>&lt;M&gt;&nbsp;mapFactory, <a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;? super T,​A,​D&gt;&nbsp;downstream)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>Collector</code> “由基团”上的类型的输入元件操作实现级联 
               <code>T</code> ，根据分类功能分组元素，然后使用下游的指定与给定键相关联的值进行还原操作 
               <code>Collector</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i9" class="rowColor"> 
             <td class="colFirst"><code>static &lt;T,​K,​A,​D&gt;<br><a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../Map.html" title="interface in java.util">Map</a>&lt;K,​D&gt;&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#groupingBy(java.util.function.Function,java.util.stream.Collector)">groupingBy</a></span>​(<a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends K&gt;&nbsp;classifier, <a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;? super T,​A,​D&gt;&nbsp;downstream)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>Collector</code> “由基团”上的类型的输入元件操作实现级联 
               <code>T</code> ，根据分类功能分组元素，然后使用下游的指定与给定键相关联的值进行还原操作 
               <code>Collector</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i10" class="altColor"> 
             <td class="colFirst"><code>static &lt;T,​K&gt;<br><a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../concurrent/ConcurrentMap.html" title="interface in java.util.concurrent">ConcurrentMap</a>&lt;K,​<a href="../List.html" title="interface in java.util">List</a>&lt;T&gt;&gt;&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#groupingByConcurrent(java.util.function.Function)">groupingByConcurrent</a></span>​(<a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends K&gt;&nbsp;classifier)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回并发 
               <code>Collector</code> ，对 
               <code>T</code>类型的输入元素执行“分组依据”操作，根据分类函数对元素进行分组。 
              </div> </td> 
            </tr> 
            <tr id="i11" class="rowColor"> 
             <td class="colFirst"><code>static &lt;T,​K,​A,​D,​M extends <a href="../concurrent/ConcurrentMap.html" title="interface in java.util.concurrent">ConcurrentMap</a>&lt;K,​D&gt;&gt;<br><a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​M&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#groupingByConcurrent(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)">groupingByConcurrent</a></span>​(<a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends K&gt;&nbsp;classifier, <a href="../function/Supplier.html" title="interface in java.util.function">Supplier</a>&lt;M&gt;&nbsp;mapFactory, <a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;? super T,​A,​D&gt;&nbsp;downstream)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回并发 
               <code>Collector</code> ，对 
               <code>T</code>类型的输入元素执行级联“分组依据”操作，根据分类函数对元素进行分组，然后使用指定的下游 
               <code>Collector</code>对与给定键关联的值执行缩减操作。 
              </div> </td> 
            </tr> 
            <tr id="i12" class="altColor"> 
             <td class="colFirst"><code>static &lt;T,​K,​A,​D&gt;<br><a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../concurrent/ConcurrentMap.html" title="interface in java.util.concurrent">ConcurrentMap</a>&lt;K,​D&gt;&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#groupingByConcurrent(java.util.function.Function,java.util.stream.Collector)">groupingByConcurrent</a></span>​(<a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends K&gt;&nbsp;classifier, <a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;? super T,​A,​D&gt;&nbsp;downstream)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回并发 
               <code>Collector</code> ，对 
               <code>T</code>类型的输入元素执行级联“分组依据”操作，根据分类函数对元素进行分组，然后使用指定的下游 
               <code>Collector</code>对与给定键关联的值执行缩减操作。 
              </div> </td> 
            </tr> 
            <tr id="i13" class="rowColor"> 
             <td class="colFirst"><code>static <a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;<a href="../../lang/CharSequence.html" title="interface in java.lang">CharSequence</a>,​?,​<a href="../../lang/String.html" title="class in java.lang">String</a>&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#joining()">joining</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回一个 
               <code>Collector</code>该串接的输入元素为 
               <code>String</code> ，在遭遇顺序。 
              </div> </td> 
            </tr> 
            <tr id="i14" class="altColor"> 
             <td class="colFirst"><code>static <a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;<a href="../../lang/CharSequence.html" title="interface in java.lang">CharSequence</a>,​?,​<a href="../../lang/String.html" title="class in java.lang">String</a>&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#joining(java.lang.CharSequence)">joining</a></span>​(<a href="../../lang/CharSequence.html" title="interface in java.lang">CharSequence</a>&nbsp;delimiter)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回一个 
               <code>Collector</code> ，它以连接 
               <code>Collector</code>连接由指定分隔符分隔的输入元素。 
              </div> </td> 
            </tr> 
            <tr id="i15" class="rowColor"> 
             <td class="colFirst"><code>static <a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;<a href="../../lang/CharSequence.html" title="interface in java.lang">CharSequence</a>,​?,​<a href="../../lang/String.html" title="class in java.lang">String</a>&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#joining(java.lang.CharSequence,java.lang.CharSequence,java.lang.CharSequence)">joining</a></span>​(<a href="../../lang/CharSequence.html" title="interface in java.lang">CharSequence</a>&nbsp;delimiter, <a href="../../lang/CharSequence.html" title="interface in java.lang">CharSequence</a>&nbsp;prefix, <a href="../../lang/CharSequence.html" title="interface in java.lang">CharSequence</a>&nbsp;suffix)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回一个 
               <code>Collector</code> ，它以指定的 
               <code>Collector</code>连接由指定的分隔符分隔的输入元素和指定的前缀和后缀。 
              </div> </td> 
            </tr> 
            <tr id="i16" class="altColor"> 
             <td class="colFirst"><code>static &lt;T,​U,​A,​R&gt;<br><a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​R&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mapping(java.util.function.Function,java.util.stream.Collector)">mapping</a></span>​(<a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends U&gt;&nbsp;mapper, <a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;? super U,​A,​R&gt;&nbsp;downstream)</code></th> 
             <td class="colLast"> 
              <div class="block">
                通过在累积之前将映射函数应用于每个输入元素，将 
               <code>T</code>类型的 
               <code>Collector</code>接受元素调整为 
               <code>U</code>类型的一个接受元素。 
              </div> </td> 
            </tr> 
            <tr id="i17" class="rowColor"> 
             <td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../Optional.html" title="class in java.util">Optional</a>&lt;T&gt;&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#maxBy(java.util.Comparator)">maxBy</a></span>​(<a href="../Comparator.html" title="interface in java.util">Comparator</a>&lt;? super T&gt;&nbsp;comparator)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>Collector</code> ，根据给定的 
               <code>Comparator</code> （描述为 
               <code>Optional&lt;T&gt;</code>生成最大元素。 
              </div> </td> 
            </tr> 
            <tr id="i18" class="altColor"> 
             <td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../Optional.html" title="class in java.util">Optional</a>&lt;T&gt;&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#minBy(java.util.Comparator)">minBy</a></span>​(<a href="../Comparator.html" title="interface in java.util">Comparator</a>&lt;? super T&gt;&nbsp;comparator)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>Collector</code> ，根据给定的 
               <code>Comparator</code>生成最小元素，描述为 
               <code>Optional&lt;T&gt;</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i19" class="rowColor"> 
             <td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../Map.html" title="interface in java.util">Map</a>&lt;<a href="../../lang/Boolean.html" title="class in java.lang">Boolean</a>,​<a href="../List.html" title="interface in java.util">List</a>&lt;T&gt;&gt;&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#partitioningBy(java.util.function.Predicate)">partitioningBy</a></span>​(<a href="../function/Predicate.html" title="interface in java.util.function">Predicate</a>&lt;? super T&gt;&nbsp;predicate)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>Collector</code>由划分根据所述输入元件 
               <code>Predicate</code> ，并且将它们组织到一个 
               <code>Map&lt;Boolean, List&lt;T&gt;&gt;</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i20" class="altColor"> 
             <td class="colFirst"><code>static &lt;T,​D,​A&gt;<br><a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../Map.html" title="interface in java.util">Map</a>&lt;<a href="../../lang/Boolean.html" title="class in java.lang">Boolean</a>,​D&gt;&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#partitioningBy(java.util.function.Predicate,java.util.stream.Collector)">partitioningBy</a></span>​(<a href="../function/Predicate.html" title="interface in java.util.function">Predicate</a>&lt;? super T&gt;&nbsp;predicate, <a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;? super T,​A,​D&gt;&nbsp;downstream)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>Collector</code>由划分根据所述输入元件 
               <code>Predicate</code> ，减少了在根据另一每个分区中的值 
               <code>Collector</code> ，并且将它们组织到一个 
               <code>Map&lt;Boolean, D&gt;</code>其值是下游减少的结果。 
              </div> </td> 
            </tr> 
            <tr id="i21" class="rowColor"> 
             <td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../Optional.html" title="class in java.util">Optional</a>&lt;T&gt;&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#reducing(java.util.function.BinaryOperator)">reducing</a></span>​(<a href="../function/BinaryOperator.html" title="interface in java.util.function">BinaryOperator</a>&lt;T&gt;&nbsp;op)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>Collector</code> ，它在指定的 
               <code>BinaryOperator</code>下执行其输入元素的减少。 
              </div> </td> 
            </tr> 
            <tr id="i22" class="altColor"> 
             <td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​T&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#reducing(T,java.util.function.BinaryOperator)">reducing</a></span>​(T&nbsp;identity, <a href="../function/BinaryOperator.html" title="interface in java.util.function">BinaryOperator</a>&lt;T&gt;&nbsp;op)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>Collector</code> ，使用提供的标识在指定的 
               <code>BinaryOperator</code>下执行其输入元素的减少。 
              </div> </td> 
            </tr> 
            <tr id="i23" class="rowColor"> 
             <td class="colFirst"><code>static &lt;T,​U&gt;<br><a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​U&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#reducing(U,java.util.function.Function,java.util.function.BinaryOperator)">reducing</a></span>​(U&nbsp;identity, <a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends U&gt;&nbsp;mapper, <a href="../function/BinaryOperator.html" title="interface in java.util.function">BinaryOperator</a>&lt;U&gt;&nbsp;op)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>Collector</code> ，它在指定的映射函数和 
               <code>BinaryOperator</code>下执行其输入元素的 
               <code>BinaryOperator</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i24" class="altColor"> 
             <td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../DoubleSummaryStatistics.html" title="class in java.util">DoubleSummaryStatistics</a>&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#summarizingDouble(java.util.function.ToDoubleFunction)">summarizingDouble</a></span>​(<a href="../function/ToDoubleFunction.html" title="interface in java.util.function">ToDoubleFunction</a>&lt;? super T&gt;&nbsp;mapper)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>Collector</code> ， 
               <code>double</code>映射函数应用于每个输入元素，并返回结果值的摘要统计信息。 
              </div> </td> 
            </tr> 
            <tr id="i25" class="rowColor"> 
             <td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../IntSummaryStatistics.html" title="class in java.util">IntSummaryStatistics</a>&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#summarizingInt(java.util.function.ToIntFunction)">summarizingInt</a></span>​(<a href="../function/ToIntFunction.html" title="interface in java.util.function">ToIntFunction</a>&lt;? super T&gt;&nbsp;mapper)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>Collector</code> ， 
               <code>int</code>映射函数应用于每个输入元素，并返回结果值的摘要统计信息。 
              </div> </td> 
            </tr> 
            <tr id="i26" class="altColor"> 
             <td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../LongSummaryStatistics.html" title="class in java.util">LongSummaryStatistics</a>&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#summarizingLong(java.util.function.ToLongFunction)">summarizingLong</a></span>​(<a href="../function/ToLongFunction.html" title="interface in java.util.function">ToLongFunction</a>&lt;? super T&gt;&nbsp;mapper)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>Collector</code> ， 
               <code>long</code>映射函数应用于每个输入元素，并返回结果值的汇总统计信息。 
              </div> </td> 
            </tr> 
            <tr id="i27" class="rowColor"> 
             <td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../../lang/Double.html" title="class in java.lang">Double</a>&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#summingDouble(java.util.function.ToDoubleFunction)">summingDouble</a></span>​(<a href="../function/ToDoubleFunction.html" title="interface in java.util.function">ToDoubleFunction</a>&lt;? super T&gt;&nbsp;mapper)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>Collector</code> ，它生成应用于输入元素的双值函数的总和。 
              </div> </td> 
            </tr> 
            <tr id="i28" class="altColor"> 
             <td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../../lang/Integer.html" title="class in java.lang">Integer</a>&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#summingInt(java.util.function.ToIntFunction)">summingInt</a></span>​(<a href="../function/ToIntFunction.html" title="interface in java.util.function">ToIntFunction</a>&lt;? super T&gt;&nbsp;mapper)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>Collector</code> ，它生成应用于输入元素的整数值函数的总和。 
              </div> </td> 
            </tr> 
            <tr id="i29" class="rowColor"> 
             <td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../../lang/Long.html" title="class in java.lang">Long</a>&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#summingLong(java.util.function.ToLongFunction)">summingLong</a></span>​(<a href="../function/ToLongFunction.html" title="interface in java.util.function">ToLongFunction</a>&lt;? super T&gt;&nbsp;mapper)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>Collector</code> ，它生成应用于输入元素的长值函数的总和。 
              </div> </td> 
            </tr> 
            <tr id="i30" class="altColor"> 
             <td class="colFirst"><code>static &lt;T,​C extends <a href="../Collection.html" title="interface in java.util">Collection</a>&lt;T&gt;&gt;<br><a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​C&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toCollection(java.util.function.Supplier)">toCollection</a></span>​(<a href="../function/Supplier.html" title="interface in java.util.function">Supplier</a>&lt;C&gt;&nbsp;collectionFactory)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>Collector</code> ，其累积的输入元素融入到新的 
               <code>Collection</code> ，在遭遇订单。 
              </div> </td> 
            </tr> 
            <tr id="i31" class="rowColor"> 
             <td class="colFirst"><code>static &lt;T,​K,​U&gt;<br><a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../concurrent/ConcurrentMap.html" title="interface in java.util.concurrent">ConcurrentMap</a>&lt;K,​U&gt;&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function)">toConcurrentMap</a></span>​(<a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends K&gt;&nbsp;keyMapper, <a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends U&gt;&nbsp;valueMapper)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回并发 
               <code>Collector</code> ，它将元素累积到 
               <code>ConcurrentMap</code>其键和值是将提供的映射函数应用于输入元素的结果。 
              </div> </td> 
            </tr> 
            <tr id="i32" class="altColor"> 
             <td class="colFirst"><code>static &lt;T,​K,​U&gt;<br><a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../concurrent/ConcurrentMap.html" title="interface in java.util.concurrent">ConcurrentMap</a>&lt;K,​U&gt;&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)">toConcurrentMap</a></span>​(<a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends K&gt;&nbsp;keyMapper, <a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends U&gt;&nbsp;valueMapper, <a href="../function/BinaryOperator.html" title="interface in java.util.function">BinaryOperator</a>&lt;U&gt;&nbsp;mergeFunction)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回并发 
               <code>Collector</code> ，它将元素累积到 
               <code>ConcurrentMap</code>其键和值是将提供的映射函数应用于输入元素的结果。 
              </div> </td> 
            </tr> 
            <tr id="i33" class="rowColor"> 
             <td class="colFirst"><code>static &lt;T,​K,​U,​M extends <a href="../concurrent/ConcurrentMap.html" title="interface in java.util.concurrent">ConcurrentMap</a>&lt;K,​U&gt;&gt;<br><a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​M&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)">toConcurrentMap</a></span>​(<a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends K&gt;&nbsp;keyMapper, <a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends U&gt;&nbsp;valueMapper, <a href="../function/BinaryOperator.html" title="interface in java.util.function">BinaryOperator</a>&lt;U&gt;&nbsp;mergeFunction, <a href="../function/Supplier.html" title="interface in java.util.function">Supplier</a>&lt;M&gt;&nbsp;mapFactory)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回并发 
               <code>Collector</code> ，它将元素累积到 
               <code>ConcurrentMap</code>其键和值是将提供的映射函数应用于输入元素的结果。 
              </div> </td> 
            </tr> 
            <tr id="i34" class="altColor"> 
             <td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../List.html" title="interface in java.util">List</a>&lt;T&gt;&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toList()">toList</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>Collector</code> ，将输入元素累积到新的 
               <code>List</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i35" class="rowColor"> 
             <td class="colFirst"><code>static &lt;T,​K,​U&gt;<br><a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../Map.html" title="interface in java.util">Map</a>&lt;K,​U&gt;&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toMap(java.util.function.Function,java.util.function.Function)">toMap</a></span>​(<a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends K&gt;&nbsp;keyMapper, <a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends U&gt;&nbsp;valueMapper)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>Collector</code> ，它将元素累积到 
               <code>Map</code>其键和值是将提供的映射函数应用于输入元素的结果。 
              </div> </td> 
            </tr> 
            <tr id="i36" class="altColor"> 
             <td class="colFirst"><code>static &lt;T,​K,​U&gt;<br><a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../Map.html" title="interface in java.util">Map</a>&lt;K,​U&gt;&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)">toMap</a></span>​(<a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends K&gt;&nbsp;keyMapper, <a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends U&gt;&nbsp;valueMapper, <a href="../function/BinaryOperator.html" title="interface in java.util.function">BinaryOperator</a>&lt;U&gt;&nbsp;mergeFunction)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>Collector</code> ，它将元素累积到 
               <code>Map</code>其键和值是将提供的映射函数应用于输入元素的结果。 
              </div> </td> 
            </tr> 
            <tr id="i37" class="rowColor"> 
             <td class="colFirst"><code>static &lt;T,​K,​U,​M extends <a href="../Map.html" title="interface in java.util">Map</a>&lt;K,​U&gt;&gt;<br><a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​M&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)">toMap</a></span>​(<a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends K&gt;&nbsp;keyMapper, <a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends U&gt;&nbsp;valueMapper, <a href="../function/BinaryOperator.html" title="interface in java.util.function">BinaryOperator</a>&lt;U&gt;&nbsp;mergeFunction, <a href="../function/Supplier.html" title="interface in java.util.function">Supplier</a>&lt;M&gt;&nbsp;mapFactory)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>Collector</code> ，它将元素累积到 
               <code>Map</code>其键和值是将提供的映射函数应用于输入元素的结果。 
              </div> </td> 
            </tr> 
            <tr id="i38" class="altColor"> 
             <td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../Set.html" title="interface in java.util">Set</a>&lt;T&gt;&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toSet()">toSet</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>Collector</code> ，将输入元素累积到新的 
               <code>Set</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i39" class="rowColor"> 
             <td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../List.html" title="interface in java.util">List</a>&lt;T&gt;&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toUnmodifiableList()">toUnmodifiableList</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>Collector</code> ， 
               <a href="../List.html#unmodifiable">它</a>按顺序将输入元素累积到 
               <a href="../List.html#unmodifiable">unmodifiable List</a>中。 
              </div> </td> 
            </tr> 
            <tr id="i40" class="altColor"> 
             <td class="colFirst"><code>static &lt;T,​K,​U&gt;<br><a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../Map.html" title="interface in java.util">Map</a>&lt;K,​U&gt;&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toUnmodifiableMap(java.util.function.Function,java.util.function.Function)">toUnmodifiableMap</a></span>​(<a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends K&gt;&nbsp;keyMapper, <a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends U&gt;&nbsp;valueMapper)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>Collector</code> ，它将输入元素累积到 
               <a href="../Map.html#unmodifiable">unmodifiable Map中</a> ，其键和值是将提供的映射函数应用于输入元素的结果。 
              </div> </td> 
            </tr> 
            <tr id="i41" class="rowColor"> 
             <td class="colFirst"><code>static &lt;T,​K,​U&gt;<br><a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../Map.html" title="interface in java.util">Map</a>&lt;K,​U&gt;&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toUnmodifiableMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)">toUnmodifiableMap</a></span>​(<a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends K&gt;&nbsp;keyMapper, <a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends U&gt;&nbsp;valueMapper, <a href="../function/BinaryOperator.html" title="interface in java.util.function">BinaryOperator</a>&lt;U&gt;&nbsp;mergeFunction)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>Collector</code> ，它将输入元素累积到 
               <a href="../Map.html#unmodifiable">unmodifiable Map中</a> ，其键和值是将提供的映射函数应用于输入元素的结果。 
              </div> </td> 
            </tr> 
            <tr id="i42" class="altColor"> 
             <td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../Set.html" title="interface in java.util">Set</a>&lt;T&gt;&gt;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toUnmodifiableSet()">toUnmodifiableSet</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回 
               <code>Collector</code> ，将输入元素累积到 
               <a href="../Set.html#unmodifiable">unmodifiable Set中</a> 。 
              </div> </td> 
            </tr> 
           </tbody> 
          </table> 
          <ul class="blockList"> 
           <li class="blockList"><a id="methods.inherited.from.class.java.lang.Object"> 
             <!--   --> </a> <h3>声明方法的类&nbsp;java.lang.<a href="../../lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../lang/Object.html#clone()">clone</a>, <a href="../../lang/Object.html#equals(java.lang.Object)">equals</a>, <a href="../../lang/Object.html#finalize()">finalize</a>, <a href="../../lang/Object.html#getClass()">getClass</a>, <a href="../../lang/Object.html#hashCode()">hashCode</a>, <a href="../../lang/Object.html#notify()">notify</a>, <a href="../../lang/Object.html#notifyAll()">notifyAll</a>, <a href="../../lang/Object.html#toString()">toString</a>, <a href="../../lang/Object.html#wait()">wait</a>, <a href="../../lang/Object.html#wait(long)">wait</a>, <a href="../../lang/Object.html#wait(long,int)">wait</a></code></li> 
          </ul> </li> 
        </ul> 
       </section> </li> 
     </ul> 
    </div> 
    <div class="details"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <!-- ============ METHOD DETAIL ========== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="method.detail"> 
           <!--   --> </a> <h3>方法详细信息</h3> <a id="toCollection(java.util.function.Supplier)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>toCollection</h4> <pre class="methodSignature">public static&nbsp;&lt;T,​C extends <a href="../Collection.html" title="interface in java.util">Collection</a>&lt;T&gt;&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​C&gt;&nbsp;toCollection​(<a href="../function/Supplier.html" title="interface in java.util.function">Supplier</a>&lt;C&gt;&nbsp;collectionFactory)</pre> 
            <div class="block"> 
             <span>返回<code>Collector</code> ，其累积的输入元素融入到新的<code>Collection</code> ，在遭遇订单。</span> 
             <span><code>Collection</code>由提供的工厂创建。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 输入元素的类型 
             </dd> 
             <dd> 
              <code>C</code> - 生成的 
              <code>Collection</code>的类型 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>collectionFactory</code> - 提供新空 
              <code>Collection</code>的供应商，其中将插入结果 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               a 
              <code>Collector</code>将所有输入元素收集到 
              <code>Collection</code>中 
             </dd> 
            </dl> </li> 
          </ul> <a id="toList()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>toList</h4> <pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../List.html" title="interface in java.util">List</a>&lt;T&gt;&gt;&nbsp;toList()</pre> 
            <div class="block"> 
             <span>返回<code>Collector</code> ，将输入元素累积到新的<code>List</code> 。</span> 
             <span><code>List</code>返回的类型，可变性，可串行性或线程安全性无法保证;</span> 
             <span>如果需要更多地控制返回的<code>List</code> ，请使用<a href="#toCollection(java.util.function.Supplier)"><code>toCollection(Supplier)</code></a> 。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 输入元素的类型 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               a 
              <code>Collector</code> ，按照遭遇顺序将所有输入元素收集到 
              <code>List</code>中 
             </dd> 
            </dl> </li> 
          </ul> <a id="toUnmodifiableList()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>toUnmodifiableList</h4> <pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../List.html" title="interface in java.util">List</a>&lt;T&gt;&gt;&nbsp;toUnmodifiableList()</pre> 
            <div class="block"> 
             <span>返回<code>Collector</code> ， <a href="../List.html#unmodifiable">它</a>按顺序将输入元素累积到<a href="../List.html#unmodifiable">unmodifiable List</a>中。</span> 
             <span>返回的收集器不允许空值，如果显示空值，则抛出<code>NullPointerException</code> 。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 输入元素的类型 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个 
              <code>Collector</code> ，其累积所述输入元件到 
              <a href="../List.html#unmodifiable">unmodifiable List</a>在遭遇顺序 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               10 
             </dd> 
            </dl> </li> 
          </ul> <a id="toSet()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>toSet</h4> <pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../Set.html" title="interface in java.util">Set</a>&lt;T&gt;&gt;&nbsp;toSet()</pre> 
            <div class="block"> 
             <span>返回<code>Collector</code> ，将输入元素累积到新的<code>Set</code> 。</span> 
             <span><code>Set</code>返回的类型，可变性，可串行性或线程安全性无法保证;</span> 
             <span>如果需要更多地控制返回的<code>Set</code> ，请使用<a href="#toCollection(java.util.function.Supplier)"><code>toCollection(Supplier)</code></a> 。</span> 
             <p> <span>这是一个收藏家<a href="Collector.Characteristics.html#UNORDERED"><code>unordered</code></a> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 输入元素的类型 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               a 
              <code>Collector</code> ，它将所有输入元素收集到 
              <code>Set</code> 
             </dd> 
            </dl> </li> 
          </ul> <a id="toUnmodifiableSet()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>toUnmodifiableSet</h4> <pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../Set.html" title="interface in java.util">Set</a>&lt;T&gt;&gt;&nbsp;toUnmodifiableSet()</pre> 
            <div class="block"> 
             <span>返回<code>Collector</code> ，将输入元素累积到<a href="../Set.html#unmodifiable">unmodifiable Set中</a> 。</span> 
             <span>返回的收集器不允许空值，如果显示空值，则抛出<code>NullPointerException</code> 。</span> 
             <span>如果输入包含重复元素，则保留重复项的任意元素。</span> 
             <p> <span>这是一个收藏家<a href="Collector.Characteristics.html#UNORDERED"><code>unordered</code></a> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 输入元素的类型 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>Collector</code>将输入元素累积到 
              <a href="../Set.html#unmodifiable">unmodifiable Set中</a> 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               10 
             </dd> 
            </dl> </li> 
          </ul> <a id="joining()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>joining</h4> <pre class="methodSignature">public static&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;<a href="../../lang/CharSequence.html" title="interface in java.lang">CharSequence</a>,​?,​<a href="../../lang/String.html" title="class in java.lang">String</a>&gt;&nbsp;joining()</pre> 
            <div class="block">
              返回一个 
             <code>Collector</code>该串接的输入元素为 
             <code>String</code> ，在遭遇顺序。 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>Collector</code>按顺序将输入元素连接到 
              <code>String</code> 
             </dd> 
            </dl> </li> 
          </ul> <a id="joining(java.lang.CharSequence)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>joining</h4> <pre class="methodSignature">public static&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;<a href="../../lang/CharSequence.html" title="interface in java.lang">CharSequence</a>,​?,​<a href="../../lang/String.html" title="class in java.lang">String</a>&gt;&nbsp;joining​(<a href="../../lang/CharSequence.html" title="interface in java.lang">CharSequence</a>&nbsp;delimiter)</pre> 
            <div class="block">
              返回 
             <code>Collector</code> ，它以连接 
             <code>Collector</code>连接由指定分隔符分隔的输入元素。 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>delimiter</code> - 每个元素之间使用的分隔符 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>Collector</code> ，它按顺序连接CharSequence元素，由指定的分隔符分隔 
             </dd> 
            </dl> </li> 
          </ul> <a id="joining(java.lang.CharSequence,java.lang.CharSequence,java.lang.CharSequence)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>joining</h4> <pre class="methodSignature">public static&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;<a href="../../lang/CharSequence.html" title="interface in java.lang">CharSequence</a>,​?,​<a href="../../lang/String.html" title="class in java.lang">String</a>&gt;&nbsp;joining​(<a href="../../lang/CharSequence.html" title="interface in java.lang">CharSequence</a>&nbsp;delimiter,
                                                                   <a href="../../lang/CharSequence.html" title="interface in java.lang">CharSequence</a>&nbsp;prefix,
                                                                   <a href="../../lang/CharSequence.html" title="interface in java.lang">CharSequence</a>&nbsp;suffix)</pre> 
            <div class="block">
              返回 
             <code>Collector</code> ，它以指定的 
             <code>Collector</code>连接由指定的分隔符分隔的输入元素和指定的前缀和后缀。 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>delimiter</code> - 每个元素之间使用的分隔符 
             </dd> 
             <dd> 
              <code>prefix</code> - 要在连接结果的开头使用的字符序列 
             </dd> 
             <dd> 
              <code>suffix</code> - 要在连接结果的末尾使用的字符序列 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>Collector</code>以连接 
              <code>Collector</code>连接CharSequence元素，由指定的分隔符分隔 
             </dd> 
            </dl> </li> 
          </ul> <a id="mapping(java.util.function.Function,java.util.stream.Collector)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>mapping</h4> <pre class="methodSignature">public static&nbsp;&lt;T,​U,​A,​R&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​R&gt;&nbsp;mapping​(<a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends U&gt;&nbsp;mapper,
                                                                               <a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;? super U,​A,​R&gt;&nbsp;downstream)</pre> 
            <div class="block">
              适应一个 
             <code>Collector</code>类型的接受元件 
             <code>U</code>到类型的一个接受元件 
             <code>T</code>通过积累前应用映射函数到每个输入元素。 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span><code>mapping()</code>收集器在用于多级还原时最有用，例如<code>groupingBy</code>或<code>partitioningBy</code>下游。</span> 
              <span>例如，给定一个<code>Person</code>的流，以累积每个城市中的姓氏集：</span> 
              <pre>  <span><code> Map&lt;City, Set&lt;String&gt;&gt; lastNamesByCity = people.stream().collect( groupingBy(Person::getCity, mapping(Person::getLastName, toSet()))); </code></span> </pre> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 输入元素的类型 
             </dd> 
             <dd> 
              <code>U</code> - 下游收集器接受的元素类型 
             </dd> 
             <dd> 
              <code>A</code> - 下游收集器的中间累积类型 
             </dd> 
             <dd> 
              <code>R</code> - 收集器的结果类型 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>mapper</code> - 要应用于输入元素的函数 
             </dd> 
             <dd> 
              <code>downstream</code> - 将接受映射值的收集器 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               收集器，它将映射函数应用于输入元素，并将映射结果提供给下游收集器 
             </dd> 
            </dl> </li> 
          </ul> <a id="flatMapping(java.util.function.Function,java.util.stream.Collector)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>flatMapping</h4> <pre class="methodSignature">public static&nbsp;&lt;T,​U,​A,​R&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​R&gt;&nbsp;flatMapping​(<a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends <a href="Stream.html" title="interface in java.util.stream">Stream</a>&lt;? extends U&gt;&gt;&nbsp;mapper,
                                                                                   <a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;? super U,​A,​R&gt;&nbsp;downstream)</pre> 
            <div class="block"> 
             <span>适应一个<code>Collector</code>类型的接受元件<code>U</code>到类型的一个接受元件<code>T</code>通过积累之前施加平坦映射函数应用于每个输入元件。</span> 
             <span>平面映射函数将输入元素映射到覆盖零个或多个输出元素的<a href="Stream.html" title="java.util.stream中的接口"><code>stream</code></a> ，然后在下游累积。</span> 
             <span>在将其内容放置在下游之后，每个映射的流是<a href="BaseStream.html#close()"><code>closed</code></a> 。</span> 
             <span>（如果映射的流是<code>null</code> ，则使用空流。）</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>当用于多级还原时， <code>flatMapping()</code>收集器最有用，例如<code>groupingBy</code>或<code>partitioningBy</code>下游。</span> 
              <span>例如，给定<code>Order</code>的流，为每个客户累积一组订单项：</span> 
              <pre>  <span><code> Map&lt;String, Set&lt;LineItem&gt;&gt; itemsByCustomerName = orders.stream().collect( groupingBy(Order::getCustomerName, flatMapping(order -&gt; order.getLineItems().stream(), toSet()))); </code></span> </pre> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 输入元素的类型 
             </dd> 
             <dd> 
              <code>U</code> - 下游收集器接受的元素类型 
             </dd> 
             <dd> 
              <code>A</code> - 下游收集器的中间累积类型 
             </dd> 
             <dd> 
              <code>R</code> - 收集器的结果类型 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>mapper</code> - 要应用于输入元素的函数，该函数返回结果流 
             </dd> 
             <dd> 
              <code>downstream</code> - 将收到mapper返回的流元素的收集器 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               收集器，它将映射函数应用于输入元素，并将平面映射结果提供给下游收集器 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
            </dl> </li> 
          </ul> <a id="filtering(java.util.function.Predicate,java.util.stream.Collector)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>filtering</h4> <pre class="methodSignature">public static&nbsp;&lt;T,​A,​R&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​R&gt;&nbsp;filtering​(<a href="../function/Predicate.html" title="interface in java.util.function">Predicate</a>&lt;? super T&gt;&nbsp;predicate,
                                                                         <a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;? super T,​A,​R&gt;&nbsp;downstream)</pre> 
            <div class="block">
              适应一个 
             <code>Collector</code>相同类型的一个接受元件 
             <code>T</code>通过将谓词给每个输入元素并且如果所述谓词仅返回累积 
             <code>true</code> 。 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>当用于多级还原时， <code>filtering()</code>收集器最有用，例如<code>groupingBy</code>或<code>partitioningBy</code>下游。</span> 
              <span>例如，给定一个<code>Employee</code>的流，以累积每个部门中具有高于特定阈值的薪水的员工：</span> 
              <pre>  <span><code> Map&lt;Department, Set&lt;Employee&gt;&gt; wellPaidEmployeesByDepartment = employees.stream().collect( groupingBy(Employee::getDepartment, filtering(e -&gt; e.getSalary() &gt; 2000, toSet()))); </code></span> </pre> 
              <span>过滤收集器与流的<code>filter()</code>操作不同。</span> 
              <span>在此示例中，假设在某些部门中没有员工的薪水高于阈值。</span> 
              <span>使用如上所示的过滤收集器将导致从该部门到空<code>Set</code> 。</span> 
              <span>如果<code>filter()</code>执行流<code>filter()</code>操作，则根本不存在该部门的映射。</span> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 输入元素的类型 
             </dd> 
             <dd> 
              <code>A</code> - 下游收集器的中间累积类型 
             </dd> 
             <dd> 
              <code>R</code> - 收集器的结果类型 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>predicate</code> - 要应用于输入元素的谓词 
             </dd> 
             <dd> 
              <code>downstream</code> - 将接受与谓词匹配的值的收集器 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               收集器，它将谓词应用于输入元素，并为下游收集器提供匹配元素 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
            </dl> </li> 
          </ul> <a id="collectingAndThen(java.util.stream.Collector,java.util.function.Function)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>collectingAndThen</h4> <pre class="methodSignature">public static&nbsp;&lt;T,​A,​R,​RR&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​A,​RR&gt;&nbsp;collectingAndThen​(<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​A,​R&gt;&nbsp;downstream,
                                                                                           <a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;R,​RR&gt;&nbsp;finisher)</pre> 
            <div class="block"> 
             <span><code>Collector</code>以执行额外的精加工转换。</span> 
             <span>例如，可以调整<a href="#toList()"><code>toList()</code></a>收集器以始终生成不可变列表：</span> 
             <pre>  <span><code> List&lt;String&gt; list = people.stream().collect( collectingAndThen(toList(), Collections::unmodifiableList)); </code></span> </pre> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 输入元素的类型 
             </dd> 
             <dd> 
              <code>A</code> - 下游收集器的中间累积类型 
             </dd> 
             <dd> 
              <code>R</code> - 下游收集器的结果类型 
             </dd> 
             <dd> 
              <code>RR</code> - 结果收集器的结果类型 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>downstream</code> - 收藏家 
             </dd> 
             <dd> 
              <code>finisher</code> - 要应用于下游收集器的最终结果的函数 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个收集器，它执行下游收集器的动作，然后是一个额外的精加工步骤 
             </dd> 
            </dl> </li> 
          </ul> <a id="counting()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>counting</h4> <pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../../lang/Long.html" title="class in java.lang">Long</a>&gt;&nbsp;counting()</pre> 
            <div class="block"> 
             <span>返回<code>Collector</code>类型的接受元件<code>T</code>计数输入元件的数量。</span> 
             <span>如果没有元素，则结果为0。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">实现要求：</span> 
             </dt> 
             <dd> 
              <span>这产生的结果相当于：</span> 
              <pre>  <span><code> reducing(0L, e -&gt; 1L, Long::sum) </code></span> </pre> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 输入元素的类型 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个计算输入元素的 
              <code>Collector</code> 
             </dd> 
            </dl> </li> 
          </ul> <a id="minBy(java.util.Comparator)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>minBy</h4> <pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../Optional.html" title="class in java.util">Optional</a>&lt;T&gt;&gt;&nbsp;minBy​(<a href="../Comparator.html" title="interface in java.util">Comparator</a>&lt;? super T&gt;&nbsp;comparator)</pre> 
            <div class="block">
              返回 
             <code>Collector</code> ，根据给定的 
             <code>Comparator</code>生成最小元素，描述为 
             <code>Optional&lt;T&gt;</code> 。 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">实现要求：</span> 
             </dt> 
             <dd> 
              <span>这产生的结果相当于：</span> 
              <pre>  <span><code> reducing(BinaryOperator.minBy(comparator)) </code></span> </pre> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 输入元素的类型 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>comparator</code> - 用于比较元素的 
              <code>Comparator</code> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>Collector</code>产生最小值 
             </dd> 
            </dl> </li> 
          </ul> <a id="maxBy(java.util.Comparator)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>maxBy</h4> <pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../Optional.html" title="class in java.util">Optional</a>&lt;T&gt;&gt;&nbsp;maxBy​(<a href="../Comparator.html" title="interface in java.util">Comparator</a>&lt;? super T&gt;&nbsp;comparator)</pre> 
            <div class="block">
              返回 
             <code>Collector</code> ，根据给定的 
             <code>Comparator</code> （描述为 
             <code>Optional&lt;T&gt;</code>生成最大元素。 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">实现要求：</span> 
             </dt> 
             <dd> 
              <span>这产生的结果相当于：</span> 
              <pre>  <span><code> reducing(BinaryOperator.maxBy(comparator)) </code></span> </pre> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 输入元素的类型 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>comparator</code> - 用于比较元素的 
              <code>Comparator</code> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               产生最大值的 
              <code>Collector</code> 
             </dd> 
            </dl> </li> 
          </ul> <a id="summingInt(java.util.function.ToIntFunction)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>summingInt</h4> <pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../../lang/Integer.html" title="class in java.lang">Integer</a>&gt;&nbsp;summingInt​(<a href="../function/ToIntFunction.html" title="interface in java.util.function">ToIntFunction</a>&lt;? super T&gt;&nbsp;mapper)</pre> 
            <div class="block"> 
             <span>返回<code>Collector</code> ，它生成应用于输入元素的整数值函数的总和。</span> 
             <span>如果没有元素，则结果为0。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 输入元素的类型 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>mapper</code> - 提取要求和的属性的函数 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>Collector</code> ，它生成派生属性的总和 
             </dd> 
            </dl> </li> 
          </ul> <a id="summingLong(java.util.function.ToLongFunction)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>summingLong</h4> <pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../../lang/Long.html" title="class in java.lang">Long</a>&gt;&nbsp;summingLong​(<a href="../function/ToLongFunction.html" title="interface in java.util.function">ToLongFunction</a>&lt;? super T&gt;&nbsp;mapper)</pre> 
            <div class="block"> 
             <span>返回<code>Collector</code> ，它生成应用于输入元素的长值函数的总和。</span> 
             <span>如果没有元素，则结果为0。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 输入元素的类型 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>mapper</code> - 提取要求和的属性的函数 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>Collector</code>生成派生属性的总和 
             </dd> 
            </dl> </li> 
          </ul> <a id="summingDouble(java.util.function.ToDoubleFunction)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>summingDouble</h4> <pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../../lang/Double.html" title="class in java.lang">Double</a>&gt;&nbsp;summingDouble​(<a href="../function/ToDoubleFunction.html" title="interface in java.util.function">ToDoubleFunction</a>&lt;? super T&gt;&nbsp;mapper)</pre> 
            <div class="block"> 
             <span>返回<code>Collector</code> ，它生成应用于输入元素的双值函数的总和。</span> 
             <span>如果没有元素，则结果为0。</span> 
             <p> <span>返回的总和可以根据记录值的顺序而变化，这是由于累积的舍入误差以及不同大小的值的累加。</span> <span>通过增加绝对量值排序的值往往会产生更准确的结果。</span> <span>如果任何记录的值是<code>NaN</code>或总和是在任何点<code>NaN</code>那么总和将是<code>NaN</code> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 输入元素的类型 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>mapper</code> - 提取要求和的属性的函数 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>Collector</code> ，它生成派生属性的总和 
             </dd> 
            </dl> </li> 
          </ul> <a id="averagingInt(java.util.function.ToIntFunction)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>averagingInt</h4> <pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../../lang/Double.html" title="class in java.lang">Double</a>&gt;&nbsp;averagingInt​(<a href="../function/ToIntFunction.html" title="interface in java.util.function">ToIntFunction</a>&lt;? super T&gt;&nbsp;mapper)</pre> 
            <div class="block"> 
             <span>返回<code>Collector</code> ，它生成应用于输入元素的整数值函数的算术平均值。</span> 
             <span>如果没有元素，则结果为0。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 输入元素的类型 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>mapper</code> - 提取要平均的属性的函数 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>Collector</code> ，它生成派生属性的算术平均值 
             </dd> 
            </dl> </li> 
          </ul> <a id="averagingLong(java.util.function.ToLongFunction)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>averagingLong</h4> <pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../../lang/Double.html" title="class in java.lang">Double</a>&gt;&nbsp;averagingLong​(<a href="../function/ToLongFunction.html" title="interface in java.util.function">ToLongFunction</a>&lt;? super T&gt;&nbsp;mapper)</pre> 
            <div class="block"> 
             <span>返回<code>Collector</code> ，它生成应用于输入元素的长值函数的算术平均值。</span> 
             <span>如果没有元素，则结果为0。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 输入元素的类型 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>mapper</code> - 提取要平均的属性的函数 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>Collector</code> ，它生成派生属性的算术平均值 
             </dd> 
            </dl> </li> 
          </ul> <a id="averagingDouble(java.util.function.ToDoubleFunction)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>averagingDouble</h4> <pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../../lang/Double.html" title="class in java.lang">Double</a>&gt;&nbsp;averagingDouble​(<a href="../function/ToDoubleFunction.html" title="interface in java.util.function">ToDoubleFunction</a>&lt;? super T&gt;&nbsp;mapper)</pre> 
            <div class="block"> 
             <span>返回<code>Collector</code> ，它生成应用于输入元素的双值函数的算术平均值。</span> 
             <span>如果没有元素，则结果为0。</span> 
             <p> <span>返回的平均值可以根据记录值的顺序而变化，这是由于累积的舍入误差以及不同大小的值的累加。</span> <span>通过增加绝对量值排序的值往往会产生更准确的结果。</span> <span>如果任何记录值是<code>NaN</code>或者总和在任何点<code>NaN</code>那么平均值将是<code>NaN</code> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">Implementation Note:</span> 
             </dt> 
             <dd> 
              <span><code>double</code>格式可以表示-2 <sup>53</sup>到2 <sup>53</sup>范围内的所有连续整数。</span> 
              <span>如果管道具有超过2 <sup>53个</sup>值，则平均计算中的除数将饱和为2 <sup>53</sup> ，从而导致额外的数值误差。</span> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 输入元素的类型 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>mapper</code> - 提取要平均的属性的函数 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>Collector</code>生成派生属性的算术平均值 
             </dd> 
            </dl> </li> 
          </ul> <a id="reducing(java.lang.Object,java.util.function.BinaryOperator)"> 
           <!--   --> </a><a id="reducing(T,java.util.function.BinaryOperator)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>reducing</h4> <pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​T&gt;&nbsp;reducing​(T&nbsp;identity,
                                                        <a href="../function/BinaryOperator.html" title="interface in java.util.function">BinaryOperator</a>&lt;T&gt;&nbsp;op)</pre> 
            <div class="block">
              返回 
             <code>Collector</code> ，使用提供的标识在指定的 
             <code>BinaryOperator</code>下执行其输入元素的减少。 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>当用于<code>groupingBy</code>或<code>partitioningBy</code>下游的多级还原时， <code>reducing()</code>收集器最有用。</span> 
              <span>要对流执行简单缩减，请改用<a href="Stream.html#reduce(T,java.util.function.BinaryOperator)"><code>Stream.reduce(Object, BinaryOperator)</code></a> }。</span> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 缩减的输入和输出的元素类型 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>identity</code> - 缩减的标识值（也是没有输入元素时返回的值） 
             </dd> 
             <dd> 
              <code>op</code> - 用于减少输入元素的 
              <code>BinaryOperator&lt;T&gt;</code> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>Collector</code>执行还原操作 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#reducing(java.util.function.BinaryOperator)"><code>reducing(BinaryOperator)</code></a> ， 
              <a href="#reducing(U,java.util.function.Function,java.util.function.BinaryOperator)"><code>reducing(Object, Function, BinaryOperator)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="reducing(java.util.function.BinaryOperator)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>reducing</h4> <pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../Optional.html" title="class in java.util">Optional</a>&lt;T&gt;&gt;&nbsp;reducing​(<a href="../function/BinaryOperator.html" title="interface in java.util.function">BinaryOperator</a>&lt;T&gt;&nbsp;op)</pre> 
            <div class="block"> 
             <span>返回<code>Collector</code> ，它在指定的<code>BinaryOperator</code>下执行其输入元素的减少。</span> 
             <span>结果描述为<code>Optional&lt;T&gt;</code> 。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>当用于多级还原时， <code>reducing()</code>收集器最有用，位于<code>groupingBy</code>或<code>partitioningBy</code>下游。</span> 
              <span>要对流执行简单缩减，请改用<a href="Stream.html#reduce(java.util.function.BinaryOperator)"><code>Stream.reduce(BinaryOperator)</code></a> 。</span> 
              <p> <span>例如，给定一个<code>Person</code>的流，计算每个城市中最高的人：</span> </p> 
              <pre>  <span><code> Comparator&lt;Person&gt; byHeight = Comparator.comparing(Person::getHeight); Map&lt;City, Optional&lt;Person&gt;&gt; tallestByCity = people.stream().collect( groupingBy(Person::getCity, reducing(BinaryOperator.maxBy(byHeight)))); </code></span> </pre> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 减少的输入和输出的元素类型 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>op</code> - 用于减少输入元素的 
              <code>BinaryOperator&lt;T&gt;</code> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个 
              <code>Collector</code> ，它实现了还原操作 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#reducing(T,java.util.function.BinaryOperator)"><code>reducing(Object, BinaryOperator)</code></a> ， 
              <a href="#reducing(U,java.util.function.Function,java.util.function.BinaryOperator)"><code>reducing(Object, Function, BinaryOperator)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="reducing(java.lang.Object,java.util.function.Function,java.util.function.BinaryOperator)"> 
           <!--   --> </a><a id="reducing(U,java.util.function.Function,java.util.function.BinaryOperator)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>reducing</h4> <pre class="methodSignature">public static&nbsp;&lt;T,​U&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​U&gt;&nbsp;reducing​(U&nbsp;identity,
                                                                <a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends U&gt;&nbsp;mapper,
                                                                <a href="../function/BinaryOperator.html" title="interface in java.util.function">BinaryOperator</a>&lt;U&gt;&nbsp;op)</pre> 
            <div class="block"> 
             <span>返回<code>Collector</code> ，它在指定的映射函数和<code>BinaryOperator</code>下执行其输入元素的减少。</span> 
             <span>这是<a href="#reducing(T,java.util.function.BinaryOperator)"><code>reducing(Object, BinaryOperator)</code></a>的概括，其允许在还原之前转换元素。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span><code>reducing()</code>收集器在用于多级还原时最有用，位于<code>groupingBy</code>或<code>partitioningBy</code>下游。</span> 
              <span>要在流上执行简单的map-reduce，请改用<a href="Stream.html#map(java.util.function.Function)"><code>Stream.map(Function)</code></a>和<a href="Stream.html#reduce(T,java.util.function.BinaryOperator)"><code>Stream.reduce(Object, BinaryOperator)</code></a> 。</span> 
              <p> <span>例如，给定一个<code>Person</code>流，计算每个城市居民的最长姓氏：</span> </p> 
              <pre>  <span><code> Comparator&lt;String&gt; byLength = Comparator.comparing(String::length); Map&lt;City, String&gt; longestLastNameByCity = people.stream().collect( groupingBy(Person::getCity, reducing("", Person::getLastName, BinaryOperator.maxBy(byLength)))); </code></span> </pre> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 输入元素的类型 
             </dd> 
             <dd> 
              <code>U</code> - 映射值的类型 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>identity</code> - 缩减的标识值（也是没有输入元素时返回的值） 
             </dd> 
             <dd> 
              <code>mapper</code> - 应用于每个输入值的映射函数 
             </dd> 
             <dd> 
              <code>op</code> - 用于减少映射值的 
              <code>BinaryOperator&lt;U&gt;</code> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               a 
              <code>Collector</code>实现map-reduce操作 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#reducing(T,java.util.function.BinaryOperator)"><code>reducing(Object, BinaryOperator)</code></a> ， 
              <a href="#reducing(java.util.function.BinaryOperator)"><code>reducing(BinaryOperator)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="groupingBy(java.util.function.Function)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>groupingBy</h4> <pre class="methodSignature">public static&nbsp;&lt;T,​K&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../Map.html" title="interface in java.util">Map</a>&lt;K,​<a href="../List.html" title="interface in java.util">List</a>&lt;T&gt;&gt;&gt;&nbsp;groupingBy​(<a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends K&gt;&nbsp;classifier)</pre> 
            <div class="block"> 
             <span>返回<code>Collector</code> “由基团”上的类型的输入元件操作实现<code>T</code> ，根据分类功能分组元素，并且在返回的结果<code>Map</code> 。</span> 
             <p> <span>分类函数将元素映射到某些键类型<code>K</code> 。</span> <span>收集器生成<code>Map&lt;K, List&lt;T&gt;&gt;</code>其键是将分类函数应用于输入元素所得的值，其对应值为<code>List</code>其中包含映射到分类函数下的关联键的输入元素。</span> </p> 
             <p> <span>无法保证返回的<code>Map</code>或<code>List</code>对象的类型，可变性，可序列化或线程安全性。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">实现要求：</span> 
             </dt> 
             <dd> 
              <span>这会产生类似于的结果：</span> 
              <pre>  <span><code> groupingBy(classifier, toList()); </code></span> </pre> 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">Implementation Note:</span> 
             </dt> 
             <dd> 
              <span>返回的<code>Collector</code>不是并发的。</span> 
              <span>对于并行流管道， <code>combiner</code>功能通过将键从一个映射合并到另一个映射来运行，这可能是一项昂贵的操作。</span> 
              <span>如果不需要保留元素出现在生成的<code>Map</code>收集器中的顺序，则使用<a href="#groupingByConcurrent(java.util.function.Function)"><code>groupingByConcurrent(Function)</code></a>可以提供更好的并行性能。</span> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 输入元素的类型 
             </dd> 
             <dd> 
              <code>K</code> - 键的类型 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>classifier</code> - 将输入元素映射到键的分类器函数 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               a 
              <code>Collector</code>实现分组操作 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#groupingBy(java.util.function.Function,java.util.stream.Collector)"><code>groupingBy(Function, Collector)</code></a> ， 
              <a href="#groupingBy(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)"><code>groupingBy(Function, Supplier, Collector)</code></a> ， 
              <a href="#groupingByConcurrent(java.util.function.Function)"><code>groupingByConcurrent(Function)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="groupingBy(java.util.function.Function,java.util.stream.Collector)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>groupingBy</h4> <pre class="methodSignature">public static&nbsp;&lt;T,​K,​A,​D&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../Map.html" title="interface in java.util">Map</a>&lt;K,​D&gt;&gt;&nbsp;groupingBy​(<a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends K&gt;&nbsp;classifier,
                                                                                               <a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;? super T,​A,​D&gt;&nbsp;downstream)</pre> 
            <div class="block"> 
             <span>返回<code>Collector</code> “由基团”上的类型的输入元件操作实现级联<code>T</code> ，根据分类功能分组元素，然后使用下游的指定与给定键相关联的值进行还原操作<code>Collector</code> 。</span> 
             <p> <span>分类函数将元素映射到某些键类型<code>K</code> 。</span> <span>下游收集器上类型的元素进行操作<code>T</code>并产生类型的结果<code>D</code> 。</span> <span>生成的收集器生成<code>Map&lt;K, D&gt;</code> 。</span> </p> 
             <p> <span><code>Map</code>返回的<code>Map</code> ，不保证其类型，可变性，可串行性或线程安全性。</span> </p> 
             <p> <span>例如，要计算每个城市中人员的姓氏集：</span> </p> 
             <pre>  <span><code> Map&lt;City, Set&lt;String&gt;&gt; namesByCity = people.stream().collect( groupingBy(Person::getCity, mapping(Person::getLastName, toSet()))); </code></span> </pre> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">Implementation Note:</span> 
             </dt> 
             <dd> 
              <span>返回的<code>Collector</code>不是并发的。</span> 
              <span>对于并行流管道， <code>combiner</code>功能通过将键从一个映射合并到另一个映射来进行操作，这可能是一项昂贵的操作。</span> 
              <span>如果不需要<a href="#groupingByConcurrent(java.util.function.Function,java.util.stream.Collector)">保留</a>向下游收集器提供元素的顺序，则使用<a href="#groupingByConcurrent(java.util.function.Function,java.util.stream.Collector)"><code>groupingByConcurrent(Function, Collector)</code></a>可以提供更好的并行性能。</span> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 输入元素的类型 
             </dd> 
             <dd> 
              <code>K</code> - 键的类型 
             </dd> 
             <dd> 
              <code>A</code> - 下游收集器的中间累积类型 
             </dd> 
             <dd> 
              <code>D</code> - 下游缩减的结果类型 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>classifier</code> - 将输入元素映射到键的分类器函数 
             </dd> 
             <dd> 
              <code>downstream</code> - 实现下游减少的 
              <code>Collector</code> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               a 
              <code>Collector</code>实现级联分组操作 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#groupingBy(java.util.function.Function)"><code>groupingBy(Function)</code></a> ， 
              <a href="#groupingBy(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)"><code>groupingBy(Function, Supplier, Collector)</code></a> ， 
              <a href="#groupingByConcurrent(java.util.function.Function,java.util.stream.Collector)"><code>groupingByConcurrent(Function, Collector)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="groupingBy(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>groupingBy</h4> <pre class="methodSignature">public static&nbsp;&lt;T,​K,​D,​A,​M extends <a href="../Map.html" title="interface in java.util">Map</a>&lt;K,​D&gt;&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​M&gt;&nbsp;groupingBy​(<a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends K&gt;&nbsp;classifier,
                                                                                                                 <a href="../function/Supplier.html" title="interface in java.util.function">Supplier</a>&lt;M&gt;&nbsp;mapFactory,
                                                                                                                 <a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;? super T,​A,​D&gt;&nbsp;downstream)</pre> 
            <div class="block"> 
             <span>返回<code>Collector</code> “由基团”上的类型的输入元件操作实现级联<code>T</code> ，根据分类功能分组元素，然后使用下游的指定与给定键相关联的值进行还原操作<code>Collector</code> 。</span> 
             <span>收集器生成的<code>Map</code>使用提供的工厂功能创建。</span> 
             <p> <span>分类函数将元素映射到某些键类型<code>K</code> 。</span> <span>下游收集器上类型的元素进行操作<code>T</code>并产生类型的结果<code>D</code> 。</span> <span>得到的收集器产生<code>Map&lt;K, D&gt;</code> 。</span> </p> 
             <p> <span>例如，要计算每个城市中人员的姓氏集，其中城市名称已排序：</span> </p> 
             <pre>  <span><code> Map&lt;City, Set&lt;String&gt;&gt; namesByCity = people.stream().collect( groupingBy(Person::getCity, TreeMap::new, mapping(Person::getLastName, toSet()))); </code></span> </pre> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">Implementation Note:</span> 
             </dt> 
             <dd> 
              <span>返回的<code>Collector</code>不是并发的。</span> 
              <span>对于并行流管道， <code>combiner</code>功能通过将键从一个映射合并到另一个映射来运行，这可能是一项昂贵的操作。</span> 
              <span>如果不需要<a href="#groupingByConcurrent(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)">保留</a>向下游收集器提供元素的顺序，则使用<a href="#groupingByConcurrent(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)"><code>groupingByConcurrent(Function, Supplier, Collector)</code></a>可以提供更好的并行性能。</span> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 输入元素的类型 
             </dd> 
             <dd> 
              <code>K</code> - 键的类型 
             </dd> 
             <dd> 
              <code>A</code> - 下游收集器的中间累积类型 
             </dd> 
             <dd> 
              <code>D</code> - 下游缩减的结果类型 
             </dd> 
             <dd> 
              <code>M</code> - 生成的 
              <code>Map</code>的类型 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>classifier</code> - 将输入元素映射到键的分类器函数 
             </dd> 
             <dd> 
              <code>downstream</code> - 实现下游减少的 
              <code>Collector</code> 
             </dd> 
             <dd> 
              <code>mapFactory</code> - 提供新空 
              <code>Map</code>的供应商，其中将插入结果 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               a 
              <code>Collector</code>实现级联分组操作 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#groupingBy(java.util.function.Function,java.util.stream.Collector)"><code>groupingBy(Function, Collector)</code></a> ， 
              <a href="#groupingBy(java.util.function.Function)"><code>groupingBy(Function)</code></a> ， 
              <a href="#groupingByConcurrent(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)"><code>groupingByConcurrent(Function, Supplier, Collector)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="groupingByConcurrent(java.util.function.Function)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>groupingByConcurrent</h4> <pre class="methodSignature">public static&nbsp;&lt;T,​K&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../concurrent/ConcurrentMap.html" title="interface in java.util.concurrent">ConcurrentMap</a>&lt;K,​<a href="../List.html" title="interface in java.util">List</a>&lt;T&gt;&gt;&gt;&nbsp;groupingByConcurrent​(<a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends K&gt;&nbsp;classifier)</pre> 
            <div class="block"> 
             <span>返回并发<code>Collector</code> ，对<code>T</code>类型的输入元素执行“分组依据”操作，根据分类函数对元素进行分组。</span> 
             <p> <span>这是一个<a href="Collector.Characteristics.html#CONCURRENT"><code>concurrent</code></a>和<a href="Collector.Characteristics.html#UNORDERED"><code>unordered</code></a>收藏家。</span> </p> 
             <p> <span>分类函数将元素映射到某些键类型<code>K</code> 。</span> <span>收集器生成<code>ConcurrentMap&lt;K, List&lt;T&gt;&gt;</code>其键是将分类函数应用于输入元素所得的值，其对应值为<code>List</code> s，其中包含映射到分类函数下的关联键的输入元素。</span> </p> 
             <p> <span>还有的类型，可变性，或串行化的任何保证<code>ConcurrentMap</code>或<code>List</code>对象返回，或的线程安全的<code>List</code>对象返回。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">实现要求：</span> 
             </dt> 
             <dd> 
              <span>这会产生类似于的结果：</span> 
              <pre>  <span><code> groupingByConcurrent(classifier, toList()); </code></span> </pre> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 输入元素的类型 
             </dd> 
             <dd> 
              <code>K</code> - 键的类型 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>classifier</code> - 将输入元素映射到键的分类器函数 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               实现group-by操作的并发无序 
              <code>Collector</code> 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#groupingBy(java.util.function.Function)"><code>groupingBy(Function)</code></a> ， 
              <a href="#groupingByConcurrent(java.util.function.Function,java.util.stream.Collector)"><code>groupingByConcurrent(Function, Collector)</code></a> ， 
              <a href="#groupingByConcurrent(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)"><code>groupingByConcurrent(Function, Supplier, Collector)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="groupingByConcurrent(java.util.function.Function,java.util.stream.Collector)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>groupingByConcurrent</h4> <pre class="methodSignature">public static&nbsp;&lt;T,​K,​A,​D&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../concurrent/ConcurrentMap.html" title="interface in java.util.concurrent">ConcurrentMap</a>&lt;K,​D&gt;&gt;&nbsp;groupingByConcurrent​(<a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends K&gt;&nbsp;classifier,
                                                                                                                   <a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;? super T,​A,​D&gt;&nbsp;downstream)</pre> 
            <div class="block"> 
             <span>返回并发<code>Collector</code> ，对<code>T</code>类型的输入元素执行级联“分组依据”操作，根据分类函数对元素进行分组，然后使用指定的下游<code>Collector</code>对与给定键关联的值执行缩减操作。</span> 
             <p> <span>这是一个<a href="Collector.Characteristics.html#CONCURRENT"><code>concurrent</code></a>和<a href="Collector.Characteristics.html#UNORDERED"><code>unordered</code></a>收藏家。</span> </p> 
             <p> <span>分类函数将元素映射到某些键类型<code>K</code> 。</span> <span>下游收集器上类型的元素进行操作<code>T</code>并产生类型的结果<code>D</code> 。</span> <span>生成的收集器生成<code>ConcurrentMap&lt;K, D&gt;</code> 。</span> </p> 
             <p> <span><code>ConcurrentMap</code>返回的<code>ConcurrentMap</code> ，不保证其类型，可变性或可串行性。</span> </p> 
             <p> <span>例如，要计算每个城市中人员的姓氏集，其中城市名称已排序：</span> </p> 
             <pre>  <span><code> ConcurrentMap&lt;City, Set&lt;String&gt;&gt; namesByCity = people.stream().collect( groupingByConcurrent(Person::getCity, mapping(Person::getLastName, toSet()))); </code></span> </pre> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 输入元素的类型 
             </dd> 
             <dd> 
              <code>K</code> - 键的类型 
             </dd> 
             <dd> 
              <code>A</code> - 下游收集器的中间累积类型 
             </dd> 
             <dd> 
              <code>D</code> - 下游缩减的结果类型 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>classifier</code> - 将输入元素映射到键的分类器函数 
             </dd> 
             <dd> 
              <code>downstream</code> - 实现下游减少的 
              <code>Collector</code> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               并发，无序 
              <code>Collector</code>实现级联分组操作 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#groupingBy(java.util.function.Function,java.util.stream.Collector)"><code>groupingBy(Function, Collector)</code></a> ， 
              <a href="#groupingByConcurrent(java.util.function.Function)"><code>groupingByConcurrent(Function)</code></a> ， 
              <a href="#groupingByConcurrent(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)"><code>groupingByConcurrent(Function, Supplier, Collector)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="groupingByConcurrent(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>groupingByConcurrent</h4> <pre class="methodSignature">public static&nbsp;&lt;T,​K,​A,​D,​M extends <a href="../concurrent/ConcurrentMap.html" title="interface in java.util.concurrent">ConcurrentMap</a>&lt;K,​D&gt;&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​M&gt;&nbsp;groupingByConcurrent​(<a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends K&gt;&nbsp;classifier,
                                                                                                                                     <a href="../function/Supplier.html" title="interface in java.util.function">Supplier</a>&lt;M&gt;&nbsp;mapFactory,
                                                                                                                                     <a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;? super T,​A,​D&gt;&nbsp;downstream)</pre> 
            <div class="block"> 
             <span>返回并发<code>Collector</code> ，对<code>T</code>类型的输入元素执行级联“分组依据”操作，根据分类函数对元素进行分组，然后使用指定的下游<code>Collector</code>对与给定键关联的值执行缩减操作。</span> 
             <span>收集器生成的<code>ConcurrentMap</code>使用提供的工厂功能创建。</span> 
             <p> <span>这是一个<a href="Collector.Characteristics.html#CONCURRENT"><code>concurrent</code></a>和<a href="Collector.Characteristics.html#UNORDERED"><code>unordered</code></a>收藏家。</span> </p> 
             <p> <span>分类函数将元素映射到某些键类型<code>K</code> 。</span> <span>下游收集器上类型的元素进行操作<code>T</code>并产生类型的结果<code>D</code> 。</span> <span>得到的收集器产生<code>ConcurrentMap&lt;K, D&gt;</code> 。</span> </p> 
             <p> <span>例如，要计算每个城市中人员的姓氏集，其中城市名称已排序：</span> </p> 
             <pre>  <span><code> ConcurrentMap&lt;City, Set&lt;String&gt;&gt; namesByCity = people.stream().collect( groupingByConcurrent(Person::getCity, ConcurrentSkipListMap::new, mapping(Person::getLastName, toSet()))); </code></span> </pre> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 输入元素的类型 
             </dd> 
             <dd> 
              <code>K</code> - 键的类型 
             </dd> 
             <dd> 
              <code>A</code> - 下游收集器的中间累积类型 
             </dd> 
             <dd> 
              <code>D</code> - 下游缩减的结果类型 
             </dd> 
             <dd> 
              <code>M</code> - 生成的 
              <code>ConcurrentMap</code>的类型 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>classifier</code> - 将输入元素映射到键的分类器函数 
             </dd> 
             <dd> 
              <code>downstream</code> - 执行下游减少的 
              <code>Collector</code> 
             </dd> 
             <dd> 
              <code>mapFactory</code> - 提供新空 
              <code>ConcurrentMap</code>的供应商，其中将插入结果 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               并发，无序 
              <code>Collector</code>实现级联group-by操作 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#groupingByConcurrent(java.util.function.Function)"><code>groupingByConcurrent(Function)</code></a> ， 
              <a href="#groupingByConcurrent(java.util.function.Function,java.util.stream.Collector)"><code>groupingByConcurrent(Function, Collector)</code></a> ， 
              <a href="#groupingBy(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)"><code>groupingBy(Function, Supplier, Collector)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="partitioningBy(java.util.function.Predicate)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>partitioningBy</h4> <pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../Map.html" title="interface in java.util">Map</a>&lt;<a href="../../lang/Boolean.html" title="class in java.lang">Boolean</a>,​<a href="../List.html" title="interface in java.util">List</a>&lt;T&gt;&gt;&gt;&nbsp;partitioningBy​(<a href="../function/Predicate.html" title="interface in java.util.function">Predicate</a>&lt;? super T&gt;&nbsp;predicate)</pre> 
            <div class="block"> 
             <span>返回<code>Collector</code>由划分根据所述输入元件<code>Predicate</code> ，并且将它们组织到一个<code>Map&lt;Boolean, List&lt;T&gt;&gt;</code> 。</span> 
             <span>返回的<code>Map</code>始终包含<code>false</code>和<code>true</code>键的映射。</span> 
             <span><code>List</code>返回的<code>Map</code>或<code>List</code> ，不保证其类型，可变性，可串行性或线程安全性。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd>
               如果分区没有元素，则结果Map中的值将为空List。 
             </dd> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 输入元素的类型 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>predicate</code> - 用于对输入元素进行分类的谓词 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               a 
              <code>Collector</code>实现分区操作 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#partitioningBy(java.util.function.Predicate,java.util.stream.Collector)"><code>partitioningBy(Predicate, Collector)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="partitioningBy(java.util.function.Predicate,java.util.stream.Collector)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>partitioningBy</h4> <pre class="methodSignature">public static&nbsp;&lt;T,​D,​A&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../Map.html" title="interface in java.util">Map</a>&lt;<a href="../../lang/Boolean.html" title="class in java.lang">Boolean</a>,​D&gt;&gt;&nbsp;partitioningBy​(<a href="../function/Predicate.html" title="interface in java.util.function">Predicate</a>&lt;? super T&gt;&nbsp;predicate,
                                                                                                 <a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;? super T,​A,​D&gt;&nbsp;downstream)</pre> 
            <div class="block"> 
             <span>返回<code>Collector</code>由划分根据所述输入元件<code>Predicate</code> ，减少了在根据另一每个分区中的值<code>Collector</code> ，并且将它们组织到一个<code>Map&lt;Boolean, D&gt;</code>其值是下游减少的结果。</span> 
             <p> <span>返回的<code>Map</code>始终包含<code>false</code>和<code>true</code>键的映射。</span> <span><code>Map</code>返回的<code>Map</code> ，不保证其类型，可变性，可串行性或线程安全性。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd>
               如果分区没有元素，则通过调用下游收集器的供应商功能然后应用修整器功能来获取结果Map中的值。 
             </dd> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 输入元素的类型 
             </dd> 
             <dd> 
              <code>A</code> - 下游收集器的中间累积类型 
             </dd> 
             <dd> 
              <code>D</code> - 下游缩减的结果类型 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>predicate</code> - 用于对输入元素进行分类的谓词 
             </dd> 
             <dd> 
              <code>downstream</code> - 实现下游减少的 
              <code>Collector</code> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>Collector</code>实现级联分区操作 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#partitioningBy(java.util.function.Predicate)"><code>partitioningBy(Predicate)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="toMap(java.util.function.Function,java.util.function.Function)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>toMap</h4> <pre class="methodSignature">public static&nbsp;&lt;T,​K,​U&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../Map.html" title="interface in java.util">Map</a>&lt;K,​U&gt;&gt;&nbsp;toMap​(<a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends K&gt;&nbsp;keyMapper,
                                                                                  <a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends U&gt;&nbsp;valueMapper)</pre> 
            <div class="block"> 
             <span>返回<code>Collector</code> ，它将元素累积到<code>Map</code>其键和值是将提供的映射函数应用于输入元素的结果。</span> 
             <p> <span>如果映射的密钥包含重复项（根据<a href="../../lang/Object.html#equals(java.lang.Object)"><code>Object.equals(Object)</code></a> ），则在执行收集操作时会引发<code>IllegalStateException</code> 。</span> <span>如果映射的键可能有重复项，请改用<a href="#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"><code>toMap(Function, Function, BinaryOperator)</code></a> 。</span> </p> 
             <p> <span><code>Map</code>返回的<code>Map</code> ，不保证其类型，可变性，可串行性或线程安全性。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>键或值通常是输入元素。</span> 
              <span>在这种情况下，实用方法<a href="../function/Function.html#identity()"><code>Function.identity()</code></a>可能是有帮助的。</span> 
              <span>例如，以下内容生成<code>Map</code>映射学生到他们的平均成绩点：</span> 
              <pre>  <span><code> Map&lt;Student, Double&gt; studentToGPA = students.stream().collect( toMap(Function.identity(), student -&gt; computeGPA(student))); </code></span> </pre> 
              <span>以下产生了<code>Map</code>映射到学生的唯一标识符：</span> 
              <pre>  <span><code> Map&lt;String, Student&gt; studentIdToStudent = students.stream().collect( toMap(Student::getId, Function.identity())); </code></span> </pre> 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">Implementation Note:</span> 
             </dt> 
             <dd> 
              <span>返回的<code>Collector</code>不是并发的。</span> 
              <span>对于并行流管道， <code>combiner</code>功能通过将键从一个映射合并到另一个映射来操作，这可能是昂贵的操作。</span> 
              <span>如果不需要将结果按顺序插入<code>Map</code> ，则使用<a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function)"><code>toConcurrentMap(Function, Function)</code></a>可以提供更好的并行性能。</span> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 输入元素的类型 
             </dd> 
             <dd> 
              <code>K</code> - 键映射函数的输出类型 
             </dd> 
             <dd> 
              <code>U</code> - 值映射函数的输出类型 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>keyMapper</code> - 用于生成密钥的映射函数 
             </dd> 
             <dd> 
              <code>valueMapper</code> - 用于生成值的映射函数 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               a 
              <code>Collector</code> ，它将元素收集到 
              <code>Map</code>其键和值是将映射函数应用于输入元素的结果 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"><code>toMap(Function, Function, BinaryOperator)</code></a> ， 
              <a href="#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)"><code>toMap(Function, Function, BinaryOperator, Supplier)</code></a> ， 
              <a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function)"><code>toConcurrentMap(Function, Function)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="toUnmodifiableMap(java.util.function.Function,java.util.function.Function)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>toUnmodifiableMap</h4> <pre class="methodSignature">public static&nbsp;&lt;T,​K,​U&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../Map.html" title="interface in java.util">Map</a>&lt;K,​U&gt;&gt;&nbsp;toUnmodifiableMap​(<a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends K&gt;&nbsp;keyMapper,
                                                                                              <a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends U&gt;&nbsp;valueMapper)</pre> 
            <div class="block"> 
             <span>返回<code>Collector</code> ，它将输入元素累积到<a href="../Map.html#unmodifiable">unmodifiable Map中</a> ，其键和值是将提供的映射函数应用于输入元素的结果。</span> 
             <p> <span>如果映射的键包含重复项（根据<a href="../../lang/Object.html#equals(java.lang.Object)"><code>Object.equals(Object)</code></a> ），则在执行收集操作时将引发<code>IllegalStateException</code> 。</span> <span>如果映射的键可能有重复项，请使用<a href="#toUnmodifiableMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"><code>toUnmodifiableMap(Function, Function, BinaryOperator)</code></a>来处理值的合并。</span> </p> 
             <p> <span>返回的收集器不允许使用null键和值。</span> <span>如果任一映射函数返回null，则将抛出<code>NullPointerException</code> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 输入元素的类型 
             </dd> 
             <dd> 
              <code>K</code> - 键映射函数的输出类型 
             </dd> 
             <dd> 
              <code>U</code> - 值映射函数的输出类型 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>keyMapper</code> - 用于生成密钥的映射函数，必须为非null 
             </dd> 
             <dd> 
              <code>valueMapper</code> - 用于生成值的映射函数，必须为非null 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>Collector</code>将输入元素累积到 
              <a href="../Map.html#unmodifiable">unmodifiable Map中</a> ，其键和值是将提供的映射函数应用于输入元素的结果 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果keyMapper或valueMapper为null 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               10 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#toUnmodifiableMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"><code>toUnmodifiableMap(Function, Function, BinaryOperator)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>toMap</h4> <pre class="methodSignature">public static&nbsp;&lt;T,​K,​U&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../Map.html" title="interface in java.util">Map</a>&lt;K,​U&gt;&gt;&nbsp;toMap​(<a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends K&gt;&nbsp;keyMapper,
                                                                                  <a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends U&gt;&nbsp;valueMapper,
                                                                                  <a href="../function/BinaryOperator.html" title="interface in java.util.function">BinaryOperator</a>&lt;U&gt;&nbsp;mergeFunction)</pre> 
            <div class="block"> 
             <span>返回<code>Collector</code> ，它将元素累积到<code>Map</code>其键和值是将提供的映射函数应用于输入元素的结果。</span> 
             <p> <span>如果映射的键包含重复项（根据<a href="../../lang/Object.html#equals(java.lang.Object)"><code>Object.equals(Object)</code></a> ），则将值映射函数应用于每个相等的元素，并使用提供的合并函数合并结果。</span> </p> 
             <p> <span><code>Map</code>返回的<code>Map</code> ，不保证其类型，可变性，可串行性或线程安全性。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>有多种方法可以处理映射到同一个键的多个元素之间的冲突。</span> 
              <span><code>toMap</code>的其他形式只使用无条件抛出的合并函数，但您可以轻松编写更灵活的合并策略。</span> 
              <span>例如，如果您有一个<code>Person</code>的流，并且您想要生成一个“电话簿”映射名称来解决，但是有两个人可能具有相同的名称，您可以按照以下方式优雅地处理这些冲突，并生成<code>Map</code>映射名称到连接的地址列表：</span> 
              <pre>  <span><code> Map&lt;String, String&gt; phoneBook = people.stream().collect( toMap(Person::getName, Person::getAddress, (s, a) -&gt; s + ", " + a)); </code></span> </pre> 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">Implementation Note:</span> 
             </dt> 
             <dd> 
              <span>返回的<code>Collector</code>不是并发的。</span> 
              <span>对于并行流管道， <code>combiner</code>功能通过将键从一个映射合并到另一个映射来进行操作，这可能是一项昂贵的操作。</span> 
              <span>如果不要求结果以遭遇顺序合并到<code>Map</code>中，则使用<a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"><code>toConcurrentMap(Function, Function, BinaryOperator)</code></a>可以提供更好的并行性能。</span> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 输入元素的类型 
             </dd> 
             <dd> 
              <code>K</code> - 键映射函数的输出类型 
             </dd> 
             <dd> 
              <code>U</code> - 值映射函数的输出类型 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>keyMapper</code> - 用于生成密钥的映射函数 
             </dd> 
             <dd> 
              <code>valueMapper</code> - 用于生成值的映射函数 
             </dd> 
             <dd> 
              <code>mergeFunction</code> - 合并函数，用于解决与同一密钥关联的值之间的冲突，如提供给 
              <a href="../Map.html#merge(K,V,java.util.function.BiFunction)"><code>Map.merge(Object, Object, BiFunction)</code></a> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>Collector</code> ，它将元素收集到 
              <code>Map</code>其键是将键映射函数应用于输入元素的结果，其值是将值映射函数应用于所有等于键的输入元素并使用合并将它们组合的结果功能 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#toMap(java.util.function.Function,java.util.function.Function)"><code>toMap(Function, Function)</code></a> ， 
              <a href="#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)"><code>toMap(Function, Function, BinaryOperator, Supplier)</code></a> ， 
              <a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"><code>toConcurrentMap(Function, Function, BinaryOperator)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="toUnmodifiableMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>toUnmodifiableMap</h4> <pre class="methodSignature">public static&nbsp;&lt;T,​K,​U&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../Map.html" title="interface in java.util">Map</a>&lt;K,​U&gt;&gt;&nbsp;toUnmodifiableMap​(<a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends K&gt;&nbsp;keyMapper,
                                                                                              <a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends U&gt;&nbsp;valueMapper,
                                                                                              <a href="../function/BinaryOperator.html" title="interface in java.util.function">BinaryOperator</a>&lt;U&gt;&nbsp;mergeFunction)</pre> 
            <div class="block"> 
             <span>返回<code>Collector</code> ，它将输入元素累积到<a href="../Map.html#unmodifiable">unmodifiable Map中</a> ，其键和值是将提供的映射函数应用于输入元素的结果。</span> 
             <p> <span>如果映射的密钥包含重复项（根据<a href="../../lang/Object.html#equals(java.lang.Object)"><code>Object.equals(Object)</code></a> ），则将值映射函数应用于每个相等的元素，并使用提供的合并函数合并结果。</span> </p> 
             <p> <span>返回的收集器不允许使用null键和值。</span> <span>如果任一映射函数返回null，则将抛出<code>NullPointerException</code> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 输入元素的类型 
             </dd> 
             <dd> 
              <code>K</code> - 键映射函数的输出类型 
             </dd> 
             <dd> 
              <code>U</code> - 值映射函数的输出类型 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>keyMapper</code> - 用于生成密钥的映射函数，必须为非null 
             </dd> 
             <dd> 
              <code>valueMapper</code> - 用于生成值的映射函数必须为非null 
             </dd> 
             <dd> 
              <code>mergeFunction</code> - 用于解决与同一密钥关联的值之间的冲突的合并函数（如提供给 
              <a href="../Map.html#merge(K,V,java.util.function.BiFunction)"><code>Map.merge(Object, Object, BiFunction)</code></a> ）必须为非null 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>Collector</code>将输入元素累积到 
              <a href="../Map.html#unmodifiable">unmodifiable Map中</a> ，其键和值是将提供的映射函数应用于输入元素的结果 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果keyMapper，valueMapper或mergeFunction为null 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               10 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#toUnmodifiableMap(java.util.function.Function,java.util.function.Function)"><code>toUnmodifiableMap(Function, Function)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>toMap</h4> <pre class="methodSignature">public static&nbsp;&lt;T,​K,​U,​M extends <a href="../Map.html" title="interface in java.util">Map</a>&lt;K,​U&gt;&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​M&gt;&nbsp;toMap​(<a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends K&gt;&nbsp;keyMapper,
                                                                                                    <a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends U&gt;&nbsp;valueMapper,
                                                                                                    <a href="../function/BinaryOperator.html" title="interface in java.util.function">BinaryOperator</a>&lt;U&gt;&nbsp;mergeFunction,
                                                                                                    <a href="../function/Supplier.html" title="interface in java.util.function">Supplier</a>&lt;M&gt;&nbsp;mapFactory)</pre> 
            <div class="block"> 
             <span>返回<code>Collector</code> ，它将元素累积到<code>Map</code>其键和值是将提供的映射函数应用于输入元素的结果。</span> 
             <p> <span>如果映射的键包含重复项（根据<a href="../../lang/Object.html#equals(java.lang.Object)"><code>Object.equals(Object)</code></a> ），则将值映射函数应用于每个相等的元素，并使用提供的合并函数合并结果。</span> <span><code>Map</code>由提供的供应商功能创建。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">Implementation Note:</span> 
             </dt> 
             <dd> 
              <span>返回的<code>Collector</code>不是并发的。</span> 
              <span>对于并行流管道， <code>combiner</code>功能通过将键从一个映射合并到另一个映射来进行操作，这可能是一项昂贵的操作。</span> 
              <span>如果不需要将结果合并到遭遇顺序中的<code>Map</code> ，则使用<a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)"><code>toConcurrentMap(Function, Function, BinaryOperator, Supplier)</code></a>可以提供更好的并行性能。</span> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 输入元素的类型 
             </dd> 
             <dd> 
              <code>K</code> - 键映射函数的输出类型 
             </dd> 
             <dd> 
              <code>U</code> - 值映射函数的输出类型 
             </dd> 
             <dd> 
              <code>M</code> - 生成的 
              <code>Map</code>的类型 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>keyMapper</code> - 用于生成密钥的映射函数 
             </dd> 
             <dd> 
              <code>valueMapper</code> - 用于生成值的映射函数 
             </dd> 
             <dd> 
              <code>mergeFunction</code> - 合并函数，用于解决与同一密钥关联的值之间的冲突，如提供给 
              <a href="../Map.html#merge(K,V,java.util.function.BiFunction)"><code>Map.merge(Object, Object, BiFunction)</code></a> 
             </dd> 
             <dd> 
              <code>mapFactory</code> - 提供新空 
              <code>Map</code>的供应商，其中将插入结果 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>Collector</code>将元素收集到 
              <code>Map</code>其键是将键映射函数应用于输入元素的结果，其值是将值映射函数应用于与键相等的所有输入元素并使用合并将它们组合的结果功能 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#toMap(java.util.function.Function,java.util.function.Function)"><code>toMap(Function, Function)</code></a> ， 
              <a href="#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"><code>toMap(Function, Function, BinaryOperator)</code></a> ， 
              <a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)"><code>toConcurrentMap(Function, Function, BinaryOperator, Supplier)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="toConcurrentMap(java.util.function.Function,java.util.function.Function)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>toConcurrentMap</h4> <pre class="methodSignature">public static&nbsp;&lt;T,​K,​U&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../concurrent/ConcurrentMap.html" title="interface in java.util.concurrent">ConcurrentMap</a>&lt;K,​U&gt;&gt;&nbsp;toConcurrentMap​(<a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends K&gt;&nbsp;keyMapper,
                                                                                                      <a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends U&gt;&nbsp;valueMapper)</pre> 
            <div class="block"> 
             <span>返回并发<code>Collector</code> ，它将元素累积到<code>ConcurrentMap</code>其键和值是将提供的映射函数应用于输入元素的结果。</span> 
             <p> <span>如果映射的密钥包含重复项（根据<a href="../../lang/Object.html#equals(java.lang.Object)"><code>Object.equals(Object)</code></a> ），则执行收集操作时将引发<code>IllegalStateException</code> 。</span> <span>如果映射的键可能有重复项，请改用<a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"><code>toConcurrentMap(Function, Function, BinaryOperator)</code></a> 。</span> </p> 
             <p> <span><code>ConcurrentMap</code>返回的<code>ConcurrentMap</code> ，不保证其类型，可变性或可串行性。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>键或值通常是输入元素。</span> 
              <span>在这种情况下，实用方法<a href="../function/Function.html#identity()"><code>Function.identity()</code></a>可能是有帮助的。</span> 
              <span>例如，以下内容生成<code>ConcurrentMap</code>映射学生平均成绩点：</span> 
              <pre>  <span><code> ConcurrentMap&lt;Student, Double&gt; studentToGPA = students.stream().collect( toConcurrentMap(Function.identity(), student -&gt; computeGPA(student))); </code></span> </pre> 
              <span>以下产生<code>ConcurrentMap</code>将唯一标识符映射到学生：</span> 
              <pre>  <span><code> ConcurrentMap&lt;String, Student&gt; studentIdToStudent = students.stream().collect( toConcurrentMap(Student::getId, Function.identity())); </code></span> </pre> 
              <p> <span>这是一个<a href="Collector.Characteristics.html#CONCURRENT"><code>concurrent</code></a>和<a href="Collector.Characteristics.html#UNORDERED"><code>unordered</code></a>收藏家。</span> </p> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 输入元素的类型 
             </dd> 
             <dd> 
              <code>K</code> - 键映射函数的输出类型 
             </dd> 
             <dd> 
              <code>U</code> - 值映射函数的输出类型 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>keyMapper</code> - 用于生成密钥的映射函数 
             </dd> 
             <dd> 
              <code>valueMapper</code> - 用于生成值的映射函数 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               并发，无序 
              <code>Collector</code> ，它将元素收集到 
              <code>ConcurrentMap</code>其键是将键映射函数应用于输入元素的结果，其值是将值映射函数应用于输入元素的结果 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#toMap(java.util.function.Function,java.util.function.Function)"><code>toMap(Function, Function)</code></a> ， 
              <a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"><code>toConcurrentMap(Function, Function, BinaryOperator)</code></a> ， 
              <a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)"><code>toConcurrentMap(Function, Function, BinaryOperator, Supplier)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>toConcurrentMap</h4> <pre class="methodSignature">public static&nbsp;&lt;T,​K,​U&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../concurrent/ConcurrentMap.html" title="interface in java.util.concurrent">ConcurrentMap</a>&lt;K,​U&gt;&gt;&nbsp;toConcurrentMap​(<a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends K&gt;&nbsp;keyMapper,
                                                                                                      <a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends U&gt;&nbsp;valueMapper,
                                                                                                      <a href="../function/BinaryOperator.html" title="interface in java.util.function">BinaryOperator</a>&lt;U&gt;&nbsp;mergeFunction)</pre> 
            <div class="block"> 
             <span>返回并发<code>Collector</code> ，它将元素累积到<code>ConcurrentMap</code>其键和值是将提供的映射函数应用于输入元素的结果。</span> 
             <p> <span>如果映射的键包含重复项（根据<a href="../../lang/Object.html#equals(java.lang.Object)"><code>Object.equals(Object)</code></a> ），则将值映射函数应用于每个相等的元素，并使用提供的合并函数合并结果。</span> </p> 
             <p> <span><code>ConcurrentMap</code>返回的<code>ConcurrentMap</code> ，不保证其类型，可变性或可串行性。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>有多种方法可以处理映射到同一个键的多个元素之间的冲突。</span> 
              <span><code>toConcurrentMap</code>的其他形式只是使用无条件抛出的合并函数，但您可以轻松编写更灵活的合并策略。</span> 
              <span>例如，如果您有一个<code>Person</code>的流，并且您想要生成一个“电话簿”映射名称来解决，但是有两个人可能具有相同的名称，您可以按照以下方式优雅地处理这些冲突，并生成<code>ConcurrentMap</code>映射名称到连接的地址列表：</span> 
              <pre>  <span><code> ConcurrentMap&lt;String, String&gt; phoneBook = people.stream().collect( toConcurrentMap(Person::getName, Person::getAddress, (s, a) -&gt; s + ", " + a)); </code></span> </pre> 
              <p> <span>这是一个<a href="Collector.Characteristics.html#CONCURRENT"><code>concurrent</code></a>和<a href="Collector.Characteristics.html#UNORDERED"><code>unordered</code></a>收藏家。</span> </p> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 输入元素的类型 
             </dd> 
             <dd> 
              <code>K</code> - 键映射函数的输出类型 
             </dd> 
             <dd> 
              <code>U</code> - 值映射函数的输出类型 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>keyMapper</code> - 用于生成密钥的映射函数 
             </dd> 
             <dd> 
              <code>valueMapper</code> - 用于生成值的映射函数 
             </dd> 
             <dd> 
              <code>mergeFunction</code> - 合并函数，用于解决与同一密钥关联的值之间的冲突，如提供给 
              <a href="../Map.html#merge(K,V,java.util.function.BiFunction)"><code>Map.merge(Object, Object, BiFunction)</code></a> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               并行，无序 
              <code>Collector</code> ，它将元素收集到 
              <code>ConcurrentMap</code>其键是将键映射函数应用于输入元素的结果，其值是将值映射函数应用于等于键的所有输入元素并将它们组合的结果使用合并功能 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function)"><code>toConcurrentMap(Function, Function)</code></a> ， 
              <a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)"><code>toConcurrentMap(Function, Function, BinaryOperator, Supplier)</code></a> ， 
              <a href="#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"><code>toMap(Function, Function, BinaryOperator)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>toConcurrentMap</h4> <pre class="methodSignature">public static&nbsp;&lt;T,​K,​U,​M extends <a href="../concurrent/ConcurrentMap.html" title="interface in java.util.concurrent">ConcurrentMap</a>&lt;K,​U&gt;&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​M&gt;&nbsp;toConcurrentMap​(<a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends K&gt;&nbsp;keyMapper,
                                                                                                                        <a href="../function/Function.html" title="interface in java.util.function">Function</a>&lt;? super T,​? extends U&gt;&nbsp;valueMapper,
                                                                                                                        <a href="../function/BinaryOperator.html" title="interface in java.util.function">BinaryOperator</a>&lt;U&gt;&nbsp;mergeFunction,
                                                                                                                        <a href="../function/Supplier.html" title="interface in java.util.function">Supplier</a>&lt;M&gt;&nbsp;mapFactory)</pre> 
            <div class="block"> 
             <span>返回并发<code>Collector</code> ，它将元素累积到<code>ConcurrentMap</code>其键和值是将提供的映射函数应用于输入元素的结果。</span> 
             <p> <span>如果映射的键包含重复项（根据<a href="../../lang/Object.html#equals(java.lang.Object)"><code>Object.equals(Object)</code></a> ），则将值映射函数应用于每个相等的元素，并使用提供的合并函数合并结果。</span> <span><code>ConcurrentMap</code>由提供的供应商功能创建。</span> </p> 
             <p> <span>这是一个<a href="Collector.Characteristics.html#CONCURRENT"><code>concurrent</code></a>和<a href="Collector.Characteristics.html#UNORDERED"><code>unordered</code></a>收藏家。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 输入元素的类型 
             </dd> 
             <dd> 
              <code>K</code> - 键映射函数的输出类型 
             </dd> 
             <dd> 
              <code>U</code> - 值映射函数的输出类型 
             </dd> 
             <dd> 
              <code>M</code> - 生成的 
              <code>ConcurrentMap</code>的类型 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>keyMapper</code> - 用于生成密钥的映射函数 
             </dd> 
             <dd> 
              <code>valueMapper</code> - 用于生成值的映射函数 
             </dd> 
             <dd> 
              <code>mergeFunction</code> - 合并函数，用于解决与同一密钥关联的值之间的冲突，如提供给 
              <a href="../Map.html#merge(K,V,java.util.function.BiFunction)"><code>Map.merge(Object, Object, BiFunction)</code></a> 
             </dd> 
             <dd> 
              <code>mapFactory</code> - 提供新空 
              <code>ConcurrentMap</code>的供应商，其中将插入结果 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个并发的，无序的 
              <code>Collector</code> ，它将元素收集到 
              <code>ConcurrentMap</code>其键是将键映射函数应用于输入元素的结果，其值是将值映射函数应用于等于键的所有输入元素并将它们组合的结果使用合并功能 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function)"><code>toConcurrentMap(Function, Function)</code></a> ， 
              <a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"><code>toConcurrentMap(Function, Function, BinaryOperator)</code></a> ， 
              <a href="#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)"><code>toMap(Function, Function, BinaryOperator, Supplier)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="summarizingInt(java.util.function.ToIntFunction)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>summarizingInt</h4> <pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../IntSummaryStatistics.html" title="class in java.util">IntSummaryStatistics</a>&gt;&nbsp;summarizingInt​(<a href="../function/ToIntFunction.html" title="interface in java.util.function">ToIntFunction</a>&lt;? super T&gt;&nbsp;mapper)</pre> 
            <div class="block">
              返回 
             <code>Collector</code> ， 
             <code>int</code>映射函数应用于每个输入元素，并返回结果值的汇总统计信息。 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 输入元素的类型 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>mapper</code> - 应用于每个元素的映射函数 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               a 
              <code>Collector</code>实现汇总统计数据减少 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#summarizingDouble(java.util.function.ToDoubleFunction)"><code>summarizingDouble(ToDoubleFunction)</code></a> ， 
              <a href="#summarizingLong(java.util.function.ToLongFunction)"><code>summarizingLong(ToLongFunction)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="summarizingLong(java.util.function.ToLongFunction)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>summarizingLong</h4> <pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../LongSummaryStatistics.html" title="class in java.util">LongSummaryStatistics</a>&gt;&nbsp;summarizingLong​(<a href="../function/ToLongFunction.html" title="interface in java.util.function">ToLongFunction</a>&lt;? super T&gt;&nbsp;mapper)</pre> 
            <div class="block">
              返回 
             <code>Collector</code> ， 
             <code>long</code>映射函数应用于每个输入元素，并返回结果值的摘要统计信息。 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 输入元素的类型 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>mapper</code> - 要应用于每个元素的映射函数 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               a 
              <code>Collector</code>实现摘要统计减少 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#summarizingDouble(java.util.function.ToDoubleFunction)"><code>summarizingDouble(ToDoubleFunction)</code></a> ， 
              <a href="#summarizingInt(java.util.function.ToIntFunction)"><code>summarizingInt(ToIntFunction)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="summarizingDouble(java.util.function.ToDoubleFunction)"> 
           <!--   --> </a> 
          <ul class="blockListLast"> 
           <li class="blockList"> <h4>summarizingDouble</h4> <pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​?,​<a href="../DoubleSummaryStatistics.html" title="class in java.util">DoubleSummaryStatistics</a>&gt;&nbsp;summarizingDouble​(<a href="../function/ToDoubleFunction.html" title="interface in java.util.function">ToDoubleFunction</a>&lt;? super T&gt;&nbsp;mapper)</pre> 
            <div class="block">
              返回 
             <code>Collector</code> ， 
             <code>double</code>映射函数应用于每个输入元素，并返回结果值的摘要统计信息。 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <code>T</code> - 输入元素的类型 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>mapper</code> - 应用于每个元素的映射函数 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               a 
              <code>Collector</code>实现摘要统计减少 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#summarizingLong(java.util.function.ToLongFunction)"><code>summarizingLong(ToLongFunction)</code></a> ， 
              <a href="#summarizingInt(java.util.function.ToIntFunction)"><code>summarizingInt(ToIntFunction)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> </li> 
        </ul> 
       </section> </li> 
     </ul> 
    </div> 
   </div> 
  </main> 
  <!-- ========= END OF CLASS DATA ========= --> 
  <footer role="contentinfo"> 
   <nav role="navigation"> 
    <!-- ======= START OF BOTTOM NAVBAR ====== --> 
    <div class="bottomNav"> 
     <a id="navbar.bottom"> 
      <!--   --> </a> 
     <div class="skipNav"> 
      <a href="#skip.navbar.bottom" title="Skip navigation links">跳过导航</a> 
     </div> 
     <a id="navbar.bottom.firstrow"> 
      <!--   --> </a> 
     <ul class="navList" title="Navigation"> 
      <li><a href="../../../../index.html">概述</a></li> 
      <li><a href="../../../module-summary.html">模块</a></li> 
      <li><a href="package-summary.html">软件包</a></li> 
      <li class="navBarCell1Rev">类</li> 
      <li><a href="class-use/Collectors.html">使用</a></li> 
      <li><a href="package-tree.html">树</a></li> 
      <li><a href="../../../../deprecated-list.html">已过时的</a></li> 
      <li><a href="../../../../index-files/index-1.html">索引</a></li> 
      <li><a href="../../../../help-doc.html">帮助</a></li> 
     </ul> 
     <div class="aboutLanguage"> 
      <div style="margin-top: 14px;"> 
       <strong>Java SE 11 &amp; JDK 11</strong> 
      </div> 
     </div> 
    </div> 
    <div class="subNav"> 
     <ul class="navList" id="allclasses_navbar_bottom"> 
      <li><a href="../../../../allclasses.html">所有类</a></li> 
     </ul> 
     <div> 
      <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
      <noscript> 
       <div>
         JavaScript is disabled on your browser. 
       </div> 
      </noscript> 
     </div> 
     <div> 
      <ul class="subNavList"> 
       <li>概要：&nbsp;</li> 
       <li>嵌套&nbsp;|&nbsp;</li> 
       <li>字段&nbsp;|&nbsp;</li> 
       <li>构造方法&nbsp;|&nbsp;</li> 
       <li><a href="#method.summary">方法</a></li> 
      </ul> 
      <ul class="subNavList"> 
       <li>详细信息：&nbsp;</li> 
       <li>字段&nbsp;|&nbsp;</li> 
       <li>构造方法&nbsp;|&nbsp;</li> 
       <li><a href="#method.detail">方法</a></li> 
      </ul> 
     </div> 
     <a id="skip.navbar.bottom"> 
      <!--   --> </a> 
    </div> 
    <!-- ======== END OF BOTTOM NAVBAR ======= --> 
   </nav> 
   <p class="legalCopy"><small><a href="http://bugreport.java.com/bugreport/">Report a bug or suggest an enhancement</a><br> For further API reference and developer documentation see the <a href="http://www.oracle.com/pls/topic/lookup?ctx=javase11.0.1&amp;id=homepage" target="_blank">Java SE Documentation</a>, which contains more detailed, developer-targeted descriptions with conceptual overviews, definitions of terms, workarounds, and working code examples.<br> Java is a trademark or registered trademark of Oracle and/or its affiliates in the US and other countries.<br> <a href="../../../../../legal/copyright.html">Copyright</a> © 1993, 2018, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.<br>All rights reserved. Use is subject to <a href="http://www.oracle.com/technetwork/java/javase/terms/license/java11.0.1speclicense.html">license terms</a> and the <a href="http://www.oracle.com/technetwork/java/redist-137594.html">documentation redistribution policy</a>. 
     <!-- Version 11.0.1+13-LTS --></small></p> 
  </footer>  
 </body>
</html>