<!doctype html>
<!-- NewPage -->
<html lang="en">
 <head> 
  <!-- Generated by javadoc --> 
  <title>java.util.stream</title> 
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> 
  <meta name="keywords" content="java.util.stream package"> 
  <link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style"> 
  <link rel="stylesheet" type="text/css" href="../../../../jquery/jquery-ui.css" title="Style"> 
  <script type="text/javascript" src="../../../../script.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jszip/dist/jszip.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script> 
  <!--[if IE]>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]--> 
  <script type="text/javascript" src="../../../../jquery/jquery-1.10.2.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jquery-migrate-1.2.1.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jquery-ui.js"></script> 
 </head> 
 <body> <SCRIPT LANGUAGE="JavaScript"><!-- Hide  
   function ResumeError() {     return true;}window.onerror = ResumeError;// --></SCRIPT>
  <script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="java.util.stream (Java SE 11 & JDK 11 )";
        }
    }
    catch(err) {
    }
//-->
var pathtoroot = "../../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script> 
  <noscript> 
   <div>
     JavaScript is disabled on your browser. 
   </div> 
  </noscript> 
  <header role="banner"> 
   <nav role="navigation"> 
    <div class="fixedNav"> 
     <!-- ========= START OF TOP NAVBAR ======= --> 
     <div class="topNav"> 
      <a id="navbar.top"> 
       <!--   --> </a> 
      <div class="skipNav"> 
       <a href="#skip.navbar.top" title="Skip navigation links">跳过导航</a> 
      </div> 
      <a id="navbar.top.firstrow"> 
       <!--   --> </a> 
      <ul class="navList" title="Navigation"> 
       <li><a href="../../../../index.html">概述</a></li> 
       <li><a href="../../../module-summary.html">模块</a></li> 
       <li class="navBarCell1Rev">软件包</li> 
       <li>类</li> 
       <li><a href="package-use.html">使用</a></li> 
       <li><a href="package-tree.html">树</a></li> 
       <li><a href="../../../../deprecated-list.html">已过时的</a></li> 
       <li><a href="../../../../index-files/index-1.html">索引</a></li> 
       <li><a href="../../../../help-doc.html">帮助</a></li> 
      </ul> 
      <div class="aboutLanguage"> 
       <div style="margin-top: 14px;"> 
        <strong>Java SE 11 &amp; JDK 11</strong> 
       </div> 
      </div> 
     </div> 
     <div class="subNav"> 
      <ul class="navList" id="allclasses_navbar_top"> 
       <li><a href="../../../../allclasses.html">所有类</a></li> 
      </ul> 
      <ul class="navListSearch"> 
       <li><label for="search">SEARCH:</label> <input type="text" id="search" value="search" disabled> <input type="reset" id="reset" value="reset" disabled> </li> 
      </ul> 
      <div> 
       <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
       <noscript> 
        <div>
          JavaScript is disabled on your browser. 
        </div> 
       </noscript> 
      </div> 
      <a id="skip.navbar.top"> 
       <!--   --> </a> 
     </div> 
     <!-- ========= END OF TOP NAVBAR ========= --> 
    </div> 
    <div class="navPadding">
      &nbsp; 
    </div> 
    <script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script> 
   </nav> 
  </header> 
  <main role="main"> 
   <div class="header"> 
    <div class="subTitle"> 
     <span class="moduleLabelInPackage">模块</span>&nbsp; 
     <a href="../../../module-summary.html">java.base</a> 
    </div> 
    <h1 title="Package" class="title">Package&nbsp;java.util.stream</h1> 
   </div> 
   <div class="contentContainer"> 
    <section role="region"> 
     <a id="package.description"> 
      <!--   --> </a> 
     <div class="block"> 
      <span>用于支持元素流上的功能样式操作的类，例如集合上的map-reduce转换。</span> 
      <span>例如：</span> 
      <pre>  <span><code> int sum = widgets.stream() .filter(b -&gt; b.getColor() == RED) .mapToInt(b -&gt; b.getWeight()) .sum(); </code></span> </pre> 
      <p> <span>这里我们使用<code>widgets</code> ，一个<code>Collection&lt;Widget&gt;</code>作为流的源，然后在流上执行filter-map-reduce以获得红色小部件的权重之和。</span> <span>（求和是<a href="package-summary.html#Reduction">reduction</a>操作的示例。）</span> </p> 
      <p> <span>此包中引入的关键抽象是<em>流</em> 。</span> <span>类<a href="Stream.html" title="java.util.stream中的接口"><code>Stream</code></a> ， <a href="IntStream.html" title="java.util.stream中的接口"><code>IntStream</code></a> ， <a href="LongStream.html" title="java.util.stream中的接口"><code>LongStream</code></a> ，和<a href="DoubleStream.html" title="java.util.stream中的接口"><code>DoubleStream</code></a>超过目的和原始流<code>int</code> ， <code>long</code>和<code>double</code>类型。</span> <span>Streams在几个方面与集合不同：</span> </p> 
      <ul> 
       <li> <span>没有存储空间</span> <span>流不是存储元素的数据结构;</span> <span>相反，它通过计算操作管道传递来自诸如数据结构，数组，生成器函数或I / O通道的源的元素。</span> </li> 
       <li> <span>功能性。</span> <span>对流的操作会产生结果，但不会修改其源。</span> <span>例如，过滤从集合中获取的<code>Stream</code>会生成不带过滤元素的新<code>Stream</code> ，而不是从源集合中删除元素。</span> </li> 
       <li> <span>懒惰寻求。</span> <span>许多流操作（例如过滤，映射或重复删除）可以懒惰地实现，从而暴露出优化的机会。</span> <span>例如，“找到带有三个连续元音的第一个<code>String</code> ”不需要检查所有输入字符串。</span> <span>流操作分为中间（ <code>Stream</code>生产）操作和终端（产生价值或副作用）操作。</span> <span>中间操作总是很懒惰。</span> </li> 
       <li> <span>可能是无限的。</span> <span>虽然集合的大小有限，但流不需要。</span> <span>短路操作（例如<code>limit(n)</code>或<code>findFirst()</code>可以允许无限流上的计算在有限时间内完成。</span> </li> 
       <li> <span>耗材。</span> <span>流的元素仅在流的生命期间访问过一次。</span> <span>与<a href="../Iterator.html" title="java.util中的接口"><code>Iterator</code>类似</a> ，必须生成新流以重新访问源的相同元素。</span> </li> 
      </ul> 
      <span>流可以通过多种方式获得。</span> 
      <span>一些例子包括：</span> 
      <ul> 
       <li> <span>从<a href="../Collection.html" title="java.util中的接口"><code>Collection</code></a>通过<code>stream()</code>和<code>parallelStream()</code>方法;</span> </li> 
       <li> <span>从阵列通过<a href="../Arrays.html#stream(T%5B%5D)"><code>Arrays.stream(Object[])</code></a> ;</span> </li> 
       <li> <span>从上流类静态工厂的方法，例如<a href="Stream.html#of(T...)"><code>Stream.of(Object[])</code></a> ， <a href="IntStream.html#range(int,int)"><code>IntStream.range(int, int)</code></a>或<a href="Stream.html#iterate(T,java.util.function.UnaryOperator)"><code>Stream.iterate(Object, UnaryOperator)</code></a> ;</span> </li> 
       <li> <span>文件的行可以从<a href="../../io/BufferedReader.html#lines()"><code>BufferedReader.lines()</code></a>获得;</span> </li> 
       <li> <span>文件路径的流可以从<a href="../../nio/file/Files.html" title="java.nio.file中的类"><code>Files</code>中的</a>方法获得;</span> </li> 
       <li> <span>随机数的流可以从<a href="../Random.html#ints()"><code>Random.ints()</code></a>获得;</span> </li> 
       <li> <span>许多其它的数据流的方法的轴承在JDK，包括<a href="../BitSet.html#stream()"><code>BitSet.stream()</code></a> ， <a href="../regex/Pattern.html#splitAsStream(java.lang.CharSequence)"><code>Pattern.splitAsStream(java.lang.CharSequence)</code></a> ，和<a href="../jar/JarFile.html#stream()"><code>JarFile.stream()</code></a> 。</span> </li> 
      </ul> 
      <p> <span>第三方库可以使用<a href="package-summary.html#StreamSources">these techniques</a>提供其他流源。</span> </p> 
      <h2> <span><a id="StreamOps">Stream operations and pipelines</a></span> </h2> 
      <p> <span>流操作分为<em>中间</em>操作和<em>终端</em>操作，并组合成<em>流管道</em> 。</span> <span>流管道由源（例如<code>Collection</code> ，阵列，生成器功能或I / O通道）组成;</span> <span>然后是零个或多个中间操作，如<code>Stream.filter</code>或<code>Stream.map</code> ;</span> <span>和终端操作，如<code>Stream.forEach</code>或<code>Stream.reduce</code> 。</span> </p> 
      <p> <span>中间操作返回一个新流。</span> <span>他们总是<em>懒惰</em> ;</span> <span>执行诸如<code>filter()</code>类的中间操作实际上不执行任何过滤，而是创建一个新流，当遍历时，该流包含与给定谓词匹配的初始流的元素。</span> <span>在执行管道的终端操作之前，不会开始遍历管道源。</span> </p> 
      <p> <span>终端操作（例如<code>Stream.forEach</code>或<code>IntStream.sum</code> ）可以遍历流以产生结果或副作用。</span> <span>在执行终端操作之后，流管道被认为已消耗，并且不能再使用;</span> <span>如果需要再次遍历同一数据源，则必须返回数据源以获取新流。</span> <span>在几乎所有情况下，终端操作都很<em>渴望</em> ，在返回之前完成数据源的遍历和管道的处理。</span> <span>只有终端操作<code>iterator()</code>和<code>spliterator()</code>不是;</span> <span>这些是作为“逃生舱口”提供的，以便在现有操作不足以执行任务时启用任意客户端控制的管道遍历。</span> </p> 
      <p> <span>懒惰地处理流可以显着提高效率;</span> <span>在诸如上面的filter-map-sum示例的流水线中，过滤，映射和求和可以融合到数据上的单个传递中，具有最小的中间状态。</span> <span>懒惰还允许在不必要时避免检查所有数据;</span> <span>对于诸如“查找超过1000个字符的第一个字符串”之类的操作，只需要检查足够的字符串以找到具有所需特征的字符串，而不检查源中可用的所有字符串。</span> <span>（当输入流是无限的而不仅仅是大的时候，这种行为变得更加重要。）</span> </p> 
      <p> <span>中间操作进一步分为<em>无</em> <em>状态</em>操作和<em>有状态</em>操作。</span> <span>无状态操作（例如<code>filter</code>和<code>map</code>在处理新元素时不保留先前看到的元素的状态 - 每个元素可以独立于其他元素上的操作进行处理。</span> <span>有状态操作（例如<code>distinct</code>和<code>sorted</code> ）可以在处理新元素时包含先前看到的元素的状态。</span> </p> 
      <p> <span>有状态操作可能需要在生成结果之前处理整个输入。</span> <span>例如，在查看流的所有元素之前，不能通过对流进行排序来产生任何结果。</span> <span>因此，在并行计算下，某些包含有状态中间操作的管道可能需要对数据进行多次传递，或者可能需要缓冲重要数据。</span> <span>仅包含无状态中间操作的管道可以在一次通过中处理，无论是顺序还是并行，具有最小的数据缓冲。</span> </p> 
      <p> <span>此外，一些操作被认为是<em>短路</em>操作。</span> <span>如果在呈现无限输入时，它可能产生有限流，则中间操作是短路的。</span> <span>如果在呈现无限输入时它可以在有限时间内终止，则终端操作是短路的。</span> <span>在流水线中进行短路操作是处理无限流以在有限时间内正常终止的必要但不充分的条件。</span> </p> 
      <h3> <span><a id="Parallelism">Parallelism</a></span> </h3> 
      <p> <span>具有显式<code>for-</code>循环的处理元素本质上是串行的。</span> <span>Streams通过将计算重新定义为聚合操作的流水线而不是作为每个单独元素的命令操作来促进并行执行。</span> <span>所有流操作都可以串行或并行执行。</span> <span>除非明确请求并行性，否则JDK中的流实现会创建串行流。</span> <span>例如， <code>Collection</code>具有方法<a href="../Collection.html#stream()"><code>Collection.stream()</code></a>和<a href="../Collection.html#parallelStream()"><code>Collection.parallelStream()</code></a> ，它们分别产生顺序和并行流;</span> <span>其他流方法（如<a href="IntStream.html#range(int,int)"><code>IntStream.range(int, int)</code>）</a>生成顺序流，但这些流可以通过调用它们的<a href="BaseStream.html#parallel()"><code>BaseStream.parallel()</code></a>方法进行有效并行化。</span> <span>要并行执行先前的“窗口小部件权重总和”查询，我们会这样做：</span> </p> 
      <pre>  <span><code> int sumOfWeights = widgets.</code><code><b>parallelStream()</b></code><code> .filter(b -&gt; b.getColor() == RED) .mapToInt(b -&gt; b.getWeight()) .sum(); </code></span> </pre> 
      <p> <span>此示例的串行和并行版本之间的唯一区别是使用“ <code>parallelStream()</code> ”而不是“ <code>stream()</code> ”创建初始流。</span> <span>根据调用终端操作的流的模式，顺序地或并行地执行流管道。</span> <span>可以使用<a href="BaseStream.html#isParallel()"><code>BaseStream.isParallel()</code></a>方法确定流的顺序或并行模式，并且可以使用<a href="BaseStream.html#sequential()"><code>BaseStream.sequential()</code></a>和<a href="BaseStream.html#parallel()"><code>BaseStream.parallel()</code></a>操作修改流的模式。</span> <span>最近的顺序或并行模式设置适用于整个流管道的执行。</span> </p> 
      <p> <span>除了标识为明确不确定的操作（例如<code>findAny()</code> ，流是顺序执行还是并行执行不应更改计算结果。</span> </p> 
      <p> <span>大多数流操作接受描述用户指定行为的参数，这些参数通常是lambda表达式。</span> <span>为了保持正确的行为，这些<em>行为参数</em>必须是<em>无干扰的</em> ，并且在大多数情况下必须是<em>无状态的</em> 。</span> <span>这些参数始终是<a href="../function/package-summary.html">functional interface的</a>实例，例如<a href="../function/Function.html" title="java.util.function中的接口"><code>Function</code></a> ，并且通常是lambda表达式或方法引用。</span> </p> 
      <h3> <span><a id="NonInterference">Non-interference</a></span> </h3> 
      <span>Streams使您能够在各种数据源上执行可能并行的聚合操作，甚至包括非线程安全的集合，例如<code>ArrayList</code> 。</span> 
      <span>只有在执行流管道期间我们能够防止<em>干扰</em>数据源时，才有可能实现这一点。</span> 
      <span>除了逃逸舱口操作<code>iterator()</code>和<code>spliterator()</code> ，在终端操作被调用时开始执行，并且在终端操作完成时结束。</span> 
      <span>对于大多数数据源，防止干扰意味着确保在流管道的执行期间<em>根本不修改</em>数据源。</span> 
      <span>值得注意的例外是其源是并发集合的流，这些集合专门用于处理并发修改。</span> 
      <span>并发流源是<code>Spliterator</code>报告<code>CONCURRENT</code>特征的那些源。</span> 
      <p> <span>因此，源流可能不是并发的流管道中的行为参数永远不应修改流的数据源。</span> <span>如果行为参数修改或导致修改流的数据源，则该行为参数会<em>干扰</em>非并发数据源。</span> <span>不干涉的需要适用于所有管道，而不仅仅是并行管道。</span> <span>除非流源是并发的，否则在执行流管道期间修改流的数据源可能会导致异常，错误答案或不一致的行为。</span> <span>对于性能良好的流源，可以在终端操作开始之前修改源，并且这些修改将反映在所覆盖的元素中。</span> <span>例如，请考虑以下代码：</span> </p> 
      <pre>  <span><code> List&lt;String&gt; l = new ArrayList(Arrays.asList("one", "two")); Stream&lt;String&gt; sl = l.stream(); l.add("three"); String s = sl.collect(joining(" ")); </code></span> </pre> 
      <span>首先创建一个包含两个字符串的列表：“one”;</span> 
      <span>和“两个”。</span> 
      <span>然后从该列表创建流。</span> 
      <span>接下来，通过添加第三个字符串来修改列表：“three”。</span> 
      <span>最后，收集流的元素并将它们连接在一起。</span> 
      <span>由于在终端<code>collect</code>操作开始之前修改了列表，结果将是一串“一二三”。</span> 
      <span>从JDK集合和大多数其他JDK类返回的所有流都以这种方式表现良好;</span> 
      <span>对于其他库生成的流，请参阅<a href="package-summary.html#StreamSources">Low-level stream construction</a>以了解构建行为良好的流的要求。</span> 
      <h3> <span><a id="Statelessness">Stateless behaviors</a></span> </h3> 
      <span>如果流操作的行为参数是<em>有状态的，</em>则流管道结果可能是不确定的或不正确的。</span> 
      <span>有状态lambda（或实现适当功能接口的其他对象）的结果取决于在流管道执行期间可能发生变化的任何状态。</span> 
      <span>有状态lambda的一个示例是<code>map()</code>的参数：</span> 
      <pre>  <span><code> Set&lt;Integer&gt; seen = Collections.synchronizedSet(new HashSet&lt;&gt;()); stream.parallel().map(e -&gt; { if (seen.add(e)) return 0; else return e; })... </code></span> </pre> 
      <span>这里，如果映射操作是并行执行的，则由于线程调度差异，相同输入的结果可能因运行而异，而对于无状态lambda表达式，结果将始终相同。</span> 
      <p> <span>另请注意，尝试从行为参数访问可变状态会使您在安全性和性能方面做出错误的选择;</span> <span>如果您没有同步对该状态的访问，则会出现数据争用，因此您的代码已损坏，但如果您同步访问该状态，则存在争用的风险会破坏您希望从中受益的并行性。</span> <span>最好的方法是避免有状态的行为参数完全流动操作;</span> <span>通常有一种方法可以重构流管道以避免状态。</span> </p> 
      <h3> <span><a id="SideEffects">Side-effects</a></span> </h3> 
      <span>通常，不鼓励行为参数对流操作的副作用，因为它们通常会导致无意中违反无国籍要求以及其他线程安全危险。</span> 
      <p> <span>如果行为参数确实有副作用，除非明确说明，否则不保证：</span> </p> 
      <ul> 
       <li> <span><a href="../concurrent/package-summary.html#MemoryVisibility"><i>visibility</i></a>对其他线程的副作用;</span> </li> 
       <li> <span>对同一流管道中“相同”元素的不同操作在同一个线程中执行;</span> <span>和</span> </li> 
       <li> <span>总是调用行为参数，因为流实现可以自由地从流管道中删除操作（或整个阶段），如果它可以证明它不会影响计算结果。</span> </li> 
      </ul> 
      <p> <span>副作用的排序可能令人惊讶。</span> <span>即使管道被约束以产生与流源的遭遇顺序一致的<em>结果</em> （例如， <code>IntStream.range(0,5).parallel().map(x -&gt; x*2).toArray()</code>必须产生<code>[0, 2, 4, 6, 8]</code> ），也不保证将映射器功能应用于各个元素的顺序，或者在什么线程中为给定元素执行任何行为参数。</span> </p> 
      <p> <span>消除副作用也可能令人惊讶。</span> <span>除了终端操作<a href="Stream.html#forEach(java.util.function.Consumer)"><code>forEach</code></a>和<a href="Stream.html#forEachOrdered(java.util.function.Consumer)"><code>forEachOrdered</code>之外</a> ，当流实现可以优化掉行为参数的执行而不影响计算结果时，可能不总是执行行为参数的副作用。</span> <span>（有关具体示例，请参阅<a href="Stream.html#count()"><code>count</code></a>操作中记录的API说明。）</span> </p> 
      <p> <span>许多可能试图使用副作用的计算可以更安全和有效地表达而没有副作用，例如使用<a href="package-summary.html#Reduction">reduction</a>而不是可变累加器。</span> <span>但是，诸如使用<code>println()</code>进行调试的副作用通常是无害的。</span> <span>少数流操作，例如<code>forEach()</code>和<code>peek()</code> ，只能通过副作用运行;</span> <span>这些应该小心使用。</span> </p> 
      <p> <span>作为如何将不适当地使用副作用的流管道转换为不使用副作用的流管道的示例，以下代码在字符串流中搜索与给定正则表达式匹配的那些，并将匹配放在列表中。</span> </p> 
      <pre>  <span><code> ArrayList&lt;String&gt; results = new ArrayList&lt;&gt;(); stream.filter(s -&gt; pattern.matcher(s).matches()) .forEach(s -&gt; results.add(s)); // Unnecessary use of side-effects! </code></span> </pre> 
      <span>此代码不必要地使用副作用。</span> 
      <span>如果并行执行， <code>ArrayList</code>的非线程安全性将导致不正确的结果，并且添加所需的同步将导致争用，从而破坏并行性的好处。</span> 
      <span>此外，在这里使用副作用是完全没有必要的;</span> 
      <span>可以简单地将<code>forEach()</code>替换为更安全，更高效且更易于并行化的还原操作：</span> 
      <pre>  <span><code> List&lt;String&gt;results = stream.filter(s -&gt; pattern.matcher(s).matches()) .collect(Collectors.toList()); // No side-effects! </code></span> </pre> 
      <h3> <span><a id="Ordering">Ordering</a></span> </h3> 
      <p> <span>流可能有也可能没有已定义的<em>遭遇顺序</em> 。</span> <span>流是否具有遭遇顺序取决于源和中间操作。</span> <span>某些流源（例如<code>List</code>或数组）本质上是有序的，而其他流（例如<code>HashSet</code> ）则不是。</span> <span>某些中间操作（例如<code>sorted()</code> ）可能会在其他无序流上强制执行遭遇顺序，而其他中间操作可能会呈现无序的有序流，例如<a href="BaseStream.html#unordered()"><code>BaseStream.unordered()</code></a> 。</span> <span>此外，一些终端操作可以忽略遭遇顺序，例如<code>forEach()</code> 。</span> </p> 
      <p> <span>如果订购了流，则大多数操作都被约束为对其遭遇顺序中的元素进行操作;</span> <span>如果流的源是<code>List</code>含有<code>[1, 2, 3]</code> ，然后执行的结果<code>map(x -&gt; x*2)</code>必须是<code>[2, 4, 6]</code> 。</span> <span>但是，如果源没有定义的遭遇顺序，则值<code>[2, 4, 6]</code>任何排列都将是有效结果。</span> </p> 
      <p> <span>对于顺序流，遭遇顺序的存在与否不会影响性能，只影响确定性。</span> <span>如果订购了流，则在相同的源上重复执行相同的流管道将产生相同的结果;</span> <span>如果没有订购，重复执行可能会产生不同的结果。</span> </p> 
      <p> <span>对于并行流，放宽排序约束有时可以实现更高效的执行。</span> <span>如果元素的排序不相关，则可以更有效地实现某些聚合操作，例如过滤重复（ <code>distinct()</code> ）或分组缩减（ <code>Collectors.groupingBy()</code> ）。</span> <span>类似地，与遇到订单本质上相关的操作（例如<code>limit()</code> ）可能需要缓冲以确保正确排序，从而破坏并行性的好处。</span> <span>在流具有遭遇顺序但用户不特别<em>关心</em>该遭遇顺序的情况下，使用<a href="BaseStream.html#unordered()"><code>unordered()</code></a>明确地对流进行<a href="BaseStream.html#unordered()">排序</a>可以改善某些有状态或终端操作的并行性能。</span> <span>然而，大多数流管道，例如上面的“块的权重总和”示例，即使在排序约束下仍然有效地并行化。</span> </p> 
      <h2> <span><a id="Reduction">Reduction operations</a></span> </h2> 
      <span><em>缩减</em>操作（也称为<em>折叠</em> ）采用一系列输入元素，并通过重复应用组合操作将它们组合成单个汇总结果，例如查找一组数字的总和或最大值，或将元素累积到列表中。</span> 
      <span>该流的类具有普遍减少操作，所谓的多种形式<a href="Stream.html#reduce(java.util.function.BinaryOperator)"><code>reduce()</code></a>和<a href="Stream.html#collect(java.util.stream.Collector)"><code>collect()</code></a> ，以及多个专业化还原的形式，如<a href="IntStream.html#sum()"><code>sum()</code></a> ， <a href="IntStream.html#max()"><code>max()</code></a> ，或<a href="IntStream.html#count()"><code>count()</code></a> 。</span> 
      <p> <span>当然，这样的操作可以很容易地实现为简单的顺序循环，如：</span> </p> 
      <pre>  <span><code> int sum = 0; for (int x : numbers) { sum += x; } </code></span> </pre> 
      <span>然而，有充分理由优先考虑减少操作而不是如上所述的变异累积。</span> 
      <span>简化不仅“更抽象” - 它作为一个整体而不是单个元素在整个流上运行 - 但正确构造的reduce操作本质上是可并行化的，只要用于处理元素的函数是<a href="package-summary.html#Associativity">associative</a>和<a href="package-summary.html#Statelessness">stateless</a> 。</span> 
      <span>例如，给定我们想要找到总和的数字流，我们可以写：</span> 
      <pre>  <span><code> int sum = numbers.stream().reduce(0, (x,y) -&gt; x+y); </code></span> </pre> 
      <span>要么：</span> 
      <pre>  <span><code> int sum = numbers.stream().reduce(0, Integer::sum); </code></span> </pre> 
      <p> <span>这些减少操作可以安全地并行运行，几乎不需要修改：</span> </p> 
      <pre>  <span><code> int sum = numbers.parallelStream().reduce(0, Integer::sum); </code></span> </pre> 
      <p> <span>减少并行很好，因为实现可以并行地对数据的子集进行操作，然后将中间结果组合以获得最终的正确答案。</span> <span>（即使语言具有“并行for-each”结构，变异累积方法仍然需要开发人员为共享累积变量<code>sum</code>提供线程安全更新，并且所需的同步可能会消除并行性能带来的任何性能提升。）使用<code>reduce()</code>代替了并行化还原操作的所有负担，并且库可以提供有效的并行实现，而无需额外的同步。</span> </p> 
      <p> <span>前面显示的“小部件”示例显示了简化如何与其他操作结合使用批量操作替换循环。</span> <span>如果<code>widgets</code>是<code>Widget</code>对象的集合，其具有<code>getWeight</code>方法，我们可以找到最重的小部件：</span> </p> 
      <pre>  <span><code> OptionalInt heaviest = widgets.parallelStream() .mapToInt(Widget::getWeight) .max(); </code></span> </pre> 
      <p> <span>在其更一般的形式，一个<code>reduce</code>上类型的元素的操作<code>&lt;T&gt;</code>得到类型的结果<code>&lt;U&gt;</code>需要三个参数：</span> </p> 
      <pre>  <span><code> &lt;U&gt; U reduce(U identity, BiFunction&lt;U, ? super T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner); </code></span> </pre> 
      <span>这里， <em>identity</em>元素既是缩减的初始种子值，也是没有输入元素的默认结果。</span> 
      <span><em>累加器</em>函数获取部分结果和下一个元素，并产生新的部分结果。</span> 
      <span><em>组合器</em>功能组合了两个部分结果以产生新的部分结果。</span> 
      <span>（组合器在并行缩减中是必要的，其中输入被分区，为每个分区计算部分累积，然后组合部分结果以产生最终结果。）</span> 
      <p> <span>更正式地说， <code>identity</code>值必须是组合器函数的<em>标识</em> 。</span> <span>这意味着，对于所有<code>u</code> ， <code>combiner.apply(identity, u)</code>等于<code>u</code> 。</span> <span>此外， <code>combiner</code>功能必须是<a href="package-summary.html#Associativity">associative</a> ，并必须与兼容<code>accumulator</code>功能：对所有<code>u</code>和<code>t</code> ， <code>combiner.apply(u, accumulator.apply(identity, t))</code>必须<code>equals()</code>至<code>accumulator.apply(u, t)</code> 。</span> </p> 
      <p> <span>三参数形式是两参数形式的概括，将映射步骤结合到累积步骤中。</span> <span>我们可以使用更通用的形式重新构建简单的权重总和示例，如下所示：</span> </p> 
      <pre>  <span><code> int sumOfWeights = widgets.stream() .reduce(0, (sum, b) -&gt; sum + b.getWeight(), Integer::sum); </code></span> </pre> 
      <span>虽然显式的map-reduce形式更具可读性，因此通常应该是首选。</span> 
      <span>通过将映射和缩减组合成单个函数，可以优化远离重要工作的情况提供通用形式。</span> 
      <h3> <span><a id="MutableReduction">Mutable reduction</a></span> </h3> 
      <span><em>可变减少操作将</em>输入元素累积到可变结果容器中，例如<code>Collection</code>或<code>StringBuilder</code> ，因为它处理流中的元素。</span> 
      <p> <span>如果我们想要获取字符串流并将它们连接成一个长字符串，我们<em>可以</em>通过普通减少<em>来</em>实现：</span> </p> 
      <pre>  <span><code> String concatenated = strings.reduce("", String::concat) </code></span> </pre> 
      <p> <span>我们会得到理想的结果，甚至可以并行工作。</span> <span>但是，我们可能对性能不满意！</span> <span>这样的实现会进行大量的字符串复制，并且运行时间的字符数为<em>O（n ^ 2）</em> 。</span> <span>更<a href="../../lang/StringBuilder.html" title="java.lang中的类">高效的</a>方法是将结果累积到<a href="../../lang/StringBuilder.html" title="java.lang中的类"><code>StringBuilder</code>中</a> ，这是一个用于累积字符串的可变容器。</span> <span>我们可以使用相同的技术来并行化可变缩减，就像我们使用普通缩减一样。</span> </p> 
      <p> <span>可变还原操作称为<a href="Stream.html#collect(java.util.stream.Collector)"><code>collect()</code></a> ，因为它将所需结果收集到结果容器（例如<code>Collection</code> 。</span> <span><code>collect</code>操作需要三个功能：构造结果容器的新实例的供应商函数，将输入元素合并到结果容器中的累加器函数，以及将一个结果容器的内容合并到另一个中的合并函数。</span> <span>这种形式与普通减少的一般形式非常相似：</span> </p> 
      <pre>  <span><code> &lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, ? super T&gt; accumulator, BiConsumer&lt;R, R&gt; combiner); </code></span> </pre> 
      <p> <span>与<code>reduce()</code> ，以这种抽象方式表达<code>collect</code>的好处是它直接适用于并行化：我们可以并行累积部分结果然后将它们组合，只要累积和组合函数满足适当的要求即可。</span> <span>例如，要将流中元素的String表示形式收集到<code>ArrayList</code> ，我们可以为每个表单编写明显的顺序：</span> </p> 
      <pre>  <span><code> ArrayList&lt;String&gt; strings = new ArrayList&lt;&gt;(); for (T element : stream) { strings.add(element.toString()); } </code></span> </pre> 
      <span>或者我们可以使用可并行化的收集表单：</span> 
      <pre>  <span><code> ArrayList&lt;String&gt; strings = stream.collect(() -&gt; new ArrayList&lt;&gt;(), (c, e) -&gt; c.add(e.toString()), (c1, c2) -&gt; c1.addAll(c2)); </code></span> </pre> 
      <span>或者，将映射操作从累加器函数中拉出来，我们可以更简洁地表达它：</span> 
      <pre>  <span><code> List&lt;String&gt; strings = stream.map(Object::toString) .collect(ArrayList::new, ArrayList::add, ArrayList::addAll); </code></span> </pre> 
      <span>在这里，我们的供应商只是<a href="../ArrayList.html#%3Cinit%3E()"><code>ArrayList constructor</code></a> ，累加器将字符串化元素添加到<code>ArrayList</code> ，组合器只使用<a href="../ArrayList.html#addAll(java.util.Collection)"><code>addAll</code></a>将字符串从一个容器复制到另一个容器。</span> 
      <p> <span><code>collect</code>的三个方面 - 供应商，累加器和组合器 - 紧密耦合。</span> <span>我们可以使用<a href="Collector.html" title="java.util.stream中的接口"><code>Collector</code></a>的抽象来捕获所有这三个方面。</span> <span>以上用于将字符串收集到<code>List</code>可以使用标准<code>Collector</code>重写为：</span> </p> 
      <pre>  <span><code> List&lt;String&gt; strings = stream.map(Object::toString) .collect(Collectors.toList()); </code></span> </pre> 
      <p> <span>将可变缩减打包到收集器中具有另一个优点：可组合性。</span> <span>类<a href="Collectors.html" title="java.util.stream中的类"><code>Collectors</code></a>包含许多用于收集器的预定义工厂，包括将一个收集器转换为另一个收集器的组合器。</span> <span>例如，假设我们有一个收集器来计算员工流的工资总和，如下所示：</span> </p> 
      <pre>  <span><code> Collector&lt;Employee, ?, Integer&gt; summingSalaries = Collectors.summingInt(Employee::getSalary); </code></span> </pre> 
      <span>（第二个类型参数的<code>?</code>仅表示我们不关心此收集器使用的中间表示。）如果我们想创建一个收集器以按部门列出工资总额，我们可以使用<code>summingSalaries</code>重用<a href="Collectors.html#groupingBy(java.util.function.Function,java.util.stream.Collector)">summingSalaries</a> ：</span> 
      <pre>  <span><code> Map&lt;Department, Integer&gt; salariesByDept = employees.stream().collect(Collectors.groupingBy(Employee::getDepartment, summingSalaries)); </code></span> </pre> 
      <p> <span>与常规还原操作一样，如果满足适当的条件，则只能并行化<code>collect()</code>操作。</span> <span>对于任何部分累积的结果，将其与空结果容器组合必须产生等效结果。</span> <span>也就是说，对于部分累积的结果<code>p</code> ，它是任何一系列累加器和组合器调用的结果， <code>p</code>必须等效于<code>combiner.apply(p, supplier.get())</code> 。</span> </p> 
      <p> <span>此外，然而，计算是分开的，它必须产生相同的结果。</span> <span>对于任何输入元素<code>t1</code>和<code>t2</code> ，以下计算中的结果<code>r1</code>和<code>r2</code>必须是等效的：</span> </p> 
      <pre>  <span><code> A a1 = supplier.get(); accumulator.accept(a1, t1); accumulator.accept(a1, t2); R r1 = finisher.apply(a1); // result without splitting A a2 = supplier.get(); accumulator.accept(a2, t1); A a3 = supplier.get(); accumulator.accept(a3, t2); R r2 = finisher.apply(combiner.apply(a2, a3)); // result with splitting </code></span> </pre> 
      <p> <span>这里，等价通常意味着根据<a href="../../lang/Object.html#equals(java.lang.Object)"><code>Object.equals(Object)</code></a> 。</span> <span>但在某些情况下，可以放宽等同性以解释顺序的差异。</span> </p> 
      <h3> <span><a id="ConcurrentReduction">Reduction, concurrency, and ordering</a></span> </h3> 
      <span>对于一些复杂的归约操作，例如<code>collect()</code>产生一个<code>Map</code> ，如：</span> 
      <pre>  <span><code> Map&lt;Buyer, List&lt;Transaction&gt;&gt; salesByBuyer = txns.parallelStream() .collect(Collectors.groupingBy(Transaction::getBuyer)); </code></span> </pre> 
      <span>实际上并行执行操作可能会适得其反。</span> 
      <span>这是因为所述组合步骤（合并一个<code>Map</code>到另一个由键）可以是用于某些昂贵<code>Map</code>实现。</span> 
      <p> <span>但是，假设此减少中使用的结果容器是可同时修改的集合 - 例如<a href="../concurrent/ConcurrentHashMap.html" title="java.util.concurrent中的类"><code>ConcurrentHashMap</code></a> 。</span> <span>在这种情况下，累加器的并行调用实际上可以将它们的结果同时存入同一个共享结果容器中，从而消除了组合器合并不同结果容器的需要。</span> <span>这可能会提升并行执行性能。</span> <span>我们称之为<em>同时</em>减少。</span> </p> 
      <p> <span>甲<a href="Collector.html" title="java.util.stream中的接口"><code>Collector</code></a>支持并发还原标有<a href="Collector.Characteristics.html#CONCURRENT"><code>Collector.Characteristics.CONCURRENT</code></a>特性。</span> <span>但是，并发收集也有缺点。</span> <span>如果多个线程同时将结果存入共享容器，则存储结果的顺序是不确定的。</span> <span>因此，只有在对正在处理的流不重要的情况下，才能实现并发减少。</span> <span><a href="Stream.html#collect(java.util.stream.Collector)"><code>Stream.collect(Collector)</code></a>实现只会执行并发减少</span> </p> 
      <ul> 
       <li> <span>流是平行的;</span> </li> 
       <li> <span>收集器具有<a href="Collector.Characteristics.html#CONCURRENT"><code>Collector.Characteristics.CONCURRENT</code></a>特性，并且;</span> </li> 
       <li> <span>流是无序的，或者收集器具有<a href="Collector.Characteristics.html#UNORDERED"><code>Collector.Characteristics.UNORDERED</code></a>特性。</span> </li> 
      </ul> 
      <span>您可以使用<a href="BaseStream.html#unordered()"><code>BaseStream.unordered()</code></a>方法确保流无序。</span> 
      <span>例如：</span> 
      <pre>  <span><code> Map&lt;Buyer, List&lt;Transaction&gt;&gt; salesByBuyer = txns.parallelStream() .unordered() .collect(groupingByConcurrent(Transaction::getBuyer)); </code></span> </pre> 
      <span>（其中<a href="Collectors.html#groupingByConcurrent(java.util.function.Function)"><code>Collectors.groupingByConcurrent(java.util.function.Function&lt;? super T, ? extends K&gt;)</code></a>是并发等效<code>groupingBy</code> ）。</span> 
      <p> <span>请注意，如果给定键的元素按照它们在源中出现的顺序出现很重要，那么我们就不能使用并发缩减，因为排序是并发插入的牺牲品之一。</span> <span>然后，我们将被限制为实现顺序缩减或基于合并的并行缩减。</span> </p> 
      <h3> <span><a id="Associativity">Associativity</a></span> </h3> 
      <span>如果满足以下<code>op</code>则运算符或函数<code>op</code>是<em>关联</em>的：</span> 
      <pre>  <span><code> (a op b) op c == a op (b op c) </code></span> </pre> 
      <span>如果我们将其扩展为四个术语，可以看出这对并行评估的重要性：</span> 
      <pre>  <span><code> a op b op c op d == (a op b) op (c op d) </code></span> </pre> 
      <span>因此我们可以与<code>(c op d)</code>并行评估<code>(a op b)</code> ，然后在结果上调用<code>op</code> 。</span> 
      <p> <span>关联操作的示例包括数字加法，最小值和最大值以及字符串连接。</span> </p> 
      <h2> <span><a id="StreamSources">Low-level stream construction</a></span> </h2> 
      <span>到目前为止，所有流示例都使用了<a href="../Collection.html#stream()"><code>Collection.stream()</code></a>或<a href="../Arrays.html#stream(T%5B%5D)"><code>Arrays.stream(Object[])</code></a>等方法来获取流。</span> 
      <span>这些流式方法是如何实现的？</span> 
      <p> <span><a href="StreamSupport.html" title="java.util.stream中的类"><code>StreamSupport</code></a>类有许多用于创建流的低级方法，所有这些方法都使用某种形式的<a href="../Spliterator.html" title="java.util中的接口"><code>Spliterator</code></a> 。</span> <span>分裂器是<code>Iterator</code>的并行<a href="../Iterator.html" title="java.util中的接口">模拟器</a> ;</span> <span>它描述了一个（可能是无限的）元素集合，支持顺序前进，批量遍历，并将输入的某些部分分成另一个可以并行处理的分裂器。</span> <span>在最低级别，所有流都由分裂器驱动。</span> </p> 
      <p> <span>在实现spliterator时有许多实现选择，几乎所有这些都是使用该spliterator在实现的简单性和流的运行时性能之间进行权衡。</span> <span>创建spliterator的最简单但性能最差的方法是使用<a href="../Spliterators.html#spliteratorUnknownSize(java.util.Iterator,int)"><code>Spliterators.spliteratorUnknownSize(java.util.Iterator, int)</code></a>从迭代器创建一个。</span> <span>虽然这样的分裂器可以工作，但它可能会提供较差的并行性能，因为我们丢失了大小调整信息（底层数据集有多大），以及被限制为简单的分裂算法。</span> </p> 
      <p> <span>更高质量的分裂器将提供平衡和已知大小的分割，准确的大小调整信息，以及可以由实现用于优化执行的分裂器或数据的许多其他<a href="../Spliterator.html#characteristics()"><code>characteristics</code></a> 。</span> </p> 
      <p> <span>可变数据源的分裂器还有一个挑战;</span> <span>绑定到数据的时间，因为数据可能在创建分裂器的时间和流管道的执行时间之间发生变化。</span> <span>理想情况下，流的分裂器会报告<code>IMMUTABLE</code>或<code>CONCURRENT</code>的特征;</span> <span>如果不是它应该是<a href="../Spliterator.html#binding"><em>late-binding</em></a> 。</span> <span>如果某个来源无法直接提供推荐的分裂器，则可以使用<code>Supplier</code>间接提供分裂器，并通过<code>Supplier</code>接受版本的<a href="StreamSupport.html#stream(java.util.function.Supplier,int,boolean)"><code>stream()</code></a>构建流。</span> <span>仅在流管道的终端操作开始之后才从供应商获得分离器。</span> </p> 
      <p> <span>这些要求显着减少了流源突变和流管道执行之间潜在干扰的范围。</span> <span>基于具有所需特征的分裂器的流或使用基于供应商的工厂形式的流不受在终端操作开始之前对数据源的修改的影响（假设流操作的行为参数满足非操作的要求标准）干涉和无国籍）。</span> <span>有关详细信息，请参阅<a href="package-summary.html#NonInterference">Non-Interference</a> 。</span> </p> 
     </div> 
     <dl> 
      <dt> 
       <span class="simpleTagLabel">从以下版本开始：</span> 
      </dt> 
      <dd>
        1.8 
      </dd> 
     </dl> 
    </section> 
    <ul class="blockList"> 
     <li class="blockList"> 
      <table class="typeSummary"> 
       <caption> 
        <span>接口摘要</span> 
        <span class="tabEnd">&nbsp;</span> 
       </caption> 
       <tbody> 
        <tr> 
         <th class="colFirst" scope="col">接口</th> 
         <th class="colLast" scope="col">描述</th> 
        </tr> 
       </tbody> 
       <tbody> 
        <tr class="altColor"> 
         <th class="colFirst" scope="row"><a href="BaseStream.html" title="interface in java.util.stream">BaseStream</a>&lt;T,​S extends <a href="BaseStream.html" title="interface in java.util.stream">BaseStream</a>&lt;T,​S&gt;&gt;</th> 
         <td class="colLast"> 
          <div class="block">
            流的基本接口，它是支持顺序和并行聚合操作的元素序列。 
          </div> </td> 
        </tr> 
        <tr class="rowColor"> 
         <th class="colFirst" scope="row"><a href="Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,​A,​R&gt;</th> 
         <td class="colLast"> 
          <div class="block"> 
           <a href="package-summary.html#Reduction">mutable reduction operation</a>将输入元素累积到可变结果容器中，可选地在处理完所有输入元素后将累积结果转换为最终表示。 
          </div> </td> 
        </tr> 
        <tr class="altColor"> 
         <th class="colFirst" scope="row"><a href="DoubleStream.html" title="interface in java.util.stream">DoubleStream</a></th> 
         <td class="colLast"> 
          <div class="block">
            一系列原始双值元素，支持顺序和并行聚合操作。 
          </div> </td> 
        </tr> 
        <tr class="rowColor"> 
         <th class="colFirst" scope="row"><a href="DoubleStream.Builder.html" title="interface in java.util.stream">DoubleStream.Builder</a></th> 
         <td class="colLast"> 
          <div class="block"> 
           <code>DoubleStream</code>可变构建器。 
          </div> </td> 
        </tr> 
        <tr class="altColor"> 
         <th class="colFirst" scope="row"><a href="IntStream.html" title="interface in java.util.stream">IntStream</a></th> 
         <td class="colLast"> 
          <div class="block">
            支持顺序和并行聚合操作的一系列原始int值元素。 
          </div> </td> 
        </tr> 
        <tr class="rowColor"> 
         <th class="colFirst" scope="row"><a href="IntStream.Builder.html" title="interface in java.util.stream">IntStream.Builder</a></th> 
         <td class="colLast"> 
          <div class="block"> 
           <code>IntStream</code>可变构建器。 
          </div> </td> 
        </tr> 
        <tr class="altColor"> 
         <th class="colFirst" scope="row"><a href="LongStream.html" title="interface in java.util.stream">LongStream</a></th> 
         <td class="colLast"> 
          <div class="block">
            一系列原始长值元素，支持顺序和并行聚合操作。 
          </div> </td> 
        </tr> 
        <tr class="rowColor"> 
         <th class="colFirst" scope="row"><a href="LongStream.Builder.html" title="interface in java.util.stream">LongStream.Builder</a></th> 
         <td class="colLast"> 
          <div class="block"> 
           <code>LongStream</code>可变构建器。 
          </div> </td> 
        </tr> 
        <tr class="altColor"> 
         <th class="colFirst" scope="row"><a href="Stream.html" title="interface in java.util.stream">Stream</a>&lt;T&gt;</th> 
         <td class="colLast"> 
          <div class="block">
            支持顺序和并行聚合操作的一系列元素。 
          </div> </td> 
        </tr> 
        <tr class="rowColor"> 
         <th class="colFirst" scope="row"><a href="Stream.Builder.html" title="interface in java.util.stream">Stream.Builder</a>&lt;T&gt;</th> 
         <td class="colLast"> 
          <div class="block"> 
           <code>Stream</code>可变构建器。 
          </div> </td> 
        </tr> 
       </tbody> 
      </table> </li> 
     <li class="blockList"> 
      <table class="typeSummary"> 
       <caption> 
        <span>类摘要</span> 
        <span class="tabEnd">&nbsp;</span> 
       </caption> 
       <tbody> 
        <tr> 
         <th class="colFirst" scope="col">类</th> 
         <th class="colLast" scope="col">描述</th> 
        </tr> 
       </tbody> 
       <tbody> 
        <tr class="altColor"> 
         <th class="colFirst" scope="row"><a href="Collectors.html" title="class in java.util.stream">Collectors</a></th> 
         <td class="colLast"> 
          <div class="block"> 
           <span>实现各种有用的约简操作的<a href="Collector.html" title="java.util.stream中的接口"><code>Collector</code>的</a>实现，例如将元素累积到集合中，根据各种标准汇总元素等。</span> 
          </div> </td> 
        </tr> 
        <tr class="rowColor"> 
         <th class="colFirst" scope="row"><a href="StreamSupport.html" title="class in java.util.stream">StreamSupport</a></th> 
         <td class="colLast"> 
          <div class="block">
            用于创建和操作流的低级实用程序方法。 
          </div> </td> 
        </tr> 
       </tbody> 
      </table> </li> 
     <li class="blockList"> 
      <table class="typeSummary"> 
       <caption> 
        <span>枚举摘要</span> 
        <span class="tabEnd">&nbsp;</span> 
       </caption> 
       <tbody> 
        <tr> 
         <th class="colFirst" scope="col">Enum</th> 
         <th class="colLast" scope="col">描述</th> 
        </tr> 
       </tbody> 
       <tbody> 
        <tr class="altColor"> 
         <th class="colFirst" scope="row"><a href="Collector.Characteristics.html" title="enum in java.util.stream">Collector.Characteristics</a></th> 
         <td class="colLast"> 
          <div class="block">
            指示 
           <code>Collector</code>属性的 
           <code>Collector</code> ，可用于优化缩减实现。 
          </div> </td> 
        </tr> 
       </tbody> 
      </table> </li> 
    </ul> 
   </div> 
  </main> 
  <footer role="contentinfo"> 
   <nav role="navigation"> 
    <!-- ======= START OF BOTTOM NAVBAR ====== --> 
    <div class="bottomNav"> 
     <a id="navbar.bottom"> 
      <!--   --> </a> 
     <div class="skipNav"> 
      <a href="#skip.navbar.bottom" title="Skip navigation links">跳过导航</a> 
     </div> 
     <a id="navbar.bottom.firstrow"> 
      <!--   --> </a> 
     <ul class="navList" title="Navigation"> 
      <li><a href="../../../../index.html">概述</a></li> 
      <li><a href="../../../module-summary.html">模块</a></li> 
      <li class="navBarCell1Rev">软件包</li> 
      <li>类</li> 
      <li><a href="package-use.html">使用</a></li> 
      <li><a href="package-tree.html">树</a></li> 
      <li><a href="../../../../deprecated-list.html">已过时的</a></li> 
      <li><a href="../../../../index-files/index-1.html">索引</a></li> 
      <li><a href="../../../../help-doc.html">帮助</a></li> 
     </ul> 
     <div class="aboutLanguage"> 
      <div style="margin-top: 14px;"> 
       <strong>Java SE 11 &amp; JDK 11</strong> 
      </div> 
     </div> 
    </div> 
    <div class="subNav"> 
     <ul class="navList" id="allclasses_navbar_bottom"> 
      <li><a href="../../../../allclasses.html">所有类</a></li> 
     </ul> 
     <div> 
      <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
      <noscript> 
       <div>
         JavaScript is disabled on your browser. 
       </div> 
      </noscript> 
     </div> 
     <a id="skip.navbar.bottom"> 
      <!--   --> </a> 
    </div> 
    <!-- ======== END OF BOTTOM NAVBAR ======= --> 
   </nav> 
   <p class="legalCopy"><small><a href="http://bugreport.java.com/bugreport/">Report a bug or suggest an enhancement</a><br> For further API reference and developer documentation see the <a href="http://www.oracle.com/pls/topic/lookup?ctx=javase11.0.1&amp;id=homepage" target="_blank">Java SE Documentation</a>, which contains more detailed, developer-targeted descriptions with conceptual overviews, definitions of terms, workarounds, and working code examples.<br> Java is a trademark or registered trademark of Oracle and/or its affiliates in the US and other countries.<br> <a href="../../../../../legal/copyright.html">Copyright</a> © 1993, 2018, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.<br>All rights reserved. Use is subject to <a href="http://www.oracle.com/technetwork/java/javase/terms/license/java11.0.1speclicense.html">license terms</a> and the <a href="http://www.oracle.com/technetwork/java/redist-137594.html">documentation redistribution policy</a>. 
     <!-- Version 11.0.1+13-LTS --></small></p> 
  </footer>  
 </body>
</html>