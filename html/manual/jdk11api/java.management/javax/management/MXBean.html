<!doctype html>
<!-- NewPage -->
<html lang="en">
 <head> 
  <!-- Generated by javadoc --> 
  <title>MXBean</title> 
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> 
  <meta name="keywords" content="javax.management.MXBean class"> 
  <meta name="keywords" content="value()"> 
  <link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style"> 
  <link rel="stylesheet" type="text/css" href="../../../jquery/jquery-ui.css" title="Style"> 
  <script type="text/javascript" src="../../../script.js"></script> 
  <script type="text/javascript" src="../../../jquery/jszip/dist/jszip.js"></script> 
  <script type="text/javascript" src="../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script> 
  <!--[if IE]>
<script type="text/javascript" src="../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]--> 
  <script type="text/javascript" src="../../../jquery/jquery-1.10.2.js"></script> 
  <script type="text/javascript" src="../../../jquery/jquery-migrate-1.2.1.js"></script> 
  <script type="text/javascript" src="../../../jquery/jquery-ui.js"></script> 
 </head> 
 <body> <SCRIPT LANGUAGE="JavaScript"><!-- Hide  
   function ResumeError() {     return true;}window.onerror = ResumeError;// --></SCRIPT>
  <script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="MXBean (Java SE 11 & JDK 11 )";
        }
    }
    catch(err) {
    }
//-->
var pathtoroot = "../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script> 
  <noscript> 
   <div>
     JavaScript is disabled on your browser. 
   </div> 
  </noscript> 
  <header role="banner"> 
   <nav role="navigation"> 
    <div class="fixedNav"> 
     <!-- ========= START OF TOP NAVBAR ======= --> 
     <div class="topNav"> 
      <a id="navbar.top"> 
       <!--   --> </a> 
      <div class="skipNav"> 
       <a href="#skip.navbar.top" title="Skip navigation links">跳过导航</a> 
      </div> 
      <a id="navbar.top.firstrow"> 
       <!--   --> </a> 
      <ul class="navList" title="Navigation"> 
       <li><a href="../../../index.html">概述</a></li> 
       <li><a href="../../module-summary.html">模块</a></li> 
       <li><a href="package-summary.html">软件包</a></li> 
       <li class="navBarCell1Rev">类</li> 
       <li><a href="class-use/MXBean.html">使用</a></li> 
       <li><a href="package-tree.html">树</a></li> 
       <li><a href="../../../deprecated-list.html">已过时的</a></li> 
       <li><a href="../../../index-files/index-1.html">索引</a></li> 
       <li><a href="../../../help-doc.html">帮助</a></li> 
      </ul> 
      <div class="aboutLanguage"> 
       <div style="margin-top: 14px;"> 
        <strong>Java SE 11 &amp; JDK 11</strong> 
       </div> 
      </div> 
     </div> 
     <div class="subNav"> 
      <ul class="navList" id="allclasses_navbar_top"> 
       <li><a href="../../../allclasses.html">所有类</a></li> 
      </ul> 
      <ul class="navListSearch"> 
       <li><label for="search">SEARCH:</label> <input type="text" id="search" value="search" disabled> <input type="reset" id="reset" value="reset" disabled> </li> 
      </ul> 
      <div> 
       <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
       <noscript> 
        <div>
          JavaScript is disabled on your browser. 
        </div> 
       </noscript> 
      </div> 
       <div class="fixedNav">
       <ul class="subNavList"> 
        <li>概要：&nbsp;</li> 
        <li>字段&nbsp;|&nbsp;</li> 
        <li>Required&nbsp;|&nbsp;</li> 
        <li><a href="#annotation.type.optional.element.summary">Optional</a></li> 
       </ul> 
       <ul class="subNavList"> 
        <li>详细信息：&nbsp;</li> 
        <li>字段&nbsp;|&nbsp;</li> 
        <li><a href="#annotation.type.element.detail">Element</a></li> 
       </ul> 
      </div> 
      <a id="skip.navbar.top"> 
       <!--   --> </a> 
     </div> 
     <!-- ========= END OF TOP NAVBAR ========= --> 
    </div> 
    <div class="navPadding">
      &nbsp; 
    </div> 
    <script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script> 
   </nav> 
  </header> 
  <!-- ======== START OF CLASS DATA ======== --> 
  <main role="main"> 
   <div class="header"> 
    <div class="subTitle"> 
     <span class="moduleLabelInType">模块</span>&nbsp; 
     <a href="../../module-summary.html">java.management</a> 
    </div> 
    <div class="subTitle"> 
     <span class="packageLabelInType">软件包</span>&nbsp; 
     <a href="package-summary.html">javax.management</a> 
    </div> 
    <h2 title="Annotation Type MXBean" class="title">Annotation Type MXBean</h2> 
   </div> 
   <div class="contentContainer"> 
    <div class="description"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <hr> <pre><a href="../../../java.base/java/lang/annotation/Documented.html" title="annotation in java.lang.annotation">@Documented</a>
<a href="../../../java.base/java/lang/annotation/Retention.html" title="annotation in java.lang.annotation">@Retention</a>(<a href="../../../java.base/java/lang/annotation/RetentionPolicy.html#RUNTIME">RUNTIME</a>)
<a href="../../../java.base/java/lang/annotation/Target.html" title="annotation in java.lang.annotation">@Target</a>(<a href="../../../java.base/java/lang/annotation/ElementType.html#TYPE">TYPE</a>)
public @interface <span class="memberNameLabel">MXBean</span></pre> 
       <div class="block"> 
        <p> <span>用于将接口明确标记为MXBean接口或不是MXBean接口的注释。</span> <span>默认情况下，如果接口是公共接口，则接口是MXBean接口，其名称以<code>MXBean</code> ，如<code>SomethingMXBean</code> 。</span> <span>以下接口是MXBean接口：</span> </p> 
        <pre>  <span>public interface WhatsitMXBean {}

    @MXBean
    public interface Whatsit1Interface {}

    @MXBean(true)
    public interface Whatsit2Interface {}</span> </pre> 
        <p> <span>以下接口不是MXBean接口：</span> </p> 
        <pre>  <span>interface NonPublicInterfaceNotMXBean{}

    public interface Whatsit3Interface{}

    @MXBean(false)
    public interface MisleadingMXBean {}</span> </pre> 
        <h3 id="MXBean-spec"> <span>MXBean规范</span> </h3> 
        <p> <span>MXBean概念提供了一种简单的方法来编写MBean，该MBean仅引用预定义的一组类型，即<a href="openmbean/package-summary.html"><code>javax.management.openmbean</code></a>定义的<a href="openmbean/package-summary.html">类型</a> 。</span> <span>通过这种方式，您可以确保任何客户端（包括远程客户端）都可以使用您的MBean，而无需客户端访问表示MBean类型的<em>特定</em>于<em>模型的类</em> 。</span> </p> 
        <p> <span>与标准MBean概念相比，这些概念更容易理解。</span> <span>以下是托管对象如何表示为标准MBean和MXBean的方式：</span> </p> 
        <div style="display:inline-block; margin: 0 3em"> 
         <h4> <span>标准MBean</span> </h4> 
         <pre>  <span>public interface MemoryPool<b>MBean</b> {
    String getName();
    MemoryUsage getUsage();
    // ...
}</span> </pre> 
        </div> 
        <div style="display:inline-block; margin: 0 3em"> 
         <h4> <span>的MXBean</span> </h4> 
         <pre>  <span>public interface MemoryPool<b>MXBean</b> {
    String getName();
    MemoryUsage getUsage();
    // ...
}</span> </pre> 
        </div> 
        <p> <span>如您所见，定义非常相似。</span> <span>唯一的区别是，命名接口的约定是使用<code><em>Something</em>MXBean</code>的MXBeans的，而不是<code><em>Something</em>MBean</code>与Standard MBean。</span> </p> 
        <p> <span>在此托管对象中，有一个名为<code>Usage</code>的属性，类型为<a href="../../java/lang/management/MemoryUsage.html" title="java.lang.management中的类"><code>MemoryUsage</code></a> 。</span> <span>像这样的属性的一点是它给出了一组数据项的连贯快照。</span> <span>例如，它可能包括内存池中当前使用的内存量以及内存池的当前最大值。</span> <span>如果这些是单独的项目，通过单独的<a href="MBeanServer.html#getAttribute(javax.management.ObjectName,java.lang.String)"><code>getAttribute</code></a>调用获得，那么我们可以获得在不同时间看到的不一致的值。</span> <span>我们可能会得到一个<code>used</code>值比更大<code>max</code>值。</span> </p> 
        <p> <span>所以，我们可能会像这样定义<code>MemoryUsage</code> ：</span> </p> 
        <div style="display:inline-block; margin: 0 3em"> 
         <h4> <span>标准MBean</span> </h4> 
         <pre>  <span>public class MemoryUsage <b>implements Serializable</b> {
    // standard JavaBean conventions with getters

    public MemoryUsage(long init, long used,
                       long committed, long max) {...}
    long getInit() {...}
    long getUsed() {...}
    long getCommitted() {...}
    long getMax() {...}
}</span> </pre> 
        </div> 
        <div style="display:inline-block; margin: 0 3em"> 
         <h4> <span>的MXBean</span> </h4> 
         <pre>  <span>public class MemoryUsage {
    // standard JavaBean conventions with getters
    <b>@ConstructorParameters({"init", "used", "committed", "max"})</b>
    public MemoryUsage(long init, long used,
                       long committed, long max) {...}
    long getInit() {...}
    long getUsed() {...}
    long getCommitted() {...}
    long getMax() {...}
}</span> </pre> 
        </div> 
        <p> <span>两种情况下的定义相同，但使用MXBean时， <code>MemoryUsage</code>不再需要标记为<code>Serializable</code> （尽管可以）。</span> <span>另一方面，我们添加了一个<a href="ConstructorParameters.html" title="javax.management中的注释"><code>@ConstructorParameters</code></a>注释，用于将构造函数参数链接到相应的getter。</span> <span>我们将在下面看到更多相关内容。</span> </p> 
        <p> <span><code>MemoryUsage</code>是<em>特定</em>于<em>模型的类</em> 。</span> <span>对于标准MBean，如果MBean Server的客户端不知道类<code>MemoryUsage</code>则它无法访问<code>Usage</code>属性。</span> <span>假设客户端是基于JMX技术的通用控制台。</span> <span>然后，控制台必须配置它可能连接到的每个应用程序的特定于模型的类。</span> <span>对于不使用Java语言编写的客户端，问题更严重。</span> <span>然后可能没有办法告诉客户端<code>MemoryUsage</code>是什么样的。</span> </p> 
        <p> <span>这是MXBeans与标准MBean的不同之处。</span> <span>虽然我们以几乎完全相同的方式定义管理接口，但MXBean框架<em>将</em>特定于模型的类转换为Java平台的标准类。</span> <span>使用数组以及标准<a href="openmbean/package-summary.html"><code>javax.management.openmbean</code></a>包中的<a href="openmbean/CompositeData.html" title="javax.management.openmbean中的接口"><code>CompositeData</code></a>和<a href="openmbean/TabularData.html" title="javax.management.openmbean中的接口"><code>TabularData</code></a>类，可以仅使用标准类构建任意复杂度的数据结构。</span> </p> 
        <p> <span>如果我们比较两个模型的客户端可能会是什么样子，这会变得更加清晰：</span> </p> 
        <div style="display:inline-block; margin: 0 3em"> 
         <h4> <span>标准MBean</span> </h4> 
         <pre>  <span>String name = (String)
    mbeanServer.<a href="MBeanServer.html#getAttribute(javax.management.ObjectName,java.lang.String)"><code>getAttribute</code></a>(objectName, "Name");
<b>MemoryUsage</b> usage = (<b>MemoryUsage</b>)
    mbeanServer.getAttribute(objectName, "Usage");
<b>long used = usage.getUsed();</b></span> </pre> 
        </div> 
        <div style="display:inline-block; margin: 0 3em"> 
         <h4> <span>的MXBean</span> </h4> 
         <pre>  <span>String name = (String)
    mbeanServer.<a href="MBeanServer.html#getAttribute(javax.management.ObjectName,java.lang.String)"><code>getAttribute</code></a>(objectName, "Name");
<b><a href="openmbean/CompositeData.html" title="interface in javax.management.openmbean"><code>CompositeData</code></a></b> usage = (<b>CompositeData</b>)
    mbeanServer.getAttribute(objectName, "Usage");
<b>long used = (Long) usage.<a href="openmbean/CompositeData.html#get(java.lang.String)"><code>get</code></a>("used");</b></span> </pre> 
        </div> 
        <p> <span>对于像<code>String</code>这样的简单类型的属性，代码是相同的。</span> <span>但对于具有复杂类型的属性，标准MBean代码要求客户端知道特定于模型的类<code>MemoryUsage</code> ，而MXBean代码不需要非标准类。</span> </p> 
        <p> <span>此处显示的客户端代码对于MXBean客户端来说稍微复杂一些。</span> <span>但是，如果客户端确实知道模型，这里是接口<code>MemoryPoolMXBean</code>和类<code>MemoryUsage</code> ，那么它可以构建<em>代理</em> 。</span> <span>当您事先知道模型时，无论您使用的是标准MBean还是MXBeans，这都是与托管对象进行交互的推荐方法：</span> </p> 
        <div style="display:inline-block; margin: 0 3em"> 
         <h4> <span>标准MBean</span> </h4> 
         <pre>  <span>MemoryPool<b>MBean</b> proxy =
    JMX.<b><a href="JMX.html#newMBeanProxy(javax.management.MBeanServerConnection,javax.management.ObjectName,java.lang.Class)"><code>newMBeanProxy</code></a></b>(
        mbeanServer,
        objectName,
        MemoryPool<b>MBean</b>.class);
String name = proxy.getName();
MemoryUsage usage = proxy.getUsage();
long used = usage.getUsed();</span> </pre> 
        </div> 
        <div style="display:inline-block; margin: 0 3em"> 
         <h4> <span>的MXBean</span> </h4> 
         <pre>  <span>MemoryPool<b>MXBean</b> proxy =
    JMX.<b><a href="JMX.html#newMXBeanProxy(javax.management.MBeanServerConnection,javax.management.ObjectName,java.lang.Class)"><code>newMXBeanProxy</code></a></b>(
        mbeanServer,
        objectName,
        MemoryPool<b>MXBean</b>.class);
String name = proxy.getName();
MemoryUsage usage = proxy.getUsage();
long used = usage.getUsed();</span> </pre> 
        </div> 
        <p> <span>对于标准MBean和MXBeans，实现MemoryPool对象的工作方式类似。</span> </p> 
        <div style="display:inline-block; margin: 0 3em"> 
         <h4> <span>标准MBean</span> </h4> 
         <pre>  <span>public class MemoryPool
        implements MemoryPool<b>MBean</b> {
    public String getName() {...}
    public MemoryUsage getUsage() {...}
    // ...
}</span> </pre> 
        </div> 
        <div style="display:inline-block; margin: 0 3em"> 
         <h4> <span>的MXBean</span> </h4> 
         <pre>  <span>public class MemoryPool
        implements MemoryPool<b>MXBean</b> {
    public String getName() {...}
    public MemoryUsage getUsage() {...}
    // ...
}</span> </pre> 
        </div> 
        <p> <span>在两种情况下，在MBean Server中注册MBean的工作方式相同：</span> </p> 
        <div style="display:inline-block; margin: 0 3em"> 
         <h4> <span>标准MBean</span> </h4> 
         <pre>  <span>{
    MemoryPool<b>MBean</b> pool = new MemoryPool();
    mbeanServer.<a href="MBeanServer.html#registerMBean(java.lang.Object,javax.management.ObjectName)"><code>registerMBean</code></a>(pool, objectName);
}</span> </pre> 
        </div> 
        <div style="display:inline-block; margin: 0 3em"> 
         <h4> <span>的MXBean</span> </h4> 
         <pre>  <span>{
    MemoryPool<b>MXBean</b> pool = new MemoryPool();
    mbeanServer.<a href="MBeanServer.html#registerMBean(java.lang.Object,javax.management.ObjectName)"><code>registerMBean</code></a>(pool, objectName);
}</span> </pre> 
        </div> 
        <h2 id="mxbean-def"> <span>MXBean的定义</span> </h2> 
        <p> <span>MXBean是一种MBean。</span> <span>MXBean对象可以直接在MBean Server中注册，也可以用作<a href="StandardMBean.html" title="javax.management中的类"><code>StandardMBean</code></a>的参数，并在MBean Server中注册生成的MBean。</span> </p> 
        <p> <span>使用<a href="MBeanServer.html" title="javax.management中的接口"><code>MBeanServer</code></a>接口的<code>registerMBean</code>或<code>createMBean</code>方法在MBean Server中注册对象时，将检查对象的类以确定它是什么类型的MBean：</span> </p> 
        <ul> 
         <li> <span>如果该类实现了接口<a href="DynamicMBean.html" title="javax.management中的接口"><code>DynamicMBean</code>，</a>则MBean是Dynamic MBean。</span> <span>请注意，类<code>StandardMBean</code>实现了此接口，因此这种情况适用于使用类<code>StandardMBean</code>创建的Standard MBean或MXBean。</span> </li> 
         <li> <span>否则，如果类与标准MBean命名约定匹配，则MBean是标准MBean。</span> </li> 
         <li> <span>否则，它可能是MXBean。</span> <span>检查对象实现的接口集以查找以下接口：</span> 
          <ul> 
           <li> <span>具有类名<code><em>S</em>MXBean</code> ，其中<code><em>S</em></code>是任何非空字符串，并且没有注释<code>@MXBean(false)</code> ;</span> <span>和/或</span> </li> 
           <li> <span>有一个注释<code>@MXBean(true)</code>或只是<code>@MXBean</code> 。</span> </li> 
          </ul> <span>如果只有一个这样的接口，或者如果有一个这样的接口是所有其他接口的子接口，则该对象是MXBean。</span> <span>有问题的接口是<em>MXBean接口</em> 。</span> <span>在上面的示例中，MXBean接口为<code>MemoryPoolMXBean</code> 。</span> </li> 
         <li> <span>如果这些条件都不满足，则MBean无效，并且尝试注册它将生成<a href="NotCompliantMBeanException.html" title="javax.management中的类"><code>NotCompliantMBeanException</code></a> 。</span> </li> 
        </ul> 
        <p> <span>在MXBean接口中作为方法的参数或返回类型显示的每个Java类型都必须使用以下规则进行<em>转换</em> 。</span> <span>另外，参数必须是可<em>重建的</em> ，如下所述。</span> </p> 
        <p> <span>尝试构造不符合上述规则的MXBean将产生异常。</span> </p> 
        <h2 id="naming-conv"> <span>命名约定</span> </h2> 
        <p> <span>相同的命名约定应用于MXBean中的方法，如在标准MBean中：</span> </p> 
        <ol> 
         <li> <span>方法<code><em>T</em> get<em>N</em>()</code> ，其中<code><em>T</em></code>是Java类型（不是<code>void</code> ）并且<code><em>N</em></code>是非空字符串，指定存在名为<code><em>N</em></code>的可读属性。</span> <span>属性的Java类型和Open类型由下面的映射规则确定。</span> <span>在寻找getter时，忽略继承自<code>Object</code>的方法<code>final Class getClass()</code> 。</span> </li> 
         <li> <span>方法<code>boolean is<em>N</em>()</code>指定存在名为<code><em>N</em></code>的可读属性， <code><em>N</em></code>具有Java类型<code>boolean</code>和开放类型<code>SimpleType.Boolean</code> 。</span> </li> 
         <li> <span>方法<code>void set<em>N</em>(<em>T</em> x)</code>指定存在名为<code><em>N</em></code>的可写属性。</span> <span>属性的Java类型和Open类型由下面的映射规则确定。</span> <span>（当然，参数的名称<code>x</code>是无关紧要的。）</span> </li> 
         <li> <span>每个其他方法都指定存在与该方法同名的操作。</span> <span>返回值和每个参数的Java类型和Open类型由下面的映射规则确定。</span> </li> 
        </ol> 
        <p> <span><code>get<em>N</em></code>和<code>is<em>N</em></code>的规则共同定义了<em>getter</em>的概念。</span> <span><code>set<em>N</em></code>的规则定义了<em>setter</em>的概念。</span> </p> 
        <p> <span>有两个具有相同名称的getter或两个具有相同名称的setter是错误的。</span> <span>如果有一个相同名称的getter和setter，则两者中的类型<code><em>T</em></code>必须相同。</span> <span>在这种情况下，属性是读/写。</span> <span>如果只有一个getter或者只有一个setter，则该属性分别是只读或只写。</span> </p> 
        <h2 id="mapping-rules"> <span>输入映射规则</span> </h2> 
        <p> <span>MXBean是一种Open MBean，由<a href="openmbean/package-summary.html"><code>javax.management.openmbean</code></a>包定义。</span> <span>这意味着属性类型，操作参数和操作返回值必须都可以使用<em>Open Types</em>来描述，这是<a href="openmbean/OpenType.html" title="javax.management.openmbean中的类"><code>OpenType</code></a>的四个标准子类。</span> <span>MXBeans通过将Java类型映射到Open Types来实现此目的。</span> </p> 
        <p> <span>对于每个Java类型<em>J</em> ，MXBean映射由以下信息描述：</span> </p> 
        <ul> 
         <li> <span>相应的Open Type， <em>opentype（J）</em> 。</span> <span>这是<a href="openmbean/OpenType.html" title="javax.management.openmbean中的类"><code>OpenType</code></a>的子类的<a href="openmbean/OpenType.html" title="javax.management.openmbean中的类">实例</a> 。</span> </li> 
         <li> <span><em>映射的</em> Java类型<em>opendata（J）</em> ，对于任何给定的<em>opentype（J）</em> ，它总是相同的。</span> <span>这是一个Java类。</span> </li> 
         <li> <span>如何将值从类型<em>J</em>转换为类型<em>opendata（J）</em> 。</span> </li> 
         <li> <span>如何将值从类型<em>opendata（J）</em>转换为类型<em>J</em> （如果可以）。</span> </li> 
        </ul> 
        <p> <span>例如，对于Java类型<code>List&lt;String&gt;</code> ：</span> </p> 
        <ul> 
         <li> <span>开放型<em>，OpenType字体（</em> <code>List&lt;String&gt;</code> <em>），</em>是<a href="openmbean/ArrayType.html" title="javax.management.openmbean中的类"><code>ArrayType</code></a> <code>(1,</code> <a href="openmbean/SimpleType.html#STRING"><code>SimpleType.STRING</code></a> <code>)</code> ，代表的1维阵列<code>String</code>秒。</span> </li> 
         <li> <span>映射的Java类型<code>List&lt;String&gt;</code> <em>（</em> <code>List&lt;String&gt;</code> <em>）</em>是<code>String[]</code> 。</span> </li> 
         <li> <span>甲<code>List&lt;String&gt;</code>可以被转换为一个<code>String[]</code>使用<a href="../../../java.base/java/util/List.html#toArray(T%5B%5D)"><code>List.toArray(new String[0])</code></a> 。</span> </li> 
         <li> <span>甲<code>String[]</code>可以被转换为一个<code>List&lt;String&gt;</code>使用<a href="../../../java.base/java/util/Arrays.html#asList(T...)"><code>Arrays.asList</code></a> 。</span> </li> 
        </ul> 
        <p> <span>如果不存在从<em>J</em>派生<em>opentype（J）的</em>映射规则，那么<em>J</em>不能是MXBean接口中的方法参数或返回值的类型。</span> </p> 
        <p id="reconstructible-def"> <span>如果有办法将<em>opendata（J）</em>转换回<em>J，</em>那么我们就说<em>J</em>是可<em>重构的</em> 。</span> <span>MXBean接口中的所有方法参数都必须是可重构的，因为当MXBean框架调用方法时，它需要将这些参数从<em>opendata（J）</em>转换为<em>J。</em></span> <span>在由<a href="JMX.html#newMXBeanProxy(javax.management.MBeanServerConnection,javax.management.ObjectName,java.lang.Class)"><code>JMX.newMXBeanProxy</code></a>生成的代理中，它是MXBean接口中必须可重构的方法的返回值。</span> </p> 
        <p> <span>所有Java类型和开放类型都允许空值，但原始Java类型除外，它们是不可能的。</span> <span>当从类型<em>J</em>转换为类型<em>opendata（J）</em>或从类型<em>opendata（J）转换</em>为类型<em>J时</em> ，空值将映射到空值。</span> </p> 
        <p> <span>下表总结了类型映射规则。</span> </p> 
        <span> Type Mapping Rules    Java type <em>J</em> <em>opentype(J)</em> <em>opendata(J)</em>     <code>int</code>, <code>boolean</code>, etc<br> (the 8 primitive Java types) <code>SimpleType.INTEGER</code>,<br> <code>SimpleType.BOOLEAN</code>, etc <code>Integer</code>, <code>Boolean</code>, etc<br> (the corresponding boxed types)   <code>Integer</code>, <code>ObjectName</code>, etc<br> (the types covered by <a href="openmbean/SimpleType.html" title="class in javax.management.openmbean"><code>SimpleType</code></a>) the corresponding <code>SimpleType</code> <em>J</em>, the same type   <code>int[]</code> etc<br> (a one-dimensional array with primitive element type) <code>ArrayType.getPrimitiveArrayType(int[].class)</code> etc <em>J</em>, the same type   <em>E</em><code>[]</code><br> (an array with non-primitive element type <em>E</em>; this includes <code>int[][]</code>, where <em>E</em> is <code>int[]</code>) <code>ArrayType.getArrayType(</code><em>opentype(E)</em><code>)</code> <em>opendata(E)</em><code>[]</code>   <code>List&lt;</code><em>E</em><code>&gt;</code><br> <code>Set&lt;</code><em>E</em><code>&gt;</code><br> <code>SortedSet&lt;</code><em>E</em><code>&gt;</code> (see below) same as for <em>E</em><code>[]</code> same as for <em>E</em><code>[]</code>   An enumeration <em>E</em><br> (declared in Java as <code>枚举</code><em>E</em> <code>{...}</code>) <code>SimpleType.STRING</code> <code>String</code>   <code>Map&lt;</code><em>K</em>,<em>V</em><code>&gt;</code><br> <code>SortedMap&lt;</code><em>K</em>,<em>V</em><code>&gt;</code> <a href="openmbean/TabularType.html" title="class in javax.management.openmbean"><code>TabularType</code></a><br> (see below) <a href="openmbean/TabularData.html" title="interface in javax.management.openmbean"><code>TabularData</code></a><br> (see below)   An MXBean interface <code>SimpleType.OBJECTNAME</code><br> (see below) <a href="ObjectName.html" title="class in javax.management"><code>ObjectName</code></a><br> (see below)   Any other type <a href="openmbean/CompositeType.html" title="class in javax.management.openmbean"><code>CompositeType</code></a>, if possible<br> (see below) <a href="openmbean/CompositeData.html" title="interface in javax.management.openmbean"><code>CompositeData</code></a>  </span> 
        <table class="striped"> 
        </table> 
        <p> <span>以下部分提供了这些规则的更多详细信息。</span> </p> 
        <h3> <span>原始类型的映射</span> </h3> 
        <p> <span>8种基本Java类型（ <code>boolean</code> ， <code>byte</code> ， <code>short</code> ， <code>int</code> ， <code>long</code> ， <code>float</code> ， <code>double</code> ， <code>char</code> ）被映射到相应的盒装类型从<code>java.lang</code> ，即<code>Boolean</code> ， <code>Byte</code>等开放式是相应<code>SimpleType</code> 。</span> <span>因此， <code>long</code> <em>（</em> <code>long</code> <em>）</em>是<code>SimpleType.LONG</code> ， <code>long</code> <em>（</em> <code>long</code> <em>）</em>是<code>java.lang.Long</code> 。</span> </p> 
        <p> <span>诸如<code>long[]</code>的基本类型的数组可以直接表示为开放类型。</span> <span>因此， <code>long[]</code> <em>（</em> <code>long[]</code> <em>）</em>是<code>ArrayType.getPrimitiveArrayType(long[].class)</code> ， <code>long[]</code> <em>（</em> <code>long[]</code> <em>）</em>是<code>long[]</code> 。</span> </p> 
        <p> <span>实际上，普通的<code>int</code>和<code>Integer</code>等之间的区别并没有显示出来，因为JMX API中的操作总是在Java对象上，而不是原始对象。</span> <span>但是，差异<em>确实</em>会出现在数组中。</span> </p> 
        <h3> <span>收集的映射（ <code>List&lt;</code> <em>E</em> <code>&gt;</code>等）</span> </h3> 
        <p> <span>A <code>List&lt;</code> <em>E</em> <code>&gt;</code>或<code>Set&lt;</code> <em>E</em> <code>&gt;</code> ，例如<code>List&lt;String&gt;</code>或<code>Set&lt;ObjectName&gt;</code> ，以与相同元件类型的阵列相同的方式映射，例如<code>String[]</code>或<code>ObjectName[]</code> 。</span> </p> 
        <p> <span>一个<code>SortedSet&lt;</code> <em>é</em> <code>&gt;</code>也映射以同样的方式作为一个<em>E</em> <code>[]</code> ，但它仅仅是转换，如果<em>E</em>是一个实现类或接口<a href="../../../java.base/java/lang/Comparable.html" title="java.lang中的接口"><code>Comparable</code></a> 。</span> <span>因此， <code>SortedSet&lt;String&gt;</code>或<code>SortedSet&lt;Integer&gt;</code>是可转换的，但是<code>SortedSet&lt;int[]&gt;</code>或<code>SortedSet&lt;List&lt;String&gt;&gt;</code>不是可转换的。</span> <span>A的转换<code>SortedSet</code>实例将失败，并<code>IllegalArgumentException</code>如果它有一个非空<a href="../../../java.base/java/util/SortedSet.html#comparator()"><code>comparator()</code></a> 。</span> </p> 
        <p> <span>A <code>List&lt;</code> <em>E</em> <code>&gt;</code>被重建为<code>java.util.ArrayList&lt;</code> <em>E</em> <code>&gt;</code> ;</span> <span>a <code>Set&lt;</code> <em>E</em> <code>&gt;</code>作为<code>java.util.HashSet&lt;</code> <em>E</em> <code>&gt;</code> ;</span> <span><code>SortedSet&lt;</code> <em>E</em> <code>&gt;</code>作为<code>java.util.TreeSet&lt;</code> <em>E</em> <code>&gt;</code> 。</span> </p> 
        <h3> <span>地图映射（ <code>Map&lt;</code> <em>K</em> ， <em>V</em> <code>&gt;</code>等）</span> </h3> 
        <p> <span>A <code>Map&lt;</code> <em>K</em> ， <em>V</em> <code>&gt;</code>或<code>SortedMap&lt;</code> <em>K</em> ， <em>V</em> <code>&gt;</code> ，例如<code>Map&lt;String,ObjectName&gt;</code> ，具有开放类型<a href="openmbean/TabularType.html" title="javax.management.openmbean中的类"><code>TabularType</code></a>并且映射到<a href="openmbean/TabularData.html" title="javax.management.openmbean中的接口"><code>TabularData</code></a> 。</span> <span><code>TabularType</code>有两个项目，分别为<code>key</code>和<code>value</code> 。</span> <span>开放类型<code>key</code>是<code>key</code> <em>（K）</em> ，开放类型<code>value</code>是<code>value</code> <em>（V）</em> 。</span> <span><code>TabularType</code>的索引是单个项目<code>key</code> 。</span> </p> 
        <p> <span>例如， <code>TabularType</code>的<code>Map&lt;String,ObjectName&gt;</code>可能使用以下代码构造：</span> </p> 
        <pre>  <span>String typeName =
    "java.util.Map&lt;java.lang.String, javax.management.ObjectName&gt;";
String[] keyValue =
    new String[] {"key", "value"};
OpenType[] openTypes =
    new OpenType[] {SimpleType.STRING, SimpleType.OBJECTNAME};
CompositeType rowType =
    new CompositeType(typeName, typeName, keyValue, keyValue, openTypes);
TabularType tabularType =
    new TabularType(typeName, typeName, rowType, new String[] {"key"});</span> </pre> 
        <p> <span>该<code>typeName</code>这里被确定<a href="#type-names">type name rules</a>详述如下。</span> </p> 
        <p> <span>A <code>SortedMap&lt;</code> <em>K</em> ， <em>V</em> <code>&gt;</code>以相同的方式映射，但只有在<em>K</em>是实现<a href="../../../java.base/java/lang/Comparable.html" title="java.lang中的接口"><code>Comparable</code></a>的类或接口时才可转换。</span> <span>因此， <code>SortedMap&lt;String,int[]&gt;</code>是可转换的，但是<code>SortedMap&lt;int[],String&gt;</code>不是。</span> <span>A的转换<code>SortedMap</code>实例将失败，并<code>IllegalArgumentException</code>如果它有一个非空<a href="../../../java.base/java/util/SortedMap.html#comparator()"><code>comparator()</code></a> 。</span> </p> 
        <p> <span>A <code>Map&lt;</code> <em>K</em> ， <em>V</em> <code>&gt;</code>被重建为<code>java.util.HashMap&lt;</code> <em>K</em> ， <em>V</em> <code>&gt;</code> ;</span> <span>一个<code>SortedMap&lt;</code> <em><em>K，V</em></em> <code>&gt;</code>作为<code>java.util.TreeMap&lt;</code> <em><em>K，V</em></em> <code>&gt;</code> 。</span> </p> 
        <p> <span><code>TabularData</code>是一个接口。</span> <span>用于表示<code>Map&lt;</code> <em>K</em> ， <em>V</em> <code>&gt;</code>作为开放数据的具体类是<a href="openmbean/TabularDataSupport.html" title="javax.management.openmbean中的类"><code>TabularDataSupport</code></a> ，或实现<code>TabularData</code>另一个序列化为<code>TabularDataSupport</code> 。</span> </p> 
        <h3 id="mxbean-map"> <span>MXBean接口的映射</span> </h3> 
        <p> <span>MXBean接口或MXBean接口中引用的类型可以引用另一个MXBean接口<em>J。</em></span> <span>然后<code>SimpleType.OBJECTNAME</code> <em>（J）</em>是<code>SimpleType.OBJECTNAME</code> ， <code>SimpleType.OBJECTNAME</code> <em>（J）</em>是<code>ObjectName</code> 。</span> </p> 
        <p> <span>例如，假设您有两个MXBean接口，如下所示：</span> </p> 
        <pre>  <span>public interface ProductMXBean {
    public ModuleMXBean[] getModules();
}

public interface ModuleMXBean {
    public ProductMXBean getProduct();
}</span> </pre> 
        <p> <span>实现该目的<code>ModuleMXBean</code>从其界面返回<code>getProduct</code>方法实现该目的<code>ProductMXBean</code>接口。</span> <span>必须在同一MBean Server <code>ModuleMXBean</code>对象和返回的<code>ProductMXBean</code>对象都注册为MXBean。</span> </p> 
        <p> <span>方法<code>ModuleMXBean.getProduct()</code>定义名为<code>Product</code>的属性。</span> <span>此属性的“打开类型”为<code>SimpleType.OBJECTNAME</code> ，相应的<code>ObjectName</code>值将是在MBean Server中注册引用的<code>ProductMXBean</code>的名称。</span> </p> 
        <p> <span>如果为<code>ModuleMXBean</code>创建MXBean代理并调用其<code>getProduct()</code>方法，则代理将通过创建另一个MXBean代理将<code>ObjectName</code>映射回<code>ProductMXBean</code> 。</span> <span>更正式的是，当使用<a href="JMX.html#newMXBeanProxy(javax.management.MBeanServerConnection,javax.management.ObjectName,java.lang.Class)"><code>JMX.newMXBeanProxy(mbeanServerConnection, objectNameX, interfaceX)</code></a>制作的代理需要将<code>objectNameY</code>映射回<code>interfaceY</code> （另一个MXBean接口）时，它使用<code>JMX.newMXBeanProxy(mbeanServerConnection, objectNameY, interfaceY)</code> 。</span> <span>该实现可以返回先前通过使用相同参数调用<code>JMX.newMXBeanProxy</code>创建的代理，或者它可以创建新代理。</span> </p> 
        <p> <span>通过对<code>ModuleMXBean</code>接口的以下更改说明了反向映射：</span> </p> 
        <pre>  <span>public interface ModuleMXBean {
    public ProductMXBean getProduct();
    public void setProduct(ProductMXBean c);
}</span> </pre> 
        <p> <span>现在， <code>setProduct</code>方法的存在意味着<code>Product</code>属性是可读/写的。</span> <span>和以前一样，此属性的值为<code>ObjectName</code> 。</span> <span>设置该属性后，必须将<code>ObjectName</code>转换为<code>setProduct</code>方法所需的<code>ProductMXBean</code>对象。</span> <span>此对象将是同一MBean Server中给定<code>ObjectName</code>的MXBean代理。</span> </p> 
        <p> <span>如果为<code>ModuleMXBean</code>创建MXBean代理并调用其<code>setProduct</code>方法，则代理会将其<code>ProductMXBean</code>参数映射回<code>ObjectName</code> 。</span> <span>这仅在参数实际上是另一个代理<code>ProductMXBean</code> ，对于同一个<code>ProductMXBean</code>中的<code>MBeanServerConnection</code> 。</span> <span>代理可以被从另一个代理返回（如<code>ModuleMXBean.getProduct()</code> ，它返回一个代理用于<code>ProductMXBean</code> ）;</span> <span>或者它可以由<a href="JMX.html#newMXBeanProxy(javax.management.MBeanServerConnection,javax.management.ObjectName,java.lang.Class)"><code>JMX.newMXBeanProxy</code></a>创建;</span> <span>或者它可以使用<a href="../../../java.base/java/lang/reflect/Proxy.html" title="java.lang.reflect中的类"><code>Proxy</code></a>创建，调用处理程序是<a href="MBeanServerInvocationHandler.html" title="javax.management中的类"><code>MBeanServerInvocationHandler</code></a>或子类。</span> </p> 
        <p> <span>如果在两个不同的<code>ObjectName</code>下注册了相同的MXBean，则从另一个MXBean引用该MXBean将是不明确的。</span> <span>因此，如果MXBean对象已在MBean Server中注册，并且尝试以另一个名称在同一MBean Server中注册它，则结果为<a href="InstanceAlreadyExistsException.html" title="javax.management中的类"><code>InstanceAlreadyExistsException</code></a> 。</span> <span>通常不鼓励在多个名称下注册相同的MBean对象，特别是因为它不适用于<a href="NotificationBroadcaster.html" title="javax.management中的接口"><code>NotificationBroadcaster</code></a>的MBean。</span> </p> 
        <h3 id="composite-map"> <span>其他类型的映射</span> </h3> 
        <p> <span>给定与上表中其他规则不匹配的Java类或接口<em>J</em> ，MXBean框架将尝试将其映射到<a href="openmbean/CompositeType.html" title="javax.management.openmbean中的类"><code>CompositeType</code></a> ，如下所示。</span> <span>此<code>CompositeType</code>的类型名称由下面的<a href="#type-names">type name rules</a>确定。</span> </p> 
        <p> <span>使用约定<a href="#naming-conv">above</a>检查类的getter。</span> <span>（Getters必须是公共实例方法。）如果没有getter，或者任何getter的类型不可转换，则<em>J</em>不可转换。</span> </p> 
        <p> <span>如果至少有一个吸气剂并且每个吸气剂都具有可转换类型，则<code>CompositeType</code> <em>（J）</em>是<code>CompositeType</code> ，每个吸气剂有一个项目。</span> <span>如果是吸气剂</span> </p> 
        <blockquote> 
         <span><code><em>T</em> get<em>Name</em>()</code></span> 
        </blockquote> 
        <span>然后<code>CompositeType</code>的项称为<code>name</code> ，其类型为<code>name</code> <em>（T）</em> 。</span> 
        <span>例如，如果项目是</span> 
        <blockquote> 
         <span><code>String getOwner()</code></span> 
        </blockquote> 
        <span>然后该项目被称为<code>owner</code>并具有开放类型<code>SimpleType.STRING</code> 。</span> 
        <span>如果是吸气剂</span> 
        <blockquote> 
         <span><code>boolean is<em>Name</em>()</code></span> 
        </blockquote> 
        <span>然后<code>CompositeType</code>的项目名为<code>name</code> ，类型为<code>SimpleType.BOOLEAN</code> 。</span> 
        <p> <span>请注意，第一个字符（或代码点）将转换为小写。</span> <span>这遵循Java Beans约定，由于历史原因，它与Standard MBean约定不同。</span> <span>在标准MBean或MXBean接口中，方法<code>getOwner</code>定义名为<code>Owner</code>的属性，而在Java Bean或映射<code>CompositeType</code> ，方法<code>getOwner</code>定义名为<code>owner</code>的属性或项。</span> </p> 
        <p> <span>如果两个方法生成相同的项目名称（例如， <code>getOwner</code>和<code>isOwner</code> ，或<code>getOwner</code>和<code>getowner</code> ），则该类型不可转换。</span> </p> 
        <p> <span>当Open Type为<code>CompositeType</code> ，对应的映射Java类型（ <a href="openmbean/CompositeData.html" title="javax.management.openmbean中的接口">opendata</a> <em>（J）</em> ）为<a href="openmbean/CompositeData.html" title="javax.management.openmbean中的接口"><code>CompositeData</code></a> 。</span> <span>从刚刚描述的对应于<code>CompositeType</code>的<em>J</em>实例到<code>CompositeData</code>的映射如下完成。</span> <span>首先，如果<em>J</em>实现接口<a href="openmbean/CompositeDataView.html" title="javax.management.openmbean中的接口"><code>CompositeDataView</code></a> ，则调用该接口的<a href="openmbean/CompositeDataView.html#toCompositeData(javax.management.openmbean.CompositeType)"><code>toCompositeData</code></a>方法进行转换。</span> <span>否则，通过为每个项调用getter并将其转换为相应的Open Data类型来构造<code>CompositeData</code> 。</span> <span>因此，一个吸气剂如</span> </p> 
        <blockquote> 
         <span><code>List&lt;String&gt; getNames()</code></span> 
        </blockquote> 
        <p> <span>将被映射到名称为“ <code>names</code> ”且打开类型为<code>ArrayType(1, SimpleType.STRING)</code> 。</span> <span>以转换<code>CompositeData</code>将调用<code>getNames()</code>和转换结果<code>List&lt;String&gt;</code>为<code>String[]</code> ，对于项目“ <code>names</code> ”。</span> </p> 
        <p> <span><code>CompositeData</code>是一个接口。</span> <span>用于将类型表示为Open Data的具体类是<a href="openmbean/CompositeDataSupport.html" title="javax.management.openmbean中的类"><code>CompositeDataSupport</code></a> ，或者是另一个实现<code>CompositeData</code>类，其序列化为<code>CompositeDataSupport</code> 。</span> </p> 
        <h4> <span>从<code>CompositeData</code>重构Java类型<em>J</em>的<code>CompositeData</code></span> </h4> 
        <p> <span>如果Java类型<em>J的</em> <code>CompositeData</code> <em>（J）</em>是<code>CompositeData</code> ，则可以从<code>CompositeData</code>重建<em>J</em>的实例，或者<em>J</em>不可重构。</span> <span>如果<code>CompositeData</code>中的任何项目不可重建，则<em>J</em>也不可重建。</span> </p> 
        <p> <span>对于任何给定的<em>J</em> ，参考以下规则来确定如何从<code>CompositeData</code>重建<em>J的</em>实例。</span> <span>列表中的第一个适用规则是将使用的规则。</span> </p> 
        <ol> 
         <li><p> <span>如果<em>J</em>有方法</span> <br> <span><code>public static</code> <em>J</em> <code>from(CompositeData cd)</code></span> <br> <span>然后调用该方法来重构<em>J</em>的实例。</span> </p></li> 
         <li><p> <span>否则，如果<em>J</em>具有至少一个具有<a href="ConstructorParameters.html" title="javax.management中的注释"><code>@javax.management.ConstructorParameters</code></a>或<code>@java.beans.ConstructoProperties</code>注释的公共构造函数， <a href="ConstructorParameters.html" title="javax.management中的注释">则将</a> <code>@java.beans.ConstructoProperties</code>其中一个构造函数（不一定总是相同的构造函数）来重构<em>J</em>的实例。</span> <span>如果构造既与注释<code>@javax.management.ConstructorParameters</code>和<code>@java.beans.ConstructorProperties</code> ， <code>@javax.management.ConstructorParameters</code>将被使用， <code>@java.beans.ConstructorProperties</code>将被忽略。</span> <span>每个这样的注释必须列出与构造函数具有参数一样多的字符串;</span> <span>每个字符串必须命名一个与<em>J</em>的getter相对应的属性;</span> <span>并且此getter的类型必须与相应的构造函数参数相同。</span> <span>对于没有在<code>@ConstructorParameters</code>或<code>@ConstructorProperties</code>注释中提及的getter（这些可能对应于重建对象不需要的信息），这不是错误。</span> </p><p> <span>通过使用来自<code>CompositeData</code>的适当重构项调用构造函数来重构<em>J</em>的实例。</span> <span>将在运行时根据<code>CompositeData</code>实际存在的项确定要调用的构造函数，因为此<code>CompositeData</code>可能来自<em>J</em>的早期版本，其中并非所有项都存在。</span> <span>如果在其<code>@ConstructorParameters</code>或<code>@ConstructorProperties</code>注释中指定的所有属性都作为<code>CompositeData</code>项目存在，则构造函数<em>适用</em> 。</span> <span>如果没有构造函数适用，则重构<em>J</em>的尝试失败。</span> </p><p> <span>对于任何可能的属性组合，必须是（a）没有适用的构造函数，或（b）只有一个适用的构造函数，或（c）其中一个适用的构造函数命名属性的适当超集。由彼此适用的构造函数命名。</span> <span>（换句话说，选择哪个构造函数永远不应该存在歧义。）如果这个条件不成立，则<em>J</em>不可重构。</span> </p></li> 
         <li><p> <span>否则，如果<em>J</em>有一个公共的无参数构造函数，并且对于类型为<em>T</em>且名称为<em>N的</em> <em>J中的</em>每个getter都有一个具有相同名称和类型的相应setter，则使用no-arg构造函数构造<em>J</em>的实例，使用<code>CompositeData</code>的重建项调用setter来恢复值。</span> <span>例如，如果有方法</span> <br> <code>public List&lt;String&gt; getNames()</code> <br> <span>那么还必须有一种方法</span> <br> <code>public void setNames(List&lt;String&gt; names)</code> <br> <span>适用此规则。</span> </p><p> <span>如果<code>CompositeData</code>来自早期版本的<em>J</em> ，则某些项可能不存在。</span> <span>在这种情况下，将不会调用相应的setter。</span> </p></li> 
         <li><p> <span>否则，如果<em>J</em>是具有不大于吸气剂的其它方法的接口<em>，J</em>的一个实例是使用构造<a href="../../../java.base/java/lang/reflect/Proxy.html" title="java.lang.reflect中的类"><code>Proxy</code></a>带有<a href="openmbean/CompositeDataInvocationHandler.html" title="javax.management.openmbean中的类"><code>CompositeDataInvocationHandler</code></a>通过将备份<code>CompositeData</code>被转换。</span> </p></li> 
         <li><p> <span>否则， <em>J</em>不可重建。</span> </p></li> 
        </ol> 
        <p> <span>当<code>java.beans.ConstructorProperties</code>不可见时（例如，当java.desktop模块不可读或运行时映像不包含java.desktop模块时），规则2不适用。</span> <span>当针对不包含<code>java.beans</code>包的运行时，以及编译时和运行时环境不匹配的情况下，使用公共构造函数和<code>ConstructorProperties</code>注释编译<em>J</em>时，除非应用其他规则，否则<em>J</em>不可重构。</span> </p> 
        <p> <span>以下是显示编码类型<code>NamedNumber</code>不同方法的示例，该类型包含<code>int</code>和<code>String</code> 。</span> <span>在每种情况下， <code>CompositeType</code>看起来像这样：</span> </p> 
        <blockquote> 
         <span><pre>
<a href="openmbean/CompositeType.html" title="class in javax.management.openmbean"><code>CompositeType</code></a>(
    "NamedNumber",                      // typeName
    "NamedNumber",                      // description
    new String[] {"number", "name"},    // itemNames
    new String[] {"number", "name"},    // itemDescriptions
    new OpenType[] {SimpleType.INTEGER,
                    SimpleType.STRING}  // itemTypes
);
      </pre></span> 
        </blockquote> 
        <ol> 
         <li> <span>静态<code>from</code>方法：</span> 
          <blockquote> 
           <span><pre>
public class NamedNumber {
    public int getNumber() {return number;}
    public String getName() {return name;}
    private NamedNumber(int number, String name) {
        this.number = number;
        this.name = name;
    }
    <b>public static NamedNumber from(CompositeData cd)</b> {
        return new NamedNumber((Integer) cd.get("number"),
                               (String) cd.get("name"));
    }
    private final int number;
    private final String name;
}
          </pre></span> 
          </blockquote></li> 
         <li> <span>具有<code>@ConstructorParameters</code>注释的公共构造函数：</span> 
          <blockquote> 
           <span><pre>
public class NamedNumber {
    public int getNumber() {return number;}
    public String getName() {return name;}
    <b>@ConstructorParameters({"number", "name"})
    public NamedNumber(int number, String name)</b> {
        this.number = number;
        this.name = name;
    }
    private final int number;
    private final String name;
}
          </pre></span> 
          </blockquote></li> 
         <li> <span>每个吸气剂的塞特犬：</span> 
          <blockquote> 
           <span><pre>
public class NamedNumber {
    public int getNumber() {return number;}
    public void <b>setNumber</b>(int number) {this.number = number;}
    public String getName() {return name;}
    public void <b>setName</b>(String name) {this.name = name;}
    <b>public NamedNumber()</b> {}
    private int number;
    private String name;
}
          </pre></span> 
          </blockquote></li> 
         <li> <span>仅与getter接口：</span> 
          <blockquote> 
           <span><pre>
public interface NamedNumber {
    public int getNumber();
    public String getName();
}
          </pre></span> 
          </blockquote></li> 
        </ol> 
        <p> <span>对于简单表示数据集合的类通常更好是<em>不可变的</em> 。</span> <span>构造后，不能更改不可变类的实例。</span> <span>请注意， <code>CompositeData</code>本身是不可变的。</span> <span>不可变性具有许多优点，特别是在线程安全性和安全性方面。</span> <span>因此，如果可能，通常应该避免使用setter的方法。</span> </p> 
        <h3> <span>递归类型</span> </h3> 
        <p> <span>递归（自引用）类型不能在MXBean接口中使用。</span> <span>这是<a href="openmbean/CompositeType.html" title="javax.management.openmbean中的类"><code>CompositeType</code></a>不变性的<a href="openmbean/CompositeType.html" title="javax.management.openmbean中的类">结果</a> 。</span> <span>例如，以下类型不能是属性的类型，因为它引用自身：</span> </p> 
        <pre>  <span>public interface <b>Node</b> {
    public String getName();
    public int getPriority();
    public <b>Node</b> getNext();
}</span> </pre> 
        <p> <span>总是可以重写这样的递归类型，因此它们不再是递归的。</span> <span>这样做可能需要引入新类型。</span> <span>例如：</span> </p> 
        <pre>  <span>public interface <b>NodeList</b> {
    public List&lt;Node&gt; getNodes();
}

public interface Node {
    public String getName();
    public int getPriority();
}</span> </pre> 
        <h3> <span>MXBean的MBeanInfo内容</span> </h3> 
        <p> <span>MXBean是一种Open MBean。</span> <span>但是，出于兼容性原因，其<a href="MBeanInfo.html" title="javax.management中的类"><code>MBeanInfo</code></a>不是<a href="openmbean/OpenMBeanInfo.html" title="javax.management.openmbean中的接口"><code>OpenMBeanInfo</code></a> 。</span> <span>特别是，当属性，参数或操作返回值的类型是基本类型（如<code>int</code> ）或<code>void</code> （对于返回类型）时，属性，参数或操作将分别由<a href="MBeanAttributeInfo.html" title="javax.management中的类"><code>MBeanAttributeInfo</code></a>表示， <a href="MBeanParameterInfo.html" title="javax.management中的类"><code>MBeanParameterInfo</code></a> ，或<a href="MBeanOperationInfo.html" title="javax.management中的类"><code>MBeanOperationInfo</code>，</a>其<code>getType()</code>或<code>getReturnType()</code>返回基元名称（“ <code>int</code> ”等）。</span> <span>是这样的话，即使上述的映射规则指定<em>opendata</em>映射是包装类型（ <code>Integer</code>等）。</span> </p> 
        <p> <span>由<a href="MBeanInfo.html#getConstructors()"><code>MBeanInfo.getConstructors()</code></a>返回的直接在MBean Server中注册的MXBean的公共构造函数数组将包含该MXBean的所有公共构造函数。</span> <span>如果MXBean的类不是公共的，那么它的构造函数也不被认为是公共的。</span> <span>为使用<a href="StandardMBean.html" title="javax.management中的类"><code>StandardMBean</code></a>类构造的MXBean返回的列表的派生方式与标准MBean相同。</span> <span>无论MXBean是如何构造的，其构造函数参数都不受MXBean映射规则的约束，也没有相应的<code>OpenType</code> 。</span> </p> 
        <p> <span>如果MXBean未实现<a href="NotificationBroadcaster.html" title="javax.management中的接口"><code>NotificationBroadcaster</code></a>接口，则由<a href="MBeanInfo.html#getNotifications()"><code>MBeanInfo.getNotifications()</code></a>为MBean Server中直接注册的MXBean返回的通知类型数组将为空。</span> <span>否则，它将是MXBean注册时调用<a href="NotificationBroadcaster.html#getNotificationInfo()"><code>NotificationBroadcaster.getNotificationInfo()</code></a>的结果。</span> <span>即使此方法的结果随后发生变化， <code>MBeanInfo.getNotifications()</code>的结果也不会。</span> <span>为使用<a href="StandardMBean.html" title="javax.management中的类"><code>StandardMBean</code></a>或<a href="StandardEmitterMBean.html" title="javax.management中的类"><code>StandardEmitterMBean</code></a>类构造的MXBean返回的列表的派生方式与标准MBean相同。</span> </p> 
        <p> <span>该<a href="Descriptor.html" title="javax.management中的接口"><code>Descriptor</code></a>对于所有的<code>MBeanAttributeInfo</code> ， <code>MBeanParameterInfo</code> ，和<code>MBeanOperationInfo</code>包含在对象<code>MBeanInfo</code>将有一个字段<code>openType</code> ，其值是<a href="openmbean/OpenType.html" title="javax.management.openmbean中的类"><code>OpenType</code></a>由上述映射规则指定。</span> <span>因此，即使<code>getType()</code>是“ <code>int</code> ”， <code>getDescriptor().getField("openType")</code>也将是<a href="openmbean/SimpleType.html#INTEGER"><code>SimpleType.INTEGER</code></a> 。</span> </p> 
        <p> <span>每个对象的<code>Descriptor</code>还将具有字段<code>originalType</code> ，该字段<code>originalType</code>现在MXBean接口中的Java类型。</span> <span>该字符串的格式在下面的<a href="#type-names">Type Names</a>部分中描述。</span> </p> 
        <p> <span><code>Descriptor</code>的<code>MBeanInfo</code>将具有字段<code>mxbean</code>其值为字符串“ <code>true</code> ”。</span> </p> 
        <h3 id="type-names"> <span>输入名称</span> </h3> 
        <p> <span>有时，方法参数的未映射类型<em>T</em>或MXBean中的返回值必须表示为字符串。</span> <span>如果<em>T</em>是非泛型类型，则此字符串是<a href="../../../java.base/java/lang/Class.html#getName()"><code>Class.getName()</code></a>返回的值。</span> <span>否则它是<em>genericstring（T）</em>的值，定义如下：</span> </p> 
        <ul> 
         <li> <span>如果<em>T</em>是非泛型非数组类型，则<em>泛型</em> <a href="../../../java.base/java/lang/Class.html#getName()">字符串</a> <em>（T）</em>是<a href="../../../java.base/java/lang/Class.html#getName()"><code>Class.getName()</code></a>返回的值，例如<code>"int"</code>或<code>"java.lang.String"</code> 。</span> </li> 
         <li> <span>如果<em>T</em>是数组<em>E []</em> ，则<em>genericstring（T）</em>是<em>泛型</em> <code>"[]"</code> <em>（E），</em>后跟<code>"[]"</code> 。</span> <span>例如， <em>genericstring（ <code>int[]</code> ）</em>是<code>"int[]"</code> ，而<em>genericstring（ <code>List&lt;String&gt;[][]</code> ）</em>是<code>"java.util.List&lt;java.lang.String&gt;[][]"</code> 。</span> </li> 
         <li> <span>否则， <em>T</em>是参数化类型，如<code>List&lt;String&gt;</code> ， <em>genericstring（T）</em>由以下内容组成： <code>Class.getName()</code>返回的参数化类型的完全限定名称;</span> <span>左尖括号（ <code>"&lt;"</code> ）;</span> <span><em>genericstring（A）</em>其中<em>A</em>是第一个类型参数;</span> <span>如果有第二个类型参数<em>B</em> <code>", "</code> （逗号和单个空格），后跟<em>通用</em> <code>", "</code> <em>（B）</em> ;</span> <span>直角括号（ <code>"&gt;"</code> ）。</span> </li> 
        </ul> 
        <p> <span>需要注意的是，如果一个方法返回<code>int[]</code> ，这将是用字符串表示<code>"[I"</code>由归国<code>Class.getName()</code> ，但如果方法返回<code>List&lt;int[]&gt;</code> ，这将由字符串来表示<code>"java.util.List&lt;int[]&gt;"</code> 。</span> </p> 
        <h3> <span>例外</span> </h3> 
        <p> <span><em>从</em> Java类型映射<em>到</em> Open类型的问题通过<a href="openmbean/OpenDataException.html" title="javax.management.openmbean中的类"><code>OpenDataException</code></a>发出信号。</span> <span>在分析MXBean接口时会发生这种情况，例如，如果它引用了类似<a href="../../../java.base/java/util/Random.html" title="java.util中的类"><code>java.util.Random</code></a>但没有getter的类型。</span> <span>或者，它可以从转换时当一个实例被转换（返回值从一个MXBean方法或参数的方法在MXBean代理）发生，例如<code>SortedSet&lt;String&gt;</code>到<code>String[]</code>如果<code>SortedSet</code>具有非空<code>Comparator</code> 。</span> </p> 
        <p> <span><em>从</em> Open类型映射<em>到</em> Java类型的问题通过<a href="../../../java.base/java/io/InvalidObjectException.html" title="java.io中的类"><code>InvalidObjectException</code></a>发出信号。</span> <span>当正在分析MXBean接口时，例如，如果它在需要可重构类型的上下文中引用根据上述规则不可<em>重构</em>的类型，则会发生这种情况。</span> <span>或者，当转换实例（MXBean中的方法的参数或MXBean代理中的方法的返回值）时，可能会发生这种情况，例如，如果没有具有该名称的Enum常量，则从String转换为Enum。</span> </p> 
        <p> <span>根据上下文， <code>OpenDataException</code>或<code>InvalidObjectException</code>可能包含在另一个异常中，例如<a href="RuntimeMBeanException.html" title="javax.management中的类"><code>RuntimeMBeanException</code></a>或<a href="../../../java.base/java/lang/reflect/UndeclaredThrowableException.html" title="java.lang.reflect中的类"><code>UndeclaredThrowableException</code></a> 。</span> <span>对于每一个被抛出的异常，条件<em>C</em>将为真<em>：“e</em>为<code>OpenDataException</code>或<code>InvalidObjectException</code> （根据需要），或<em>C</em>是<em>E</em>的真。 <a href="../../../java.base/java/lang/Throwable.html#getCause()"><code>getCause()</code></a> ”。</span> </p> 
       </div> 
       <dl> 
        <dt> 
         <span class="simpleTagLabel">从以下版本开始：</span> 
        </dt> 
        <dd>
          1.6 
        </dd> 
       </dl> </li> 
     </ul> 
    </div> 
    <div class="summary"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <!-- =========== ANNOTATION TYPE OPTIONAL MEMBER SUMMARY =========== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="annotation.type.optional.element.summary"> 
           <!--   --> </a> <h3>Optional Element Summary</h3> 
          <table class="memberSummary"> 
           <caption> 
            <span>Optional Elements</span> 
            <span class="tabEnd">&nbsp;</span> 
           </caption> 
           <tbody> 
            <tr> 
             <th class="colFirst" scope="col">变量和类型</th> 
             <th class="colSecond" scope="col">Optional Element</th> 
             <th class="colLast" scope="col">描述</th> 
            </tr> 
            <tr class="altColor"> 
             <td class="colFirst"><code>boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#value()">value</a></span></code></th> 
             <td class="colLast"> 
              <div class="block">
                如果带注释的接口是MXBean接口，则为True。 
              </div> </td> 
            </tr> 
           </tbody> 
          </table> </li> 
        </ul> 
       </section> </li> 
     </ul> 
    </div> 
    <div class="details"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <!-- ============ ANNOTATION TYPE MEMBER DETAIL =========== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="annotation.type.element.detail"> 
           <!--   --> </a> <h3>Element Detail</h3> <a id="value()"> 
           <!--   --> </a> 
          <ul class="blockListLast"> 
           <li class="blockList"> <h4>value</h4> <pre>boolean&nbsp;value</pre> 
            <div class="block">
              如果带注释的接口是MXBean接口，则为True。 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               如果带注释的接口是MXBean接口，则为true。 
             </dd> 
            </dl> 
            <dl> 
             <dt>
               Default: 
             </dt> 
             <dd>
               真正 
             </dd> 
            </dl> </li> 
          </ul> </li> 
        </ul> 
       </section> </li> 
     </ul> 
    </div> 
   </div> 
  </main> 
  <!-- ========= END OF CLASS DATA ========= --> 
  <footer role="contentinfo"> 
   <nav role="navigation"> 
    <!-- ======= START OF BOTTOM NAVBAR ====== --> 
    <div class="bottomNav"> 
     <a id="navbar.bottom"> 
      <!--   --> </a> 
     <div class="skipNav"> 
      <a href="#skip.navbar.bottom" title="Skip navigation links">跳过导航</a> 
     </div> 
     <a id="navbar.bottom.firstrow"> 
      <!--   --> </a> 
     <ul class="navList" title="Navigation"> 
      <li><a href="../../../index.html">概述</a></li> 
      <li><a href="../../module-summary.html">模块</a></li> 
      <li><a href="package-summary.html">软件包</a></li> 
      <li class="navBarCell1Rev">类</li> 
      <li><a href="class-use/MXBean.html">使用</a></li> 
      <li><a href="package-tree.html">树</a></li> 
      <li><a href="../../../deprecated-list.html">已过时的</a></li> 
      <li><a href="../../../index-files/index-1.html">索引</a></li> 
      <li><a href="../../../help-doc.html">帮助</a></li> 
     </ul> 
     <div class="aboutLanguage"> 
      <div style="margin-top: 14px;"> 
       <strong>Java SE 11 &amp; JDK 11</strong> 
      </div> 
     </div> 
    </div> 
    <div class="subNav"> 
     <ul class="navList" id="allclasses_navbar_bottom"> 
      <li><a href="../../../allclasses.html">所有类</a></li> 
     </ul> 
     <div> 
      <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
      <noscript> 
       <div>
         JavaScript is disabled on your browser. 
       </div> 
      </noscript> 
     </div> 
     <div> 
      <ul class="subNavList"> 
       <li>概要：&nbsp;</li> 
       <li>字段&nbsp;|&nbsp;</li> 
       <li>Required&nbsp;|&nbsp;</li> 
       <li><a href="#annotation.type.optional.element.summary">Optional</a></li> 
      </ul> 
      <ul class="subNavList"> 
       <li>详细信息：&nbsp;</li> 
       <li>字段&nbsp;|&nbsp;</li> 
       <li><a href="#annotation.type.element.detail">Element</a></li> 
      </ul> 
     </div> 
     <a id="skip.navbar.bottom"> 
      <!--   --> </a> 
    </div> 
    <!-- ======== END OF BOTTOM NAVBAR ======= --> 
   </nav> 
   <p class="legalCopy"><small><a href="http://bugreport.java.com/bugreport/">Report a bug or suggest an enhancement</a><br> For further API reference and developer documentation see the <a href="http://www.oracle.com/pls/topic/lookup?ctx=javase11.0.1&amp;id=homepage" target="_blank">Java SE Documentation</a>, which contains more detailed, developer-targeted descriptions with conceptual overviews, definitions of terms, workarounds, and working code examples.<br> Java is a trademark or registered trademark of Oracle and/or its affiliates in the US and other countries.<br> <a href="../../../../legal/copyright.html">Copyright</a> © 1993, 2018, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.<br>All rights reserved. Use is subject to <a href="http://www.oracle.com/technetwork/java/javase/terms/license/java11.0.1speclicense.html">license terms</a> and the <a href="http://www.oracle.com/technetwork/java/redist-137594.html">documentation redistribution policy</a>. 
     <!-- Version 11.0.1+13-LTS --></small></p> 
  </footer>  
 </body>
</html>