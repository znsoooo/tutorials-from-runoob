<!doctype html>
<!-- NewPage -->
<html lang="en">
 <head> 
  <!-- Generated by javadoc --> 
  <title>javax.sql.rowset.spi</title> 
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> 
  <meta name="keywords" content="javax.sql.rowset.spi package"> 
  <link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style"> 
  <link rel="stylesheet" type="text/css" href="../../../../../jquery/jquery-ui.css" title="Style"> 
  <script type="text/javascript" src="../../../../../script.js"></script> 
  <script type="text/javascript" src="../../../../../jquery/jszip/dist/jszip.js"></script> 
  <script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script> 
  <!--[if IE]>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]--> 
  <script type="text/javascript" src="../../../../../jquery/jquery-1.10.2.js"></script> 
  <script type="text/javascript" src="../../../../../jquery/jquery-migrate-1.2.1.js"></script> 
  <script type="text/javascript" src="../../../../../jquery/jquery-ui.js"></script> 
 </head> 
 <body> <SCRIPT LANGUAGE="JavaScript"><!-- Hide  
   function ResumeError() {     return true;}window.onerror = ResumeError;// --></SCRIPT>
  <script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="javax.sql.rowset.spi (Java SE 11 & JDK 11 )";
        }
    }
    catch(err) {
    }
//-->
var pathtoroot = "../../../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script> 
  <noscript> 
   <div>
     JavaScript is disabled on your browser. 
   </div> 
  </noscript> 
  <header role="banner"> 
   <nav role="navigation"> 
    <div class="fixedNav"> 
     <!-- ========= START OF TOP NAVBAR ======= --> 
     <div class="topNav"> 
      <a id="navbar.top"> 
       <!--   --> </a> 
      <div class="skipNav"> 
       <a href="#skip.navbar.top" title="Skip navigation links">跳过导航</a> 
      </div> 
      <a id="navbar.top.firstrow"> 
       <!--   --> </a> 
      <ul class="navList" title="Navigation"> 
       <li><a href="../../../../../index.html">概述</a></li> 
       <li><a href="../../../../module-summary.html">模块</a></li> 
       <li class="navBarCell1Rev">软件包</li> 
       <li>类</li> 
       <li><a href="package-use.html">使用</a></li> 
       <li><a href="package-tree.html">树</a></li> 
       <li><a href="../../../../../deprecated-list.html">已过时的</a></li> 
       <li><a href="../../../../../index-files/index-1.html">索引</a></li> 
       <li><a href="../../../../../help-doc.html">帮助</a></li> 
      </ul> 
      <div class="aboutLanguage"> 
       <div style="margin-top: 14px;"> 
        <strong>Java SE 11 &amp; JDK 11</strong> 
       </div> 
      </div> 
     </div> 
     <div class="subNav"> 
      <ul class="navList" id="allclasses_navbar_top"> 
       <li><a href="../../../../../allclasses.html">所有类</a></li> 
      </ul> 
      <ul class="navListSearch"> 
       <li><label for="search">SEARCH:</label> <input type="text" id="search" value="search" disabled> <input type="reset" id="reset" value="reset" disabled> </li> 
      </ul> 
      <div> 
       <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
       <noscript> 
        <div>
          JavaScript is disabled on your browser. 
        </div> 
       </noscript> 
      </div> 
      <a id="skip.navbar.top"> 
       <!--   --> </a> 
     </div> 
     <!-- ========= END OF TOP NAVBAR ========= --> 
    </div> 
    <div class="navPadding">
      &nbsp; 
    </div> 
    <script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script> 
   </nav> 
  </header> 
  <main role="main"> 
   <div class="header"> 
    <div class="subTitle"> 
     <span class="moduleLabelInPackage">模块</span>&nbsp; 
     <a href="../../../../module-summary.html">java.sql.rowset</a> 
    </div> 
    <h1 title="Package" class="title">Package&nbsp;javax.sql.rowset.spi</h1> 
   </div> 
   <div class="contentContainer"> 
    <section role="region"> 
     <a id="package.description"> 
      <!--   --> </a> 
     <div class="block"> 
      <span>第三方供应商在实现同步提供程序时必须使用的标准类和接口。</span> 
      <span>这些类和接口称为服务提供者接口（SPI）。</span> 
      <span>为了使<code>RowSet</code>对象可以使用实现，供应商必须将其注册到<code>SyncFactory</code>单例。</span> 
      <span>（有关注册过程和要使用的命名约定的完整说明，请参阅<code>SyncProvider</code>的类注释。）</span> 
      <h2> <span>目录</span> </h2> 
      <ul> 
       <li> <span><a href="#pkgspec">1.0 Package Specification</a></span> </li> 
       <li> <span><a href="#arch">2.0 Service Provider Architecture</a></span> </li> 
       <li> <span><a href="#impl">3.0 Implementer's Guide</a></span> </li> 
       <li> <span><a href="#resolving">4.0 Resolving Synchronization Conflicts</a></span> </li> 
       <li> <span><a href="#relspec">5.0 Related Specifications</a></span> </li> 
       <li> <span><a href="#reldocs">6.0 Related Documentation</a></span> </li> 
      </ul> 
      <h3> <span><a id="pkgspec">1.0 Package Specification</a></span> </h3> 
      <p> <span>以下类和接口组成<code>javax.sql.rowset.spi</code>包：</span> </p> 
      <ul> 
       <li> <code>SyncFactory</code> </li> 
       <li> <code>SyncProvider</code> </li> 
       <li> <code>SyncFactoryException</code> </li> 
       <li> <code>SyncProviderException</code> </li> 
       <li> <code>SyncResolver</code> </li> 
       <li> <code>XmlReader</code> </li> 
       <li> <code>XmlWriter</code> </li> 
       <li> <code>TransactionalWriter</code> </li> 
      </ul> 
      <span><code>javax.sql</code>包中的以下接口也是SPI的一部分：</span> 
      <ul> 
       <li> <code>RowSetReader</code> </li> 
       <li> <code>RowSetWriter</code> </li> 
      </ul> 
      <p> <span><code>SyncProvider</code>实现提供了一个断开连接的<code>RowSet</code>对象，该对象具有将数据读入其中以及将已在其中修改的数据写回底层数据源的机制。</span> <span>当<code>CachedRowSet</code>方法<code>execute</code>或<code>populate</code>时，读取<i>器</i> <code>RowSetReader</code>或<code>XMLReader</code>对象将数据读入<code>RowSet</code>对象。</span> <span><i>作家</i> ， <code>RowSetWriter</code>或<code>XMLWriter</code>当对象，写入变回底层数据源<code>CachedRowSet</code>方法<code>acceptChanges</code>被调用。</span> </p> 
      <p> <span>将<code>RowSet</code>对象中的更改写入其数据源的过程称为<i>同步</i> 。</span> <span>所述<code>SyncProvider</code>实现，一个<code>RowSet</code>对象是使用判定同步的水平<code>RowSet</code>对象的作者使用。</span> <span>各种级别的同步称为<i>等级</i> 。</span> </p> 
      <p> <span>较低等级的同步被称为<i>乐观</i>并发级别，因为它们乐观地认为不会发生冲突或冲突很少。</span> <span>当在数据源中修改了<code>RowSet</code>对象中修改的相同数据时，存在冲突。</span> <span>使用乐观并发模型意味着如果存在冲突，将丢失对数据源或<code>RowSet</code>对象的修改。</span> </p> 
      <p> <span>更高级别的同步被称为<i>悲观，</i>因为他们认为其他人将访问数据源并进行修改。</span> <span>这些等级设置不同级别的锁定以增加不发生冲突的机会。</span> </p> 
      <p> <span>最低级别的同步只是将对<code>RowSet</code>对象所做的任何更改写入其基础数据源。</span> <span>作者没有做任何事情来检查冲突。</span> <span>如果存在冲突并且数据源值被覆盖，则其他方对数据源所做的更改将丢失。</span> </p> 
      <p> <span><code>RIXMLProvider</code>实现使用最低级别的同步，只是将<code>RowSet</code>更改写入数据源。</span> </p> 
      <p> <span>对于下一级别，编写器检查是否存在任何冲突，如果存在冲突，则不会向数据源写入任何内容。</span> <span>此并发级别的问题是，如果另一方修改了数据源中的相应数据，因为<code>RowSet</code>对象获取了其数据，则对<code>RowSet</code>对象所做的更改将丢失。</span> <span><code>RIOptimisticProvider</code>实现使用此级别的同步。</span> </p> 
      <p> <span>在更高级别的同步（称为悲观并发）时，编写器通过设置锁来采取措施来避免冲突。</span> <span>设置锁定可以从设置单个行上的锁定到设置表格锁定或整个数据源。</span> <span>因此，同步级别是用户同时访问数据源的能力与写入器保持<code>RowSet</code>对象中的数据及其数据源同步的能力之间的权衡。</span> </p> 
      <p> <span>这是所有断开的要求<code>RowSet</code>对象（ <code>CachedRowSet</code> ， <code>FilteredRowSet</code> ， <code>JoinRowSet</code>和<code>WebRowSet</code>对象）获得其<code>SyncProvider</code>从对象<code>SyncFactory</code>机制。</span> </p> 
      <p> <span>参考实现（RI）提供两个同步提供程序。</span> </p> 
      <ul> 
       <li> <b><code>RIOptimisticProvider</code></b> <br> <span>在未指定提供程序实现时， <code>SyncFactory</code>实例将向断开连接的<code>RowSet</code>对象提供的默认提供程序。</span> <br> <span>此同步提供程序使用乐观并发模型，假设在访问数据库中的相同数据的用户之间几乎没有冲突。</span> <span>它避免使用锁;</span> <span>相反，它会在尝试同步<code>RowSet</code>对象和数据源之前检查是否存在冲突。</span> <span>如果存在冲突，则不执行任何操作，这意味着对<code>RowSet</code>对象的更改不会持久保存到数据源。</span> </li> 
       <li> <b><code>RIXMLProvider</code></b> <br> <span>可与<code>WebRowSet</code>对象一起使用的同步提供程序，该对象是可以XML格式编写或从XML格式读取的行集。</span> <span><code>RIXMLProvider</code>实现根本不检查冲突，只是将<code>WebRowSet</code>对象中的任何更新数据写入基础数据源。</span> <span><code>WebRowSet</code>对象在处理XML数据时使用此提供程序。</span> </li> 
      </ul> 
      <span>这些<code>SyncProvider</code>实现与参考实现捆绑在一起，这使得它们始终可用于<code>RowSet</code>实现。</span> 
      <span><code>SyncProvider</code>实现通过向<code>SyncFactory</code> singleton注册使其可用。</span> 
      <span>当<code>RowSet</code>对象请求提供者时，通过在构造函数中指定它或者作为<code>CachedRowSet</code>方法<code>setSyncProvider</code>的参数， <code>SyncFactory</code>单例检查以查看所请求的提供者是否已向其注册。</span> 
      <span>如果有，则<code>SyncFactory</code>创建它的实例并将其传递给请求的<code>RowSet</code>对象。</span> 
      <span>如果尚未注册指定的<code>SyncProvider</code>实现，则<code>SyncFactory</code>单例将导致抛出<code>SyncFactoryException</code>对象。</span> 
      <span>如果未指定提供程序，则<code>SyncFactory</code>单例将创建默认提供程序实现的实例<code>RIOptimisticProvider</code> ，并将其传递给请求<code>RowSet</code>对象。</span> 
      <p> <span>如果<code>WebRowSet</code>对象没有指定在其构造一个提供者， <code>SyncFactory</code>将给它的一个实例<code>RIOptimisticProvider</code> 。</span> <span>但是，实现了<code>WebRowSet</code>的构造函数以将提供程序设置为<code>RIXMLProvider</code> ，它以XML格式读取和写入<code>RowSet</code>对象。</span> </p> 
      <p> <span>有关更多详细信息，请参阅<a href="SyncProvider.html">SyncProvider</a>类规范。</span> </p> 
      <p> <span>供应商可以使用任何一种可能的同步级别开发<code>SyncProvider</code>实现，从而为<code>RowSet</code>对象提供了同步机制的选择。</span> </p> 
      <h3> <span><a id="arch">2.0 Service Provider Interface Architecture</a></span> </h3> 
      <span><b>2.1概述</b></span> 
      <p> <span>服务提供程序接口提供了一种可插入的机制，通过该机制可以注册<code>SyncProvider</code>实现，然后在需要时生成。</span> <span><code>SyncFactory</code>使用的惰性引用机制通过在断开的<code>RowSet</code>对象需要之前不创建实例<code>SyncFactory</code>限制不必要的资源消耗。</span> <span><code>SyncFactory</code>类还提供了一个标准API，用于配置特定<code>SyncProvider</code>实现<b>可能</b>提供的日志记录选项和流。</span> </p> 
      <p> <span><b>2.2注册<code>SyncFactory</code></b></span> </p> 
      <p> <span>必须向<code>SyncFactory</code>注册第三方<code>SyncProvider</code>实现，以便断开连接的<code>RowSet</code>对象以获取它，从而使用其<code>javax.sql.RowSetReader</code>和<code>javax.sql.RowSetWriter</code>实现。</span> <span>以下注册机制适用于所有<code>SyncProvider</code>实施：</span> </p> 
      <ul> 
       <li> <span><b>系统属性</b> - 在命令行中设置的属性。</span> <span>这些属性在运行时设置，并在每次调用Java应用程序时应用于系统范围。</span> <span>请参阅<a href="#reldocs">"Related Documentation"</a>部分的更多相关信息。</span> </li> 
       <li> <span><b>属性文件</b> - 标准属性文件中指定的属性。</span> <span>这可以使用系统属性或修改位于平台运行时的标准属性文件来指定。</span> <span>此技术的参考实现包括一个标准属性文件，可以编辑以添加其他<code>SyncProvider</code>对象。</span> </li> 
       <li> <span><b>JNDI上下文</b> - 可以在JNDI上下文中注册可用的提供程序。</span> <span><code>SyncFactory</code>将尝试加载绑定到上下文的<code>SyncProvider</code>对象并将其注册到工厂。</span> <span>必须将此上下文提供给<code>SyncFactory</code>才能使机制正常运行。</span> </li> 
      </ul> 
      <p> <span>有关如何在属性文件中指定系统属性或属性以及如何配置JNDI上下文的详细信息，请<a href="SyncFactory.html">参见<code>SyncFactory</code></a>类说明。</span> </p> 
      <p> <span><b>2.3 SyncFactory提供程序实例生成策略</b></span> </p> 
      <p> <span>如果提供程序已正确注册， <code>SyncFactory</code>生成请求的<code>SyncProvider</code>对象。</span> <span>当使用指定的<code>SyncProvider</code>实现实例化断开的<code>RowSet</code>对象或使用备用<code>SyncProvider</code>对象在运行时重新配置时，将遵循以下策略。</span> </p> 
      <ul> 
       <li> <span>如果<code>SyncProvider</code>指定对象和<code>SyncFactory</code> <i>没有</i>提及的供应商， <code>SyncFactoryException</code>异常。</span> </li> 
       <li> <span>如果指定了<code>SyncProvider</code>对象且<code>SyncFactory</code>包含对提供程序的引用，则会提供所请求的提供程序。</span> </li> 
       <li> <span>如果未指定<code>SyncProvider</code>对象，则提供参考实现提供者<code>RIOptimisticProvider</code> 。</span> </li> 
      </ul> 
      <p> <span>这些政策在<a href="SyncFactory.html"><code>SyncFactory</code></a>课程中有更详细的<a href="SyncFactory.html">探讨</a> 。</span> </p> 
      <h3> <span><a id="impl">3.0 SyncProvider Implementer's Guide</a></span> </h3> 
      <span><b>3.1要求</b></span> 
      <p> <span>柔顺<code>SyncProvider</code>实现，它是完全可插入到<code>SyncFactory</code> <b>必须</b>扩展和实施中的所有抽象方法<a href="SyncProvider.html"><code>SyncProvider</code></a>类。</span> <span>此外，实现<b>必须</b>确定<code>SyncProvider</code>类定义中定义的等级，锁定和可更新视图功能。</span> <span><b>必须</b>支持一个或多个<code>SyncProvider</code>描述标准。</span> <span>预计供应商实现将提供一系列等级，锁定和可更新视图功能。</span> </p> 
      <p> <span>此外， <b>必须</b>遵循<code>SyncProvider</code>命名约定，如<a href="SyncProvider.html"><code>SyncProvider</code></a>类描述中所述。</span> </p> 
      <p> <span><b>3.2等级</b></span> </p> 
      <p> <span>JSR 114定义了一组等级来描述<code>SyncProvider</code>对象可以提供断开的<code>RowSet</code>对象的同步质量。</span> <span>这些等级从最低服务质量到最高等级列出。</span> </p> 
      <ul> 
       <li> <span><b>GRADE_NONE</b> - 未提供与原始数据源的同步。</span> <span>返回此等级的<code>SyncProvider</code>实现将只是尝试将<code>RowSet</code>对象中已更改的任何数据写入基础数据源，覆盖其中的任何内容。</span> <span>不会尝试将原始值与当前值进行比较，以查看是否存在冲突。</span> <span><code>RIXMLProvider</code>是用这个等级实现的。</span> </li> 
       <li> <span><b>GRADE_CHECK_MODIFIED_AT_COMMIT</b> - 低级别的乐观同步。</span> <span>返回此等级的<code>SyncProvider</code>实现将检查在上次同步和正在进行的当前同步之间已更改的行中的冲突。</span> <span>已修改的原始数据源中的任何更改都不会反映在已断开连接的<code>RowSet</code>对象中。</span> <span>如果没有冲突， <code>RowSet</code>将<code>RowSet</code>对象中的更改写入数据源。</span> <span>如果存在冲突，则不会写入任何更改。</span> <span><code>RIOptimisticProvider</code>实现使用此等级。</span> </li> 
       <li> <span><b>GRADE_CHECK_ALL_AT_COMMIT</b> - 高级乐观同步。</span> <span>返回此等级的<code>SyncProvider</code>实现将检查所有行，包括在断开连接的<code>RowSet</code>对象中未更改的行。</span> <span>这样，当同步成功完成时，对基础数据源中的行的任何更改都将反映在断开连接的<code>RowSet</code>对象中。</span> </li> 
       <li> <span><b>GRADE_LOCK_WHEN_MODIFIED</b> - 一种悲观的同步等级。</span> <span>返回此等级的<code>SyncProvider</code>实现将锁定原始数据源中与<code>RowSet</code>对象中正在更改的行对应的行，以减少其他进程修改数据源中相同数据的可能性。</span> </li> 
       <li> <span><b>GRADE_LOCK_WHEN_LOADED</b> - 更高的悲观同步等级。</span> <span>返回此等级的<code>SyncProvider</code>实现将锁定受用于填充<code>RowSet</code>对象的原始查询影响的整个视图和/或表。</span> </li> 
      </ul> 
      <p> <span><b>3.3锁</b></span> </p> 
      <p> <span>JSR 114定义了一组常量，这些常量指定是否已将任何锁定放置在<code>RowSet</code>对象的基础数据源上，如果是，则置于锁定放置的构造上。</span> <span>当<code>RowSet</code>对象与数据源断开连接时，这些锁将保留在数据源上。</span> </p> 
      <p> <span><b>应将</b>这些常数视为等级常数的补充。</span> <span>大多数成绩设置的默认设置要求当<code>RowSet</code>对象与其数据源断开连接时，不会保留任何数据源锁。</span> <span>等级<code>GRADE_LOCK_WHEN_MODIFIED</code>和<code>GRADE_LOCK_WHEN_LOADED</code>允许断开连接的<code>RowSet</code>对象对锁定程度进行细粒度控制。</span> </p> 
      <ul> 
       <li> <span><b>DATASOURCE_NO_LOCK</b> - 原始数据源上没有锁定。</span> <span>这是所有<code>SyncProvider</code>实现的默认锁定设置，除非<code>RowSet</code>对象另有指示。</span> </li> 
       <li> <span><b>DATASOURCE_ROW_LOCK</b> - 在用于填充<code>RowSet</code>对象的原始SQL查询所触及的行上放置一个锁。</span> </li> 
       <li> <span><b>DATASOURCE_TABLE_LOCK</b> - 锁定放置在用于填充<code>RowSet</code>对象的查询所触及的所有表上。</span> </li> 
       <li> <span><b>DATASOURCE_DB_LOCK</b>锁定放置在<code>RowSet</code>对象使用的整个数据源上。</span> </li> 
      </ul> 
      <p> <span><b>3.4可更新视图</b></span> </p> 
      <p> <span>可以使用来自SQL <code>VIEW</code>数据填充<code>RowSet</code>对象。</span> <span>以下常量指示<code>SyncProvider</code>对象是否可以更新<code>VIEW</code>派生<code>VIEW</code>的表中的数据。</span> </p> 
      <ul> 
       <li> <span><b>UPDATABLE_VIEW_SYNC</b>指示<code>SyncProvider</code>实现支持与用于填充<code>RowSet</code>对象的SQL <code>VIEW</code>派生的表或表的同步。</span> </li> 
       <li> <span><b>NONUPDATABLE_VIEW_SYNC</b>表示一个<code>SyncProvider</code>实现<b>不</b>支持同步从该SQL表或表<code>VIEW</code>用于填充<code>RowSet</code>对象导出。</span> </li> 
      </ul> 
      <p> <span><b>3.5 <code>SyncProvider</code>评分和锁定的用法</b></span> </p> 
      <p> <span>在下面的示例中，引用<code>CachedRowSetImpl</code>实现通过调用<code>setSyncProvider</code>方法重新配置其当前的<code>SyncProvider</code>对象。</span> <br></p> 
      <pre>  <span>CachedRowSetImpl crs = new CachedRowSetImpl();
   crs.setSyncProvider("com.foo.bar.HASyncProvider");</span> </pre> 
      <span>应用程序可以检索<code>SyncProvider</code>由断开当前对象使用<code>RowSet</code>对象。</span> 
      <span>它还可以检索实现提供程序的同步等级以及当前使用的锁定程度。</span> 
      <span>此外，应用程序可以灵活地设置要使用的锁定程度，这可以增加成功同步的可能性。</span> 
      <span>这些操作显示在以下代码片段中。</span> 
      <pre>  <span>SyncProvider sync = crs.getSyncProvider();

   switch (sync.getProviderGrade()) {
   case: SyncProvider.GRADE_CHECK_ALL_AT_COMMIT
         //A high grade of optimistic synchronization
    break;
    case: SyncProvider.GRADE_CHECK_MODIFIED_AT_COMMIT
         //A low grade of optimistic synchronization
    break;
    case: SyncProvider.GRADE_LOCK_WHEN_LOADED
         // A pessimistic synchronization grade
    break;
    case: SyncProvider.GRADE_LOCK_WHEN_MODIFIED
         // A pessimistic synchronization grade
    break;
    case: SyncProvider.GRADE_NONE
      // No synchronization with the originating data source provided
    break;
    }

    switch (sync.getDataSourcLock() {
      case: SyncProvider.DATASOURCE_DB_LOCK
       // A lock is placed on the entire datasource that is used by the
       // <code>RowSet</code> object
       break;

      case: SyncProvider.DATASOURCE_NO_LOCK
       // No locks remain on the  originating data source.
      break;

      case: SyncProvider.DATASOURCE_ROW_LOCK
       // A lock is placed on the rows that are  touched by the original
       // SQL statement used to populate
       // the RowSet object that is using the SyncProvider
       break;

      case: DATASOURCE_TABLE_LOCK
       // A lock is placed on  all tables that are touched by the original
       // SQL statement used to populated
       // the RowSet object that is using the SyncProvider
      break;</span> </pre> 
      <span>也可以使用<code>SyncFactory</code>类中的静态实用程序方法来确定当前在<code>SyncFactory</code>注册的<code>SyncProvider</code>实现的列表。</span> 
      <pre>  <span>Enumeration e = SyncFactory.getRegisteredProviders();</span> </pre> 
      <h3> <span><a id="resolving">4.0 Resolving Synchronization Conflicts</a></span> </h3> 
      <span>界面<code>SyncResolver</code>提供了一种应用程序在发生冲突时手动决定要做什么的方式。</span> 
      <span>当<code>CachedRowSet</code>方法<code>acceptChanges</code>完成并检测到一个或多个冲突时，它会抛出<code>SyncProviderException</code>对象。</span> 
      <span>应用程序可以捕获异常并通过调用方法<code>SyncProviderException.getSyncResolver()</code>检索<code>SyncResolver</code>对象。</span> 
      <p> <span><code>SyncResolver</code>对象是一种特殊的<code>CachedRowSet</code>对象或实现了<code>SyncResolver</code>接口的<code>JdbcRowSet</code>对象，它<code>SyncResolver</code>检查冲突。</span> <span>它是正在同步的<code>RowSet</code>对象的副本，除了它只包含来自数据源的数据，这会导致冲突。</span> <span>所有其他列值都设置为<code>null</code> 。</span> <span>为了从一个冲突值导航到另一个冲突值， <code>SyncResolver</code>对象提供方法<code>nextConflict</code>和<code>previousConflict</code> 。</span> </p> 
      <p> <span><code>SyncResolver</code>接口还提供了执行以下操作的方法：</span> </p> 
      <ul> 
       <li> <span>找出冲突是否涉及更新，删除或插入</span> </li> 
       <li> <span>获取导致冲突的数据源中的值</span> </li> 
       <li> <span>设置应该在数据源中的值（如果需要更改）或设置应该在<code>RowSet</code>对象中的值（如果需要更改）</span> </li> 
      </ul> 
      <p> <span>当调用<code>CachedRowSet</code>方法<code>acceptChanges</code> ，它委托给<code>RowSet</code>对象的<code>SyncProvider</code>对象。</span> <span>如何实现该<code>SyncProvider</code>对象提供的作者确定将对冲突进行检查的级别（等级）。</span> <span>在完成所有冲突检查并且已经找到一个或多个冲突之后，方法<code>acceptChanges</code>抛出<code>SyncProviderException</code>对象。</span> <span>应用程序可以捕获异常并使用它来获取<code>SyncResolver</code>对象。</span> </p> 
      <p> <span>然后，应用程序可以使用<code>SyncResolver</code>方法获取有关每个冲突的信息并决定要执行的操作。</span> <span>如果应用程序逻辑或用户决定<code>RowSet</code>对象中的值应该是持久的值，则应用程序或用户可以使用它覆盖数据源值。</span> </p> 
      <p> <span><code>SyncResolver</code>界面的评论有更多细节。</span> </p> 
      <h3> <span><a id="relspec">5.0 Related Specifications</a></span> </h3> 
      <ul> 
       <li> <span><a href="http://docs.oracle.com/javase/jndi/tutorial/index.html">JNDI</a></span> </li> 
       <li> <span><a href="../../../../../java.logging/java/util/logging/package-summary.html">Java Logging APIs</a></span> </li> 
      </ul> 
      <h3> <span><a id="reldocs">6.0 Related Documentation</a></span> </h3> 
      <ul> 
       <li> <span><a href="http://docs.oracle.com/javase/tutorial/jdbc/">DataSource for JDBC Connections</a></span> </li> 
      </ul> 
     </div> 
    </section> 
    <ul class="blockList"> 
     <li class="blockList"> 
      <table class="typeSummary"> 
       <caption> 
        <span>接口摘要</span> 
        <span class="tabEnd">&nbsp;</span> 
       </caption> 
       <tbody> 
        <tr> 
         <th class="colFirst" scope="col">接口</th> 
         <th class="colLast" scope="col">描述</th> 
        </tr> 
       </tbody> 
       <tbody> 
        <tr class="altColor"> 
         <th class="colFirst" scope="row"><a href="SyncResolver.html" title="interface in javax.sql.rowset.spi">SyncResolver</a></th> 
         <td class="colLast"> 
          <div class="block">
            定义一个框架，允许应用程序使用手动决策树来决定发生同步冲突时应该执行的操作。 
          </div> </td> 
        </tr> 
        <tr class="rowColor"> 
         <th class="colFirst" scope="row"><a href="TransactionalWriter.html" title="interface in javax.sql.rowset.spi">TransactionalWriter</a></th> 
         <td class="colLast"> 
          <div class="block">
            一个专门的接口，有助于扩展标准 
           <code>SyncProvider</code>抽象类，使其具有更细粒度的事务控制。 
          </div> </td> 
        </tr> 
        <tr class="altColor"> 
         <th class="colFirst" scope="row"><a href="XmlReader.html" title="interface in javax.sql.rowset.spi">XmlReader</a></th> 
         <td class="colLast"> 
          <div class="block">
            一个专门的接口，有助于为面向XML的同步提供程序扩展 
           <code>SyncProvider</code>抽象类。 
          </div> </td> 
        </tr> 
        <tr class="rowColor"> 
         <th class="colFirst" scope="row"><a href="XmlWriter.html" title="interface in javax.sql.rowset.spi">XmlWriter</a></th> 
         <td class="colLast"> 
          <div class="block">
            一种专用接口，有助于扩展面向XML的同步提供程序的 
           <code>SyncProvider</code>抽象类。 
          </div> </td> 
        </tr> 
       </tbody> 
      </table> </li> 
     <li class="blockList"> 
      <table class="typeSummary"> 
       <caption> 
        <span>类摘要</span> 
        <span class="tabEnd">&nbsp;</span> 
       </caption> 
       <tbody> 
        <tr> 
         <th class="colFirst" scope="col">类</th> 
         <th class="colLast" scope="col">描述</th> 
        </tr> 
       </tbody> 
       <tbody> 
        <tr class="altColor"> 
         <th class="colFirst" scope="row"><a href="SyncFactory.html" title="class in javax.sql.rowset.spi">SyncFactory</a></th> 
         <td class="colLast"> 
          <div class="block">
            服务提供程序接口（SPI）机制，生成 
           <code>SyncProvider</code>实例，供断开连接的 
           <code>RowSet</code>对象使用。 
          </div> </td> 
        </tr> 
        <tr class="rowColor"> 
         <th class="colFirst" scope="row"><a href="SyncProvider.html" title="class in javax.sql.rowset.spi">SyncProvider</a></th> 
         <td class="colLast"> 
          <div class="block">
            为断开连接的 
           <code>RowSet</code>对象提供读取器/写入器功能的同步机制。 
          </div> </td> 
        </tr> 
       </tbody> 
      </table> </li> 
     <li class="blockList"> 
      <table class="typeSummary"> 
       <caption> 
        <span>异常摘要</span> 
        <span class="tabEnd">&nbsp;</span> 
       </caption> 
       <tbody> 
        <tr> 
         <th class="colFirst" scope="col">异常</th> 
         <th class="colLast" scope="col">描述</th> 
        </tr> 
       </tbody> 
       <tbody> 
        <tr class="altColor"> 
         <th class="colFirst" scope="row"><a href="SyncFactoryException.html" title="class in javax.sql.rowset.spi">SyncFactoryException</a></th> 
         <td class="colLast"> 
          <div class="block">
            表示 
           <code>SyncFactory</code>机制的错误。 
          </div> </td> 
        </tr> 
        <tr class="rowColor"> 
         <th class="colFirst" scope="row"><a href="SyncProviderException.html" title="class in javax.sql.rowset.spi">SyncProviderException</a></th> 
         <td class="colLast"> 
          <div class="block">
            表示 
           <code>SyncProvider</code>机制出错。 
          </div> </td> 
        </tr> 
       </tbody> 
      </table> </li> 
    </ul> 
   </div> 
  </main> 
  <footer role="contentinfo"> 
   <nav role="navigation"> 
    <!-- ======= START OF BOTTOM NAVBAR ====== --> 
    <div class="bottomNav"> 
     <a id="navbar.bottom"> 
      <!--   --> </a> 
     <div class="skipNav"> 
      <a href="#skip.navbar.bottom" title="Skip navigation links">跳过导航</a> 
     </div> 
     <a id="navbar.bottom.firstrow"> 
      <!--   --> </a> 
     <ul class="navList" title="Navigation"> 
      <li><a href="../../../../../index.html">概述</a></li> 
      <li><a href="../../../../module-summary.html">模块</a></li> 
      <li class="navBarCell1Rev">软件包</li> 
      <li>类</li> 
      <li><a href="package-use.html">使用</a></li> 
      <li><a href="package-tree.html">树</a></li> 
      <li><a href="../../../../../deprecated-list.html">已过时的</a></li> 
      <li><a href="../../../../../index-files/index-1.html">索引</a></li> 
      <li><a href="../../../../../help-doc.html">帮助</a></li> 
     </ul> 
     <div class="aboutLanguage"> 
      <div style="margin-top: 14px;"> 
       <strong>Java SE 11 &amp; JDK 11</strong> 
      </div> 
     </div> 
    </div> 
    <div class="subNav"> 
     <ul class="navList" id="allclasses_navbar_bottom"> 
      <li><a href="../../../../../allclasses.html">所有类</a></li> 
     </ul> 
     <div> 
      <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
      <noscript> 
       <div>
         JavaScript is disabled on your browser. 
       </div> 
      </noscript> 
     </div> 
     <a id="skip.navbar.bottom"> 
      <!--   --> </a> 
    </div> 
    <!-- ======== END OF BOTTOM NAVBAR ======= --> 
   </nav> 
   <p class="legalCopy"><small><a href="http://bugreport.java.com/bugreport/">Report a bug or suggest an enhancement</a><br> For further API reference and developer documentation see the <a href="http://www.oracle.com/pls/topic/lookup?ctx=javase11.0.1&amp;id=homepage" target="_blank">Java SE Documentation</a>, which contains more detailed, developer-targeted descriptions with conceptual overviews, definitions of terms, workarounds, and working code examples.<br> Java is a trademark or registered trademark of Oracle and/or its affiliates in the US and other countries.<br> <a href="../../../../../../legal/copyright.html">Copyright</a> © 1993, 2018, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.<br>All rights reserved. Use is subject to <a href="http://www.oracle.com/technetwork/java/javase/terms/license/java11.0.1speclicense.html">license terms</a> and the <a href="http://www.oracle.com/technetwork/java/redist-137594.html">documentation redistribution policy</a>. 
     <!-- Version 11.0.1+13-LTS --></small></p> 
  </footer>  
 </body>
</html>