<!doctype html>
<!-- NewPage -->
<html lang="en">
 <head> 
  <!-- Generated by javadoc --> 
  <title>GSSContext</title> 
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> 
  <meta name="keywords" content="org.ietf.jgss.GSSContext interface"> 
  <meta name="keywords" content="DEFAULT_LIFETIME"> 
  <meta name="keywords" content="INDEFINITE_LIFETIME"> 
  <meta name="keywords" content="initSecContext()"> 
  <meta name="keywords" content="acceptSecContext()"> 
  <meta name="keywords" content="isEstablished()"> 
  <meta name="keywords" content="dispose()"> 
  <meta name="keywords" content="getWrapSizeLimit()"> 
  <meta name="keywords" content="wrap()"> 
  <meta name="keywords" content="unwrap()"> 
  <meta name="keywords" content="getMIC()"> 
  <meta name="keywords" content="verifyMIC()"> 
  <meta name="keywords" content="export()"> 
  <meta name="keywords" content="requestMutualAuth()"> 
  <meta name="keywords" content="requestReplayDet()"> 
  <meta name="keywords" content="requestSequenceDet()"> 
  <meta name="keywords" content="requestCredDeleg()"> 
  <meta name="keywords" content="requestAnonymity()"> 
  <meta name="keywords" content="requestConf()"> 
  <meta name="keywords" content="requestInteg()"> 
  <meta name="keywords" content="requestLifetime()"> 
  <meta name="keywords" content="setChannelBinding()"> 
  <meta name="keywords" content="getCredDelegState()"> 
  <meta name="keywords" content="getMutualAuthState()"> 
  <meta name="keywords" content="getReplayDetState()"> 
  <meta name="keywords" content="getSequenceDetState()"> 
  <meta name="keywords" content="getAnonymityState()"> 
  <meta name="keywords" content="isTransferable()"> 
  <meta name="keywords" content="isProtReady()"> 
  <meta name="keywords" content="getConfState()"> 
  <meta name="keywords" content="getIntegState()"> 
  <meta name="keywords" content="getLifetime()"> 
  <meta name="keywords" content="getSrcName()"> 
  <meta name="keywords" content="getTargName()"> 
  <meta name="keywords" content="getMech()"> 
  <meta name="keywords" content="getDelegCred()"> 
  <meta name="keywords" content="isInitiator()"> 
  <link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style"> 
  <link rel="stylesheet" type="text/css" href="../../../../jquery/jquery-ui.css" title="Style"> 
  <script type="text/javascript" src="../../../../script.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jszip/dist/jszip.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script> 
  <!--[if IE]>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]--> 
  <script type="text/javascript" src="../../../../jquery/jquery-1.10.2.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jquery-migrate-1.2.1.js"></script> 
  <script type="text/javascript" src="../../../../jquery/jquery-ui.js"></script> 
 </head> 
 <body> <SCRIPT LANGUAGE="JavaScript"><!-- Hide  
   function ResumeError() {     return true;}window.onerror = ResumeError;// --></SCRIPT>
  <script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="GSSContext (Java SE 11 & JDK 11 )";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":6,"i1":38,"i2":6,"i3":6,"i4":6,"i5":6,"i6":6,"i7":6,"i8":6,"i9":6,"i10":6,"i11":6,"i12":38,"i13":6,"i14":6,"i15":6,"i16":6,"i17":6,"i18":6,"i19":6,"i20":38,"i21":6,"i22":6,"i23":6,"i24":6,"i25":6,"i26":6,"i27":6,"i28":6,"i29":6,"i30":6,"i31":6,"i32":6,"i33":6,"i34":6,"i35":38,"i36":6,"i37":38,"i38":6,"i39":38};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"],32:["t6","Deprecated Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script> 
  <noscript> 
   <div>
     JavaScript is disabled on your browser. 
   </div> 
  </noscript> 
  <header role="banner"> 
   <nav role="navigation"> 
    <div class="fixedNav"> 
     <!-- ========= START OF TOP NAVBAR ======= --> 
     <div class="topNav"> 
      <a id="navbar.top"> 
       <!--   --> </a> 
      <div class="skipNav"> 
       <a href="#skip.navbar.top" title="Skip navigation links">跳过导航</a> 
      </div> 
      <a id="navbar.top.firstrow"> 
       <!--   --> </a> 
      <ul class="navList" title="Navigation"> 
       <li><a href="../../../../index.html">概述</a></li> 
       <li><a href="../../../module-summary.html">模块</a></li> 
       <li><a href="package-summary.html">软件包</a></li> 
       <li class="navBarCell1Rev">类</li> 
       <li><a href="class-use/GSSContext.html">使用</a></li> 
       <li><a href="package-tree.html">树</a></li> 
       <li><a href="../../../../deprecated-list.html">已过时的</a></li> 
       <li><a href="../../../../index-files/index-1.html">索引</a></li> 
       <li><a href="../../../../help-doc.html">帮助</a></li> 
      </ul> 
      <div class="aboutLanguage"> 
       <div style="margin-top: 14px;"> 
        <strong>Java SE 11 &amp; JDK 11</strong> 
       </div> 
      </div> 
     </div> 
     <div class="subNav"> 
      <ul class="navList" id="allclasses_navbar_top"> 
       <li><a href="../../../../allclasses.html">所有类</a></li> 
      </ul> 
      <ul class="navListSearch"> 
       <li><label for="search">SEARCH:</label> <input type="text" id="search" value="search" disabled> <input type="reset" id="reset" value="reset" disabled> </li> 
      </ul> 
      <div> 
       <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
       <noscript> 
        <div>
          JavaScript is disabled on your browser. 
        </div> 
       </noscript> 
      </div> 
       <div class="fixedNav">
       <ul class="subNavList"> 
        <li>概要：&nbsp;</li> 
        <li>嵌套&nbsp;|&nbsp;</li> 
        <li><a href="#field.summary">字段</a>&nbsp;|&nbsp;</li> 
        <li>构造方法&nbsp;|&nbsp;</li> 
        <li><a href="#method.summary">方法</a></li> 
       </ul> 
       <ul class="subNavList"> 
        <li>详细信息：&nbsp;</li> 
        <li><a href="#field.detail">字段</a>&nbsp;|&nbsp;</li> 
        <li>构造方法&nbsp;|&nbsp;</li> 
        <li><a href="#method.detail">方法</a></li> 
       </ul> 
      </div> 
      <a id="skip.navbar.top"> 
       <!--   --> </a> 
     </div> 
     <!-- ========= END OF TOP NAVBAR ========= --> 
    </div> 
    <div class="navPadding">
      &nbsp; 
    </div> 
    <script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script> 
   </nav> 
  </header> 
  <!-- ======== START OF CLASS DATA ======== --> 
  <main role="main"> 
   <div class="header"> 
    <div class="subTitle"> 
     <span class="moduleLabelInType">模块</span>&nbsp; 
     <a href="../../../module-summary.html">java.security.jgss</a> 
    </div> 
    <div class="subTitle"> 
     <span class="packageLabelInType">软件包</span>&nbsp; 
     <a href="package-summary.html">org.ietf.jgss</a> 
    </div> 
    <h2 title="Interface GSSContext" class="title">Interface GSSContext</h2> 
   </div> 
   <div class="contentContainer"> 
    <div class="description"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <dl> 
        <dt>
          All Known Subinterfaces: 
        </dt> 
        <dd> 
         <code><a href="../../../../jdk.security.jgss/com/sun/security/jgss/ExtendedGSSContext.html" title="interface in com.sun.security.jgss">ExtendedGSSContext</a></code> 
        </dd> 
       </dl> 
       <hr> <pre>public interface <span class="typeNameLabel">GSSContext</span></pre> 
       <div class="block"> 
        <span>此接口封装GSS-API安全上下文，并提供上下文中可用的安全服务。</span> 
        <span>使用本地获取的凭证在对等体之间建立安全性上下文。</span> 
        <span>使用相同或不同的凭证集可以在一对对等体之间同时存在多个上下文。</span> 
        <span>GSS-API以独立于底层传输协议的方式运行，并依赖于其调用应用程序来传输由对等体之间的安全性上下文生成的令牌。</span> 
        <p> <span>如果调用者使用默认的<code>GSSManager</code>实例实例化上下文，则保证Kerberos v5 GSS-API机制可用于上下文建立。</span> <span>该机制由Oid“1.2.840.113554.1.2.2”标识，并在RFC 1964中定义。</span> </p> 
        <p> <span>在启动上下文建立阶段之前，上下文发起者可以请求所建立的上下文所需的特定特征。</span> <span>并非所有底层机制都支持调用者可能想要的所有特征。</span> <span>在建立上下文之后，调用者可以通过各种查询方法检查该上下文提供的实际特征和服务。</span> <span>使用默认<code>GSSManager</code>实例提供的Kerberos v5 GSS-API机制时，所有可选服务都将在本地可用。</span> <span>它们是相互身份验证，凭据委派，机密性和完整性保护，以及每个消息重放检测和排序。</span> <span>请注意，在GSS-API中，消息完整性是消息机密性的先决条件。</span> </p> 
        <p> <span>上下文建立发生在循环中，其中发起者调用<a href="#initSecContext(byte%5B%5D,int,int)"><code>initSecContext</code></a>并且接受者调用<a href="#acceptSecContext(byte%5B%5D,int,int)"><code>acceptSecContext</code></a>直到建立上下文。</span> <span>在此循环中， <code>initSecContext</code>和<code>acceptSecContext</code>方法生成应用程序发送给对等方的令牌。</span> <span>根据具体情况，对等体将任何此类令牌作为输入传递给其<code>acceptSecContext</code>或<code>initSecContext</code> 。</span> </p> 
        <p> <span>在上下文建立阶段期间，可以调用<a href="#isProtReady()"><code>isProtReady</code></a>方法以确定上下文是否可以用于<a href="#wrap(byte%5B%5D,int,int,org.ietf.jgss.MessageProp)"><code>wrap</code></a>和<a href="#getMIC(byte%5B%5D,int,int,org.ietf.jgss.MessageProp)"><code>getMIC</code></a>的每消息操作。</span> <span>这允许应用程序在尚未完全建立的上下文上使用按消息操作。</span> </p> 
        <p> <span>在建立上下文或<code>isProtReady</code>方法返回<code>true</code> ，可以调用查询例程以确定所建立的上下文的实际特征和服务。</span> <span>应用程序还可以使用<a href="#wrap(byte%5B%5D,int,int,org.ietf.jgss.MessageProp)"><code>wrap</code></a>和<a href="#getMIC(byte%5B%5D,int,int,org.ietf.jgss.MessageProp)"><code>getMIC</code></a>的每消息方法<a href="#wrap(byte%5B%5D,int,int,org.ietf.jgss.MessageProp)">开始</a> ，以获取应用程序提供的数据的加密操作。</span> </p> 
        <p> <span>当不再需要上下文时，应用程序应调用<a href="#dispose()"><code>dispose</code></a>以释放上下文可能正在使用的任何系统资源。</span> </p> 
        <p> <span>安全上下文通常维护有关其处理的令牌的排序和重放检测信息。</span> <span>因此，将任何令牌呈现给该上下文以进行处理的顺序可能是重要的。</span> <span>另请注意，此接口中的所有方法都不会同步。</span> <span>因此，除非某些应用程序级别同步到位，否则不建议在多个线程之间共享<code>GSSContext</code> 。</span> </p> 
        <p> <span>最后，不同的机制提供程序可能会对使用GSS-API上下文设置不同的安全限制。</span> <span>这些将由机制提供商记录。</span> <span>如果在机制层中进行此类检查，应用程序将需要确保它具有适当的权限。</span> </p> 
        <p> <span>基于流的方法<code>GSSContext</code>已在Java SE 11中<a href="http://tools.ietf.org/html/rfc8353">弃用</a> 。由于以下原因，这些方法也已从<a href="http://tools.ietf.org/html/rfc8353">RFC 8353: Generic Security Service API Version 2: Java Bindings Update中</a>删除（参见第11节）：“使用输入和输出流作为传达方式的GSSContext的重载方法此更新中删除了RFC 5653第5.15节中描述的身份验证和按消息GSS-API令牌，因为有线协议应由应用程序而不是库定义。当令牌没有时，也无法正确实现这些方法自组织（无法确定结束），或者库不知道令牌格式（例如，作为与另一个GSS库交谈的桥梁）“。</span> <span>这些方法包括： <a href="#initSecContext(java.io.InputStream,java.io.OutputStream)"><code>initSecContext(InputStream, OutputStream)</code></a> ， <a href="#acceptSecContext(java.io.InputStream,java.io.OutputStream)"><code>acceptSecContext(InputStream, OutputStream)</code></a> ， <a href="#wrap(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)"><code>wrap(InputStream, OutputStream, MessageProp)</code></a> ， <a href="#unwrap(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)"><code>unwrap(InputStream, OutputStream, MessageProp)</code></a> ， <a href="#getMIC(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)"><code>getMIC(InputStream, OutputStream, MessageProp)</code></a>和<a href="#verifyMIC(java.io.InputStream,java.io.InputStream,org.ietf.jgss.MessageProp)"><code>verifyMIC(InputStream, InputStream, MessageProp)</code></a> 。</span> </p> 
        <p> <span>下面给出的示例代码演示了启动对等体使用<code>GSSContext</code>接口。</span> <span>对<code>GSSContext</code>对象进行了不同的操作，包括：对象实例化，所需标志的设置，上下文建立，实际上下文标志的查询，对应用程序数据的每消息操作，以及最后的上下文删除。</span> </p> 
        <pre>  <span>// Create a context using default credentials
    // and the implementation specific default mechanism
    GSSManager manager ...
    GSSName targetName ...
    GSSContext context = manager.createContext(targetName, null, null,
                                           GSSContext.INDEFINITE_LIFETIME);

    // set desired context options prior to context establishment
    context.requestConf(true);
    context.requestMutualAuth(true);
    context.requestReplayDet(true);
    context.requestSequenceDet(true);

    // establish a context between peers

    byte []inToken = new byte[0];

    // Loop while there still is a token to be processed

    while (!context.isEstablished()) {

        byte[] outToken
            = context.initSecContext(inToken, 0, inToken.length);

        // send the output token if generated
        if (outToken != null)
            sendToken(outToken);

        if (!context.isEstablished()) {
            inToken = readToken();
    }

     // display context information
     System.out.println("Remaining lifetime in seconds = "
                                          + context.getLifetime());
     System.out.println("Context mechanism = " + context.getMech());
     System.out.println("Initiator = " + context.getSrcName());
     System.out.println("Acceptor = " + context.getTargName());

     if (context.getConfState())
             System.out.println("Confidentiality (i.e., privacy) is available");

     if (context.getIntegState())
             System.out.println("Integrity is available");

     // perform wrap on an application supplied message, appMsg,
     // using QOP = 0, and requesting privacy service
     byte [] appMsg ...

     MessageProp mProp = new MessageProp(0, true);

     byte []tok = context.wrap(appMsg, 0, appMsg.length, mProp);

     sendToken(tok);

     // release the local-end of the context
     context.dispose();</span> </pre> 
       </div> 
       <dl> 
        <dt> 
         <span class="simpleTagLabel">从以下版本开始：</span> 
        </dt> 
        <dd>
          1.4 
        </dd> 
       </dl> </li> 
     </ul> 
    </div> 
    <div class="summary"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <!-- =========== FIELD SUMMARY =========== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="field.summary"> 
           <!--   --> </a> <h3>字段汇总</h3> 
          <table class="memberSummary"> 
           <caption> 
            <span>字段</span> 
            <span class="tabEnd">&nbsp;</span> 
           </caption> 
           <tbody> 
            <tr> 
             <th class="colFirst" scope="col">变量和类型</th> 
             <th class="colSecond" scope="col">字段</th> 
             <th class="colLast" scope="col">描述</th> 
            </tr> 
            <tr class="altColor"> 
             <td class="colFirst"><code>static int</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#DEFAULT_LIFETIME">DEFAULT_LIFETIME</a></span></code></th> 
             <td class="colLast"> 
              <div class="block">
                表示默认上下文生存期的生命周期常量。 
              </div> </td> 
            </tr> 
            <tr class="rowColor"> 
             <td class="colFirst"><code>static int</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#INDEFINITE_LIFETIME">INDEFINITE_LIFETIME</a></span></code></th> 
             <td class="colLast"> 
              <div class="block">
                表示无限上下文生命周期的生命周期常量。 
              </div> </td> 
            </tr> 
           </tbody> 
          </table> </li> 
        </ul> 
       </section> 
       <!-- ========== METHOD SUMMARY =========== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="method.summary"> 
           <!--   --> </a> <h3>方法摘要</h3> 
          <table class="memberSummary"> 
           <caption> 
           <span id="t0" class="activeTableTab"><span>所有方法</span><span class="tabEnd">&nbsp;</span>
             <span id="t2" class="tableTab"><span><a href="javascript:show(2);">实例方法</a>  </span></span> 
            <span id="t3" class="tableTab"><span><a href="javascript:show(4);">抽象方法</a></span><span class="tabEnd">&nbsp;</span></span> 
            <span id="t6" class="tableTab"><span><a href="javascript:show(32);">弃用的方法</a></span><span class="tabEnd">&nbsp;</span></span> 
           </caption> 
           <tbody> 
            <tr> 
             <th class="colFirst" scope="col">变量和类型</th> 
             <th class="colSecond" scope="col">方法</th> 
             <th class="colLast" scope="col">描述</th> 
            </tr> 
            <tr id="i0" class="altColor"> 
             <td class="colFirst"><code>byte[]</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#acceptSecContext(byte%5B%5D,int,int)">acceptSecContext</a></span>​(byte[]&nbsp;inToken, int&nbsp;offset, int&nbsp;len)</code></th> 
             <td class="colLast"> 
              <div class="block">
                在从对等方接收到令牌时由上下文接受方调用。 
              </div> </td> 
            </tr> 
            <tr id="i1" class="rowColor"> 
             <td class="colFirst"><code>void</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#acceptSecContext(java.io.InputStream,java.io.OutputStream)">acceptSecContext</a></span>​(<a href="../../../../java.base/java/io/InputStream.html" title="class in java.io">InputStream</a>&nbsp;inStream, <a href="../../../../java.base/java/io/OutputStream.html" title="class in java.io">OutputStream</a>&nbsp;outStream)</code></th> 
             <td class="colLast"> 
              <div class="block"> 
               <span><span class="deprecatedLabel">已过时。</span></span> 
               <div class="deprecationComment"> 
                <span>基于流的方法已从RFC 8353中删除。</span> 
               </div> 
              </div> </td> 
            </tr> 
            <tr id="i2" class="altColor"> 
             <td class="colFirst"><code>void</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#dispose()">dispose</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                释放存储在上下文对象中的任何系统资源和加密信息，并使上下文无效。 
              </div> </td> 
            </tr> 
            <tr id="i3" class="rowColor"> 
             <td class="colFirst"><code>byte[]</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#export()">export</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                导出此上下文，以便其他进程可以导入它。 
              </div> </td> 
            </tr> 
            <tr id="i4" class="altColor"> 
             <td class="colFirst"><code>boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getAnonymityState()">getAnonymityState</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                确定上下文启动器是否对上下文接受器进行匿名身份验证。 
              </div> </td> 
            </tr> 
            <tr id="i5" class="rowColor"> 
             <td class="colFirst"><code>boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getConfState()">getConfState</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                确定上下文中是否可以使用数据机密性。 
              </div> </td> 
            </tr> 
            <tr id="i6" class="altColor"> 
             <td class="colFirst"><code>boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getCredDelegState()">getCredDelegState</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                确定是否在此上下文中启用了凭据委派。 
              </div> </td> 
            </tr> 
            <tr id="i7" class="rowColor"> 
             <td class="colFirst"><code><a href="GSSCredential.html" title="interface in org.ietf.jgss">GSSCredential</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getDelegCred()">getDelegCred</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                获取上下文启动器委派给上下文接受器的凭据。 
              </div> </td> 
            </tr> 
            <tr id="i8" class="altColor"> 
             <td class="colFirst"><code>boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getIntegState()">getIntegState</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                确定上下文中是否可以使用数据完整性。 
              </div> </td> 
            </tr> 
            <tr id="i9" class="rowColor"> 
             <td class="colFirst"><code>int</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getLifetime()">getLifetime</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                确定此上下文的剩余生命周期。 
              </div> </td> 
            </tr> 
            <tr id="i10" class="altColor"> 
             <td class="colFirst"><code><a href="Oid.html" title="class in org.ietf.jgss">Oid</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getMech()">getMech</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                确定用于此上下文的机制。 
              </div> </td> 
            </tr> 
            <tr id="i11" class="rowColor"> 
             <td class="colFirst"><code>byte[]</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getMIC(byte%5B%5D,int,int,org.ietf.jgss.MessageProp)">getMIC</a></span>​(byte[]&nbsp;inMsg, int&nbsp;offset, int&nbsp;len, <a href="MessageProp.html" title="class in org.ietf.jgss">MessageProp</a>&nbsp;msgProp)</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回包含所提供消息的加密消息完整性代码（MIC）的标记，以便传输到对等应用程序。 
              </div> </td> 
            </tr> 
            <tr id="i12" class="altColor"> 
             <td class="colFirst"><code>void</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getMIC(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)">getMIC</a></span>​(<a href="../../../../java.base/java/io/InputStream.html" title="class in java.io">InputStream</a>&nbsp;inStream, <a href="../../../../java.base/java/io/OutputStream.html" title="class in java.io">OutputStream</a>&nbsp;outStream, <a href="MessageProp.html" title="class in org.ietf.jgss">MessageProp</a>&nbsp;msgProp)</code></th> 
             <td class="colLast"> 
              <div class="block"> 
               <span><span class="deprecatedLabel">已过时。</span></span> 
               <div class="deprecationComment"> 
                <span>基于流的方法已从RFC 8353中删除。</span> 
               </div> 
              </div> </td> 
            </tr> 
            <tr id="i13" class="rowColor"> 
             <td class="colFirst"><code>boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getMutualAuthState()">getMutualAuthState</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                确定是否在此上下文中启用了相互身份验证。 
              </div> </td> 
            </tr> 
            <tr id="i14" class="altColor"> 
             <td class="colFirst"><code>boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getReplayDetState()">getReplayDetState</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                确定是否从此上下文为每个消息的安全服务启用了重放检测。 
              </div> </td> 
            </tr> 
            <tr id="i15" class="rowColor"> 
             <td class="colFirst"><code>boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getSequenceDetState()">getSequenceDetState</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                确定是否从此上下文为每个消息的安全服务启用了序列检查。 
              </div> </td> 
            </tr> 
            <tr id="i16" class="altColor"> 
             <td class="colFirst"><code><a href="GSSName.html" title="interface in org.ietf.jgss">GSSName</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getSrcName()">getSrcName</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回上下文启动器的名称。 
              </div> </td> 
            </tr> 
            <tr id="i17" class="rowColor"> 
             <td class="colFirst"><code><a href="GSSName.html" title="interface in org.ietf.jgss">GSSName</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getTargName()">getTargName</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                返回上下文接受器的名称。 
              </div> </td> 
            </tr> 
            <tr id="i18" class="altColor"> 
             <td class="colFirst"><code>int</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getWrapSizeLimit(int,boolean,int)">getWrapSizeLimit</a></span>​(int&nbsp;qop, boolean&nbsp;confReq, int&nbsp;maxTokenSize)</code></th> 
             <td class="colLast"> 
              <div class="block">
                用于确定可以传递给 
               <code>wrap</code>的消息大小的限制。 
              </div> </td> 
            </tr> 
            <tr id="i19" class="rowColor"> 
             <td class="colFirst"><code>byte[]</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#initSecContext(byte%5B%5D,int,int)">initSecContext</a></span>​(byte[]&nbsp;inputBuf, int&nbsp;offset, int&nbsp;len)</code></th> 
             <td class="colLast"> 
              <div class="block">
                由上下文启动器调用以启动上下文创建阶段 
               <code>acceptSecContext</code>对等方的 
               <code>acceptSecContext</code>方法生成的任何令牌。 
              </div> </td> 
            </tr> 
            <tr id="i20" class="altColor"> 
             <td class="colFirst"><code>int</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#initSecContext(java.io.InputStream,java.io.OutputStream)">initSecContext</a></span>​(<a href="../../../../java.base/java/io/InputStream.html" title="class in java.io">InputStream</a>&nbsp;inStream, <a href="../../../../java.base/java/io/OutputStream.html" title="class in java.io">OutputStream</a>&nbsp;outStream)</code></th> 
             <td class="colLast"> 
              <div class="block"> 
               <span><span class="deprecatedLabel">已过时。</span></span> 
               <div class="deprecationComment"> 
                <span>基于流的方法已从RFC 8353中删除。</span> 
               </div> 
              </div> </td> 
            </tr> 
            <tr id="i21" class="rowColor"> 
             <td class="colFirst"><code>boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isEstablished()">isEstablished</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                在上下文建立期间用于确定上下文的状态。 
              </div> </td> 
            </tr> 
            <tr id="i22" class="altColor"> 
             <td class="colFirst"><code>boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isInitiator()">isInitiator</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                确定这是否是上下文启动器。 
              </div> </td> 
            </tr> 
            <tr id="i23" class="rowColor"> 
             <td class="colFirst"><code>boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isProtReady()">isProtReady</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                确定上下文是否已准备好对其使用的每个消息操作。 
              </div> </td> 
            </tr> 
            <tr id="i24" class="altColor"> 
             <td class="colFirst"><code>boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isTransferable()">isTransferable</a></span>()</code></th> 
             <td class="colLast"> 
              <div class="block">
                通过使用 
               <a href="#export()"><code>export</code></a>方法确定上下文是否可以转移到其他进程。 
              </div> </td> 
            </tr> 
            <tr id="i25" class="rowColor"> 
             <td class="colFirst"><code>void</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#requestAnonymity(boolean)">requestAnonymity</a></span>​(boolean&nbsp;state)</code></th> 
             <td class="colLast"> 
              <div class="block">
                要求不向接收方披露发起人的身份。 
              </div> </td> 
            </tr> 
            <tr id="i26" class="altColor"> 
             <td class="colFirst"><code>void</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#requestConf(boolean)">requestConf</a></span>​(boolean&nbsp;state)</code></th> 
             <td class="colLast"> 
              <div class="block">
                请求为 
               <code>wrap</code>方法启用数据机密性。 
              </div> </td> 
            </tr> 
            <tr id="i27" class="rowColor"> 
             <td class="colFirst"><code>void</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#requestCredDeleg(boolean)">requestCredDeleg</a></span>​(boolean&nbsp;state)</code></th> 
             <td class="colLast"> 
              <div class="block">
                请求在上下文建立期间将发起者的凭证委托给接受者。 
              </div> </td> 
            </tr> 
            <tr id="i28" class="altColor"> 
             <td class="colFirst"><code>void</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#requestInteg(boolean)">requestInteg</a></span>​(boolean&nbsp;state)</code></th> 
             <td class="colLast"> 
              <div class="block">
                请求为 
               <code>wrap</code>和 
               <code>getMIC</code>方法启用数据完整性。 
              </div> </td> 
            </tr> 
            <tr id="i29" class="rowColor"> 
             <td class="colFirst"><code>void</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#requestLifetime(int)">requestLifetime</a></span>​(int&nbsp;lifetime)</code></th> 
             <td class="colLast"> 
              <div class="block">
                请求上下文的生命周期（以秒为单位）。 
              </div> </td> 
            </tr> 
            <tr id="i30" class="altColor"> 
             <td class="colFirst"><code>void</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#requestMutualAuth(boolean)">requestMutualAuth</a></span>​(boolean&nbsp;state)</code></th> 
             <td class="colLast"> 
              <div class="block">
                请求在上下文建立期间完成相互身份验证。 
              </div> </td> 
            </tr> 
            <tr id="i31" class="rowColor"> 
             <td class="colFirst"><code>void</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#requestReplayDet(boolean)">requestReplayDet</a></span>​(boolean&nbsp;state)</code></th> 
             <td class="colLast"> 
              <div class="block">
                请求在上下文建立后为每个消息的安全服务启用重放检测。 
              </div> </td> 
            </tr> 
            <tr id="i32" class="altColor"> 
             <td class="colFirst"><code>void</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#requestSequenceDet(boolean)">requestSequenceDet</a></span>​(boolean&nbsp;state)</code></th> 
             <td class="colLast"> 
              <div class="block">
                请求在上下文建立后为每个消息的安全服务启用序列检查。 
              </div> </td> 
            </tr> 
            <tr id="i33" class="rowColor"> 
             <td class="colFirst"><code>void</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setChannelBinding(org.ietf.jgss.ChannelBinding)">setChannelBinding</a></span>​(<a href="ChannelBinding.html" title="class in org.ietf.jgss">ChannelBinding</a>&nbsp;cb)</code></th> 
             <td class="colLast"> 
              <div class="block">
                设置在上下文建立期间使用的通道绑定。 
              </div> </td> 
            </tr> 
            <tr id="i34" class="altColor"> 
             <td class="colFirst"><code>byte[]</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unwrap(byte%5B%5D,int,int,org.ietf.jgss.MessageProp)">unwrap</a></span>​(byte[]&nbsp;inBuf, int&nbsp;offset, int&nbsp;len, <a href="MessageProp.html" title="class in org.ietf.jgss">MessageProp</a>&nbsp;msgProp)</code></th> 
             <td class="colLast"> 
              <div class="block">
                用于处理上下文另一侧的 
               <code>wrap</code>方法生成的令牌。 
              </div> </td> 
            </tr> 
            <tr id="i35" class="rowColor"> 
             <td class="colFirst"><code>void</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unwrap(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)">unwrap</a></span>​(<a href="../../../../java.base/java/io/InputStream.html" title="class in java.io">InputStream</a>&nbsp;inStream, <a href="../../../../java.base/java/io/OutputStream.html" title="class in java.io">OutputStream</a>&nbsp;outStream, <a href="MessageProp.html" title="class in org.ietf.jgss">MessageProp</a>&nbsp;msgProp)</code></th> 
             <td class="colLast"> 
              <div class="block"> 
               <span><span class="deprecatedLabel">已过时。</span></span> 
               <div class="deprecationComment"> 
                <span>基于流的方法已从RFC 8353中删除。</span> 
               </div> 
              </div> </td> 
            </tr> 
            <tr id="i36" class="altColor"> 
             <td class="colFirst"><code>void</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#verifyMIC(byte%5B%5D,int,int,byte%5B%5D,int,int,org.ietf.jgss.MessageProp)">verifyMIC</a></span>​(byte[]&nbsp;inToken, int&nbsp;tokOffset, int&nbsp;tokLen, byte[]&nbsp;inMsg, int&nbsp;msgOffset, int&nbsp;msgLen, <a href="MessageProp.html" title="class in org.ietf.jgss">MessageProp</a>&nbsp;msgProp)</code></th> 
             <td class="colLast"> 
              <div class="block">
                通过提供的消息验证令牌参数中包含的加密MIC。 
              </div> </td> 
            </tr> 
            <tr id="i37" class="rowColor"> 
             <td class="colFirst"><code>void</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#verifyMIC(java.io.InputStream,java.io.InputStream,org.ietf.jgss.MessageProp)">verifyMIC</a></span>​(<a href="../../../../java.base/java/io/InputStream.html" title="class in java.io">InputStream</a>&nbsp;tokStream, <a href="../../../../java.base/java/io/InputStream.html" title="class in java.io">InputStream</a>&nbsp;msgStream, <a href="MessageProp.html" title="class in org.ietf.jgss">MessageProp</a>&nbsp;msgProp)</code></th> 
             <td class="colLast"> 
              <div class="block"> 
               <span><span class="deprecatedLabel">已过时。</span></span> 
               <div class="deprecationComment"> 
                <span>基于流的方法已从RFC 8353中删除。</span> 
               </div> 
              </div> </td> 
            </tr> 
            <tr id="i38" class="altColor"> 
             <td class="colFirst"><code>byte[]</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#wrap(byte%5B%5D,int,int,org.ietf.jgss.MessageProp)">wrap</a></span>​(byte[]&nbsp;inBuf, int&nbsp;offset, int&nbsp;len, <a href="MessageProp.html" title="class in org.ietf.jgss">MessageProp</a>&nbsp;msgProp)</code></th> 
             <td class="colLast"> 
              <div class="block">
                在已建立的安全上下文中应用每个消息的安全服务。 
              </div> </td> 
            </tr> 
            <tr id="i39" class="rowColor"> 
             <td class="colFirst"><code>void</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#wrap(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)">wrap</a></span>​(<a href="../../../../java.base/java/io/InputStream.html" title="class in java.io">InputStream</a>&nbsp;inStream, <a href="../../../../java.base/java/io/OutputStream.html" title="class in java.io">OutputStream</a>&nbsp;outStream, <a href="MessageProp.html" title="class in org.ietf.jgss">MessageProp</a>&nbsp;msgProp)</code></th> 
             <td class="colLast"> 
              <div class="block"> 
               <span><span class="deprecatedLabel">已过时。</span></span> 
               <div class="deprecationComment"> 
                <span>基于流的方法已从RFC 8353中删除。</span> 
               </div> 
              </div> </td> 
            </tr> 
           </tbody> 
          </table> </li> 
        </ul> 
       </section> </li> 
     </ul> 
    </div> 
    <div class="details"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <!-- ============ FIELD DETAIL =========== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="field.detail"> 
           <!--   --> </a> <h3>字段详细信息</h3> <a id="DEFAULT_LIFETIME"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>DEFAULT_LIFETIME</h4> <pre>static final&nbsp;int DEFAULT_LIFETIME</pre> 
            <div class="block"> 
             <span>表示默认上下文生存期的生命周期常量。</span> 
             <span>该值设置为0。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="../../../../constant-values.html#org.ietf.jgss.GSSContext.DEFAULT_LIFETIME">常数字段值</a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="INDEFINITE_LIFETIME"> 
           <!--   --> </a> 
          <ul class="blockListLast"> 
           <li class="blockList"> <h4>INDEFINITE_LIFETIME</h4> <pre>static final&nbsp;int INDEFINITE_LIFETIME</pre> 
            <div class="block"> 
             <span>表示无限上下文生命周期的生命周期常量。</span> 
             <span>此值必须设置为Java中的最大整数值 - <a href="../../../../java.base/java/lang/Integer.html#MAX_VALUE"><code>Integer.MAX_VALUE</code></a> 。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="../../../../constant-values.html#org.ietf.jgss.GSSContext.INDEFINITE_LIFETIME">常数字段值</a> 
             </dd> 
            </dl> </li> 
          </ul> </li> 
        </ul> 
       </section> 
       <!-- ============ METHOD DETAIL ========== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="method.detail"> 
           <!--   --> </a> <h3>方法详细信息</h3> <a id="initSecContext(byte[],int,int)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>initSecContext</h4> <pre class="methodSignature">byte[]&nbsp;initSecContext​(byte[]&nbsp;inputBuf,
                      int&nbsp;offset,
                      int&nbsp;len)
               throws <a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></pre> 
            <div class="block"> 
             <span>由上下文启动器调用以启动上下文创建阶段<code>acceptSecContext</code>对等方的<code>acceptSecContext</code>方法生成的任何令牌。</span> 
             <span>此方法可能会返回一个输出令牌，应用程序需要将该令牌发送给对等方，以便通过其<code>acceptSecContext</code>方法进行处理。</span> 
             <span>应用程序可以调用<a href="#isEstablished()"><code>isEstablished</code></a>来确定上下文建立阶段是否在上下文的这一侧完成。</span> 
             <span><code>false</code>的返回值<code>isEstablished</code>表示预计将向<code>initSecContext</code>提供更多令牌。</span> 
             <span>完成上下文建立后，可以通过get方法查询可用的上下文选项。</span> 
             <p> <span>请注意， <code>initSecContext</code>方法可能会为对等方返回一个令牌，而<code>true</code>也<code>isEstablished</code>返回<code>true</code> 。</span> <span>这表示需要将令牌发送给对等体，但现在完全建立了上下文的本地端。</span> </p> 
             <p> <span>某些机制提供程序可能要求授予调用方启动安全上下文的权限。</span> <span>权限检查失败可能会导致从此方法抛出<a href="../../../../java.base/java/lang/SecurityException.html" title="java.lang中的类"><code>SecurityException</code></a> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <span><code>inputBuf</code> - 对等<code>inputBuf</code>令牌。</span> 
              <span>在第一次调用时忽略此参数，因为没有从对等方收到任何令牌。</span> 
             </dd> 
             <dd> 
              <code>offset</code> - 令牌开始的inputBuf中的偏移量。 
             </dd> 
             <dd> 
              <code>len</code> - 令牌的长度。 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <span>包含要发送给对等方的令牌的byte []。</span> 
              <span><code>null</code>表示没有生成令牌。</span> 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></code> -包含以下主要错误代码： 
              <a href="GSSException.html#DEFECTIVE_TOKEN"><code>GSSException.DEFECTIVE_TOKEN</code></a> ， 
              <a href="GSSException.html#BAD_MIC"><code>GSSException.BAD_MIC</code></a> ， 
              <a href="GSSException.html#NO_CRED"><code>GSSException.NO_CRED</code></a> ， 
              <a href="GSSException.html#CREDENTIALS_EXPIRED"><code>GSSException.CREDENTIALS_EXPIRED</code></a> ， 
              <a href="GSSException.html#BAD_BINDINGS"><code>GSSException.BAD_BINDINGS</code></a> ， 
              <a href="GSSException.html#OLD_TOKEN"><code>GSSException.OLD_TOKEN</code></a> ， 
              <a href="GSSException.html#DUPLICATE_TOKEN"><code>GSSException.DUPLICATE_TOKEN</code></a> ， 
              <a href="GSSException.html#BAD_NAMETYPE"><code>GSSException.BAD_NAMETYPE</code></a> ， 
              <a href="GSSException.html#BAD_MECH"><code>GSSException.BAD_MECH</code></a> ， 
              <a href="GSSException.html#FAILURE"><code>GSSException.FAILURE</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="initSecContext(java.io.InputStream,java.io.OutputStream)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>initSecContext</h4> <pre class="methodSignature"><a href="../../../../java.base/java/lang/Deprecated.html" title="annotation in java.lang">@Deprecated</a>(<a href="../../../../java.base/java/lang/Deprecated.html#since()">since</a>="11")
int&nbsp;initSecContext​(<a href="../../../../java.base/java/io/InputStream.html" title="class in java.io">InputStream</a>&nbsp;inStream,
                   <a href="../../../../java.base/java/io/OutputStream.html" title="class in java.io">OutputStream</a>&nbsp;outStream)
            throws <a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></pre> 
            <div class="deprecationBlock"> 
             <span class="deprecatedLabel">Deprecated.</span> 
             <div class="deprecationComment">
               The stream-based methods have been removed from RFC 8353. Use 
              <a href="#initSecContext(byte%5B%5D,int,int)"><code>initSecContext(byte[], int, int)</code></a> instead. 
             </div> 
            </div> 
            <div class="block"> 
             <span>由上下文启动器调用以启动上下文创建阶段并使用流来处理由对等方的<code>acceptSecContext</code>方法生成的任何令牌。</span> 
             <span>此方法可能会将输出令牌写入<code>OutpuStream</code> ，应用程序需要将其发送给对等方，以便通过其<code>acceptSecContext</code>调用进行处理。</span> 
             <span>通常，应用程序将通过调用确保此<a href="../../../../java.base/java/io/OutputStream.html#flush()"><code>flush</code></a>上的方法<code>OutputStream</code> ，它封装了两个对等体之间的连接。</span> 
             <span>应用程序可以根据此方法的返回值确定是否将令牌写入OutputStream。</span> 
             <span>返回值<code>0</code>表示未写入任何令牌。</span> 
             <span>应用程序可以调用<a href="#isEstablished()"><code>isEstablished</code></a>来确定上下文建立阶段是否在上下文的这一侧完成。</span> 
             <span>的返回值<code>false</code>从<code>isEstablished</code>表明更多的标记，预计将被供应到<code>initSecContext</code> 。</span> 
             <span>完成上下文建立后，可以通过get方法查询可用的上下文选项。</span> 
             <p> <span>请注意， <code>initSecContext</code>方法可能会为对等方返回令牌，而<code>true</code>也<code>isEstablished</code>返回<code>true</code> 。</span> <span>这表示需要将令牌发送给对等体，但现在完全建立了上下文的本地端。</span> </p> 
             <p> <span>GSS-API身份验证令牌包含明确的开始和结束。</span> <span>此方法将尝试每次调用读取其中一个标记，并且如果只有部分令牌可用，则可能会阻塞流。</span> <span>在所有其他方面，此方法等效于基于字节数组的<a href="#initSecContext(byte%5B%5D,int,int)"><code>initSecContext</code></a> 。</span> </p> 
             <p> <span>某些机制提供程序可能要求授予调用方启动安全上下文的权限。</span> <span>权限检查失败可能会导致从此方法抛出<a href="../../../../java.base/java/lang/SecurityException.html" title="java.lang中的类"><code>SecurityException</code></a> 。</span> </p> 
             <p> <span>以下示例代码演示了如何使用此方法：</span> </p> 
             <pre>  <span>InputStream is ...
     OutputStream os ...
     GSSContext context ...

     // Loop while there is still a token to be processed

     while (!context.isEstablished()) {

         context.initSecContext(is, os);

         // send output token if generated
         os.flush();
     }</span> </pre> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <span><code>inStream</code> - 包含对等方生成的令牌的InputStream。</span> 
              <span>在第一次调用时忽略此参数，因为此时没有或将从对等方接收到令牌。</span> 
             </dd> 
             <dd> 
              <span><code>outStream</code> - 将写入输出令牌的OutputStream。</span> 
              <span>在上下文建立的最后阶段，可能没有写入字节。</span> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <span>写入OutputStream的字节数，作为要发送给对等方的令牌的一部分。</span> 
              <span>值为0表示不需要发送令牌。</span> 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></code> -包含以下主要错误代码： 
              <a href="GSSException.html#DEFECTIVE_TOKEN"><code>GSSException.DEFECTIVE_TOKEN</code></a> ， 
              <a href="GSSException.html#BAD_MIC"><code>GSSException.BAD_MIC</code></a> ， 
              <a href="GSSException.html#NO_CRED"><code>GSSException.NO_CRED</code></a> ， 
              <a href="GSSException.html#CREDENTIALS_EXPIRED"><code>GSSException.CREDENTIALS_EXPIRED</code></a> ， 
              <a href="GSSException.html#BAD_BINDINGS"><code>GSSException.BAD_BINDINGS</code></a> ， 
              <a href="GSSException.html#OLD_TOKEN"><code>GSSException.OLD_TOKEN</code></a> ， 
              <a href="GSSException.html#DUPLICATE_TOKEN"><code>GSSException.DUPLICATE_TOKEN</code></a> ， 
              <a href="GSSException.html#BAD_NAMETYPE"><code>GSSException.BAD_NAMETYPE</code></a> ， 
              <a href="GSSException.html#BAD_MECH"><code>GSSException.BAD_MECH</code></a> ， 
              <a href="GSSException.html#FAILURE"><code>GSSException.FAILURE</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="acceptSecContext(byte[],int,int)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>acceptSecContext</h4> <pre class="methodSignature">byte[]&nbsp;acceptSecContext​(byte[]&nbsp;inToken,
                        int&nbsp;offset,
                        int&nbsp;len)
                 throws <a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></pre> 
            <div class="block"> 
             <span>在从对等方接收到令牌时由上下文接受方调用。</span> 
             <span>此方法可能会返回一个输出令牌，应用程序需要将该令牌发送给对等方，以便通过其<code>initSecContext</code>调用进行进一步处理。</span> 
             <p> <span>应用程序可以调用<a href="#isEstablished()"><code>isEstablished</code></a>来确定该对等方是否完成了上下文建立阶段。</span> <span>的返回值<code>false</code>从<code>isEstablished</code>表明更多的标记，预计将要提供给该方法。</span> <span>完成上下文建立后，可以通过get方法查询可用的上下文选项。</span> </p> 
             <p> <span>请注意， <code>acceptSecContext</code>可能会为对等<code>acceptSecContext</code>返回令牌，而<code>true</code>也<code>isEstablished</code>返回<code>true</code> 。</span> <span>这表示需要将令牌发送给对等体，但现在完全建立了上下文的本地端。</span> </p> 
             <p> <span>某些机制提供程序可能要求授予调用方接受安全上下文的权限。</span> <span>权限检查失败可能导致从此方法抛出<a href="../../../../java.base/java/lang/SecurityException.html" title="java.lang中的类"><code>SecurityException</code></a> 。</span> </p> 
             <p> <span>以下示例代码演示了如何使用此方法：</span> </p> 
             <pre>  <span>byte[] inToken;
     byte[] outToken;
     GSSContext context ...

     // Loop while there is still a token to be processed

     while (!context.isEstablished()) {
         inToken = readToken();
         outToken = context.acceptSecContext(inToken, 0,
                                             inToken.length);
         // send output token if generated
         if (outToken != null)
             sendToken(outToken);
     }</span> </pre> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>inToken</code> - 对等 
              <code>inToken</code>令牌。 
             </dd> 
             <dd> 
              <code>offset</code> - 令牌开始的inToken中的偏移量。 
             </dd> 
             <dd> 
              <code>len</code> - 令牌的长度。 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <span>包含要发送给对等方的令牌的byte []。</span> 
              <span><code>null</code>表示没有生成令牌。</span> 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></code> -包含以下主要错误代码： 
              <a href="GSSException.html#DEFECTIVE_TOKEN"><code>GSSException.DEFECTIVE_TOKEN</code></a> ， 
              <a href="GSSException.html#BAD_MIC"><code>GSSException.BAD_MIC</code></a> ， 
              <a href="GSSException.html#NO_CRED"><code>GSSException.NO_CRED</code></a> ， 
              <a href="GSSException.html#CREDENTIALS_EXPIRED"><code>GSSException.CREDENTIALS_EXPIRED</code></a> ， 
              <a href="GSSException.html#BAD_BINDINGS"><code>GSSException.BAD_BINDINGS</code></a> ， 
              <a href="GSSException.html#OLD_TOKEN"><code>GSSException.OLD_TOKEN</code></a> ， 
              <a href="GSSException.html#DUPLICATE_TOKEN"><code>GSSException.DUPLICATE_TOKEN</code></a> ， 
              <a href="GSSException.html#BAD_MECH"><code>GSSException.BAD_MECH</code></a> ， 
              <a href="GSSException.html#FAILURE"><code>GSSException.FAILURE</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="acceptSecContext(java.io.InputStream,java.io.OutputStream)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>acceptSecContext</h4> <pre class="methodSignature"><a href="../../../../java.base/java/lang/Deprecated.html" title="annotation in java.lang">@Deprecated</a>(<a href="../../../../java.base/java/lang/Deprecated.html#since()">since</a>="11")
void&nbsp;acceptSecContext​(<a href="../../../../java.base/java/io/InputStream.html" title="class in java.io">InputStream</a>&nbsp;inStream,
                      <a href="../../../../java.base/java/io/OutputStream.html" title="class in java.io">OutputStream</a>&nbsp;outStream)
               throws <a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></pre> 
            <div class="deprecationBlock"> 
             <span class="deprecatedLabel">Deprecated.</span> 
             <div class="deprecationComment">
               The stream-based methods have been removed from RFC 8353. Use 
              <a href="#acceptSecContext(byte%5B%5D,int,int)"><code>acceptSecContext(byte[], int, int)</code></a> instead. 
             </div> 
            </div> 
            <div class="block"> 
             <span>由上下文接受器调用以使用流处理来自对等方的令牌。</span> 
             <span>它可以将输出令牌写入<code>OutputStream</code> ，应用程序需要将其发送给对等方以便通过其<code>initSecContext</code>方法进行处理。</span> 
             <span>通常，应用程序将通过调用确保此<a href="../../../../java.base/java/io/OutputStream.html#flush()"><code>flush</code></a>上的方法<code>OutputStream</code> ，它封装了两个对等体之间的连接。</span> 
             <span>应用程序可以调用<a href="#isEstablished()"><code>isEstablished</code></a>来确定上下文建立阶段是否在上下文的这一侧完成。</span> 
             <span>的返回值<code>false</code>从<code>isEstablished</code>表明更多的标记，预计将被供应到<code>acceptSecContext</code> 。</span> 
             <span>完成上下文建立后，可以通过get方法查询可用的上下文选项。</span> 
             <p> <span>请注意， <code>acceptSecContext</code>可能会为对等<code>acceptSecContext</code>返回令牌，而<code>true</code>也<code>isEstablished</code>返回<code>true</code> 。</span> <span>这表示需要将令牌发送给对等体，但现在完全建立了上下文的本地端。</span> </p> 
             <p> <span>GSS-API身份验证令牌包含明确的开始和结束。</span> <span>此方法将尝试每次调用读取其中一个标记，并且如果只有部分令牌可用，则可能会阻塞流。</span> <span>在所有其他方面，此方法等效于基于字节数组的<a href="#acceptSecContext(byte%5B%5D,int,int)"><code>acceptSecContext</code></a> 。</span> </p> 
             <p> <span>某些机制提供程序可能要求授予调用方接受安全上下文的权限。</span> <span>权限检查失败可能导致从此方法抛出<a href="../../../../java.base/java/lang/SecurityException.html" title="java.lang中的类"><code>SecurityException</code></a> 。</span> </p> 
             <p> <span>以下示例代码演示了如何使用此方法：</span> </p> 
             <pre>  <span>InputStream is ...
     OutputStream os ...
     GSSContext context ...

     // Loop while there is still a token to be processed

     while (!context.isEstablished()) {

         context.acceptSecContext(is, os);

         // send output token if generated
         os.flush();
     }</span> </pre> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>inStream</code> - 包含对等方生成的令牌的InputStream。 
             </dd> 
             <dd> 
              <span><code>outStream</code> - 将写入输出令牌的OutputStream。</span> 
              <span>在上下文建立的最后阶段，可能没有写入字节。</span> 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></code> -包含以下主要错误代码： 
              <a href="GSSException.html#DEFECTIVE_TOKEN"><code>GSSException.DEFECTIVE_TOKEN</code></a> ， 
              <a href="GSSException.html#BAD_MIC"><code>GSSException.BAD_MIC</code></a> ， 
              <a href="GSSException.html#NO_CRED"><code>GSSException.NO_CRED</code></a> ， 
              <a href="GSSException.html#CREDENTIALS_EXPIRED"><code>GSSException.CREDENTIALS_EXPIRED</code></a> ， 
              <a href="GSSException.html#BAD_BINDINGS"><code>GSSException.BAD_BINDINGS</code></a> ， 
              <a href="GSSException.html#OLD_TOKEN"><code>GSSException.OLD_TOKEN</code></a> ， 
              <a href="GSSException.html#DUPLICATE_TOKEN"><code>GSSException.DUPLICATE_TOKEN</code></a> ， 
              <a href="GSSException.html#BAD_MECH"><code>GSSException.BAD_MECH</code></a> ， 
              <a href="GSSException.html#FAILURE"><code>GSSException.FAILURE</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="isEstablished()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>isEstablished</h4> <pre class="methodSignature">boolean&nbsp;isEstablished()</pre> 
            <div class="block">
              在上下文建立期间用于确定上下文的状态。 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd> 
              <code>true</code>如果这是呼叫方的完全建立的上下文，则不需要来自对等方的更多令牌。 
             </dd> 
            </dl> </li> 
          </ul> <a id="dispose()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>dispose</h4> <pre class="methodSignature">void&nbsp;dispose()
      throws <a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></pre> 
            <div class="block">
              释放存储在上下文对象中的任何系统资源和加密信息，并使上下文无效。 
            </div> 
            <dl> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></code> - 包含以下主要错误代码： 
              <a href="GSSException.html#FAILURE"><code>GSSException.FAILURE</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getWrapSizeLimit(int,boolean,int)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getWrapSizeLimit</h4> <pre class="methodSignature">int&nbsp;getWrapSizeLimit​(int&nbsp;qop,
                     boolean&nbsp;confReq,
                     int&nbsp;maxTokenSize)
              throws <a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></pre> 
            <div class="block"> 
             <span>用于确定可以传递给<code>wrap</code>的消息大小的限制。</span> 
             <span>返回最大消息大小，如果使用相同的<code>confReq</code>和<code>qop</code>参数提供给<code>wrap</code>方法，将导致输出标记包含不超过<code>maxTokenSize</code>个字节。</span> 
             <p> <span>此调用旨在供通过最大消息大小的协议进行通信的应用程序使用。</span> <span>它使应用程序能够在应用保护之前对消息进行分段。</span> </p> 
             <p> <span>建议使用GSS-API实现，但在<code>getWrapSizeLimit</code>时不需要检测无效的QOP值。</span> <span>此例程仅保证最大消息大小，而不保证消息保护的特定QOP值的可用性。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>qop</code> - 将要求提供保护包装的级别。 
             </dd> 
             <dd> 
              <code>confReq</code> - 
              <code>true</code>如果要求包装提供隐私， 
              <code>false</code> 。 
             </dd> 
             <dd> 
              <code>maxTokenSize</code> - 包装发出的令牌所需的最大大小。 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               给定输出令牌大小的输入令牌的最大大小 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></code> -包含以下主要错误代码： 
              <a href="GSSException.html#CONTEXT_EXPIRED"><code>GSSException.CONTEXT_EXPIRED</code></a> ， 
              <a href="GSSException.html#BAD_QOP"><code>GSSException.BAD_QOP</code></a> ， 
              <a href="GSSException.html#FAILURE"><code>GSSException.FAILURE</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="wrap(byte[],int,int,org.ietf.jgss.MessageProp)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>wrap</h4> <pre class="methodSignature">byte[]&nbsp;wrap​(byte[]&nbsp;inBuf,
            int&nbsp;offset,
            int&nbsp;len,
            <a href="MessageProp.html" title="class in org.ietf.jgss">MessageProp</a>&nbsp;msgProp)
     throws <a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></pre> 
            <div class="block"> 
             <span>在已建立的安全上下文中应用每个消息的安全服务。</span> 
             <span>该方法将返回一个令牌，其中包含应用程序提供的数据和一个加密MIC。</span> 
             <span>如果请求机密性（隐私），则可以加密数据。</span> 
             <p> <span>MessageProp对象由应用程序实例化，用于指定选择加密算法的QOP值，以及可选地加密消息的隐私服务。</span> <span>呼叫中使用的基础机制可能无法提供隐私服务。</span> <span>它设置它在此MessageProp对象中提供的实际隐私服务，然后调用者应在返回时进行查询。</span> <span>如果该机制无法提供所请求的QOP，则会抛出带有BAD_QOP代码的GSSException。</span> </p> 
             <p> <span>由于某些应用程序级协议可能希望使用由wrap发出的令牌来提供“安全框架”，因此实现应该支持包含零长度消息。</span> </p> 
             <p> <span>应用程序将负责将令牌发送给对等方。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>inBuf</code> - 要保护的应用程序数据。 
             </dd> 
             <dd> 
              <code>offset</code> - 数据开始的inBuf中的偏移量。 
             </dd> 
             <dd> 
              <code>len</code> - 数据的长度 
             </dd> 
             <dd> 
              <span><code>msgProp</code> - 应用程序用于设置所需QOP和隐私状态的MessageProp实例。</span> 
              <span>将所需的QOP设置为0以请求默认QOP。</span> 
              <span>从此方法返回时，此对象将包含底层机制应用于消息的实际隐私状态。</span> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               包含要发送给对等方的令牌的byte []。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></code> -包含以下主要错误代码： 
              <a href="GSSException.html#CONTEXT_EXPIRED"><code>GSSException.CONTEXT_EXPIRED</code></a> ， 
              <a href="GSSException.html#BAD_QOP"><code>GSSException.BAD_QOP</code></a> ， 
              <a href="GSSException.html#FAILURE"><code>GSSException.FAILURE</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="wrap(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>wrap</h4> <pre class="methodSignature"><a href="../../../../java.base/java/lang/Deprecated.html" title="annotation in java.lang">@Deprecated</a>(<a href="../../../../java.base/java/lang/Deprecated.html#since()">since</a>="11")
void&nbsp;wrap​(<a href="../../../../java.base/java/io/InputStream.html" title="class in java.io">InputStream</a>&nbsp;inStream,
          <a href="../../../../java.base/java/io/OutputStream.html" title="class in java.io">OutputStream</a>&nbsp;outStream,
          <a href="MessageProp.html" title="class in org.ietf.jgss">MessageProp</a>&nbsp;msgProp)
   throws <a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></pre> 
            <div class="deprecationBlock"> 
             <span class="deprecatedLabel">Deprecated.</span> 
             <div class="deprecationComment">
               The stream-based methods have been removed from RFC 8353. Use 
              <a href="#wrap(byte%5B%5D,int,int,org.ietf.jgss.MessageProp)"><code>wrap(byte[], int, int, MessageProp)</code></a> instead. 
             </div> 
            </div> 
            <div class="block"> 
             <span>使用流在已建立的安全上下文中应用每个消息安全服务。</span> 
             <span>该方法将返回一个令牌，其中包含应用程序提供的数据和一个加密MIC。</span> 
             <span>如果请求机密性（隐私），则可以加密数据。</span> 
             <span>此方法相当于基于字节数组的<a href="#wrap(byte%5B%5D,int,int,org.ietf.jgss.MessageProp)"><code>wrap</code></a>方法。</span> 
             <p> <span>应用程序将负责将令牌发送给对等方。</span> <span>通常，应用程序将通过调用确保此<a href="../../../../java.base/java/io/OutputStream.html#flush()"><code>flush</code></a>上的方法<code>OutputStream</code> ，它封装了两个对等体之间的连接。</span> </p> 
             <p> <span>MessageProp对象由应用程序实例化，用于指定选择加密算法的QOP值，以及可选地加密消息的隐私服务。</span> <span>呼叫中使用的基础机制可能无法提供隐私服务。</span> <span>它设置它在此MessageProp对象中提供的实际隐私服务，然后调用者应在返回时进行查询。</span> <span>如果该机制无法提供所请求的QOP，则会抛出带有BAD_QOP代码的GSSException。</span> </p> 
             <p> <span>由于某些应用程序级协议可能希望使用由wrap发出的令牌来提供“安全框架”，因此实现应该支持包含零长度消息。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <span><code>inStream</code> - 包含要保护的应用程序数据的InputStream。</span> 
              <span>使用inStream中可用的所有数据。</span> 
             </dd> 
             <dd> 
              <code>outStream</code> - 用于将受保护消息写入的OutputStream。 
             </dd> 
             <dd> 
              <span><code>msgProp</code> - 应用程序用于设置所需QOP和隐私状态的MessageProp实例。</span> 
              <span>将所需的QOP设置为0以请求默认QOP。</span> 
              <span>从此方法返回时，此对象将包含底层机制应用于消息的实际隐私状态。</span> 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></code> -包含以下主要错误代码： 
              <a href="GSSException.html#CONTEXT_EXPIRED"><code>GSSException.CONTEXT_EXPIRED</code></a> ， 
              <a href="GSSException.html#BAD_QOP"><code>GSSException.BAD_QOP</code></a> ， 
              <a href="GSSException.html#FAILURE"><code>GSSException.FAILURE</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="unwrap(byte[],int,int,org.ietf.jgss.MessageProp)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>unwrap</h4> <pre class="methodSignature">byte[]&nbsp;unwrap​(byte[]&nbsp;inBuf,
              int&nbsp;offset,
              int&nbsp;len,
              <a href="MessageProp.html" title="class in org.ietf.jgss">MessageProp</a>&nbsp;msgProp)
       throws <a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></pre> 
            <div class="block"> 
             <span>用于处理上下文另一侧的<code>wrap</code>方法生成的令牌。</span> 
             <span>该方法将对等应用程序提供的消息返回到其包装调用，同时验证该消息的嵌入式MIC。</span> 
             <p> <span>MessageProp对象由应用程序实例化，并由底层机制用于将信息返回给调用者，例如QOP，是否对消息应用了机密性，以及其他补充消息状态信息。</span> </p> 
             <p> <span>由于某些应用程序级协议可能希望使用wrap发出的令牌来提供“安全框架”，因此实现应支持对零长度消息进行打包和解包。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>inBuf</code> - 包含从对等方接收的包装令牌的字节数组。 
             </dd> 
             <dd> 
              <code>offset</code> - 令牌开始的偏移量。 
             </dd> 
             <dd> 
              <code>len</code> - 令牌的长度 
             </dd> 
             <dd> 
              <code>msgProp</code> - 从方法返回时，此对象将包含应用的QOP，消息的隐私状态以及补充信息，表明令牌是重复的，旧的，不按顺序还是在间隙之后到达。 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               包含从输入令牌解包的消息的byte []。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></code> -包含以下主要错误代码： 
              <a href="GSSException.html#DEFECTIVE_TOKEN"><code>GSSException.DEFECTIVE_TOKEN</code></a> ， 
              <a href="GSSException.html#BAD_MIC"><code>GSSException.BAD_MIC</code></a> ， 
              <a href="GSSException.html#CONTEXT_EXPIRED"><code>GSSException.CONTEXT_EXPIRED</code></a> ， 
              <a href="GSSException.html#FAILURE"><code>GSSException.FAILURE</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="unwrap(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>unwrap</h4> <pre class="methodSignature"><a href="../../../../java.base/java/lang/Deprecated.html" title="annotation in java.lang">@Deprecated</a>(<a href="../../../../java.base/java/lang/Deprecated.html#since()">since</a>="11")
void&nbsp;unwrap​(<a href="../../../../java.base/java/io/InputStream.html" title="class in java.io">InputStream</a>&nbsp;inStream,
            <a href="../../../../java.base/java/io/OutputStream.html" title="class in java.io">OutputStream</a>&nbsp;outStream,
            <a href="MessageProp.html" title="class in org.ietf.jgss">MessageProp</a>&nbsp;msgProp)
     throws <a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></pre> 
            <div class="deprecationBlock"> 
             <span class="deprecatedLabel">Deprecated.</span> 
             <div class="deprecationComment">
               The stream-based methods have been removed from RFC 8353. Use 
              <a href="#unwrap(byte%5B%5D,int,int,org.ietf.jgss.MessageProp)"><code>unwrap(byte[], int, int, MessageProp)</code></a> instead. 
             </div> 
            </div> 
            <div class="block"> 
             <span>使用流来处理由上下文另一侧的<code>wrap</code>方法生成的令牌。</span> 
             <span>该方法将对等应用程序提供的消息返回到其包装调用，同时验证该消息的嵌入式MIC。</span> 
             <p> <span>MessageProp对象由应用程序实例化，并由底层机制用于将信息返回给调用者，例如QOP，是否对消息应用了机密性，以及其他补充消息状态信息。</span> </p> 
             <p> <span>由于某些应用程序级协议可能希望使用wrap发出的令牌来提供“安全框架”，因此实现应支持对零长度消息进行打包和解包。</span> </p> 
             <p> <span>此方法读取的输入标记的格式在将使用的基础机制的规范中定义。</span> <span>此方法将尝试每次调用读取其中一个标记。</span> <span>如果机制令牌包含明确的开始和结束，则此方法可能会阻止<code>InputStream</code>如果只有部分令牌可用）。</span> <span>如果令牌的开头和结尾不是确定的，则该方法将尝试将所有可用字节视为令牌的一部分。</span> </p> 
             <p> <span>除了上面描述的可能的阻塞行为之外，该方法等效于基于字节数组的<a href="#unwrap(byte%5B%5D,int,int,org.ietf.jgss.MessageProp)"><code>unwrap</code></a>方法。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>inStream</code> - 包含对等方生成的包装令牌的InputStream。 
             </dd> 
             <dd> 
              <code>outStream</code> - 用于将应用程序消息写入的OutputStream。 
             </dd> 
             <dd> 
              <code>msgProp</code> - 从方法返回时，此对象将包含应用的QOP，消息的隐私状态以及说明令牌是重复，旧，不按顺序还是在间隙之后到达的补充信息。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></code> -包含以下主要错误代码： 
              <a href="GSSException.html#DEFECTIVE_TOKEN"><code>GSSException.DEFECTIVE_TOKEN</code></a> ， 
              <a href="GSSException.html#BAD_MIC"><code>GSSException.BAD_MIC</code></a> ， 
              <a href="GSSException.html#CONTEXT_EXPIRED"><code>GSSException.CONTEXT_EXPIRED</code></a> ， 
              <a href="GSSException.html#FAILURE"><code>GSSException.FAILURE</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getMIC(byte[],int,int,org.ietf.jgss.MessageProp)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getMIC</h4> <pre class="methodSignature">byte[]&nbsp;getMIC​(byte[]&nbsp;inMsg,
              int&nbsp;offset,
              int&nbsp;len,
              <a href="MessageProp.html" title="class in org.ietf.jgss">MessageProp</a>&nbsp;msgProp)
       throws <a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></pre> 
            <div class="block"> 
             <span>返回包含所提供消息的加密消息完整性代码（MIC）的标记，以便传输到对等应用程序。</span> 
             <span>与wrap（用于将用户消息封装在返回的令牌中）不同，在输出令牌中仅返回消息MIC。</span> 
             <p> <span>请注意，隐私只能通过包装调用来应用。</span> </p> 
             <p> <span>由于某些应用级协议可能希望使用getMIC发出的令牌来提供“安全帧”，因此实现应该支持从零长度消息中推导出MIC。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>inMsg</code> - 生成MIC的消息。 
             </dd> 
             <dd> 
              <code>offset</code> - 消息开始的inMsg内的偏移量。 
             </dd> 
             <dd> 
              <code>len</code> - 消息的长度 
             </dd> 
             <dd> 
              <span><code>msgProp</code> - 应用程序用于设置所需QOP的<code>MessageProp</code>实例。</span> 
              <span>设置需要的QOP到<code>0</code>在<code>msgProp</code>来请求默认QOP。</span> 
              <span>或者，传入<code>null</code>以获取<code>msgProp</code>以请求默认QOP。</span> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               包含要发送给对等方的令牌的byte []。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></code> -包含以下主要错误代码： 
              <a href="GSSException.html#CONTEXT_EXPIRED"><code>GSSException.CONTEXT_EXPIRED</code></a> ， 
              <a href="GSSException.html#BAD_QOP"><code>GSSException.BAD_QOP</code></a> ， 
              <a href="GSSException.html#FAILURE"><code>GSSException.FAILURE</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getMIC(java.io.InputStream,java.io.OutputStream,org.ietf.jgss.MessageProp)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getMIC</h4> <pre class="methodSignature"><a href="../../../../java.base/java/lang/Deprecated.html" title="annotation in java.lang">@Deprecated</a>(<a href="../../../../java.base/java/lang/Deprecated.html#since()">since</a>="11")
void&nbsp;getMIC​(<a href="../../../../java.base/java/io/InputStream.html" title="class in java.io">InputStream</a>&nbsp;inStream,
            <a href="../../../../java.base/java/io/OutputStream.html" title="class in java.io">OutputStream</a>&nbsp;outStream,
            <a href="MessageProp.html" title="class in org.ietf.jgss">MessageProp</a>&nbsp;msgProp)
     throws <a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></pre> 
            <div class="deprecationBlock"> 
             <span class="deprecatedLabel">Deprecated.</span> 
             <div class="deprecationComment">
               The stream-based methods have been removed from RFC 8353. Use 
              <a href="#getMIC(byte%5B%5D,int,int,org.ietf.jgss.MessageProp)"><code>getMIC(byte[], int, int, MessageProp)</code></a> instead. 
             </div> 
            </div> 
            <div class="block"> 
             <span>使用流生成包含所提供消息的加密MIC的令牌，以便传输到对等应用程序。</span> 
             <span>与将用户消息封装在返回的令牌中的wrap不同，只在输出令牌中生成消息MIC。</span> 
             <span>此方法相当于基于字节数组的<a href="#getMIC(byte%5B%5D,int,int,org.ietf.jgss.MessageProp)"><code>getMIC</code></a>方法。</span> 
             <span>请注意，隐私只能通过包装调用来应用。</span> 
             <p> <span>由于某些应用级协议可能希望使用getMIC发出的令牌来提供“安全帧”，因此实现应该支持从零长度消息中推导出MIC。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <span><code>inStream</code> - 包含生成MIC的消息的InputStream。</span> 
              <span>使用inStream中可用的所有数据。</span> 
             </dd> 
             <dd> 
              <code>outStream</code> - 用于将输出标记写入的OutputStream。 
             </dd> 
             <dd> 
              <span><code>msgProp</code> - 应用程序用于设置所需QOP的<code>MessageProp</code>的实例。</span> 
              <span>设置需要的QOP到<code>0</code>在<code>msgProp</code>来请求默认QOP。</span> 
              <span>或者通过<code>null</code>传递<code>msgProp</code>以请求默认QOP。</span> 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></code> -包含以下主要错误代码： 
              <a href="GSSException.html#CONTEXT_EXPIRED"><code>GSSException.CONTEXT_EXPIRED</code></a> ， 
              <a href="GSSException.html#BAD_QOP"><code>GSSException.BAD_QOP</code></a> ， 
              <a href="GSSException.html#FAILURE"><code>GSSException.FAILURE</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="verifyMIC(byte[],int,int,byte[],int,int,org.ietf.jgss.MessageProp)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>verifyMIC</h4> <pre class="methodSignature">void&nbsp;verifyMIC​(byte[]&nbsp;inToken,
               int&nbsp;tokOffset,
               int&nbsp;tokLen,
               byte[]&nbsp;inMsg,
               int&nbsp;msgOffset,
               int&nbsp;msgLen,
               <a href="MessageProp.html" title="class in org.ietf.jgss">MessageProp</a>&nbsp;msgProp)
        throws <a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></pre> 
            <div class="block"> 
             <span>通过提供的消息验证令牌参数中包含的加密MIC。</span> 
             <p> <span>MessageProp对象由应用程序实例化，并由底层机制用于将信息返回给调用者，例如QOP，指示应用于消息的保护强度和其他补充消息状态信息。</span> </p> 
             <p> <span>由于某些应用级协议可能希望使用getMIC发出的令牌来提供“安全帧”，因此实现应该支持在零长度消息上计算和验证MIC。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>inToken</code> - peer的getMIC方法生成的令牌。 
             </dd> 
             <dd> 
              <code>tokOffset</code> - 令牌开始的inToken内的偏移量。 
             </dd> 
             <dd> 
              <code>tokLen</code> - 令牌的长度。 
             </dd> 
             <dd> 
              <code>inMsg</code> - 用于验证加密MIC的应用程序消息。 
             </dd> 
             <dd> 
              <code>msgOffset</code> - 消息开始的inMsg中的偏移量。 
             </dd> 
             <dd> 
              <code>msgLen</code> - 消息的长度。 
             </dd> 
             <dd> 
              <code>msgProp</code> - 从方法返回时，此对象将包含应用的QOP和补充信息，说明令牌是重复的，旧的，不按顺序还是在间隙之后到达。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></code> - 包含以下主要错误代码： 
              <a href="GSSException.html#DEFECTIVE_TOKEN"><code>GSSException.DEFECTIVE_TOKEN</code></a> 
              <a href="GSSException.html#BAD_MIC"><code>GSSException.BAD_MIC</code></a> 
              <a href="GSSException.html#CONTEXT_EXPIRED"><code>GSSException.CONTEXT_EXPIRED</code></a> 
              <a href="GSSException.html#FAILURE"><code>GSSException.FAILURE</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="verifyMIC(java.io.InputStream,java.io.InputStream,org.ietf.jgss.MessageProp)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>verifyMIC</h4> <pre class="methodSignature"><a href="../../../../java.base/java/lang/Deprecated.html" title="annotation in java.lang">@Deprecated</a>(<a href="../../../../java.base/java/lang/Deprecated.html#since()">since</a>="11")
void&nbsp;verifyMIC​(<a href="../../../../java.base/java/io/InputStream.html" title="class in java.io">InputStream</a>&nbsp;tokStream,
               <a href="../../../../java.base/java/io/InputStream.html" title="class in java.io">InputStream</a>&nbsp;msgStream,
               <a href="MessageProp.html" title="class in org.ietf.jgss">MessageProp</a>&nbsp;msgProp)
        throws <a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></pre> 
            <div class="deprecationBlock"> 
             <span class="deprecatedLabel">Deprecated.</span> 
             <div class="deprecationComment">
               The stream-based methods have been removed from RFC 8353. Use 
              <a href="#verifyMIC(byte%5B%5D,int,int,byte%5B%5D,int,int,org.ietf.jgss.MessageProp)"><code>verifyMIC(byte[], int, int, byte[], int, int, MessageProp)</code></a> instead. 
             </div> 
            </div> 
            <div class="block"> 
             <span>使用流来验证令牌参数中包含的加密MIC对提供的消息的影响。</span> 
             <span>此方法相当于基于字节数组的<a href="#verifyMIC(byte%5B%5D,int,int,byte%5B%5D,int,int,org.ietf.jgss.MessageProp)"><code>verifyMIC</code></a>方法。</span> 
             <span>MessageProp对象由应用程序实例化，并由底层机制用于将信息返回给调用者，例如QOP，指示应用于消息的保护强度和其他补充消息状态信息。</span> 
             <p> <span>由于某些应用级协议可能希望使用getMIC发出的令牌来提供“安全帧”，因此实现应该支持在零长度消息上计算和验证MIC。</span> </p> 
             <p> <span>此方法读取的输入标记的格式在将使用的基础机制的规范中定义。</span> <span>此方法将尝试每次调用读取其中一个标记。</span> <span>如果机制令牌包含明确的开始和结束，则此方法可能会阻止<code>InputStream</code>如果只有部分令牌可用）。</span> <span>如果令牌的开头和结尾不是确定的，则该方法将尝试将所有可用字节视为令牌的一部分。</span> </p> 
             <p> <span>除了上面描述的可能的阻塞行为之外，该方法等效于基于字节数组的<a href="#verifyMIC(byte%5B%5D,int,int,byte%5B%5D,int,int,org.ietf.jgss.MessageProp)"><code>verifyMIC</code></a>方法。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>tokStream</code> - 包含由对等方的getMIC方法生成的标记的InputStream。 
             </dd> 
             <dd> 
              <span><code>msgStream</code> - 包含用于验证加密MIC的应用程序消息的InputStream。</span> 
              <span>使用msgStream中可用的所有数据。</span> 
             </dd> 
             <dd> 
              <code>msgProp</code> - 从方法返回时，此对象将包含应用的QOP和补充信息，说明令牌是重复的，旧的，不按顺序还是在间隙之后到达。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></code> - 包含以下主要错误代码： 
              <a href="GSSException.html#DEFECTIVE_TOKEN"><code>GSSException.DEFECTIVE_TOKEN</code></a> 
              <a href="GSSException.html#BAD_MIC"><code>GSSException.BAD_MIC</code></a> 
              <a href="GSSException.html#CONTEXT_EXPIRED"><code>GSSException.CONTEXT_EXPIRED</code></a> 
              <a href="GSSException.html#FAILURE"><code>GSSException.FAILURE</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="export()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>export</h4> <pre class="methodSignature">byte[]&nbsp;export()
       throws <a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></pre> 
            <div class="block"> 
             <span>导出此上下文，以便另一个进程可以导入它。提供支持多个进程之间的工作共享。</span> 
             <span>此例程通常由上下文接受器使用，在单个进程接收传入连接请求并在其上接受安全上下文的应用程序中，然后将建立的上下文传递给一个或多个其他进程以进行消息交换。</span> 
             <p> <span>此方法停用安全上下文并创建进程间令牌，当在另一个进程中传递给<a href="GSSManager.html#createContext(byte%5B%5D)"><code>GSSManager.createContext</code></a>时，将在第二个进程中重新激活上下文。</span> <span>在任何时候，只有给定上下文的单个实例可以是活动的;</span> <span>上下文导出器随后尝试访问导出的安全上下文将失败。</span> </p> 
             <p> <span>实现可以约束可以导入进程间令牌的进程集，作为本地安全策略的函数，或者作为实现决策的结果。</span> <span>例如，某些实现可能会限制上下文仅在同一帐户下运行的进程之间传递，或者是同一进程组的一部分。</span> </p> 
             <p> <span>进程间令牌可能包含安全敏感信息（例如加密密钥）。</span> <span>虽然鼓励机制要么避免将这些敏感信息放在进程间令牌中，要么在将令牌返回给应用程序之前加密令牌，但在典型的GSS-API实现中，这可能是不可能的。</span> <span>因此，应用程序必须注意保护进程间令牌，并确保转移令牌的任何进程都是值得信赖的。</span> </p> 
             <p> <span>不需要实现来支持安全上下文的进程间转移。</span> <span>调用<a href="#isTransferable()"><code>isTransferable</code></a>方法将指示上下文对象是否可转移。</span> </p> 
             <p> <span>在不可导出的上下文上调用此方法将导致抛出此异常，错误代码为<a href="GSSException.html#UNAVAILABLE"><code>GSSException.UNAVAILABLE</code></a> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               包含导出上下文的byte [] 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></code> -包含以下主要错误代码： 
              <a href="GSSException.html#UNAVAILABLE"><code>GSSException.UNAVAILABLE</code></a> ， 
              <a href="GSSException.html#CONTEXT_EXPIRED"><code>GSSException.CONTEXT_EXPIRED</code></a> ， 
              <a href="GSSException.html#NO_CONTEXT"><code>GSSException.NO_CONTEXT</code></a> ， 
              <a href="GSSException.html#FAILURE"><code>GSSException.FAILURE</code></a> 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="GSSManager.html#createContext(byte%5B%5D)"><code>GSSManager.createContext(byte[])</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="requestMutualAuth(boolean)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>requestMutualAuth</h4> <pre class="methodSignature">void&nbsp;requestMutualAuth​(boolean&nbsp;state)
                throws <a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></pre> 
            <div class="block"> 
             <span>请求在上下文建立期间完成相互身份验证。</span> 
             <span>此请求只能在上下文发起方一方进行，并且必须在第一次调用<code>initSecContext</code>之前完成。</span> 
             <p> <span>并非所有机制都支持相互身份验证，某些机制可能需要相互身份验证，即使应用程序没有。</span> <span>因此，应用程序应检查请求是否符合<a href="#getMutualAuthState()"><code>getMutualAuthState</code></a>方法。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>state</code> - 一个布尔值，指示是否应使用相互身份验证。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></code> - 包含以下主要错误代码： 
              <a href="GSSException.html#FAILURE"><code>GSSException.FAILURE</code></a> 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#getMutualAuthState()"><code>getMutualAuthState()</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="requestReplayDet(boolean)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>requestReplayDet</h4> <pre class="methodSignature">void&nbsp;requestReplayDet​(boolean&nbsp;state)
               throws <a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></pre> 
            <div class="block"> 
             <span>请求在上下文建立后为每个消息的安全服务启用重放检测。</span> 
             <span>此请求只能在上下文发起方一方进行，并且必须在第一次调用<code>initSecContext</code>之前完成。</span> 
             <span>在上下文建立期间，重放检测不是一种选择，而是底层机制能力的函数。</span> 
             <p> <span>并非所有机制都支持重放检测，并且某些机制可能需要重放检测，即使应用程序没有。</span> <span>因此，应用程序应检查请求是否符合<a href="#getReplayDetState()"><code>getReplayDetState</code></a>方法。</span> <span>如果启用了重放检测，则<a href="MessageProp.html#isDuplicateToken()"><code>MessageProp.isDuplicateToken</code></a>和<a href="MessageProp.html#isOldToken()"><code>MessageProp.isOldToken</code></a>方法将返回传递给<code>unwrap</code>方法或<code>verifyMIC</code>方法的<code>MessageProp</code>对象的有效结果。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>state</code> - 一个布尔值，指示是否应在已建立的上下文中启用重放检测。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></code> - 包含以下主要错误代码： 
              <a href="GSSException.html#FAILURE"><code>GSSException.FAILURE</code></a> 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#getReplayDetState()"><code>getReplayDetState()</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="requestSequenceDet(boolean)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>requestSequenceDet</h4> <pre class="methodSignature">void&nbsp;requestSequenceDet​(boolean&nbsp;state)
                 throws <a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></pre> 
            <div class="block"> 
             <span>请求在上下文建立后为每个消息的安全服务启用序列检查。</span> 
             <span>此请求只能在上下文发起方一方进行，并且必须在第一次调用<code>initSecContext</code>之前完成。</span> 
             <span>在上下文建立期间，序列检查不是一个选项，而是底层机制功能的函数。</span> 
             <p> <span>并非所有机制都支持序列检查，并且某些机制可能需要序列检查，即使应用程序没有。</span> <span>因此，应用程序应检查请求是否符合<a href="#getSequenceDetState()"><code>getSequenceDetState</code></a>方法。</span> <span>如果序列检查已启用，则<a href="MessageProp.html#isDuplicateToken()"><code>MessageProp.isDuplicateToken</code></a> ， <a href="MessageProp.html#isOldToken()"><code>MessageProp.isOldToken</code></a> ， <a href="MessageProp.html#isUnseqToken()"><code>MessageProp.isUnseqToken</code></a>和<a href="MessageProp.html#isGapToken()"><code>MessageProp.isGapToken</code></a>方法将返回有效的结果<code>MessageProp</code>即到传递的对象<code>unwrap</code>方法或<code>verifyMIC</code>方法。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>state</code> - 一个布尔值，指示是否应在已建立的上下文中启用序列检查。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></code> - 包含以下主要错误代码： 
              <a href="GSSException.html#FAILURE"><code>GSSException.FAILURE</code></a> 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#getSequenceDetState()"><code>getSequenceDetState()</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="requestCredDeleg(boolean)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>requestCredDeleg</h4> <pre class="methodSignature">void&nbsp;requestCredDeleg​(boolean&nbsp;state)
               throws <a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></pre> 
            <div class="block"> 
             <span>请求在上下文建立期间将发起者的凭证委托给接受者。</span> 
             <span>此请求只能在上下文发起方一方进行，并且必须在第一次调用<code>initSecContext</code>之前完成。</span> 
             <span>并非所有机制都支持凭证委派。</span> 
             <span>因此，希望委派的应用程序应检查该请求是否符合<a href="#getCredDelegState()"><code>getCredDelegState</code></a>方法。</span> 
             <span>如果应用程序指示不得使用委托，则该机制将遵循该请求并且不会发生委托。</span> 
             <span>这是一般规则的例外，即即使未请求服务，机制也可以启用服务。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>state</code> - 一个布尔值，指示是否应委派凭据。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></code> - 包含以下主要错误代码： 
              <a href="GSSException.html#FAILURE"><code>GSSException.FAILURE</code></a> 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#getCredDelegState()"><code>getCredDelegState()</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="requestAnonymity(boolean)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>requestAnonymity</h4> <pre class="methodSignature">void&nbsp;requestAnonymity​(boolean&nbsp;state)
               throws <a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></pre> 
            <div class="block"> 
             <span>要求不向接收方披露发起人的身份。</span> 
             <span>此请求只能在上下文发起方一方进行，并且必须在第一次调用<code>initSecContext</code>之前完成。</span> 
             <span>并非所有机制都支持发起者的匿名性。</span> 
             <span>因此，应用程序应检查请求是否符合<a href="#getAnonymityState()"><code>getAnonymityState</code></a>方法。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>state</code> - 一个布尔值，指示是否应将启动器作为匿名主体对接受者进行身份验证。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></code> - 包含以下主要错误代码： 
              <a href="GSSException.html#FAILURE"><code>GSSException.FAILURE</code></a> 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#getAnonymityState()"><code>getAnonymityState()</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="requestConf(boolean)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>requestConf</h4> <pre class="methodSignature">void&nbsp;requestConf​(boolean&nbsp;state)
          throws <a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></pre> 
            <div class="block"> 
             <span>请求为<code>wrap</code>方法启用数据机密性。</span> 
             <span>此请求只能在上下文发起方一方进行，并且必须在第一次调用<code>initSecContext</code>之前完成。</span> 
             <span>并非所有机制都支持机密性，即使应用程序没有请求，其他机制也可能启用它。</span> 
             <span>应用程序可能会检查请求是否符合<a href="#getConfState()"><code>getConfState</code></a>方法。</span> 
             <span>如果启用了机密性，则机制才会在传递给<code>wrap</code>方法的<a href="MessageProp.html#%3Cinit%3E(int,boolean)"><code>MessageProp</code></a>对象中遵守隐私请求。</span> 
             <p> <span>启用机密性还将自动启用完整性。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>state</code> - 一个布尔值，指示是否应启用机密性。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></code> - 包含以下主要错误代码： 
              <a href="GSSException.html#FAILURE"><code>GSSException.FAILURE</code></a> 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <span><a href="#getConfState()"><code>getConfState()</code></a> ， <a href="#getIntegState()"><code>getIntegState()</code></a> ， <a href="#requestInteg(boolean)"><code>requestInteg(boolean)</code></a> ， <a href="MessageProp.html" title="org.ietf.jgss中的类"><code>MessageProp</code></a></span> 
             </dd> 
            </dl> </li> 
          </ul> <a id="requestInteg(boolean)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>requestInteg</h4> <pre class="methodSignature">void&nbsp;requestInteg​(boolean&nbsp;state)
           throws <a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></pre> 
            <div class="block"> 
             <span>请求为<code>wrap</code>和<code>getMIC</code>方法启用数据完整性。</span> 
             <span>此请求只能在上下文发起方一方进行，并且必须在第一次调用<code>initSecContext</code>之前完成。</span> 
             <span>并非所有机制都支持完整性，即使应用程序没有请求它，其他机制也可能启用它。</span> 
             <span>应用程序可能会检查请求是否符合<a href="#getIntegState()"><code>getIntegState</code></a>方法。</span> 
             <p> <span>禁用完整性也会自动禁用机密性。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>state</code> - 一个布尔值，指示是否应启用完整性。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></code> - 包含以下主要错误代码： 
              <a href="GSSException.html#FAILURE"><code>GSSException.FAILURE</code></a> 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#getIntegState()"><code>getIntegState()</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="requestLifetime(int)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>requestLifetime</h4> <pre class="methodSignature">void&nbsp;requestLifetime​(int&nbsp;lifetime)
              throws <a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></pre> 
            <div class="block"> 
             <span>请求上下文的生命周期（以秒为单位）。</span> 
             <span>此方法只能在上下文发起方一方调用，必须在第一次调用<code>initSecContext</code>之前完成。</span> 
             <p> <span>上下文的实际生命周期取决于底层机制的功能，应用程序应调用<a href="#getLifetime()"><code>getLifetime</code></a>方法来确定这一点。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <span><code>lifetime</code> - 所需的上下文生存期（以秒为单位）。</span> 
              <span>使用<code>INDEFINITE_LIFETIME</code>请求无限期生命周期，使用<code>DEFAULT_LIFETIME</code>请求默认生存期。</span> 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></code> - 包含以下主要错误代码： 
              <a href="GSSException.html#FAILURE"><code>GSSException.FAILURE</code></a> 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#getLifetime()"><code>getLifetime()</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="setChannelBinding(org.ietf.jgss.ChannelBinding)"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>setChannelBinding</h4> <pre class="methodSignature">void&nbsp;setChannelBinding​(<a href="ChannelBinding.html" title="class in org.ietf.jgss">ChannelBinding</a>&nbsp;cb)
                throws <a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></pre> 
            <div class="block"> 
             <span>设置在上下文建立期间使用的通道绑定。</span> 
             <span>可以在上下文发起方和上下文接受方一起调用此方法，但必须在上下文建立开始之前调用它。</span> 
             <span>这意味着启动器必须在第一次调用<code>initSecContext</code>之前调用它，并且接收器必须在第一次调用<code>acceptSecContext</code>之前调用它。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>cb</code> - 要使用的通道绑定。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></code> - 包含以下主要错误代码： 
              <a href="GSSException.html#FAILURE"><code>GSSException.FAILURE</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getCredDelegState()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getCredDelegState</h4> <pre class="methodSignature">boolean&nbsp;getCredDelegState()</pre> 
            <div class="block"> 
             <span>确定是否在此上下文中启用了凭据委派。</span> 
             <span>它可以由上下文启动器和上下文接受器调用。</span> 
             <span>要获得明确的答案，必须在上下文建立完成后调用此方法。</span> 
             <span>请注意，如果发起方请求不允许委托，则<a href="#requestCredDeleg(boolean)"><code>requestCredDeleg</code></a>方法将<a href="#requestCredDeleg(boolean)">遵循</a>该请求，并且此方法将从该点开始在发起方返回<code>false</code> 。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               如果已启用委派，则为true，否则为false。 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#requestCredDeleg(boolean)"><code>requestCredDeleg(boolean)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getMutualAuthState()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getMutualAuthState</h4> <pre class="methodSignature">boolean&nbsp;getMutualAuthState()</pre> 
            <div class="block"> 
             <span>确定是否在此上下文中启用了相互身份验证。</span> 
             <span>它可以由上下文启动器和上下文接受器调用。</span> 
             <span>要获得明确的答案，必须在上下文建立完成后调用此方法。</span> 
             <span>请求相互身份验证的启动器可以在上下文完成后调用此方法，并在其请求未得到遵守时处置上下文。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               如果启用了相互身份验证，则为true，否则为false 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#requestMutualAuth(boolean)"><code>requestMutualAuth(boolean)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getReplayDetState()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getReplayDetState</h4> <pre class="methodSignature">boolean&nbsp;getReplayDetState()</pre> 
            <div class="block"> 
             <span>确定是否从此上下文为每个消息的安全服务启用了重放检测。</span> 
             <span>它可以由上下文启动器和上下文接受器调用。</span> 
             <span>要获得明确的答案，必须在上下文建立完成后调用此方法。</span> 
             <span>请求重放检测的启动器可以在上下文完成后调用此方法，并在其请求未被遵守时处置上下文。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               如果启用了重放检测，则为true，否则为false。 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#requestReplayDet(boolean)"><code>requestReplayDet(boolean)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getSequenceDetState()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getSequenceDetState</h4> <pre class="methodSignature">boolean&nbsp;getSequenceDetState()</pre> 
            <div class="block"> 
             <span>确定是否从此上下文为每个消息的安全服务启用了序列检查。</span> 
             <span>它可以由上下文启动器和上下文接受器调用。</span> 
             <span>要获得明确的答案，必须在上下文建立完成后调用此方法。</span> 
             <span>请求序列检查的启动器可以在上下文完成后调用此方法，并在其请求未被遵守时处置上下文。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               如果启用了序列检查，则为true，否则为false。 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#requestSequenceDet(boolean)"><code>requestSequenceDet(boolean)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getAnonymityState()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getAnonymityState</h4> <pre class="methodSignature">boolean&nbsp;getAnonymityState()</pre> 
            <div class="block"> 
             <span>确定上下文启动器是否对上下文接受器进行匿名身份验证。</span> 
             <span>它可以由上下文发起者和上下文接受者在任何时候调用。</span> 
             <span><strong>在发起者方面，对该方法的调用确定是否已在迄今为止由<code>initSecContext</code>生成的任何上下文建立令牌中公开了发起者的身份。</strong></span> 
             <span><strong>绝对必须匿名身份验证的启动器应在每次调用<code>initSecContext</code>后调用此方法，以确定是否应将生成的令牌发送到对等方或中止上下文。</strong></span> 
             <span>在接受方，对此方法的调用确定到目前为止由<code>acceptSecContext</code>处理的任何令牌是否泄露了发起者的身份。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               如果上下文启动器仍然是匿名的，则返回true，否则返回false。 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#requestAnonymity(boolean)"><code>requestAnonymity(boolean)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="isTransferable()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>isTransferable</h4> <pre class="methodSignature">boolean&nbsp;isTransferable()
                throws <a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></pre> 
            <div class="block"> 
             <span>通过使用<a href="#export()"><code>export</code></a>方法确定上下文是否可以转移到其他进程。</span> 
             <span>此调用仅在完全建立的上下文中有效。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               如果可以导出此上下文，则返回true，否则返回false。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></code> - 包含以下主要错误代码： 
              <a href="GSSException.html#FAILURE"><code>GSSException.FAILURE</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="isProtReady()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>isProtReady</h4> <pre class="methodSignature">boolean&nbsp;isProtReady()</pre> 
            <div class="block"> 
             <span>确定上下文是否已准备好对其使用的每个消息操作。</span> 
             <span>一些机制可以允许在完全建立上下文之前使用每消息操作。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               如果类似的方法真 
              <code>wrap</code> ， 
              <code>unwrap</code> ， 
              <code>getMIC</code>和 
              <code>verifyMIC</code>可以用此背景下，在上下文创建的当前阶段使用，否则为false。 
             </dd> 
            </dl> </li> 
          </ul> <a id="getConfState()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getConfState</h4> <pre class="methodSignature">boolean&nbsp;getConfState()</pre> 
            <div class="block"> 
             <span>确定上下文中是否可以使用数据机密性。</span> 
             <span>上下文启动器和上下文接受器都可以调用此方法，但仅在<a href="#isProtReady()"><code>isProtReady</code></a>或<a href="#isEstablished()"><code>isEstablished</code>之一</a>返回<code>true</code> 。</span> 
             <span>如果此方法返回<code>true</code> ，则<a href="#getIntegState()"><code>getIntegState</code></a> <code>true</code>如此</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               如果可用保密服务，则为true，否则为false。 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#requestConf(boolean)"><code>requestConf(boolean)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getIntegState()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getIntegState</h4> <pre class="methodSignature">boolean&nbsp;getIntegState()</pre> 
            <div class="block"> 
             <span>确定上下文中是否可以使用数据完整性。</span> 
             <span>上下文启动器和上下文接受器都可以调用此方法，但仅在<a href="#isProtReady()"><code>isProtReady</code></a>或<a href="#isEstablished()"><code>isEstablished</code></a>之一之后返回<code>true</code> 。</span> 
             <span>如果<a href="#getConfState()"><code>getConfState</code></a>返回true，则此方法将始终返回<code>true</code> 。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               如果提供完整性服务，则为true，否则为false。 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#requestInteg(boolean)"><code>requestInteg(boolean)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getLifetime()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getLifetime</h4> <pre class="methodSignature">int&nbsp;getLifetime()</pre> 
            <div class="block"> 
             <span>确定此上下文的剩余生命周期。</span> 
             <span>它可以由上下文启动器和上下文接受器调用，但是对于确定的答案，只有在<a href="#isEstablished()"><code>isEstablished</code></a>返回true后才应调用它。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               剩余的生命周期以秒为单位 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="#requestLifetime(int)"><code>requestLifetime(int)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getSrcName()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getSrcName</h4> <pre class="methodSignature"><a href="GSSName.html" title="interface in org.ietf.jgss">GSSName</a>&nbsp;getSrcName()
            throws <a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></pre> 
            <div class="block"> 
             <span>返回上下文启动器的名称。</span> 
             <span>此调用仅在<a href="#isProtReady()"><code>isProtReady</code></a>或<a href="#isEstablished()"><code>isEstablished</code>之一</a>返回<code>true</code>后有效。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               GSSName是包含上下文发起者名称的MN。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></code> - 包含以下主要错误代码： 
              <a href="GSSException.html#FAILURE"><code>GSSException.FAILURE</code></a> 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <span><a href="GSSName.html" title="org.ietf.jgss中的接口"><code>GSSName</code></a></span> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getTargName()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getTargName</h4> <pre class="methodSignature"><a href="GSSName.html" title="interface in org.ietf.jgss">GSSName</a>&nbsp;getTargName()
             throws <a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></pre> 
            <div class="block"> 
             <span>返回上下文接受器的名称。</span> 
             <span>此调用仅在<a href="#isProtReady()"><code>isProtReady</code></a>或<a href="#isEstablished()"><code>isEstablished</code>之一</a>返回<code>true</code>后有效。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               GSSName是包含上下文接受者名称的MN。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></code> - 包含以下主要错误代码： 
              <a href="GSSException.html#FAILURE"><code>GSSException.FAILURE</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getMech()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getMech</h4> <pre class="methodSignature"><a href="Oid.html" title="class in org.ietf.jgss">Oid</a>&nbsp;getMech()
     throws <a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></pre> 
            <div class="block"> 
             <span>确定用于此上下文的机制。</span> 
             <span>可以在完全建立上下文之前调用此方法，但是返回的机制可能会在协商机制情况下的连续调用中发生更改。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               正在使用的机制的Oid 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></code> - 包含以下主要错误代码： 
              <a href="GSSException.html#FAILURE"><code>GSSException.FAILURE</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="getDelegCred()"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>getDelegCred</h4> <pre class="methodSignature"><a href="GSSCredential.html" title="interface in org.ietf.jgss">GSSCredential</a>&nbsp;getDelegCred()
                    throws <a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></pre> 
            <div class="block"> 
             <span>获取上下文启动器委派给上下文接受器的凭据。</span> 
             <span>它应该仅在上下文接受者的一侧调用，并且一旦上下文完全建立。</span> 
             <span>调用者可以使用方法<a href="#getCredDelegState()"><code>getCredDelegState</code></a>来确定是否存在任何委派凭证。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               GSSCredential包含发起者的委派凭据，或 
              <code>null</code>没有委派凭据。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></code> - 包含以下主要错误代码： 
              <a href="GSSException.html#FAILURE"><code>GSSException.FAILURE</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="isInitiator()"> 
           <!--   --> </a> 
          <ul class="blockListLast"> 
           <li class="blockList"> <h4>isInitiator</h4> <pre class="methodSignature">boolean&nbsp;isInitiator()
             throws <a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></pre> 
            <div class="block"> 
             <span>确定这是否是上下文启动器。</span> 
             <span>这可以在上下文发起者和上下文接受者的一侧调用。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               如果这是上下文启动器，则返回true;如果是上下文接收器，则返回false。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="GSSException.html" title="class in org.ietf.jgss">GSSException</a></code> - 包含以下主要错误代码： 
              <a href="GSSException.html#FAILURE"><code>GSSException.FAILURE</code></a> 
             </dd> 
            </dl> </li> 
          </ul> </li> 
        </ul> 
       </section> </li> 
     </ul> 
    </div> 
   </div> 
  </main> 
  <!-- ========= END OF CLASS DATA ========= --> 
  <footer role="contentinfo"> 
   <nav role="navigation"> 
    <!-- ======= START OF BOTTOM NAVBAR ====== --> 
    <div class="bottomNav"> 
     <a id="navbar.bottom"> 
      <!--   --> </a> 
     <div class="skipNav"> 
      <a href="#skip.navbar.bottom" title="Skip navigation links">跳过导航</a> 
     </div> 
     <a id="navbar.bottom.firstrow"> 
      <!--   --> </a> 
     <ul class="navList" title="Navigation"> 
      <li><a href="../../../../index.html">概述</a></li> 
      <li><a href="../../../module-summary.html">模块</a></li> 
      <li><a href="package-summary.html">软件包</a></li> 
      <li class="navBarCell1Rev">类</li> 
      <li><a href="class-use/GSSContext.html">使用</a></li> 
      <li><a href="package-tree.html">树</a></li> 
      <li><a href="../../../../deprecated-list.html">已过时的</a></li> 
      <li><a href="../../../../index-files/index-1.html">索引</a></li> 
      <li><a href="../../../../help-doc.html">帮助</a></li> 
     </ul> 
     <div class="aboutLanguage"> 
      <div style="margin-top: 14px;"> 
       <strong>Java SE 11 &amp; JDK 11</strong> 
      </div> 
     </div> 
    </div> 
    <div class="subNav"> 
     <ul class="navList" id="allclasses_navbar_bottom"> 
      <li><a href="../../../../allclasses.html">所有类</a></li> 
     </ul> 
     <div> 
      <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
      <noscript> 
       <div>
         JavaScript is disabled on your browser. 
       </div> 
      </noscript> 
     </div> 
     <div> 
      <ul class="subNavList"> 
       <li>概要：&nbsp;</li> 
       <li>嵌套&nbsp;|&nbsp;</li> 
       <li><a href="#field.summary">字段</a>&nbsp;|&nbsp;</li> 
       <li>构造方法&nbsp;|&nbsp;</li> 
       <li><a href="#method.summary">方法</a></li> 
      </ul> 
      <ul class="subNavList"> 
       <li>详细信息：&nbsp;</li> 
       <li><a href="#field.detail">字段</a>&nbsp;|&nbsp;</li> 
       <li>构造方法&nbsp;|&nbsp;</li> 
       <li><a href="#method.detail">方法</a></li> 
      </ul> 
     </div> 
     <a id="skip.navbar.bottom"> 
      <!--   --> </a> 
    </div> 
    <!-- ======== END OF BOTTOM NAVBAR ======= --> 
   </nav> 
   <p class="legalCopy"><small><a href="http://bugreport.java.com/bugreport/">Report a bug or suggest an enhancement</a><br> For further API reference and developer documentation see the <a href="http://www.oracle.com/pls/topic/lookup?ctx=javase11.0.1&amp;id=homepage" target="_blank">Java SE Documentation</a>, which contains more detailed, developer-targeted descriptions with conceptual overviews, definitions of terms, workarounds, and working code examples.<br> Java is a trademark or registered trademark of Oracle and/or its affiliates in the US and other countries.<br> <a href="../../../../../legal/copyright.html">Copyright</a> © 1993, 2018, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.<br>All rights reserved. Use is subject to <a href="http://www.oracle.com/technetwork/java/javase/terms/license/java11.0.1speclicense.html">license terms</a> and the <a href="http://www.oracle.com/technetwork/java/redist-137594.html">documentation redistribution policy</a>. 
     <!-- Version 11.0.1+13-LTS --></small></p> 
  </footer>  
 </body>
</html>