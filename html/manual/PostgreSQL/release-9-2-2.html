<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>E.80. 版本9.2.2</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="release-9-2-3.html" title="E.79. 版本9.2.3" /><link rel="next" href="release-9-2-1.html" title="E.81. 版本9.2.1" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">E.80. 版本9.2.2</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="release-9-2-3.html" title="E.79. 版本9.2.3">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="release.html" title="附录 E. 版本说明">上一级</a></td><th width="60%" align="center">附录 E. 版本说明</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.1 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="release-9-2-1.html" title="E.81. 版本9.2.1">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="RELEASE-9-2-2"><div class="titlepage"><div><div><h2 class="title" style="clear: both">E.80. 版本9.2.2</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="release-9-2-2.html#idp71586160">E.80.1. 迁移到版本9.2.2</a></span></dt><dt><span class="sect2"><a href="release-9-2-2.html#idp71589280">E.80.2. 变化</a></span></dt></dl></div><p><strong>发布日期: </strong>2012-12-06</p><p>   这个版本包含9.2.1的各种修复。有关9.2主要版本的新功能的信息，参阅
   <a class="xref" href="release-9-2.html" title="E.82. 版本9.2">第 E.82 节</a>。</p><div class="sect2" id="idp71586160"><div class="titlepage"><div><div><h3 class="title">E.80.1. 迁移到版本9.2.2</h3></div></div></div><p>  为了运行9.2.X不需要转储/恢复。</p><p>   然而，你可能需要执行<code class="command">REINDEX</code>操作以调整并发建立索引问题，
   正如下面描述的第一个changelog项。</p><p>   同时，如果你正在从版本9.2.0更新，那么请参阅<a class="xref" href="release-9-2-1.html" title="E.81. 版本9.2.1">第 E.81 节</a>。</p></div><div class="sect2" id="idp71589280"><div class="titlepage"><div><div><h3 class="title">E.80.2. 变化</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>   修复与<code class="command">CREATE/DROP INDEX CONCURRENTLY</code>相关的多个错误(Andres Freund, Tom Lane, Simon Riggs, Pavan Deolasee)</p><p>    当在<code class="command">CREATE INDEX CONCURRENTLY</code>最初阶段添加<code class="command">DROP INDEX CONCURRENTLY</code>
允许不正确索引决定，引入错误；因此通过该命令建立的索引可能败坏。
在应用该更新后推荐使用<code class="command">CREATE INDEX CONCURRENTLY</code>在9.2.X中重新建立索引。</p><p>   另外，当改变索引的<code class="structname">pg_index</code>行状态时，修复<code class="command">CREATE/DROP INDEX CONCURRENTLY</code>使用合适更新。
   这避免竞争条件导致并发会话错过更新目标索引，因此再次导致败坏同时创建索引。
   </p><p>    同时，修复各种其他操作以确保他们忽略了
一个来自失败的<code class="command">CREATE INDEX CONCURRENTLY</code>命令的无效索引。最重要的是<code class="command">VACUUM</code>，
因为在采用调整动作以修复或者删除无效索引之前在表上可以很容易启动自动清理。</p><p>     同时修复<code class="command">DROP INDEX CONCURRENTLY</code>用来不禁用
插入到目标索引直到所有查询使用它。</p><p>     如果取消<code class="command">DROP INDEX CONCURRENTLY</code>:先前编码可以留下未删除的索引，修复不正当操作。</p></li><li class="listitem"><p>    为了<code class="command">DROP INDEX CONCURRENTLY</code>调整谓词锁 (Kevin Grittner)</p><p>   先前，在错误的时间处理SSI谓词锁，可能导致与<code class="command">DROP</code>并行执行的可串行化事务不正确操作。</p></li><li class="listitem"><p>     在WAL回放期间修复缓冲区锁定(Tom Lane)</p><p>     当回放WAL记录影响超过一页时，那么WAL回放编码不能仔细锁定缓冲区。这可能导致
 热备份查询瞬时看到不一致状态，导致错误结果或者意外失败。
 </p></li><li class="listitem"><p>    修复GIN索引在WAL产生逻辑中的错误(Tom Lane)</p><p>     这可能导致索引败坏，如果发生破损页失败。</p></li><li class="listitem"><p>    修复SP-GiST索引在WAL回放逻辑错误(Tom Lane)</p><p>    这可能导致崩溃后索引败坏，或者是在备用服务器上。</p></li><li class="listitem"><p>    在WAL恢复期间修复基础备份位置的不正确检查(Heikki Linnakangas)</p><p>    数据库达到一致状态之前该错误允许热备份模式启动。</p></li><li class="listitem"><p>    当推动热备服务器正常运行时，正常删除启动进程的虚拟XID锁(Simon Riggs)</p><p>    该监督可以防止某种操作的后续执行比如<code class="command">CREATE INDEX CONCURRENTLY</code>。</p></li><li class="listitem"><p>    避免备用模式中假冒的<span class="quote">“<span class="quote">失序时间线ID</span>”</span>错误(Heikki Linnakangas)</p></li><li class="listitem"><p>    在它接收到关机信号之后阻止postmaster发起新的子进程(Tom Lane)</p><p>     该错误可能导致比较长的关闭，或者即使从来没有完成没有额外用户操作。</p></li><li class="listitem"><p>    当<code class="varname">log_rotation_age</code>超过2^31毫秒时（大约25天），那么修复syslogger进程而不会失败。(Tom Lane)</p></li><li class="listitem"><p>    当请求的超时过期的时候，那么修复<code class="function">WaitLatch()</code>以及时返回(Jeff Janes, Tom Lane)</p><p>     与以前的编码，非等待终止中断的稳定流可能会延迟从<code class="function">WaitLatch()</code>
无限期的返回。这已被证明是一个自动清理发射进程中的问题，
可能会导致其他地方的麻烦。</p></li><li class="listitem"><p>    当内存不足的时候避免内部哈希表的败坏(Hitoshi Harada)</p></li><li class="listitem"><p>   防止已删除表文件描述符在以前事务结束中保持打开(Tom Lane)</p><p>     这应该减少长期以来已删除的表继续占用磁盘空间问题。</p></li><li class="listitem"><p>     当一个新的子进程无法为它的闭锁创建一个管道的时候，防止数据库端的崩溃和重启(Tom Lane)</p><p>      虽然新的进程失败了，没有充分的理由强迫数据库端重新启动，
  所以要避免。当内核差不多超出文件描述符的时候，这提高了鲁棒性。</p></li><li class="listitem"><p>     避免与加入不平的子查询的规划器崩溃(Tom Lane)</p></li><li class="listitem"><p>    修复外连接上的非严格等价从句的规划(Tom Lane)</p><p>     规划器可以获得来自分句等同于
其他一些的非严格构建的不正确的约束，例如
<code class="literal">WHERE COALESCE(foo, 0) = 0</code>，
当<code class="literal">foo</code>来自外连接的空侧。
9.2显示了比以前的版本更多的情况下的这种类型错误，
但是基本的错误已经有很长时间。</p></li><li class="listitem"><p>     使用继承树上的索引优化<code class="function">MIN</code>/<code class="function">MAX</code>修复<code class="command">SELECT DISTINCT</code> (Tom Lane)</p><p>      该计划在给定的这些因素的结合<span class="quote">“<span class="quote">未能重新找到MinMaxAggInfo记录</span>”</span>可能失败。</p></li><li class="listitem"><p>     确保规划器将隐式和显式转换出于所有目的看作等效的，
 除了少数情况下实际上是一个语义差异(Tom Lane)</p></li><li class="listitem"><p>     当考虑是否部分索引可用于查询时，包含join子句(Tom Lane)</p><p>     严格的join子句可以充分建立一个
<em class="replaceable"><code>x</code></em> <code class="literal">IS NOT NULL</code>断言，比如。
修复9.2中的规划器回归分析，因为先前版本可能做了可比较推理。</p></li><li class="listitem"><p>   当同一索引中有很多可索引join子句时，限制规划器时间的增长(Tom Lane)</p></li><li class="listitem"><p>     提高规划器的能力以证明等价类的排除约束(Tom Lane) </p></li><li class="listitem"><p>    修复散列子规划中的部分行匹配以正确处理交叉类型例子(Tom Lane)</p><p>     这影响到多列<code class="literal">NOT IN</code>子规划，比如<code class="literal">WHERE (a, b) NOT IN (SELECT x, y FROM ...)</code>
当例如<code class="literal">b</code>和<code class="literal">y</code>分别为<code class="type">int4</code>和<code class="type">int8</code>时。
这个错误导致错误结果或依据所涉及的具体数据类型崩溃。</p></li><li class="listitem"><p>   修复btree 标记/恢复函数以处理数组键(Tom Lane)</p><p>     这种疏忽可能导致来自
    内侧是使用<code class="literal"><em class="replaceable"><code>indexed_column</code></em> = ANY(<em class="replaceable"><code>array</code></em>)</code>条件的索引扫描的合并联接中的错误结果。</p></li><li class="listitem"><p>     为采用更少快照恢复补丁(Tom Lane)</p><p>      减少查询执行中采取的快照数的9.2变化  
导致一些在以前版本中没有见过的异常行为，
因为执行会继续在锁定查询使用的表之前获得的一个快照。
因此，例如，查询将不保证能够看到前面事务提交的更新
即使该事务有排他锁。我们可能会在未来版本中重新审视它，但同时把它以9.2之前方式放回到原处。</p></li><li class="listitem"><p>     当为<code class="literal">AFTER ROW UPDATE/DELETE</code>触发器重新读取旧的元组时，获取缓冲锁(Andres Freund)   </p><p>     在十分特殊的情况下，这可能会导致传递
不正确的数据到一个触发器<code class="literal">WHEN</code>条件，
或对一个外键执行触发器重新检测逻辑。
这可能导致崩溃，或在错误决定情况下触发触发器。</p></li><li class="listitem"><p>     修复<code class="command">ALTER COLUMN TYPE</code>正确处理继承的检查约束(Pavan Deolasee)</p><p>      这在以前8.4版本中正常工作，并且现在在8.4及以后版本中也正常工作。</p></li><li class="listitem"><p>      修复<code class="command">ALTER EXTENSION SET SCHEMA</code>的错误以移动一些附属对象到新模式中(Álvaro Herrera, Dimitri Fontaine)</p></li><li class="listitem"><p>    在扩展查询协议中正确处理<code class="command">CREATE TABLE AS EXECUTE</code> (Tom Lane)</p></li><li class="listitem"><p>   不要在<code class="command">DROP RULE IF NOT EXISTS</code> and <code class="command">DROP TRIGGER IF NOT EXISTS</code>中修改输入解析树(Tom Lane)</p><p>    如果重新执行这些类型之一的已缓存语句，那么可能产生错误。  </p></li><li class="listitem"><p>    修复<code class="command">REASSIGN OWNED</code>处理表空间上的授权(Álvaro Herrera)</p></li><li class="listitem"><p>     忽略视图系统列错误的<code class="structname">pg_attribute</code>项(Tom Lane)</p><p>     视图没有任何系统列。然而，当转换表到视图时我们忘了
删除该项。在9.3以及以后被正确修复，但在以前的分支中我们需要防卫
现有的错误转换视图。</p></li><li class="listitem"><p>     修复规则输出以正确转储<code class="literal">INSERT INTO <em class="replaceable"><code>table</code></em>DEFAULT VALUES</code>(Tom Lane)</p></li><li class="listitem"><p>    当在一个查询中有太多<code class="literal">UNION</code>/<code class="literal">INTERSECT</code>/<code class="literal">EXCEPT</code>子句时，防止堆栈溢出(Tom Lane)</p></li><li class="listitem"><p>    当使用-1区分尽可能低的整数值时，避免平台相关错误(Xi Wang, Tom Lane)</p></li><li class="listitem"><p>    修复日期分析中可能访问以前的字符串末尾(Hitoshi Harada)</p></li><li class="listitem"><p>     如果在检查点期间发生XID概括并且<code class="varname">wal_level</code>是<code class="literal">hot_standby</code>，
 那么修复错误以提前XID时代(Tom Lane, Andres Freund)</p><p>     当这个错误对<span class="productname">PostgreSQL</span>自身没有特别的影响时，
 对于依赖于<code class="function">txid_current()</code>和相关函数是一个坏的应用：TXID值将出现回退。</p></li><li class="listitem"><p>   修复<code class="function">pg_terminate_backend()</code>和<code class="function">pg_cancel_backend()</code>
   不要为非存在的目标过程抛出错误(Josh Kupershmidt)</p><p>  当通过超级用户调用的时候，该种情况已经按照预期进行，但是当通过普通用户调用的时候并不这样。</p></li><li class="listitem"><p>   修复页面边界<code class="structname">pg_stat_replication</code>.<code class="structfield">sync_state</code>的显示(Kyotaro Horiguchi)</p></li><li class="listitem"><p>   如果为了Unix域套接字的路径名长度超过特定平台限制，
   那么产生可理解的错误消息(Tom Lane, Andrew Dunstan)</p><p>    以前这可能导致一些无用的东西，比如<span class="quote">“<span class="quote">域名解析不可恢复故障</span>”</span></p></li><li class="listitem"><p>     当发送复合列值给客户端时，修复内存泄露(Tom Lane)</p></li><li class="listitem"><p>      通过提交时不搜索子事务锁节省一些周期(Simon Riggs)  </p><p>      在事务中持有许多排他锁，这些无效活动可能是相当昂贵的。</p></li><li class="listitem"><p> 
     使得<span class="application">pg_ctl</span>关于读取<code class="filename">postmaster.pid</code>文件更加健壮(Heikki Linnakangas)。</p><p>      这将修复竞争条件和可能的文件描述符泄漏。</p></li><li class="listitem"><p>      如果提出错误编码数据，并且<code class="varname">client_encoding</code>设置是客户端编码，比如SJIS，
  那么可能在<span class="application">psql</span>中崩溃(Jiang Guiqing)</p></li><li class="listitem"><p>     在数据不是归档预先数据段中使得<span class="application">pg_dump</span>备份<code class="literal">SEQUENCE SET</code>项(Tom Lane)   </p><p>     这种修复了<code class="option">--data-only</code>和<code class="option">--section=data</code>意义之间不良的不一致，
 并修复备份被标记为可扩展配置表序列。</p></li><li class="listitem"><p>     修复<code class="option">--clean</code>模式中<code class="command">DROP DATABASE</code>命令的<span class="application">pg_dump</span>的处理(Guillaume Lelarge)</p><p>     9.2.0开始，<code class="literal">pg_dump --clean</code>提出<code class="command">DROP DATABASE</code>，
 根据使用场景这是无用的或者危险的。现在不再是这样了。
这种变化也将修复<code class="option">--clean</code>和<code class="option">--create</code>的结合以正常运行，
即，发出<code class="command">DROP DATABASE</code>然后重新连接
目标数据库之前发出<code class="command">CREATE DATABASE</code>。</p></li><li class="listitem"><p>    为了循环依赖的视图和没有关系的选项修复<span class="application">pg_dump</span>(Tom Lane)   </p><p>   当视图涉及没有选项不正常工作的情况下的循环依赖时，
   先前修复是备份关系选项。它发出<code class="literal">ALTER VIEW foo SET ()</code>，这是无效的语法。</p></li><li class="listitem"><p>   修复通过<code class="literal">tar</code>输出格式中<span class="application">pg_dump</span>发出的<code class="filename">restore.sql</code>脚本中的错误(Tom Lane)</p><p>     该脚本在名字包括大写字母的表上可能失败。同时，
 使脚本在<code class="option">--inserts</code>模式中和规则COPY模式中能够恢复数据。</p></li><li class="listitem"><p>     修复<span class="application">pg_restore</span>接受符合POSIX标准的<code class="literal">tar</code>的文件(Brian Weaver, Tom Lane)</p><p>     <span class="application">pg_dump</span>的<code class="literal">tar</code>输出模式的原始编码产生不能与POSIX标准完全一致的文件。
这是9.3版本的修正。这个补丁更新以前的分支，以致于它们会接受
不正确的和正确的格式，为了避免9.3出现的
兼容性问题。</p></li><li class="listitem"><p>   修复通过<span class="application">pg_basebackup</span>发出的<code class="literal">tar</code>文件到符合POSIX标准(Brian Weaver, Tom Lane)</p></li><li class="listitem"><p>      当给出了数据目录相应路径时，修复<span class="application">pg_resetxlog</span>以正确定位<code class="filename">postmaster.pid</code>(Tom Lane)</p><p>     这个错误可能导致<span class="application">pg_resetxlog</span>没有注意到使用数据目录的一个活跃postmaster。</p></li><li class="listitem"><p>   修复<span class="application">libpq</span>的<code class="function">lo_import()</code>和<code class="function">lo_export()</code>函数以正确报告文件I/O错误(Tom Lane)</p></li><li class="listitem"><p>    修复嵌套结构指针变量的<span class="application">ecpg</span>处理(Muhammad Usama)</p></li><li class="listitem"><p>   修复<span class="application">ecpg</span>的<code class="function">ecpg_get_data</code>函数以正确处理数组(Michael Meskes)</p></li><li class="listitem"><p>    防止<span class="application">pg_upgrade</span>试图处理系统目录的TOAST表(Bruce Momjian)</p><p>     当<code class="literal">information_schema</code>已被删除或重新创建时，这修复了发现的错误。
 其他错误也是可能的。</p></li><li class="listitem"><p>    通过设置新群集中<code class="varname">synchronous_commit</code>到<code class="literal">off</code>提升<span class="application">pg_upgrade</span>性能(Bruce Momjian)</p></li><li class="listitem"><p>    使得<code class="filename">contrib/pageinspect</code>的btree页检查函数当检查页时采用缓冲锁(Tom Lane)</p></li><li class="listitem"><p>     解决<code class="literal">malloc(0)</code>和<code class="literal">realloc(NULL, 0)</code>不可移植操作(Tom Lane)</p><p>     平台上这些调用返回<code class="literal">NULL</code>，一些代码错误地认为内存不足。
对数据库不包含用户自定义聚合已损坏的<span class="application">pg_dump</span>是已知的。
可能还有其他的情况。
</p></li><li class="listitem"><p>    确保<code class="literal">make install</code>为扩展创建<code class="filename">extension</code>安装目录(Cédric Villemain)</p><p>     以前，如果在扩展的Makefile中设置<code class="varname">MODULEDIR</code>，可以省略该步。</p></li><li class="listitem"><p>      修复<span class="application">pgxs</span>支持AIX上编译可加载模块(Tom Lane)</p><p>     编译不在AIX上运行的初始源码树外部模块。 </p></li><li class="listitem"><p>     为了Cuba, Israel, Jordan, Libya, Palestine, Western
      Samoa以及Brazil区域中DST变化规律更
 新时区数据文件到<span class="application">tzdata</span>版本2012j。
</p></li></ul></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="release-9-2-3.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="release.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="release-9-2-1.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">E.79. 版本9.2.3 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> E.81. 版本9.2.1</td></tr></table></div></body></html>
