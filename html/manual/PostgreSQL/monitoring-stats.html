<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>28.2. 统计收集器</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="monitoring-ps.html" title="28.1. 标准 Unix 工具" /><link rel="next" href="monitoring-locks.html" title="28.3. 查看锁" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">28.2. 统计收集器</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="monitoring-ps.html" title="28.1. 标准 Unix 工具">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="monitoring.html" title="第 28 章 监控数据库活动">上一级</a></td><th width="60%" align="center">第 28 章 监控数据库活动</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.1 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="monitoring-locks.html" title="28.3. 查看锁">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="MONITORING-STATS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">28.2. 统计收集器</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="monitoring-stats.html#MONITORING-STATS-SETUP">28.2.1. 统计收集配置</a></span></dt><dt><span class="sect2"><a href="monitoring-stats.html#MONITORING-STATS-VIEWS">28.2.2. 查看统计信息</a></span></dt><dt><span class="sect2"><a href="monitoring-stats.html#MONITORING-STATS-FUNCTIONS">28.2.3. 统计函数</a></span></dt></dl></div><a id="idp25328944" class="indexterm"></a><p>   <span class="productname">PostgreSQL</span>的<em class="firstterm">统计收集器</em>是一个支持收集和报告服务器活动信息的子系统。 目前，这个收集器可以对表和索引的访问计数，计数可以按磁盘块和个体行来进行。它还跟踪每个表中的总行数、每个表的清理和分析动作的信息。它也统计调用用户定义函数的次数以及在每次调用中花费的总时间。
  </p><p>   <span class="productname">PostgreSQL</span>也支持报告有关系统正在干什么的
   动态信息，例如当前正在被其他服务器进程执行的命令以及系统中存在哪些其他连接。
   这个功能是独立于收集器进程存在的。
  </p><div class="sect2" id="MONITORING-STATS-SETUP"><div class="titlepage"><div><div><h3 class="title">28.2.1. 统计收集配置</h3></div></div></div><p>   因为统计收集给查询执行增加了一些负荷，系统可以被配置为收集或不收集信息。这由配置参数控制，它们通常在<code class="filename">postgresql.conf</code>中设置（关于设置配置参数的细节请见<a class="xref" href="runtime-config.html" title="第 19 章 服务器配置">第 19 章</a>）。
  </p><p>   参数<a class="xref" href="runtime-config-statistics.html#GUC-TRACK-ACTIVITIES">track_activities</a>允许监控当前被任意服务器进程执行的命令。
  </p><p>   参数<a class="xref" href="runtime-config-statistics.html#GUC-TRACK-COUNTS">track_counts</a>控制是否收集关于表和索引访问的统计信息。
  </p><p>   参数<a class="xref" href="runtime-config-statistics.html#GUC-TRACK-FUNCTIONS">track_functions</a>启用对用户定义函数使用的跟踪。
  </p><p>   参数<a class="xref" href="runtime-config-statistics.html#GUC-TRACK-IO-TIMING">track_io_timing</a>启用对块读写次数的监控。
  </p><p>   通常这些参数被设置在<code class="filename">postgresql.conf</code>中，这样它们会应用于所有服务器进程，但是可以在单个会话中使用<a class="xref" href="sql-set.html" title="SET"><span class="refentrytitle">SET</span></a>命令打开或关闭它们（为了阻止普通用户对管理员隐藏他们的活动，只有超级用户被允许使用<code class="command">SET</code>来改变这些参数）。
  </p><p>   统计收集器通过临时文件将收集到的信息传送给其他<span class="productname">PostgreSQL</span>进程。这些文件被存储在名字由<a class="xref" href="runtime-config-statistics.html#GUC-STATS-TEMP-DIRECTORY">stats_temp_directory</a>参数指定的目录中，默认是<code class="filename">pg_stat_tmp</code>。为了得到更好的性能，<code class="varname">stats_temp_directory</code>可以被指向一个基于 RAM 的文件系统来降低物理 I/O 需求。当服务器被干净地关闭时，一份统计数据的永久拷贝被存储在<code class="filename">pg_stat</code>子目录中，这样在服务器重启后统计信息能被保持。当在服务器启动时执行恢复时（例如立即关闭、服务器崩溃以及时间点恢复之后），所有统计计数器会被重置。
  </p></div><div class="sect2" id="MONITORING-STATS-VIEWS"><div class="titlepage"><div><div><h3 class="title">28.2.2. 查看统计信息</h3></div></div></div><p>   <a class="xref" href="monitoring-stats.html#MONITORING-STATS-DYNAMIC-VIEWS-TABLE" title="表 28.1. 动态统计视图">表 28.1</a>中列出了一些预定义视图
   可以用来显示系统的当前状态。
   <a class="xref" href="monitoring-stats.html#MONITORING-STATS-VIEWS-TABLE" title="表 28.2. 已收集统计信息的视图">表 28.2</a>中列出了另一些视图可以
   显示统计收集的结果。你也可以使用底层统计函数（在
   <a class="xref" href="monitoring-stats.html#MONITORING-STATS-FUNCTIONS" title="28.2.3. 统计函数">第 28.2.3 节</a>中讨论）来建立自定义的视图。
  </p><p>   在使用统计信息监控收集到的数据时，你必须了解这些信息并非是实时更新的。每个独立的服务器进程只在进入闲置状态之前才向收集器传送新的统计计数；因此正在进行的查询或事务并不影响显示出来的总数。同样，收集器本身也最多每<code class="varname">PGSTAT_STAT_INTERVAL</code>毫秒（缺省为 500ms，除非在编译服务器的时候修改过）发送一 次新的报告。因此显示的信息总是落后于实际活动。但是由<code class="varname">track_activities</code>收集的当前查询信息总是最新的。
  </p><p>   另一个重点是当一个服务器进程被要求显示任何这些统计信息时，它首先取得收集器进程最近发出的报告并且接着为所有统计视图和函数使用这个快照，直到它的当前事务的结尾。因此只要你继续当前事务，统计数据将会一直显示静态信息。相似地，当任何关于所有会话的当前查询的信息在一个事务中第一次被请求时，这样的信息将被收集。并且在整个事务期间将显示相同的信息。这是一种特性而非缺陷，因为它允许你在该统计信息上执行多个查询并且关联结果而不用担心那些数字会在你不知情的情况下改变。但是如果你希望用每个查询都看到新结果，要确保在任何事务块之外做那些查询。或者，你可以调用<code class="function">pg_stat_clear_snapshot</code>()，那将丢弃当前事务的统计快照（如果有）。下一次对统计性信息的使用将导致获取一个新的快照。
  </p><p>   一个事务也可以在视图<code class="structname">pg_stat_xact_all_tables</code>、<code class="structname">pg_stat_xact_sys_tables</code>、<code class="structname">pg_stat_xact_user_tables</code>和<code class="structname">pg_stat_xact_user_functions</code>中看到它自己的统计信息（还没有被传送给收集器）。这些数字并不像上面所述的那样行动，相反它们在事务期间持续被更新。
  </p><div class="table" id="MONITORING-STATS-DYNAMIC-VIEWS-TABLE"><p class="title"><strong>表 28.1. 动态统计视图</strong></p><div class="table-contents"><table class="table" summary="动态统计视图" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>视图名称</th><th>描述</th></tr></thead><tbody><tr><td>       <code class="structname">pg_stat_activity</code>
       <a id="idp25361088" class="indexterm"></a>
      </td><td>       每个服务器进程一行，显示与那个进程的当前活动相关的信息，例如状态和当前查询。详见<a class="xref" href="monitoring-stats.html#PG-STAT-ACTIVITY-VIEW" title="表 28.3. pg_stat_activity 视图">pg_stat_activity</a>。
      </td></tr><tr><td><code class="structname">pg_stat_replication</code><a id="idp25363712" class="indexterm"></a></td><td>每一个 WAL 发送进程一行，显示有关到该发送进程
      连接的后备服务器的复制的统计信息。详见
      <a class="xref" href="monitoring-stats.html#PG-STAT-REPLICATION-VIEW" title="表 28.5. pg_stat_replication 视图">pg_stat_replication</a>。
      </td></tr><tr><td><code class="structname">pg_stat_wal_receiver</code><a id="idp25366288" class="indexterm"></a></td><td>只有一行，显示来自 WAL 接收器所连接服务器的有关该接收器的统计信息。详见<a class="xref" href="monitoring-stats.html#PG-STAT-WAL-RECEIVER-VIEW" title="表 28.6. pg_stat_wal_receiver 视图">pg_stat_wal_receiver</a>。
      </td></tr><tr><td><code class="structname">pg_stat_subscription</code><a id="idp25368784" class="indexterm"></a></td><td>每个订阅至少一行，显示订阅工作者的相关信息。详细信息，请参阅
       <a class="xref" href="monitoring-stats.html#PG-STAT-SUBSCRIPTION" title="表 28.7. pg_stat_subscription 视图">pg_stat_subscription</a>。
      </td></tr><tr><td><code class="structname">pg_stat_ssl</code><a id="idp25371184" class="indexterm"></a></td><td>每个连接（常规连接和复制连接）一行，
      显示有关在此连接上使用的 SSL 的信息。
      详见<a class="xref" href="monitoring-stats.html#PG-STAT-SSL-VIEW" title="表 28.8. pg_stat_ssl 视图">pg_stat_ssl</a>。
      </td></tr><tr><td><code class="structname">pg_stat_progress_vacuum</code><a id="idp25373664" class="indexterm"></a></td><td>每个运行<code class="command">VACUUM</code>的后端(包括 autovacuum 工作者进程)一行，
	  显示当前的进度。参阅<a class="xref" href="progress-reporting.html#VACUUM-PROGRESS-REPORTING" title="28.4.1. VACUUM进度报告">第 28.4.1 节</a>。
      </td></tr></tbody></table></div></div><br class="table-break" /><div class="table" id="MONITORING-STATS-VIEWS-TABLE"><p class="title"><strong>表 28.2. 已收集统计信息的视图</strong></p><div class="table-contents"><table class="table" summary="已收集统计信息的视图" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>视图名称</th><th>描述</th></tr></thead><tbody><tr><td><code class="structname">pg_stat_archiver</code><a id="idp25379072" class="indexterm"></a></td><td>只有一行，显示有关 WAL 归档进程活动的统计信息。详见<a class="xref" href="monitoring-stats.html#PG-STAT-ARCHIVER-VIEW" title="表 28.9. pg_stat_archiver视图">pg_stat_archiver</a>。
      </td></tr><tr><td><code class="structname">pg_stat_bgwriter</code><a id="idp25381456" class="indexterm"></a></td><td>只有一行，显示有关后台写进程的活动的统计信息。详见<a class="xref" href="monitoring-stats.html#PG-STAT-BGWRITER-VIEW" title="表 28.10. pg_stat_bgwriter视图">pg_stat_bgwriter</a>。
     </td></tr><tr><td><code class="structname">pg_stat_database</code><a id="idp25383888" class="indexterm"></a></td><td>每个数据库一行，显示数据库范围的统计信息。详见<a class="xref" href="monitoring-stats.html#PG-STAT-DATABASE-VIEW" title="表 28.11. pg_stat_database视图">pg_stat_database</a>。
      </td></tr><tr><td><code class="structname">pg_stat_database_conflicts</code><a id="idp25386144" class="indexterm"></a></td><td>       每个数据库一行，显示数据库范围的统计信息，
       这些信息的内容是关于由于与后备服务器的恢复过程
       发生冲突而被取消的查询。详见
       <a class="xref" href="monitoring-stats.html#PG-STAT-DATABASE-CONFLICTS-VIEW" title="表 28.12. pg_stat_database_conflicts 视图">pg_stat_database_conflicts</a>。
      </td></tr><tr><td><code class="structname">pg_stat_all_tables</code><a id="idp25389008" class="indexterm"></a></td><td>       当前数据库中每个表一行，显示有关访问指定表的统计信息。详见<a class="xref" href="monitoring-stats.html#PG-STAT-ALL-TABLES-VIEW" title="表 28.13. pg_stat_all_tables视图">pg_stat_all_tables</a>。
      </td></tr><tr><td><code class="structname">pg_stat_sys_tables</code><a id="idp25391504" class="indexterm"></a></td><td>和<code class="structname">pg_stat_all_tables</code>一样，但只显示系统表。</td></tr><tr><td><code class="structname">pg_stat_user_tables</code><a id="idp25393488" class="indexterm"></a></td><td>和<code class="structname">pg_stat_all_tables</code>一样，但只显示用户表。</td></tr><tr><td><code class="structname">pg_stat_xact_all_tables</code><a id="idp25395472" class="indexterm"></a></td><td>和<code class="structname">pg_stat_all_tables</code>相似，但计数动作只在当前事务内发生（还<span class="emphasis"><em>没有</em></span>被包括在<code class="structname">pg_stat_all_tables</code>和相关视图中）。用于生存和死亡行数量的列以及清理和分析动作在此视图中不出现。</td></tr><tr><td><code class="structname">pg_stat_xact_sys_tables</code><a id="idp25398480" class="indexterm"></a></td><td>和<code class="structname">pg_stat_xact_all_tables</code>一样，但只显示系统表。</td></tr><tr><td><code class="structname">pg_stat_xact_user_tables</code><a id="idp25400480" class="indexterm"></a></td><td>和<code class="structname">pg_stat_xact_all_tables</code>一样，但只显示用户表。</td></tr><tr><td><code class="structname">pg_stat_all_indexes</code><a id="idp25402480" class="indexterm"></a></td><td>       当前数据库中的每个索引一行，显示：表OID、索引OID、模式名、表名、索引名、 使用了该索引的索引扫描总数、索引扫描返回的索引记录数、使用该索引的简 单索引扫描抓取的活表(livetable)中数据行数。
       当前数据库中的每个索引一行，显示与访问指定索引有关的统计信息。详见<a class="xref" href="monitoring-stats.html#PG-STAT-ALL-INDEXES-VIEW" title="表 28.14. pg_stat_all_indexes视图">pg_stat_all_indexes</a>。
      </td></tr><tr><td><code class="structname">pg_stat_sys_indexes</code><a id="idp25405520" class="indexterm"></a></td><td>和<code class="structname">pg_stat_all_indexes</code>一样，但只显示系统表上的索引。</td></tr><tr><td><code class="structname">pg_stat_user_indexes</code><a id="idp25407520" class="indexterm"></a></td><td>和<code class="structname">pg_stat_all_indexes</code>一样，但只显示用户表上的索引。</td></tr><tr><td><code class="structname">pg_statio_all_tables</code><a id="idp25409520" class="indexterm"></a></td><td>       当前数据库中每个表一行(包括TOAST表)，显示：表OID、模式名、表名、 从该表中读取的磁盘块总数、缓冲区命中次数、该表上所有索引的磁盘块读取总数、 该表上所有索引的缓冲区命中总数、在该表的辅助TOAST表(如果存在)上的磁盘块读取总数、 在该表的辅助TOAST表(如果存在)上的缓冲区命中总数、TOAST表的索引的磁盘块读 取总数、TOAST表的索引的缓冲区命中总数。
       当前数据库中的每个表一行，显示有关在指定表上 I/O 的统计信息。详见<a class="xref" href="monitoring-stats.html#PG-STATIO-ALL-TABLES-VIEW" title="表 28.15. pg_statio_all_tables视图">pg_statio_all_tables</a>。
      </td></tr><tr><td><code class="structname">pg_statio_sys_tables</code><a id="idp25412528" class="indexterm"></a></td><td>和<code class="structname">pg_statio_all_tables</code>一样，但只显示系统表。</td></tr><tr><td><code class="structname">pg_statio_user_tables</code><a id="idp25414464" class="indexterm"></a></td><td>和<code class="structname">pg_statio_all_tables</code>一样，但只显示用户表。</td></tr><tr><td><code class="structname">pg_statio_all_indexes</code><a id="idp25416448" class="indexterm"></a></td><td>       当前数据库中每个索引一行，显示：表OID、索引OID、模式名、 表名、索引名、该索引的磁盘块读取总数、该索引的缓冲区命中总数。
       当前数据库中的每个索引一行，显示与指定索引上的 I/O 有关的统计信息。详见<a class="xref" href="monitoring-stats.html#PG-STATIO-ALL-INDEXES-VIEW" title="表 28.16. pg_statio_all_indexes视图">pg_statio_all_indexes</a>。
      </td></tr><tr><td><code class="structname">pg_statio_sys_indexes</code><a id="idp25419472" class="indexterm"></a></td><td>和<code class="structname">pg_statio_all_indexes</code>一样，但只显示系统表上的索引。</td></tr><tr><td><code class="structname">pg_statio_user_indexes</code><a id="idp25421472" class="indexterm"></a></td><td>和<code class="structname">pg_statio_all_indexes</code>一样，但只显示用户表上的索引。</td></tr><tr><td><code class="structname">pg_statio_all_sequences</code><a id="idp25423472" class="indexterm"></a></td><td>       当前数据库中每个序列对象一行，显示：序列OID、模式名、序列名、序列的磁盘读取总数、序列的缓冲区命中总数。
       当前数据库中的每个序列一行，显示与指定序列上的 I/O 有关的统计信息。详见<a class="xref" href="monitoring-stats.html#PG-STATIO-ALL-SEQUENCES-VIEW" title="表 28.17. pg_statio_all_sequences视图">pg_statio_all_sequences</a>。
     </td></tr><tr><td><code class="structname">pg_statio_sys_sequences</code><a id="idp25426352" class="indexterm"></a></td><td>和<code class="structname">pg_statio_all_sequences</code>一样，但只显示系统序列（目前没有定义系统序列，因此这个视图总是为空）。</td></tr><tr><td><code class="structname">pg_statio_user_sequences</code><a id="idp25428384" class="indexterm"></a></td><td>和<code class="structname">pg_statio_all_sequences</code>一样，但只显示用户序列。</td></tr><tr><td><code class="structname">pg_stat_user_functions</code><a id="idp25430384" class="indexterm"></a></td><td>       对于所有跟踪功能，函数的OID，模式，名称，数量 通话总时间，和自我的时间。自我时间是 在函数本身所花费的时间量，总时间包括 它调用函数所花费的时间。时间值以毫秒为单位。
       每一个被跟踪的函数一行，显示与执行该函数有关的统计信息。详见<a class="xref" href="monitoring-stats.html#PG-STAT-USER-FUNCTIONS-VIEW" title="表 28.18. pg_stat_user_functions视图">pg_stat_user_functions</a>。
      </td></tr><tr><td><code class="structname">pg_stat_xact_user_functions</code><a id="idp25433408" class="indexterm"></a></td><td>和<code class="structname">pg_stat_user_functions</code>相似，但是只统计在当前事务期间的调用（还<span class="emphasis"><em>没有</em></span>被包括在<code class="structname">pg_stat_user_functions</code>中）。</td></tr></tbody></table></div></div><br class="table-break" /><p>   针对每个索引的统计信息对于判断哪个索引正被使用以及它们的效果特别有用。
  </p><p>   <code class="structname">pg_statio_</code>系列视图主要用于判断缓冲区的效果。当实际磁盘读取数远小于缓冲区命中时，这个缓冲能满足大部分读请求而无需进行内核调用。但是，这些统计信息并没有给出所有的事情：由于<span class="productname">PostgreSQL</span>处理磁盘 I/O 的方式，不在<span class="productname">PostgreSQL</span>缓冲区中的数据库仍然驻留在内核的 I/O 缓存中，并且因此可以被再次读取而不需要物理磁盘读取。我们建议希望了解<span class="productname">PostgreSQL</span> I/O 行为更多细节的用户将<span class="productname">PostgreSQL</span>统计收集器和操作系统中允许观察内核处理 I/O 的工具一起使用。
  </p><div class="table" id="PG-STAT-ACTIVITY-VIEW"><p class="title"><strong>表 28.3. <code class="structname">pg_stat_activity</code> 视图</strong></p><div class="table-contents"><table class="table" summary="pg_stat_activity 视图" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>列</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="structfield">datid</code></td><td><code class="type">oid</code></td><td>这个后端连接到的数据库的OID</td></tr><tr><td><code class="structfield">datname</code></td><td><code class="type">name</code></td><td>这个后端连接到的数据库的名称</td></tr><tr><td><code class="structfield">pid</code></td><td><code class="type">integer</code></td><td>这个后端的进程 ID</td></tr><tr><td><code class="structfield">usesysid</code></td><td><code class="type">oid</code></td><td>登录到这个后端的用户的 OID</td></tr><tr><td><code class="structfield">usename</code></td><td><code class="type">name</code></td><td>登录到这个后端的用户的名称</td></tr><tr><td><code class="structfield">application_name</code></td><td><code class="type">text</code></td><td>连接到这个后端的应用的名称</td></tr><tr><td><code class="structfield">client_addr</code></td><td><code class="type">inet</code></td><td>连接到这个后端的客户端的 IP 地址。如果这个域为空，它表示客户端通过服务器机器上的一个 Unix 套接字连接或者这是一个内部进程（如自动清理）。
     </td></tr><tr><td><code class="structfield">client_hostname</code></td><td><code class="type">text</code></td><td>已连接的客户端的主机名，由<code class="structfield">client_addr</code>的反向 DNS 查找报告。这个域将只对 IP 连接非空，并且只有<a class="xref" href="runtime-config-logging.html#GUC-LOG-HOSTNAME">log_hostname</a>被启用时才会非空。
     </td></tr><tr><td><code class="structfield">client_port</code></td><td><code class="type">integer</code></td><td>客户端用以和这个后端通信的 TCP 端口号，如果使用 Unix 套接字则为<code class="literal">-1</code>
     </td></tr><tr><td><code class="structfield">backend_start</code></td><td><code class="type">timestamp with time zone</code></td><td>这个进程被启动的时间，对于客户端后端，这是客户端连接到服务器的时间。
     </td></tr><tr><td><code class="structfield">xact_start</code></td><td><code class="type">timestamp with time zone</code></td><td>这个进程的当前事务被启动的时间，如果没有活动事务则为空。如果当前查询是它的第一个事务，这一列等于<code class="structfield">query_start</code>。
     </td></tr><tr><td><code class="structfield">query_start</code></td><td><code class="type">timestamp with time zone</code></td><td>当前活动查询被开始的时间，如果<code class="structfield">state</code>不是<code class="literal">active</code>，这个域为上一个查询被开始的时间
     </td></tr><tr><td><code class="structfield">state_change</code></td><td><code class="type">timestamp with time zone</code></td><td><code class="structfield">state</code>上一次被改变的时间</td></tr><tr><td><code class="structfield">wait_event_type</code></td><td><code class="type">text</code></td><td>后端正在等待的事件类型，如果不存在则为 NULL。可能的值有：
       <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>          <code class="literal">LWLock</code>：后端正在等待一个轻量级锁。
		  每一个这样的锁保护共享内存中的一个特定数据结构。
		  <code class="literal">wait_event</code>将包含一个名称，标识轻量级锁的用途。
		  （一些锁具有特定的名称；另一些锁则是一组锁的一部分，每个都有类似的用途。）
         </p></li><li class="listitem"><p>          <code class="literal">Lock</code>：后端正在等待一个重量级锁。重量级锁，也称为锁管理器锁或者简单锁，主要保护 SQL 可见的对象，例如表。不过，它们也被用于确保特定内部操作的互斥，例如关系扩展。<code class="literal">wait_event</code>将标识等待的锁的类型。
         </p></li><li class="listitem"><p>          <code class="literal">BufferPin</code>：服务器进程正在等待访问一个数据缓冲区，而此时没有其他进程正在检查该缓冲区。如果另一个进程持有一个最终从要访问的缓冲区中读取数据的打开的游标，缓冲区 pin 等待可能会被拖延。
         </p></li><li class="listitem"><p>          <code class="literal">Activity</code>:服务器进程空闲。这由系统进程在其主要处理循环中等待活动使用。
		  <code class="literal">wait_event</code>将识别特定的等待点。
         </p></li><li class="listitem"><p>          <code class="literal">Extension</code>: 服务器进程正在等待扩展模块中的活动。此类别对于跟踪自定义等待点的模块很有用。
         </p></li><li class="listitem"><p>          <code class="literal">Client</code>:服务器进程正在等待来自用户应用程序的套接字上的某些活动，
		  并且服务器期望发生与其内部进程无关的事情。
		  <code class="literal">wait_event</code>将识别特定的等待点。
         </p></li><li class="listitem"><p>          <code class="literal">IPC</code>: 服务器进程正在等待来自服务器中另一个进程的某些活动。
		  <code class="literal">wait_event</code>将识别特定的等待点。
         </p></li><li class="listitem"><p>          <code class="literal">Timeout</code>: 服务器进程正在等待超时到期。<code class="literal">wait_event</code>将识别特定的等待点。
         </p></li><li class="listitem"><p>          <code class="literal">IO</code>: 服务器进程正在等待IO完成。<code class="literal">wait_event</code>将识别特定的等待点。
         </p></li></ul></div>
      </td></tr><tr><td><code class="structfield">wait_event</code></td><td><code class="type">text</code></td><td>如果后端当前正在等待，则是等待事件的名称，否则为 NULL。详见<a class="xref" href="monitoring-stats.html#WAIT-EVENT-TABLE" title="表 28.4. wait_event 描述">表 28.4</a>。
     </td></tr><tr><td><code class="structfield">state</code></td><td><code class="type">text</code></td><td>这个后端的当前总体状态。可能的值是：
       <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>           <code class="literal">active</code>：后端正在执行一个查询。
          </p></li><li class="listitem"><p>           <code class="literal">idle</code>：后端正在等待一个新的客户端命令。
          </p></li><li class="listitem"><p>           <code class="literal">idle in transaction</code>：后端在一个事务中，但是当前没有正在执行一个查询。
          </p></li><li class="listitem"><p>           <code class="literal">idle in transaction (aborted)</code>：这个状态与<code class="literal">idle in transaction</code>相似，不过在该事务中的一个语句导致了一个错误。
          </p></li><li class="listitem"><p>           <code class="literal">fastpath function call</code>：后端正在执行一个 fast-path 函数。
          </p></li><li class="listitem"><p>           <code class="literal">disabled</code>：如果在这个后端中<a class="xref" href="runtime-config-statistics.html#GUC-TRACK-ACTIVITIES">track_activities</a>被禁用，则报告这个状态。
          </p></li></ul></div>
     </td></tr><tr><td><code class="structfield">backend_xid</code></td><td><code class="type">xid</code></td><td>这个后端的顶层事务标识符（如果存在）。</td></tr><tr><td><code class="structfield">backend_xmin</code></td><td><code class="type">xid</code></td><td>当前后端的<code class="literal">xmin</code>范围。</td></tr><tr><td><code class="structfield">query</code></td><td><code class="type">text</code></td><td>这个后端最近查询的文本。如果<code class="structfield">state</code>为<code class="literal">active</code>，这个域显示当前正在执行的查询。在所有其他状态下，它显示上一个被执行的查询。
	  默认情况下，查询文本被截断为1024个字符；可以通过参数
	  <a class="xref" href="runtime-config-statistics.html#GUC-TRACK-ACTIVITY-QUERY-SIZE">track_activity_query_size</a>更改此值。
     </td></tr><tr><td><code class="structfield">backend_type</code></td><td><code class="type">text</code></td><td>当前后端的类型。可能的类型有
      <code class="literal">autovacuum launcher</code>、<code class="literal">autovacuum worker</code>、
      <code class="literal">background worker</code>、<code class="literal">background writer</code>、
      <code class="literal">client backend</code>、<code class="literal">checkpointer</code>、
      <code class="literal">startup</code>、<code class="literal">walreceiver</code>、
      <code class="literal">walsender</code>和<code class="literal">walwriter</code>。
     </td></tr></tbody></table></div></div><br class="table-break" /><p>   <code class="structname">pg_stat_activity</code>视图将为每一个服务器进程有一行，显示与该进程的当前活动相关的信息。
  </p><div class="note"><h3 class="title">注意</h3><p>    <code class="structfield">wait_event</code>和<code class="structfield">state</code>列是独立的。如果一个后端处于<code class="literal">active</code>状态，它可能是也可能不是某个事件上的<code class="literal">waiting</code>。如果状态是<code class="literal">active</code>并且<code class="structfield">wait_event</code>为非空，它意味着一个查询正在被执行，但是它被阻塞在系统中某处。
   </p></div><div class="table" id="WAIT-EVENT-TABLE"><p class="title"><strong>表 28.4. <code class="structname">wait_event</code> 描述</strong></p><div class="table-contents"><table class="table" summary="wait_event 描述" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>等待事件类型</th><th>等待事件名称</th><th>描述</th></tr></thead><tbody><tr><td rowspan="63"><code class="literal">LWLock</code></td><td><code class="literal">ShmemIndexLock</code></td><td>正等待在共享内存中查找或者分配空间。</td></tr><tr><td><code class="literal">OidGenLock</code></td><td>正等待分配或者赋予一个 OID。</td></tr><tr><td><code class="literal">XidGenLock</code></td><td>正等待分配或者赋予一个事务 ID。</td></tr><tr><td><code class="literal">ProcArrayLock</code></td><td>正等待在事务结尾得到一个快照或者清除事务 ID。</td></tr><tr><td><code class="literal">SInvalReadLock</code></td><td>正等待从共享无效消息队列中检索或者移除消息。</td></tr><tr><td><code class="literal">SInvalWriteLock</code></td><td>正等待在共享无效消息队列中增加一个消息。</td></tr><tr><td><code class="literal">WALBufMappingLock</code></td><td>正等待在 WAL 缓冲区中替换一个页面。</td></tr><tr><td><code class="literal">WALWriteLock</code></td><td>正等待 WAL 缓冲区被写入到磁盘。</td></tr><tr><td><code class="literal">ControlFileLock</code></td><td>正等待读取或者更新控制文件或创建一个新的 WAL 文件。</td></tr><tr><td><code class="literal">CheckpointLock</code></td><td>正等待执行检查点。</td></tr><tr><td><code class="literal">CLogControlLock</code></td><td>正等待读取或者更新事务状态。</td></tr><tr><td><code class="literal">SubtransControlLock</code></td><td>正等待读取或者更新子事务信息。</td></tr><tr><td><code class="literal">MultiXactGenLock</code></td><td>正等待读取或者更新共享多事务状态。</td></tr><tr><td><code class="literal">MultiXactOffsetControlLock</code></td><td>正等待读取或者更新多事务偏移映射。</td></tr><tr><td><code class="literal">MultiXactMemberControlLock</code></td><td>正等待读取或者更新多事务成员映射。</td></tr><tr><td><code class="literal">RelCacheInitLock</code></td><td>正等待读取或者写入关系缓冲区初始化文件。</td></tr><tr><td><code class="literal">CheckpointerCommLock</code></td><td>正等待管理 fsync 请求。</td></tr><tr><td><code class="literal">TwoPhaseStateLock</code></td><td>正等待读取或者更新预备事务的状态。</td></tr><tr><td><code class="literal">TablespaceCreateLock</code></td><td>正等待创建或者删除表空间。</td></tr><tr><td><code class="literal">BtreeVacuumLock</code></td><td>正等待读取或者更新一个 B-树索引的 vacuum 相关的信息。</td></tr><tr><td><code class="literal">AddinShmemInitLock</code></td><td>正等待管理共享内存中的空间分配。</td></tr><tr><td><code class="literal">AutovacuumLock</code></td><td>自动清理工作者或者启动器正等待更新或者读取自动清理工作者的当前状态。</td></tr><tr><td><code class="literal">AutovacuumScheduleLock</code></td><td>正等待确认选中进行清理的表仍需要清理。
         </td></tr><tr><td><code class="literal">SyncScanLock</code></td><td>正等待为同步扫描得到一个表上扫描的开始位置。</td></tr><tr><td><code class="literal">RelationMappingLock</code></td><td>正等待更新用来存储目录到文件节点映射的关系映射文件。
         </td></tr><tr><td><code class="literal">AsyncCtlLock</code></td><td>正等待读取或者更新共享通知状态。</td></tr><tr><td><code class="literal">AsyncQueueLock</code></td><td>正等待读取或者更新通知消息。</td></tr><tr><td><code class="literal">SerializableXactHashLock</code></td><td>正等待检索或者存储有关可序列化事务的信息。</td></tr><tr><td><code class="literal">SerializableFinishedListLock</code></td><td>正等待访问已结束可序列化事务的列表。</td></tr><tr><td><code class="literal">SerializablePredicateLockListLock</code></td><td>正等待在由可序列化事务持有的所列表上执行一个操作。</td></tr><tr><td><code class="literal">OldSerXidLock</code></td><td>正等待读取或者记录冲突的可序列化事务。</td></tr><tr><td><code class="literal">SyncRepLock</code></td><td>正等待读取或者更新有关同步复制的信息。</td></tr><tr><td><code class="literal">BackgroundWorkerLock</code></td><td>正等待读取或者更新后台工作者状态。</td></tr><tr><td><code class="literal">DynamicSharedMemoryControlLock</code></td><td>正等待读取或者更新动态共享内存状态。</td></tr><tr><td><code class="literal">AutoFileLock</code></td><td>正等待更新<code class="filename">postgresql.auto.conf</code>文件。</td></tr><tr><td><code class="literal">ReplicationSlotAllocationLock</code></td><td>正等待分配或者释放一个复制槽。</td></tr><tr><td><code class="literal">ReplicationSlotControlLock</code></td><td>正等待读取或者更新复制槽状态。</td></tr><tr><td><code class="literal">CommitTsControlLock</code></td><td>正等待读取或者更新事务提交时间戳。</td></tr><tr><td><code class="literal">CommitTsLock</code></td><td>正等待读取或者更新事务时间戳的最新设置值。</td></tr><tr><td><code class="literal">ReplicationOriginLock</code></td><td>正等待设置、删除或者使用复制源头。</td></tr><tr><td><code class="literal">MultiXactTruncationLock</code></td><td>正等待读取或者阶段多事务信息。</td></tr><tr><td><code class="literal">OldSnapshotTimeMapLock</code></td><td>正等待读取或者更新旧的快照控制信息。</td></tr><tr><td><code class="literal">BackendRandomLock</code></td><td>等待生成一个随机数。</td></tr><tr><td><code class="literal">LogicalRepWorkerLock</code></td><td>等待逻辑复制工作者完成操作。</td></tr><tr><td><code class="literal">CLogTruncationLock</code></td><td>等待截断预写日志或等待预写日志截断完成。</td></tr><tr><td><code class="literal">clog</code></td><td>正等待一个 clog（事务状态）缓冲区上的 I/O。</td></tr><tr><td><code class="literal">commit_timestamp</code></td><td>正等待提交时间戳缓冲区上的 I/O。</td></tr><tr><td><code class="literal">subtrans</code></td><td>正等待子事务缓冲区上的 I/O。</td></tr><tr><td><code class="literal">multixact_offset</code></td><td>正等待多事务偏移缓冲区上的 I/O。</td></tr><tr><td><code class="literal">multixact_member</code></td><td>正等待多事务成员缓冲区上的 I/O。</td></tr><tr><td><code class="literal">async</code></td><td>正等待 async（通知）缓冲区上的 I/O。</td></tr><tr><td><code class="literal">oldserxid</code></td><td>正等待 oldserxid 缓冲区上的 I/O。</td></tr><tr><td><code class="literal">wal_insert</code></td><td>正等待把 WAL 插入到一个内存缓冲区。</td></tr><tr><td><code class="literal">buffer_content</code></td><td>正等待读取或者写入内存中的一个数据页。</td></tr><tr><td><code class="literal">buffer_io</code></td><td>正等待一个数据页面上的 I/O。</td></tr><tr><td><code class="literal">replication_origin</code></td><td>正等待读取或者更新复制进度。</td></tr><tr><td><code class="literal">replication_slot_io</code></td><td>正等待一个复制槽上的 I/O。</td></tr><tr><td><code class="literal">proc</code></td><td>正等待读取或者更新 fast-path 锁信息。</td></tr><tr><td><code class="literal">buffer_mapping</code></td><td>正等待把一个数据块与缓冲池中的一个缓冲区关联。</td></tr><tr><td><code class="literal">lock_manager</code></td><td>正等待增加或者检查用于后端的锁，或者正等待加入或者退出一个锁定组（并行查询使用）。</td></tr><tr><td><code class="literal">predicate_lock_manager</code></td><td>正等待增加或者检查谓词锁信息。</td></tr><tr><td><code class="literal">parallel_query_dsa</code></td><td>等待并行查询动态共享内存分配锁定。</td></tr><tr><td><code class="literal">tbm</code></td><td>等待TBM共享迭代器锁定。</td></tr><tr><td rowspan="10"><code class="literal">Lock</code></td><td><code class="literal">relation</code></td><td>正等待获得一个关系上的锁。</td></tr><tr><td><code class="literal">extend</code></td><td>正等待扩展一个关系。</td></tr><tr><td><code class="literal">page</code></td><td>正等待获得一个关系上的页面的锁。</td></tr><tr><td><code class="literal">tuple</code></td><td>正等待获得一个元组上的锁。</td></tr><tr><td><code class="literal">transactionid</code></td><td>正等待一个事务结束。</td></tr><tr><td><code class="literal">virtualxid</code></td><td>正等待获得一个虚拟 xid 锁。</td></tr><tr><td><code class="literal">speculative token</code></td><td>正等待获取一个  speculative insertion lock。</td></tr><tr><td><code class="literal">object</code></td><td>正等待获得一个非关系数据库对象上的锁。</td></tr><tr><td><code class="literal">userlock</code></td><td>正等待获得一个用户锁。</td></tr><tr><td><code class="literal">advisory</code></td><td>正等待获得一个咨询用户锁。</td></tr><tr><td><code class="literal">BufferPin</code></td><td><code class="literal">BufferPin</code></td><td>正等待在一个缓冲区上加 pin。</td></tr><tr><td rowspan="14"><code class="literal">Activity</code></td><td><code class="literal">ArchiverMain</code></td><td>在归档进程的主循环中等待。</td></tr><tr><td><code class="literal">AutoVacuumMain</code></td><td>在自动清理加载进程的主循环中等待。</td></tr><tr><td><code class="literal">BgWriterHibernate</code></td><td>在后台写入进程中等待，蛰伏。</td></tr><tr><td><code class="literal">BgWriterMain</code></td><td>在后台写入进程后台工作的主循环中等待。</td></tr><tr><td><code class="literal">CheckpointerMain</code></td><td>在检查点进程的主循环中等待。</td></tr><tr><td><code class="literal">LogicalLauncherMain</code></td><td>在逻辑启动进程的主循环中等待。</td></tr><tr><td><code class="literal">LogicalApplyMain</code></td><td>在逻辑应用程序的主循环中等待。</td></tr><tr><td><code class="literal">PgStatMain</code></td><td>在统计收集器进程的主循环中等待。</td></tr><tr><td><code class="literal">RecoveryWalAll</code></td><td>在恢复期间从任何类型的源（本地，归档或流）等待WAL。</td></tr><tr><td><code class="literal">RecoveryWalStream</code></td><td>在恢复期间从流中等待WAL。</td></tr><tr><td><code class="literal">SysLoggerMain</code></td><td>在syslogger进程的主循环中等待。</td></tr><tr><td><code class="literal">WalReceiverMain</code></td><td>在WAL接收器进程的主循环中等待。</td></tr><tr><td><code class="literal">WalSenderMain</code></td><td>在WAL发送器进程的主循环中等待。</td></tr><tr><td><code class="literal">WalWriterMain</code></td><td>在WAL编写器进程的主循环中等待。</td></tr><tr><td rowspan="8"><code class="literal">Client</code></td><td><code class="literal">ClientRead</code></td><td>等待从客户端读取数据。</td></tr><tr><td><code class="literal">ClientWrite</code></td><td>等待从客户端写入数据。</td></tr><tr><td><code class="literal">LibPQWalReceiverConnect</code></td><td>等待WAL接收器建立与远程服务器的连接。</td></tr><tr><td><code class="literal">LibPQWalReceiverReceive</code></td><td>等待WAL接收器接收来自远程服务器的数据。</td></tr><tr><td><code class="literal">SSLOpenServer</code></td><td>尝试连接时等待SSL。</td></tr><tr><td><code class="literal">WalReceiverWaitStart</code></td><td>等待启动进程发送流式复制的初始数据。</td></tr><tr><td><code class="literal">WalSenderWaitForWAL</code></td><td>等待WAL在WAL发送者进程中刷新。</td></tr><tr><td><code class="literal">WalSenderWriteData</code></td><td>在WAL发送者进程中处理来自WAL接收者的回复时等待任何活动。</td></tr><tr><td><code class="literal">Extension</code></td><td><code class="literal">Extension</code></td><td>在一个扩展中等待。</td></tr><tr><td rowspan="17"><code class="literal">IPC</code></td><td><code class="literal">BgWorkerShutdown</code></td><td>等待后台工作者关闭。</td></tr><tr><td><code class="literal">BgWorkerStartup</code></td><td>等待后台工作者启动。</td></tr><tr><td><code class="literal">BtreePage</code></td><td>等待继续并行B-tree扫描变得可用所需的页码</td></tr><tr><td><code class="literal">ExecuteGather</code></td><td>在执行<code class="literal">Gather</code>节点时等待子进程的活动。</td></tr><tr><td><code class="literal">LogicalSyncData</code></td><td>等待逻辑复制远程服务器为初始表同步发送数据。</td></tr><tr><td><code class="literal">LogicalSyncStateChange</code></td><td>等待逻辑复制远程服务器更改状态。</td></tr><tr><td><code class="literal">MessageQueueInternal</code></td><td>等待其他进程被附加到共享消息队列中。</td></tr><tr><td><code class="literal">MessageQueuePutMessage</code></td><td>等待将协议消息写入共享消息队列。</td></tr><tr><td><code class="literal">MessageQueueReceive</code></td><td>等待接收来自共享消息队列的字节。</td></tr><tr><td><code class="literal">MessageQueueSend</code></td><td>等待将字节发送到共享消息队列。</td></tr><tr><td><code class="literal">ParallelFinish</code></td><td>等待并行工作者完成计算。</td></tr><tr><td><code class="literal">ParallelBitmapScan</code></td><td>等待并行位图扫描初始化。</td></tr><tr><td><code class="literal">ProcArrayGroupUpdate</code></td><td>等待小组负责人在事务结束时清除事务ID。</td></tr><tr><td><code class="literal">ReplicationOriginDrop</code></td><td>等待复制起点变为非活动状态以便删除。</td></tr><tr><td><code class="literal">ReplicationSlotDrop</code></td><td>等待复制槽变为非活动状态以便删除。</td></tr><tr><td><code class="literal">SafeSnapshot</code></td><td>等待<code class="literal">READ ONLY DEFERRABLE</code>事务的快照。</td></tr><tr><td><code class="literal">SyncRep</code></td><td>在同步复制期间等待来自远程服务器的确认。</td></tr><tr><td rowspan="3"><code class="literal">Timeout</code></td><td><code class="literal">BaseBackupThrottle</code></td><td>节流活动时在基准备份期间等待。</td></tr><tr><td><code class="literal">PgSleep</code></td><td>在名为<code class="function">pg_sleep</code>的进程中等待。</td></tr><tr><td><code class="literal">RecoveryApplyDelay</code></td><td>等待恢复时使用WAL，因为它被延迟。</td></tr><tr><td rowspan="66"><code class="literal">IO</code></td><td><code class="literal">BufFileRead</code></td><td>等待从缓冲文件读取数据。</td></tr><tr><td><code class="literal">BufFileWrite</code></td><td>等待写入缓冲文件。</td></tr><tr><td><code class="literal">ControlFileRead</code></td><td>等待读取控制文件。</td></tr><tr><td><code class="literal">ControlFileSync</code></td><td>等待控制文件达到稳定存储。</td></tr><tr><td><code class="literal">ControlFileSyncUpdate</code></td><td>等待控制文件的更新以达到稳定的存储。</td></tr><tr><td><code class="literal">ControlFileWrite</code></td><td>等待写入控制文件。</td></tr><tr><td><code class="literal">ControlFileWriteUpdate</code></td><td>等待写入更新控制文件。</td></tr><tr><td><code class="literal">CopyFileRead</code></td><td>在文件复制操作期间等待读取。</td></tr><tr><td><code class="literal">CopyFileWrite</code></td><td>在文件复制操作期间等待写入。</td></tr><tr><td><code class="literal">DataFileExtend</code></td><td>等待关系数据文件被扩展。</td></tr><tr><td><code class="literal">DataFileFlush</code></td><td>等待关系数据文件达到稳定存储。</td></tr><tr><td><code class="literal">DataFileImmediateSync</code></td><td>等待关系数据文件的立即同步达到稳定存储。</td></tr><tr><td><code class="literal">DataFilePrefetch</code></td><td>等待关系数据文件的异步预取。</td></tr><tr><td><code class="literal">DataFileRead</code></td><td>等待关系数据文件的读取。</td></tr><tr><td><code class="literal">DataFileSync</code></td><td>等待关系数据文件的更改达到稳定的存储。</td></tr><tr><td><code class="literal">DataFileTruncate</code></td><td>等待关系数据文件被截断。</td></tr><tr><td><code class="literal">DataFileWrite</code></td><td>等待写入关系数据文件。</td></tr><tr><td><code class="literal">DSMFillZeroWrite</code></td><td>等待将零字节写入动态共享内存备份文件。</td></tr><tr><td><code class="literal">LockFileAddToDataDirRead</code></td><td>在向数据目录锁定文件添加一行时等待读取。</td></tr><tr><td><code class="literal">LockFileAddToDataDirSync</code></td><td>在向数据目录锁定文件添加一行时等待数据达到稳定存储。</td></tr><tr><td><code class="literal">LockFileAddToDataDirWrite</code></td><td>在向数据目录锁定文件添加一行时等待写入。</td></tr><tr><td><code class="literal">LockFileCreateRead</code></td><td>在创建数据目录锁定文件时等待读取。</td></tr><tr><td><code class="literal">LockFileCreateSync</code></td><td>等待数据在创建数据目录锁定文件时达到稳定存储。</td></tr><tr><td><code class="literal">LockFileCreateWrite</code></td><td>在创建数据目录锁定文件时等待写入。</td></tr><tr><td><code class="literal">LockFileReCheckDataDirRead</code></td><td>在重新检查数据目录锁定文件期间等待读取。</td></tr><tr><td><code class="literal">LogicalRewriteCheckpointSync</code></td><td>等待逻辑重写映射在检查点期间达到稳定存储。</td></tr><tr><td><code class="literal">LogicalRewriteMappingSync</code></td><td>在逻辑重写期间等待映射数据达到稳定存储。</td></tr><tr><td><code class="literal">LogicalRewriteMappingWrite</code></td><td>在逻辑重写期间等待写入映射数据。</td></tr><tr><td><code class="literal">LogicalRewriteSync</code></td><td>等待逻辑重写映射达到稳定的存储。</td></tr><tr><td><code class="literal">LogicalRewriteWrite</code></td><td>等待写入逻辑重写映射。</td></tr><tr><td><code class="literal">RelationMapRead</code></td><td>等待读取关系映射文件。</td></tr><tr><td><code class="literal">RelationMapSync</code></td><td>等待关系映射文件达到稳定存储。</td></tr><tr><td><code class="literal">RelationMapWrite</code></td><td>等待写入关系映射文件。</td></tr><tr><td><code class="literal">ReorderBufferRead</code></td><td>在排序缓冲区管理期间等待读取。</td></tr><tr><td><code class="literal">ReorderBufferWrite</code></td><td>在重新排序缓冲区管理期间等待写入。</td></tr><tr><td><code class="literal">ReorderLogicalMappingRead</code></td><td>在重新排序缓冲区管理期间等待读取逻辑映射。</td></tr><tr><td><code class="literal">ReplicationSlotRead</code></td><td>等待从复制插槽控制文件读取数据。</td></tr><tr><td><code class="literal">ReplicationSlotRestoreSync</code></td><td>等待复制插槽控制文件在恢复到内存时达到稳定的存储。</td></tr><tr><td><code class="literal">ReplicationSlotSync</code></td><td>等待复制插槽控制文件达到稳定存储。</td></tr><tr><td><code class="literal">ReplicationSlotWrite</code></td><td>等待写入复制插槽控制文件。</td></tr><tr><td><code class="literal">SLRUFlushSync</code></td><td>在检查点或数据库关闭期间等待SLRU数据达到稳定存储。</td></tr><tr><td><code class="literal">SLRURead</code></td><td>等待读取SLRU页面。</td></tr><tr><td><code class="literal">SLRUSync</code></td><td>等待SLRU数据在页面写入后达到稳定存储。</td></tr><tr><td><code class="literal">SLRUWrite</code></td><td>等待写一个SLRU页面。</td></tr><tr><td><code class="literal">SnapbuildRead</code></td><td>等待读取序列化的历史目录快照。</td></tr><tr><td><code class="literal">SnapbuildSync</code></td><td>等待序列化的历史目录快照达到稳定的存储。</td></tr><tr><td><code class="literal">SnapbuildWrite</code></td><td>等待写入序列化的历史目录快照。</td></tr><tr><td><code class="literal">TimelineHistoryFileSync</code></td><td>等待通过流式复制接收的时间线历史文件以达到稳定的存储。</td></tr><tr><td><code class="literal">TimelineHistoryFileWrite</code></td><td>等待写入通过流式复制接收的时间线历史文件。</td></tr><tr><td><code class="literal">TimelineHistoryRead</code></td><td>等待读取时间线历史文件。</td></tr><tr><td><code class="literal">TimelineHistorySync</code></td><td>等待新创建的时间线历史文件以达到稳定的存储。</td></tr><tr><td><code class="literal">TimelineHistoryWrite</code></td><td>等待写入新创建的时间线历史文件。</td></tr><tr><td><code class="literal">TwophaseFileRead</code></td><td>等待读取两阶段状态文件。</td></tr><tr><td><code class="literal">TwophaseFileSync</code></td><td>等待两阶段状态文件以达到稳定存储。</td></tr><tr><td><code class="literal">TwophaseFileWrite</code></td><td>等待写入两阶段状态文件。</td></tr><tr><td><code class="literal">WALBootstrapSync</code></td><td>等待WAL在启动过程中达到稳定存储。</td></tr><tr><td><code class="literal">WALBootstrapWrite</code></td><td>在启动过程中等待写入WAL页面。</td></tr><tr><td><code class="literal">WALCopyRead</code></td><td>通过复制现有的WAL段创建新的WAL段时等待读取。</td></tr><tr><td><code class="literal">WALCopySync</code></td><td>等待通过复制现有WAL段来创建新的WAL段达到稳定的存储。</td></tr><tr><td><code class="literal">WALCopyWrite</code></td><td>通过复制现有的WAL段来创建新的WAL段时，等待写入。</td></tr><tr><td><code class="literal">WALInitSync</code></td><td>等待新初始化的WAL文件达到稳定存储。</td></tr><tr><td><code class="literal">WALInitWrite</code></td><td>在初始化新的WAL文件时等待写入。</td></tr><tr><td><code class="literal">WALRead</code></td><td>等待从WAL文件读取。</td></tr><tr><td><code class="literal">WALSenderTimelineHistoryRead</code></td><td>在walsender时间轴命令期间等待时间线历史文件的读取。</td></tr><tr><td><code class="literal">WALSyncMethodAssign</code></td><td>在分配WAL同步方法时等待数据达到稳定存储。</td></tr><tr><td><code class="literal">WALWrite</code></td><td>等待写入WAL文件。</td></tr></tbody></table></div></div><br class="table-break" /><div class="note"><h3 class="title">注意</h3><p>     对于扩展安装的切片（tranche），这个名称由扩展指定并且会被<code class="structfield">wait_event</code>显示出来。很有可能在其他后端不知道的情况下，用户在其中一个后端中注册了切片（通过在动态共享内存中分配），那么我们对这种情况会显示<code class="literal">extension</code>。
    </p></div><p>     下面的例子展示了如何查看等待事件

</p><pre class="programlisting">SELECT pid, wait_event_type, wait_event FROM pg_stat_activity WHERE wait_event is NOT NULL;
 pid  | wait_event_type |  wait_event
------+-----------------+---------------
 2540 | Lock            | relation
 6644 | LWLock          | ProcArrayLock
(2 rows)</pre><p>
   </p><div class="table" id="PG-STAT-REPLICATION-VIEW"><p class="title"><strong>表 28.5. <code class="structname">pg_stat_replication</code> 视图</strong></p><div class="table-contents"><table class="table" summary="pg_stat_replication 视图" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>列</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="structfield">pid</code></td><td><code class="type">integer</code></td><td>一个 WAL 发送进程的进程 ID</td></tr><tr><td><code class="structfield">usesysid</code></td><td><code class="type">oid</code></td><td>登录到这个 WAL 发送进程的用户的 OID</td></tr><tr><td><code class="structfield">usename</code></td><td><code class="type">name</code></td><td>登录到这个 WAL 发送进程的用户的名称</td></tr><tr><td><code class="structfield">application_name</code></td><td><code class="type">text</code></td><td>连接到这个 WAL 发送进程的应用的名称</td></tr><tr><td><code class="structfield">client_addr</code></td><td><code class="type">inet</code></td><td>连接到这个 WAL 发送进程的客户端的 IP 地址。
     如果这个域为空，它表示该客户端通过服务器机器上的一个
     Unix 套接字连接。
     </td></tr><tr><td><code class="structfield">client_hostname</code></td><td><code class="type">text</code></td><td>连接上的客户端的主机名，由一次对<code class="structfield">client_addr</code>
     的逆向 DNS 查找报告。这个域将只对 IP 连接非空，并且只有在
     <a class="xref" href="runtime-config-logging.html#GUC-LOG-HOSTNAME">log_hostname</a>被启用时非空
     </td></tr><tr><td><code class="structfield">client_port</code></td><td><code class="type">integer</code></td><td>客户端用来与这个 WAL 发送进程通讯的 TCP 端口号，
     如果使用 Unix 套接字则为<code class="literal">-1</code>
     </td></tr><tr><td><code class="structfield">backend_start</code></td><td><code class="type">timestamp with time zone</code></td><td>这个进程开始的时间，即客户端是何时连接到这个
     WAL 发送进程的
     </td></tr><tr><td><code class="structfield">backend_xmin</code></td><td><code class="type">xid</code></td><td>由<a class="xref" href="runtime-config-replication.html#GUC-HOT-STANDBY-FEEDBACK">hot_standby_feedback</a>报告
     的这个后备机的<code class="literal">xmin</code>水平线。</td></tr><tr><td><code class="structfield">state</code></td><td><code class="type">text</code></td><td>当前的 WAL 发送进程状态
       可能的值是：
       <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>           <code class="literal">startup</code>: 这个 WAL 发送进程正在启动。
          </p></li><li class="listitem"><p>           <code class="literal">catchup</code>: 这个 WAL 发送进程连接的备用服务器正在追赶主服务器。
          </p></li><li class="listitem"><p>           <code class="literal">streaming</code>: 这个 WAL 发送进程在其连接的备用服务器追赶上主服务器之后传输更改。
          </p></li><li class="listitem"><p>           <code class="literal">backup</code>: 这个 WAL 发送进程正在发送一个备份。
          </p></li><li class="listitem"><p>           <code class="literal">stopping</code>: 这个 WAL 发送进程正在停止。
          </p></li></ul></div>
     </td></tr><tr><td><code class="structfield">sent_lsn</code></td><td><code class="type">pg_lsn</code></td><td>在这个连接上发送的最后一个预写日志的位置</td></tr><tr><td><code class="structfield">write_lsn</code></td><td><code class="type">pg_lsn</code></td><td>被这个后备服务器写入到磁盘的最后一个预写日志的位置</td></tr><tr><td><code class="structfield">flush_lsn</code></td><td><code class="type">pg_lsn</code></td><td>被这个后备服务器刷入到磁盘的最后一个预写日志的位置</td></tr><tr><td><code class="structfield">replay_lsn</code></td><td><code class="type">pg_lsn</code></td><td>被重放到这个后备服务器上的数据库中的最后一个预写日志的位置</td></tr><tr><td><code class="structfield">write_lag</code></td><td><code class="type">interval</code></td><td>从本地刷新最近的WAL到接收到该备用服务器已经写入它（但尚未刷新或应用它）
	  的通知之间所经过的时间。如果将此服务器配置为同步备用服务器，
	  则可以用它来测量在提交时发生的<code class="literal">synchronous_commit</code>
	  级别的<code class="literal">remote_write</code>的延迟。</td></tr><tr><td><code class="structfield">flush_lag</code></td><td><code class="type">interval</code></td><td>从本地刷新最近的WAL到接收到该备用服务器写入并刷新它
	  （但尚未应用它）的通知之间的时间间隔。如果将此服务器配置为同步备用服务器，
	  则可以用它来测量在提交时发生的<code class="literal">synchronous_commit</code>
	  级别的<code class="literal">remote_flush</code>的延迟。</td></tr><tr><td><code class="structfield">replay_lag</code></td><td><code class="type">interval</code></td><td>从本地刷新最近的WAL到接收到该备用服务器写入、
	  刷新并应用它的通知之间的时间间隔。如果将此服务器配置为同步备用服务器，
	  则可以用它来测量在提交时发生的<code class="literal">synchronous_commit</code>
	  级别的<code class="literal">remote_apply</code>的延迟。</td></tr><tr><td><code class="structfield">sync_priority</code></td><td><code class="type">integer</code></td><td>此备用服务器的优先级被选为基于优先级的同步复制中的同步备用服务器。
	 这在基于定量的同步复制中不起作用。</td></tr><tr><td><code class="structfield">sync_state</code></td><td><code class="type">text</code></td><td>这个后备服务器的同步状态
       可能的值是：
       <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>           <code class="literal">async</code>: 该备用服务器是异步的。
          </p></li><li class="listitem"><p>           <code class="literal">potential</code>: 
		   此备用服务器现在是异步的，但如果当前同步服务器中的一个出现故障，可能会变为同步服务器。
          </p></li><li class="listitem"><p>           <code class="literal">sync</code>: 该备用服务器是同步的。
          </p></li><li class="listitem"><p>           <code class="literal">quorum</code>: 此备用服务器被视为仲裁备用服务器的候选人。
          </p></li></ul></div>
     </td></tr></tbody></table></div></div><br class="table-break" /><p>   <code class="structname">pg_stat_replication</code>视图中将为每一个 WAL
   发送进程包含一行，用来显示与该发送进程连接的后备服务器的复制统计信息。
   这个视图中只会列出直接连接的后备机，下游后备服务器的信息不包含在此。
  </p><p>   在<code class="structname">pg_stat_replication</code>视图中报告的滞后时间是对最近WAL写入、
   刷新和重放以及让发送程序了解它的时间的度量。如果将远程服务器配置为同步备用数据库，
   则这些时间表示由每个同步提交级别引入的提交延迟。对于异步备用数据库，
   <code class="structfield">replay_lag</code>列近似于最近事务对查询可见之前的延迟。
   如果备用服务器已完全赶上发送服务器并且没有更多WAL活动，
   则最近测量的滞后时间将在短时间内继续显示，然后显示NULL。
  </p><p>   延迟时间会自动用于物理复制。逻辑解码插件可以选择发送跟踪消息；
   如果他们不这样做，跟踪机制将显示NULL滞后。
  </p><div class="note"><h3 class="title">注意</h3><p>    所报告的滞后时间并不能预测备用服务器假设当前的重播速度赶上发送服务器需要多长时间。
	这种系统会在生成新的WAL时显示类似的时间，但当发送进程闲置时会有所不同。
	特别是，当备用数据库完全追赶上时，<code class="structname">pg_stat_replication</code>
	显示写入、刷新和重播最近报告的WAL位置所需的时间，而不是像某些用户预期的那样为零。
	这与测量近期写入事务的同步提交和事务可见性延迟的目标一致。
	为了减少期待不同滞后模型的用户的混淆，滞后列在完全重放的空闲系统上短时间后恢复为NULL。
	监测系统应选择是否将其表示为缺失数据，为零或继续显示最后已知的值。
   </p></div><div class="table" id="PG-STAT-WAL-RECEIVER-VIEW"><p class="title"><strong>表 28.6. <code class="structname">pg_stat_wal_receiver</code> 视图</strong></p><div class="table-contents"><table class="table" summary="pg_stat_wal_receiver 视图" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>列</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="structfield">pid</code></td><td><code class="type">integer</code></td><td>WAL 接收器进程的进程 ID</td></tr><tr><td><code class="structfield">status</code></td><td><code class="type">text</code></td><td>WAL 接收器进程的活动状态</td></tr><tr><td><code class="structfield">receive_start_lsn</code></td><td><code class="type">pg_lsn</code></td><td>WAL 接收器启动时使用的第一个预写日志位置</td></tr><tr><td><code class="structfield">receive_start_tli</code></td><td><code class="type">integer</code></td><td>WAL 接收器启动时使用的第一个时间线编号</td></tr><tr><td><code class="structfield">received_lsn</code></td><td><code class="type">pg_lsn</code></td><td>已经接收到并且已经被杀入磁盘的最后一个预写日志的位置，这个域的初始值是 WAL 接收器启动时使用的第一个日志位置</td></tr><tr><td><code class="structfield">received_tli</code></td><td><code class="type">integer</code></td><td>已经接收到并且已经被杀入磁盘的最后一个预写日志的时间线编号，这个域的初始值是 WAL 接收器启动时使用的第一个日志所在的时间线编号
     </td></tr><tr><td><code class="structfield">last_msg_send_time</code></td><td><code class="type">timestamp with time zone</code></td><td>从源头 WAL 发送器接收到的最后一个消息的发送时间</td></tr><tr><td><code class="structfield">last_msg_receipt_time</code></td><td><code class="type">timestamp with time zone</code></td><td>从源头 WAL 发送器接收到的最后一个消息的接收时间</td></tr><tr><td><code class="structfield">latest_end_lsn</code></td><td><code class="type">pg_lsn</code></td><td>报告给源头 WAL 发送器的最后一个预写日志位置</td></tr><tr><td><code class="structfield">latest_end_time</code></td><td><code class="type">timestamp with time zone</code></td><td>报告给源头 WAL 发送器最后一个预写日志位置的时间</td></tr><tr><td><code class="structfield">slot_name</code></td><td><code class="type">text</code></td><td>这个 WAL 接收器使用的复制槽的名称</td></tr><tr><td><code class="structfield">conninfo</code></td><td><code class="type">text</code></td><td>      这个 WAL 接收器使用的连接串，安全相关的域会被隐去。
     </td></tr></tbody></table></div></div><br class="table-break" /><p>   <code class="structname">pg_stat_wal_receiver</code>事务只包含一行，它显示了从 WAL 接收器所连接的服务器得到的有关该接收器的统计信息。
  </p><div class="table" id="PG-STAT-SUBSCRIPTION"><p class="title"><strong>表 28.7. <code class="structname">pg_stat_subscription</code> 视图</strong></p><div class="table-contents"><table class="table" summary="pg_stat_subscription 视图" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="structfield">subid</code></td><td><code class="type">oid</code></td><td>订阅的 OID</td></tr><tr><td><code class="structfield">subname</code></td><td><code class="type">text</code></td><td>订阅的名称</td></tr><tr><td><code class="structfield">pid</code></td><td><code class="type">integer</code></td><td>订阅工作进程的进程ID</td></tr><tr><td><code class="structfield">relid</code></td><td><code class="type">Oid</code></td><td>工作进程正在同步的关系的OID；主应用工作进程为null</td></tr><tr><td><code class="structfield">received_lsn</code></td><td><code class="type">pg_lsn</code></td><td>最后一次接收到预写日志位置，此字段的初始值为0</td></tr><tr><td><code class="structfield">last_msg_send_time</code></td><td><code class="type">timestamp with time zone</code></td><td>从原始WAL发件程序收到的最后一条消息的发送时间</td></tr><tr><td><code class="structfield">last_msg_receipt_time</code></td><td><code class="type">timestamp with time zone</code></td><td>从原始WAL发件程序收到的最后一条消息的接收时间
     </td></tr><tr><td><code class="structfield">latest_end_lsn</code></td><td><code class="type">pg_lsn</code></td><td>报告给原始WAL发送程序的最后预写日志位置
     </td></tr><tr><td><code class="structfield">latest_end_time</code></td><td><code class="type">timestamp with time zone</code></td><td>给原始WAL发送程序报告最后预写日志位置的时间</td></tr></tbody></table></div></div><br class="table-break" /><p>   <code class="structname">pg_stat_subscription</code>
   视图将包含主工作进程的每个订阅一行（如果工作进程未运行，则为null PID），
   以及处理订阅表的初始数据副本的工作进程的附加行。
  </p><div class="table" id="PG-STAT-SSL-VIEW"><p class="title"><strong>表 28.8. <code class="structname">pg_stat_ssl</code> 视图</strong></p><div class="table-contents"><table class="table" summary="pg_stat_ssl 视图" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>列</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="structfield">pid</code></td><td><code class="type">integer</code></td><td>一个后端或者 WAL 发送进程的进程 ID</td></tr><tr><td><code class="structfield">ssl</code></td><td><code class="type">boolean</code></td><td>如果在这个连接上使用了 SSL 则为真</td></tr><tr><td><code class="structfield">version</code></td><td><code class="type">text</code></td><td>在用的 SSL 版本，如果这个连接上没有使用 SSL 则为 NULL</td></tr><tr><td><code class="structfield">cipher</code></td><td><code class="type">text</code></td><td>在用的 SSL 密码的名称，如果这个连接上没有使用 SSL 则为 NULL</td></tr><tr><td><code class="structfield">bits</code></td><td><code class="type">integer</code></td><td>使用的加密算法中的位数，如果这个连接上没有使用 SSL 则为 NULL</td></tr><tr><td><code class="structfield">compression</code></td><td><code class="type">boolean</code></td><td>如果使用了 SSL 压缩则为真，否则为假，
     如果这个连接上没有使用 SSL 则为 NULL</td></tr><tr><td><code class="structfield">clientdn</code></td><td><code class="type">text</code></td><td>来自所使用的客户端证书的识别名（DN）域，
     如果没有提供客户端证书或者这个连接上没有使用 SSL 
     则为 NULL。如果 DN 域长度超过
     <code class="symbol">NAMEDATALEN</code>（标准编译
     中是 64 个字符），则它会被截断。
     </td></tr></tbody></table></div></div><br class="table-break" /><p>   <code class="structname">pg_stat_ssl</code>视图将为每一个后端或者 WAL 发送进程
   包含一行，用来显示这个连接上的 SSL 使用情况。可以把它与
   <code class="structname">pg_stat_activity</code>或者
   <code class="structname">pg_stat_replication</code>通过
   <code class="structfield">pid</code>列连接来得到更多有关该连接的细节。
  </p><div class="table" id="PG-STAT-ARCHIVER-VIEW"><p class="title"><strong>表 28.9. <code class="structname">pg_stat_archiver</code>视图</strong></p><div class="table-contents"><table class="table" summary="pg_stat_archiver视图" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>列</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="structfield">archived_count</code></td><td><code class="type">bigint</code></td><td>已被成功归档的 WAL 文件数量</td></tr><tr><td><code class="structfield">last_archived_wal</code></td><td><code class="type">text</code></td><td>最后一个被成功归档的 WAL 文件名称</td></tr><tr><td><code class="structfield">last_archived_time</code></td><td><code class="type">timestamp with time zone</code></td><td>最后一次成功归档操作的时间</td></tr><tr><td><code class="structfield">failed_count</code></td><td><code class="type">bigint</code></td><td>失败的归档 WAL 文件尝试的数量</td></tr><tr><td><code class="structfield">last_failed_wal</code></td><td><code class="type">text</code></td><td>最后一次失败的归档操作的 WAL 文件名称</td></tr><tr><td><code class="structfield">last_failed_time</code></td><td><code class="type">timestamp with time zone</code></td><td>最后一次失败的归档操作的时间</td></tr><tr><td><code class="structfield">stats_reset</code></td><td><code class="type">timestamp with time zone</code></td><td>这些统计信息最后一次被重置的时间</td></tr></tbody></table></div></div><br class="table-break" /><p>   The <code class="structname">pg_stat_archiver</code>视图将总是一个单一的行，
   该行包含着有关集簇的归档进程的数据。
  </p><div class="table" id="PG-STAT-BGWRITER-VIEW"><p class="title"><strong>表 28.10. <code class="structname">pg_stat_bgwriter</code>视图</strong></p><div class="table-contents"><table class="table" summary="pg_stat_bgwriter视图" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>列</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="structfield">checkpoints_timed</code></td><td><code class="type">bigint</code></td><td>已经被执行的计划中检查点的数量</td></tr><tr><td><code class="structfield">checkpoints_req</code></td><td><code class="type">bigint</code></td><td>已经被执行的请求检查点的数量</td></tr><tr><td><code class="structfield">checkpoint_write_time</code></td><td><code class="type">double precision</code></td><td>在文件被写入磁盘的检查点处理部分花费的总时间，以毫秒计
      </td></tr><tr><td><code class="structfield">checkpoint_sync_time</code></td><td><code class="type">double precision</code></td><td>在文件被同步到磁盘中的检查点处理部分花费的总时间，以毫秒计
      </td></tr><tr><td><code class="structfield">buffers_checkpoint</code></td><td><code class="type">bigint</code></td><td>在检查点期间被写的缓冲区数目</td></tr><tr><td><code class="structfield">buffers_clean</code></td><td><code class="type">bigint</code></td><td>被后台写进程写的缓冲区数目</td></tr><tr><td><code class="structfield">maxwritten_clean</code></td><td><code class="type">bigint</code></td><td>后台写进程由于已经写了太多缓冲区而停止清洁扫描的次数</td></tr><tr><td><code class="structfield">buffers_backend</code></td><td><code class="type">bigint</code></td><td>被一个后端直接写的缓冲区数量</td></tr><tr><td><code class="structfield">buffers_backend_fsync</code></td><td><code class="type">bigint</code></td><td>一个后端不得不自己执行<code class="function">fsync</code>调用的次数（通常即使后端自己进行写操作，后台写进程也会处理这些）</td></tr><tr><td><code class="structfield">buffers_alloc</code></td><td><code class="type">bigint</code></td><td>被分配的缓冲区数量</td></tr><tr><td><code class="structfield">stats_reset</code></td><td><code class="type">timestamp with time zone</code></td><td>这些统计信息上次被重置的时间</td></tr></tbody></table></div></div><br class="table-break" /><p>   <code class="structname">pg_stat_bgwriter</code>视图将总是只有单独的一行，它包含集簇的全局数据。
  </p><div class="table" id="PG-STAT-DATABASE-VIEW"><p class="title"><strong>表 28.11. <code class="structname">pg_stat_database</code>视图</strong></p><div class="table-contents"><table class="table" summary="pg_stat_database视图" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>列</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="structfield">datid</code></td><td><code class="type">oid</code></td><td>一个数据库的 OID</td></tr><tr><td><code class="structfield">datname</code></td><td><code class="type">name</code></td><td>这个数据库的名称</td></tr><tr><td><code class="structfield">numbackends</code></td><td><code class="type">integer</code></td><td>当前连接到这个数据库的后端数量。这是在这个视图中唯一一个返回反映当前状态值的列。所有其他列返回从上次重置以来积累的值。</td></tr><tr><td><code class="structfield">xact_commit</code></td><td><code class="type">bigint</code></td><td>在这个数据库中已经被提交的事务的数量</td></tr><tr><td><code class="structfield">xact_rollback</code></td><td><code class="type">bigint</code></td><td>在这个数据库中已经被回滚的事务的数量</td></tr><tr><td><code class="structfield">blks_read</code></td><td><code class="type">bigint</code></td><td>在这个数据库中被读取的磁盘块的数量</td></tr><tr><td><code class="structfield">blks_hit</code></td><td><code class="type">bigint</code></td><td>磁盘块被发现已经在缓冲区中的次数，这样不需要一次读取（这只包括 PostgreSQL 缓冲区中的命中，而不包括在操作系统文件系统缓冲区中的命中）
     </td></tr><tr><td><code class="structfield">tup_returned</code></td><td><code class="type">bigint</code></td><td>在这个数据库中被查询返回的行数</td></tr><tr><td><code class="structfield">tup_fetched</code></td><td><code class="type">bigint</code></td><td>在这个数据库中被查询取出的行数</td></tr><tr><td><code class="structfield">tup_inserted</code></td><td><code class="type">bigint</code></td><td>在这个数据库中被查询插入的行数</td></tr><tr><td><code class="structfield">tup_updated</code></td><td><code class="type">bigint</code></td><td>在这个数据库中被查询更新的行数</td></tr><tr><td><code class="structfield">tup_deleted</code></td><td><code class="type">bigint</code></td><td>在这个数据库中被查询删除的行数</td></tr><tr><td><code class="structfield">conflicts</code></td><td><code class="type">bigint</code></td><td>由于与恢复冲突而在这个数据库中被取消的查询的数目（冲突只发生在后备服务器上，详见<a class="xref" href="monitoring-stats.html#PG-STAT-DATABASE-CONFLICTS-VIEW" title="表 28.12. pg_stat_database_conflicts 视图">pg_stat_database_conflicts</a>）。
     </td></tr><tr><td><code class="structfield">temp_files</code></td><td><code class="type">bigint</code></td><td>在这个数据库中被查询创建的临时文件的数量。所有临时文件都被统计，不管为什么创建这些临时文件（如排序或哈希），并且不管<a class="xref" href="runtime-config-logging.html#GUC-LOG-TEMP-FILES">log_temp_files</a>设置。
     </td></tr><tr><td><code class="structfield">temp_bytes</code></td><td><code class="type">bigint</code></td><td>在这个数据库中被查询写到临时文件中的数据总量。所有临时文件都被统计，不管为什么创建这些临时文件（如排序或哈希），并且不管<a class="xref" href="runtime-config-logging.html#GUC-LOG-TEMP-FILES">log_temp_files</a>设置。
     </td></tr><tr><td><code class="structfield">deadlocks</code></td><td><code class="type">bigint</code></td><td>在这个数据库中被检测到的死锁数</td></tr><tr><td><code class="structfield">blk_read_time</code></td><td><code class="type">double precision</code></td><td>在这个数据库中后端花费在读取数据文件块的时间，以毫秒计</td></tr><tr><td><code class="structfield">blk_write_time</code></td><td><code class="type">double precision</code></td><td>在这个数据库中后端花费在写数据文件块的时间，以毫秒计</td></tr><tr><td><code class="structfield">stats_reset</code></td><td><code class="type">timestamp with time zone</code></td><td>这些统计信息上次被重置的时间</td></tr></tbody></table></div></div><br class="table-break" /><p>   <code class="structname">pg_stat_database</code>视图将为集簇中的每一个数据库包含有一行，每一行显示数据库范围的统计信息。
  </p><div class="table" id="PG-STAT-DATABASE-CONFLICTS-VIEW"><p class="title"><strong>表 28.12. <code class="structname">pg_stat_database_conflicts</code> 视图</strong></p><div class="table-contents"><table class="table" summary="pg_stat_database_conflicts 视图" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>列</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="structfield">datid</code></td><td><code class="type">oid</code></td><td>一个数据库的 OID</td></tr><tr><td><code class="structfield">datname</code></td><td><code class="type">name</code></td><td>这个数据库的名称</td></tr><tr><td><code class="structfield">confl_tablespace</code></td><td><code class="type">bigint</code></td><td>这个数据库中由于表空间被删掉而取消的查询数量</td></tr><tr><td><code class="structfield">confl_lock</code></td><td><code class="type">bigint</code></td><td>这个数据库中由于锁超时而取消的查询数量</td></tr><tr><td><code class="structfield">confl_snapshot</code></td><td><code class="type">bigint</code></td><td>这个数据库中由于旧快照而取消的查询数量</td></tr><tr><td><code class="structfield">confl_bufferpin</code></td><td><code class="type">bigint</code></td><td>这个数据库中由于被占用的缓冲区而取消的查询数量</td></tr><tr><td><code class="structfield">confl_deadlock</code></td><td><code class="type">bigint</code></td><td>这个数据库中由于死锁而取消的查询数量</td></tr></tbody></table></div></div><br class="table-break" /><p>   <code class="structname">pg_stat_database_conflicts</code>视图为每一个
   数据库包含一行，用来显示数据库范围内由于与后备服务器上的恢复过程
   冲突而被取消的查询的统计信息。 这个视图将只包含后备服务器上的信息，
   因为冲突会不发生在主服务器上。
  </p><div class="table" id="PG-STAT-ALL-TABLES-VIEW"><p class="title"><strong>表 28.13. <code class="structname">pg_stat_all_tables</code>视图</strong></p><div class="table-contents"><table class="table" summary="pg_stat_all_tables视图" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>列</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="structfield">relid</code></td><td><code class="type">oid</code></td><td>一个表的 OID</td></tr><tr><td><code class="structfield">schemaname</code></td><td><code class="type">name</code></td><td>这个表所在的模式的名称</td></tr><tr><td><code class="structfield">relname</code></td><td><code class="type">name</code></td><td>这个表的名称</td></tr><tr><td><code class="structfield">seq_scan</code></td><td><code class="type">bigint</code></td><td>在这个表上发起的顺序扫描的次数</td></tr><tr><td><code class="structfield">seq_tup_read</code></td><td><code class="type">bigint</code></td><td>被顺序扫描取得的活着的行的数量</td></tr><tr><td><code class="structfield">idx_scan</code></td><td><code class="type">bigint</code></td><td>在这个表上发起的索引扫描的次数</td></tr><tr><td><code class="structfield">idx_tup_fetch</code></td><td><code class="type">bigint</code></td><td>被索引扫描取得的活着的行的数量</td></tr><tr><td><code class="structfield">n_tup_ins</code></td><td><code class="type">bigint</code></td><td>被插入的行数</td></tr><tr><td><code class="structfield">n_tup_upd</code></td><td><code class="type">bigint</code></td><td>被更新的行数（包括 HOT 更新的行）</td></tr><tr><td><code class="structfield">n_tup_del</code></td><td><code class="type">bigint</code></td><td>被删除的行数</td></tr><tr><td><code class="structfield">n_tup_hot_upd</code></td><td><code class="type">bigint</code></td><td>被更新的 HOT 行数（即不要求独立索引更新的行更新）</td></tr><tr><td><code class="structfield">n_live_tup</code></td><td><code class="type">bigint</code></td><td>活着的行的估计数量</td></tr><tr><td><code class="structfield">n_dead_tup</code></td><td><code class="type">bigint</code></td><td>死亡行的估计数量</td></tr><tr><td><code class="structfield">n_mod_since_analyze</code></td><td><code class="type">bigint</code></td><td>从这个表最后一次被分析后备修改的行的估计数量</td></tr><tr><td><code class="structfield">last_vacuum</code></td><td><code class="type">timestamp with time zone</code></td><td>上次这个表被手动清理的时间（不统计<code class="command">VACUUM FULL</code>）</td></tr><tr><td><code class="structfield">last_autovacuum</code></td><td><code class="type">timestamp with time zone</code></td><td>上次这个表被自动清理守护进程清理的时间</td></tr><tr><td><code class="structfield">last_analyze</code></td><td><code class="type">timestamp with time zone</code></td><td>上次这个表被手动分析的时间</td></tr><tr><td><code class="structfield">last_autoanalyze</code></td><td><code class="type">timestamp with time zone</code></td><td>上次这个表被自动清理守护进程分析的时间</td></tr><tr><td><code class="structfield">vacuum_count</code></td><td><code class="type">bigint</code></td><td>这个表已被手工清理的次数（不统计<code class="command">VACUUM FULL</code>）</td></tr><tr><td><code class="structfield">autovacuum_count</code></td><td><code class="type">bigint</code></td><td>这个表已被自动清理守护进程清理的次数</td></tr><tr><td><code class="structfield">analyze_count</code></td><td><code class="type">bigint</code></td><td>这个表已被手工分析的次数</td></tr><tr><td><code class="structfield">autoanalyze_count</code></td><td><code class="type">bigint</code></td><td>这个表已被自动清理守护进程分析的次数</td></tr></tbody></table></div></div><br class="table-break" /><p>   <code class="structname">pg_stat_all_tables</code>视图将为当前数据库中的每一个表（包括 TOAST 表）包含一行，该行显示与对该表的访问相关的统计信息。<code class="structname">pg_stat_user_tables</code>和<code class="structname">pg_stat_sys_tables</code>视图包含相同的信息，但是被过滤得分别只显示用户和系统表。
  </p><div class="table" id="PG-STAT-ALL-INDEXES-VIEW"><p class="title"><strong>表 28.14. <code class="structname">pg_stat_all_indexes</code>视图</strong></p><div class="table-contents"><table class="table" summary="pg_stat_all_indexes视图" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>列</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="structfield">relid</code></td><td><code class="type">oid</code></td><td>这个索引的基表的 OID</td></tr><tr><td><code class="structfield">indexrelid</code></td><td><code class="type">oid</code></td><td>这个索引的 OID</td></tr><tr><td><code class="structfield">schemaname</code></td><td><code class="type">name</code></td><td>这个索引所在的模式的名称</td></tr><tr><td><code class="structfield">relname</code></td><td><code class="type">name</code></td><td>这个索引的基表的名称</td></tr><tr><td><code class="structfield">indexrelname</code></td><td><code class="type">name</code></td><td>这个索引的名称</td></tr><tr><td><code class="structfield">idx_scan</code></td><td><code class="type">bigint</code></td><td>在这个索引上发起的索引扫描次数</td></tr><tr><td><code class="structfield">idx_tup_read</code></td><td><code class="type">bigint</code></td><td>在这个索引上由扫描返回的索引项数量</td></tr><tr><td><code class="structfield">idx_tup_fetch</code></td><td><code class="type">bigint</code></td><td>被使用这个索引的简单索引扫描取得的活着的表行数量</td></tr></tbody></table></div></div><br class="table-break" /><p>   <code class="structname">pg_stat_all_indexes</code>视图将为当前数据库中的每个索引包含一行，该行显示关于对该索引访问的统计信息。<code class="structname">pg_stat_user_indexes</code>和<code class="structname">pg_stat_sys_indexes</code>视图包含相同的信息，但是被过滤得只分别显示用户和系统索引。
  </p><p>   索引可以被简单索引扫描、<span class="quote">“<span class="quote">位图</span>”</span>索引扫描以及优化器使用。在一次位图扫描中，多个索引的输出可以被通过 AND 或 OR 规则组合，因此当使用一次位图扫描时难以将取得的个体堆行与特定的索引关联起来。因此，一次位图扫描会增加它使用的索引的<code class="structname">pg_stat_all_indexes</code>.<code class="structfield">idx_tup_read</code>计数，并且为每个表增加<code class="structname">pg_stat_all_tables</code>.<code class="structfield">idx_tup_fetch</code>计数，但是它不影响<code class="structname">pg_stat_all_indexes</code>.<code class="structfield">idx_tup_fetch</code>。如果所提供的常量值不在优化器统计信息记录的范围之内，优化器也会访问索引来检查，因为优化器统计信息可能已经“不新鲜”了。
  </p><div class="note"><h3 class="title">注意</h3><p>    即使不用位图扫描，<code class="structfield">idx_tup_read</code>和<code class="structfield">idx_tup_fetch</code>计数也可能不同，因为<code class="structfield">idx_tup_read</code>统计从该索引取得的索引项而<code class="structfield">idx_tup_fetch</code>统计从表取得的或者的行。如果使用该索引取得了任何死亡行或还未提交的行，或者如果通过一次只用索引扫描的方式避免了任何堆获取，后者将较小。
   </p></div><div class="table" id="PG-STATIO-ALL-TABLES-VIEW"><p class="title"><strong>表 28.15. <code class="structname">pg_statio_all_tables</code>视图</strong></p><div class="table-contents"><table class="table" summary="pg_statio_all_tables视图" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>列</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="structfield">relid</code></td><td><code class="type">oid</code></td><td>一个表的 OID</td></tr><tr><td><code class="structfield">schemaname</code></td><td><code class="type">name</code></td><td>这个表所在的模式的名称</td></tr><tr><td><code class="structfield">relname</code></td><td><code class="type">name</code></td><td>这个表的名称</td></tr><tr><td><code class="structfield">heap_blks_read</code></td><td><code class="type">bigint</code></td><td>从这个表读取的磁盘块数量</td></tr><tr><td><code class="structfield">heap_blks_hit</code></td><td><code class="type">bigint</code></td><td>在这个表中的缓冲区命中数量</td></tr><tr><td><code class="structfield">idx_blks_read</code></td><td><code class="type">bigint</code></td><td>从这个表上所有索引中读取的磁盘块数</td></tr><tr><td><code class="structfield">idx_blks_hit</code></td><td><code class="type">bigint</code></td><td>在这个表上的所有索引中的缓冲区命中数量</td></tr><tr><td><code class="structfield">toast_blks_read</code></td><td><code class="type">bigint</code></td><td>从这个表的 TOAST 表（如果有）读取的磁盘块数</td></tr><tr><td><code class="structfield">toast_blks_hit</code></td><td><code class="type">bigint</code></td><td>在这个表的 TOAST 表（如果有）中的缓冲区命中数量</td></tr><tr><td><code class="structfield">tidx_blks_read</code></td><td><code class="type">bigint</code></td><td>从这个表的 TOAST 表索引（如果有）中读取的磁盘块数</td></tr><tr><td><code class="structfield">tidx_blks_hit</code></td><td><code class="type">bigint</code></td><td>在这个表的 TOAST 表索引（如果有）中的缓冲区命中数量</td></tr></tbody></table></div></div><br class="table-break" /><p>   <code class="structname">pg_statio_all_tables</code>视图将为当前数据库中的每个表（包括 TOAST 表）包含一行，该行显示指定表上有关 I/O 的统计信息。<code class="structname">pg_statio_user_tables</code>和<code class="structname">pg_statio_sys_tables</code>视图包含相同的信息，但是被过滤得分别只显示用户表和系统表。
  </p><div class="table" id="PG-STATIO-ALL-INDEXES-VIEW"><p class="title"><strong>表 28.16. <code class="structname">pg_statio_all_indexes</code>视图</strong></p><div class="table-contents"><table class="table" summary="pg_statio_all_indexes视图" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>列</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="structfield">relid</code></td><td><code class="type">oid</code></td><td>这个索引的基表的 OID</td></tr><tr><td><code class="structfield">indexrelid</code></td><td><code class="type">oid</code></td><td>这个索引的 OID</td></tr><tr><td><code class="structfield">schemaname</code></td><td><code class="type">name</code></td><td>这个索引所在的模式的名称</td></tr><tr><td><code class="structfield">relname</code></td><td><code class="type">name</code></td><td>这个索引的基表的名称</td></tr><tr><td><code class="structfield">indexrelname</code></td><td><code class="type">name</code></td><td>这个索引的名称</td></tr><tr><td><code class="structfield">idx_blks_read</code></td><td><code class="type">bigint</code></td><td>从这个索引读取的磁盘块数</td></tr><tr><td><code class="structfield">idx_blks_hit</code></td><td><code class="type">bigint</code></td><td>在这个索引中的缓冲区命中数量</td></tr></tbody></table></div></div><br class="table-break" /><p>   <code class="structname">pg_statio_all_indexes</code>视图将为当前数据库中的每个索引包含一行，该行显示指定索引上有关 I/O 的统计信息。<code class="structname">pg_statio_user_indexes</code>和<code class="structname">pg_statio_sys_indexes</code>视图包含相同的信息，但是被过滤得分别只显示用户索引和系统索引。
  </p><div class="table" id="PG-STATIO-ALL-SEQUENCES-VIEW"><p class="title"><strong>表 28.17. <code class="structname">pg_statio_all_sequences</code>视图</strong></p><div class="table-contents"><table class="table" summary="pg_statio_all_sequences视图" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>列</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="structfield">relid</code></td><td><code class="type">oid</code></td><td>一个序列的 OID</td></tr><tr><td><code class="structfield">schemaname</code></td><td><code class="type">name</code></td><td>这个序列所在的模式的名称</td></tr><tr><td><code class="structfield">relname</code></td><td><code class="type">name</code></td><td>这个序列的名称</td></tr><tr><td><code class="structfield">blks_read</code></td><td><code class="type">bigint</code></td><td>从这个序列中读取的磁盘块数</td></tr><tr><td><code class="structfield">blks_hit</code></td><td><code class="type">bigint</code></td><td>在这个序列中的缓冲区命中数量</td></tr></tbody></table></div></div><br class="table-break" /><p>   <code class="structname">pg_statio_all_sequences</code>视图将为当前数据库中的每个序列包含一行，该行显示在指定序列上有关 I/O 的统计信息。
  </p><div class="table" id="PG-STAT-USER-FUNCTIONS-VIEW"><p class="title"><strong>表 28.18. <code class="structname">pg_stat_user_functions</code>视图</strong></p><div class="table-contents"><table class="table" summary="pg_stat_user_functions视图" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>列</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="structfield">funcid</code></td><td><code class="type">oid</code></td><td>一个函数的 OID</td></tr><tr><td><code class="structfield">schemaname</code></td><td><code class="type">name</code></td><td>这个函数所在的模式的名称</td></tr><tr><td><code class="structfield">funcname</code></td><td><code class="type">name</code></td><td>这个函数的名称</td></tr><tr><td><code class="structfield">calls</code></td><td><code class="type">bigint</code></td><td>这个函数已经被调用的次数</td></tr><tr><td><code class="structfield">total_time</code></td><td><code class="type">double precision</code></td><td>在这个函数以及它所调用的其他函数中花费的总时间，以毫秒计</td></tr><tr><td><code class="structfield">self_time</code></td><td><code class="type">double precision</code></td><td>在这个函数本身花费的总时间，不包括被它调用的其他函数，以毫秒计</td></tr></tbody></table></div></div><br class="table-break" /><p>   <code class="structname">pg_stat_user_functions</code>视图将为每一个被追踪的函数包含一行，该行显示有关该函数执行的统计信息。<a class="xref" href="runtime-config-statistics.html#GUC-TRACK-FUNCTIONS">track_functions</a>参数控制到底哪些函数被跟踪。
  </p></div><div class="sect2" id="MONITORING-STATS-FUNCTIONS"><div class="titlepage"><div><div><h3 class="title">28.2.3. 统计函数</h3></div></div></div><p>   其他查看统计信息的方法是直接使用查询，这些查询使用上述标准视图用到的底层统计信息访问函数。如要了解如函数名等细节，可参考标准视图的定义（例如，在<span class="application">psql</span>中你可以发出<code class="literal">\d+ pg_stat_activity</code>）。针对每一个数据库统计信息的访问函数把一个数据库 OID 作为参数来标识要报告哪个数据库。而针对每个表和每个索引的函数要求表或索引 OID。针对每个函数统计信息的函数用一个函数 OID。注意只有在当前数据库中的表、索引和函数才能被这些函数看到。
  </p><p>   与统计收集相关的额外函数被列举在<a class="xref" href="monitoring-stats.html#MONITORING-STATS-FUNCS-TABLE" title="表 28.19. 额外统计函数">表 28.19</a>中。
  </p><div class="table" id="MONITORING-STATS-FUNCS-TABLE"><p class="title"><strong>表 28.19. 额外统计函数</strong></p><div class="table-contents"><table class="table" summary="额外统计函数" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>函数</th><th>返回类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="literal"><code class="function">pg_backend_pid()</code></code></td><td><code class="type">integer</code></td><td>       处理当前会话的服务器进程的进程 ID
      </td></tr><tr><td><code class="literal"><code class="function">pg_stat_get_activity</code>(<code class="type">integer</code>)</code><a id="idp26039776" class="indexterm"></a></td><td><code class="type">setof record</code></td><td>       返回具有指定 PID 的后端相关的一个记录，或者在指定<code class="symbol">NULL</code>的情况下为系统中每一个活动后端返回一个记录。被返回的域是<code class="structname">pg_stat_activity</code>视图中的那些域的一个子集。
      </td></tr><tr><td><code class="literal"><code class="function">pg_stat_get_snapshot_timestamp()</code></code><a id="idp26043488" class="indexterm"></a></td><td><code class="type">带时区的时间戳</code></td><td>       返回当前统计信息快照的时间戳
      </td></tr><tr><td><code class="literal"><code class="function">pg_stat_clear_snapshot()</code></code><a id="idp26046224" class="indexterm"></a></td><td><code class="type">void</code></td><td>       抛弃当前的统计快照
      </td></tr><tr><td><code class="literal"><code class="function">pg_stat_reset()</code></code><a id="idp26048896" class="indexterm"></a></td><td><code class="type">void</code></td><td>       把用于当前数据库的所有统计计数器重置为零（默认要求超级用户权限，但这个函数的 EXECUTE 可以被授予给其他人）。
      </td></tr><tr><td><code class="literal"><code class="function">pg_stat_reset_shared</code>(text)</code><a id="idp26051984" class="indexterm"></a></td><td><code class="type">void</code></td><td>       把某些集簇范围的统计计数器重置为零，具体哪些取决于参数（默认要求超级用户权限，但这个函数的 EXECUTE 可以被授予给其他人）。
       调用<code class="literal">pg_stat_reset_shared('bgwriter')</code>把<code class="structname">pg_stat_bgwriter</code>
       视图中显示的所有计数器清零。调用<code class="literal">pg_stat_reset_shared('archiver')</code>
       将会把<code class="structname">pg_stat_archiver</code>视图中展示的所有计数器清零。
      </td></tr><tr><td><code class="literal"><code class="function">pg_stat_reset_single_table_counters</code>(oid)</code><a id="idp26057664" class="indexterm"></a></td><td><code class="type">void</code></td><td>       把当前数据库中用于单个表或索引的统计数据重置为零（默认要求超级用户权限，但这个函数的 EXECUTE 可以被授予给其他人）
      </td></tr><tr><td><code class="literal"><code class="function">pg_stat_reset_single_function_counters</code>(oid)</code><a id="idp26060800" class="indexterm"></a></td><td><code class="type">void</code></td><td>       把当前数据库中用于单个函数的统计信息重置为零（默认要求超级用户权限，但这个函数的 EXECUTE 可以被授予给其他人）
      </td></tr></tbody></table></div></div><br class="table-break" /><p>   <code class="function">pg_stat_get_activity</code>是<code class="structname">pg_stat_activity</code>视图的底层函数，它返回一个行集合，其中包含有关每个后端进程所有可用的信息。有时只获得该信息的一个子集可能会更方便。在那些情况中，可以使用一组更老的针对每个后端的统计访问函数，这些显示在<a class="xref" href="monitoring-stats.html#MONITORING-STATS-BACKEND-FUNCS-TABLE" title="表 28.20. 针对每个后端的统计函数">表 28.20</a>中。这些访问函数使用一个后端 ID 号，范围从 1 到当前活动后端数目。函数<code class="function">pg_stat_get_backend_idset</code>提供了一种方便的方法为每个活动后端产生一行来调用这些函数。例如，要显示<acronym class="acronym">PID</acronym>以及所有后端当前的查询：

</p><pre class="programlisting">SELECT pg_stat_get_backend_pid(s.backendid) AS pid,
       pg_stat_get_backend_activity(s.backendid) AS query
    FROM (SELECT pg_stat_get_backend_idset() AS backendid) AS s;</pre><p>
  </p><div class="table" id="MONITORING-STATS-BACKEND-FUNCS-TABLE"><p class="title"><strong>表 28.20. 针对每个后端的统计函数</strong></p><div class="table-contents"><table class="table" summary="针对每个后端的统计函数" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>函数</th><th>返回类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="literal"><code class="function">pg_stat_get_backend_idset()</code></code></td><td><code class="type">setof integer</code></td><td>当前活动后端 ID 号的集合（从 1 到活动后端数目）</td></tr><tr><td><code class="literal"><code class="function">pg_stat_get_backend_activity(integer)</code></code></td><td><code class="type">text</code></td><td>这个后端最近查询的文本</td></tr><tr><td><code class="literal"><code class="function">pg_stat_get_backend_activity_start(integer)</code></code></td><td><code class="type">timestamp with time zone</code></td><td>最近查询被开始的时间</td></tr><tr><td><code class="literal"><code class="function">pg_stat_get_backend_client_addr(integer)</code></code></td><td><code class="type">inet</code></td><td>该客户端连接到这个后端的 IP 地址</td></tr><tr><td><code class="literal"><code class="function">pg_stat_get_backend_client_port(integer)</code></code></td><td><code class="type">integer</code></td><td>该客户端用来通信的 TCP 端口号</td></tr><tr><td><code class="literal"><code class="function">pg_stat_get_backend_dbid(integer)</code></code></td><td><code class="type">oid</code></td><td>这个后端连接到的数据库的 OID</td></tr><tr><td><code class="literal"><code class="function">pg_stat_get_backend_pid(integer)</code></code></td><td><code class="type">integer</code></td><td>这个后端的进程 ID</td></tr><tr><td><code class="literal"><code class="function">pg_stat_get_backend_start(integer)</code></code></td><td><code class="type">timestamp with time zone</code></td><td>这个进程被开始的时间</td></tr><tr><td><code class="literal"><code class="function">pg_stat_get_backend_userid(integer)</code></code></td><td><code class="type">oid</code></td><td>登录到这个后端的用户的 OID</td></tr><tr><td><code class="literal"><code class="function">pg_stat_get_backend_wait_event_type(integer)</code></code></td><td><code class="type">text</code></td><td>如果后端正在等待，则是等待事件类型的名称，否则为 NULL。详见<a class="xref" href="monitoring-stats.html#WAIT-EVENT-TABLE" title="表 28.4. wait_event 描述">表 28.4</a>。
        </td></tr><tr><td><code class="literal"><code class="function">pg_stat_get_backend_wait_event(integer)</code></code></td><td><code class="type">text</code></td><td>如果后端正在等待，则是等待事件的名称，否则为 NULL。详见<a class="xref" href="monitoring-stats.html#WAIT-EVENT-TABLE" title="表 28.4. wait_event 描述">表 28.4</a>。
       </td></tr><tr><td><code class="literal"><code class="function">pg_stat_get_backend_xact_start(integer)</code></code></td><td><code class="type">timestamp with time zone</code></td><td>当前事务被开始的时间</td></tr></tbody></table></div></div><br class="table-break" /></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="monitoring-ps.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="monitoring.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="monitoring-locks.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">28.1. 标准 Unix 工具 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 28.3. 查看锁</td></tr></table></div></body></html>
