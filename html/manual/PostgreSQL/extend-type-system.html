<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>37.2. PostgreSQL类型系统</title><link rel="stylesheet" type="text/css" href="../../0/stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="extend-how.html" title="37.1. 扩展性如何工作" /><link rel="next" href="xfunc.html" title="37.3. 用户定义的函数" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">37.2. <span xmlns="http://www.w3.org/1999/xhtml" class="productname">PostgreSQL</span>类型系统</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="extend-how.html" title="37.1. 扩展性如何工作">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="extend.html" title="第 37 章 扩展 SQL">上一级</a></td><th width="60%" align="center">第 37 章 扩展 <acronym xmlns="http://www.w3.org/1999/xhtml" class="acronym">SQL</acronym></th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.1 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="xfunc.html" title="37.3. 用户定义的函数">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="EXTEND-TYPE-SYSTEM"><div class="titlepage"><div><div><h2 class="title" style="clear: both">37.2. <span class="productname">PostgreSQL</span>类型系统</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="extend-type-system.html#idp32958064">37.2.1. 基础类型</a></span></dt><dt><span class="sect2"><a href="extend-type-system.html#idp32961136">37.2.2. 组合类型</a></span></dt><dt><span class="sect2"><a href="extend-type-system.html#EXTEND-TYPE-SYSTEM-DOMAINS">37.2.3. 域</a></span></dt><dt><span class="sect2"><a href="extend-type-system.html#idp74000">37.2.4. 伪类型</a></span></dt><dt><span class="sect2"><a href="extend-type-system.html#EXTEND-TYPES-POLYMORPHIC">37.2.5. 多态类型</a></span></dt></dl></div><a id="idp32952096" class="indexterm"></a><a id="idp32953232" class="indexterm"></a><a id="idp32954592" class="indexterm"></a><a id="idp32955664" class="indexterm"></a><p>    <span class="productname">PostgreSQL</span>数据类型被划分为基础类型、组合类型、域和伪类型。
   </p><div class="sect2" id="idp32958064"><div class="titlepage"><div><div><h3 class="title">37.2.1. 基础类型</h3></div></div></div><p>     基础类型是那些被实现在<acronym class="acronym">SQL</acronym>语言层面之下的类型（通常用一种底层语言，如 C），例如<code class="type">int4</code>。它们通常对应于常说的抽象数据类型。<span class="productname">PostgreSQL</span>只能通过由用户提供的函数在这类类型上操作，并且只能理解到用户描述这种类型行为的程度。基础类型会被进一步划分为标量和数组类型。对于每一种标量类型，会自动创建一个相应的数组类型，它能够保存该标量类型的可变尺寸的数组。
    </p></div><div class="sect2" id="idp32961136"><div class="titlepage"><div><div><h3 class="title">37.2.2. 组合类型</h3></div></div></div><p>     只要用户创建一个表，就会创建组合类型或者行类型。也可以使用<a class="xref" href="sql-createtype.html" title="CREATE TYPE"><span class="refentrytitle">CREATE TYPE</span></a>来定义一个没有关联表的<span class="quote">“<span class="quote">stand-alone</span>”</span>组合类型。一个组合类型只是一个具有相关域名称的类型列表。一个组合类型的值是一个行或者域值记录。用户可以访问来自<acronym class="acronym">SQL</acronym>查询的组成域。更多关于组合类型的信息请参考<a class="xref" href="rowtypes.html" title="8.16. 复合类型">第 8.16 节</a>。
    </p></div><div class="sect2" id="EXTEND-TYPE-SYSTEM-DOMAINS"><div class="titlepage"><div><div><h3 class="title">37.2.3. 域</h3></div></div></div><p>     一个域是基于一种特定基础类型的，并且出于很多目的它可以与其基础类型互换。不过，一个域能够具有约束来限制它的合法值于其底层基础类型允许值的一个子集。
    </p><p>     可以使用<acronym class="acronym">SQL</acronym>命令<a class="xref" href="sql-createdomain.html" title="CREATE DOMAIN"><span class="refentrytitle">CREATE DOMAIN</span></a>创建域。本章不会讨论它们的创建和使用。
    </p></div><div class="sect2" id="idp74000"><div class="titlepage"><div><div><h3 class="title">37.2.4. 伪类型</h3></div></div></div><p>     有一些用于特殊目的<span class="quote">“<span class="quote">伪类型</span>”</span>。伪类型不能作为表列或者组合类型的属性出现，但是它们能被用于声明函数的参数和结果类型。这在类型系统中提供了一种机制来标识函数的特殊分类。<a class="xref" href="datatype-pseudo.html#DATATYPE-PSEUDOTYPES-TABLE" title="表 8.25. 伪类型">表 8.25</a>列出了现有的伪类型。
    </p></div><div class="sect2" id="EXTEND-TYPES-POLYMORPHIC"><div class="titlepage"><div><div><h3 class="title">37.2.5. 多态类型</h3></div></div></div><a id="idp76880" class="indexterm"></a><a id="idp77984" class="indexterm"></a><a id="idp79088" class="indexterm"></a><a id="idp80480" class="indexterm"></a><p>     特别让人感兴趣的五种伪类型是<code class="type">anyelement</code>、<code class="type">anyarray</code>、<code class="type">anynonarray</code>、<code class="type">anyenum</code>以及<code class="type">anyrange</code>，它们被统称为<em class="firstterm">多态类型</em>。任何使用这些类型声明的函数被称作是一个<em class="firstterm">多态函数</em>。通过使用根据一次特定调用实际传递的数据类型所决定的相关数据类型，一个多态函数能够在多种不同数据类型上操作。
    </p><p>     多态参数和结果是相互关联的，并且它们在解析调用多态函数的查询时被决定到一种特定的数据类型。每一个被声明为<code class="type">anyelement</code>的位置（参数或返回值）被允许具有任意特定的实际数据类型，但是在任何给定的查询中它们必须全部是<span class="emphasis"><em>相同</em></span>的实际类型。每一个被声明为<code class="type">anyarray</code>的位置可以有任意数组数据类型，但是相似地，它们必须全部具有相同类型。并且类似地，被声明为<code class="type">anyrange</code>的位置必须是全部是相同的范围类型。此外，如果有位置被声明为<code class="type">anyarray</code>并且其他位置被声明为<code class="type">anyelement</code>，<code class="type">anyarray</code>位置中的实际数组类型必须是一个数组，该数组的元素都是出现在<code class="type">anyelement</code>位置的同一种类型。相似地，如果有位置被声明为<code class="type">anyrange</code>并且其他位置被声明为<code class="type">anyelement</code>，<code class="type">anyrange</code>位置的实际范围类型必须是一个范围，该范围的子类型是出现在<code class="type">anyelement</code>位置的同一种类型。<code class="type">anynonarray</code>被当做和<code class="type">anyelement</code>相同，但是增加了额外的约束要求实际类型不能是一种数组类型。<code class="type">anyenum</code>被当做和<code class="type">anyelement</code>相同，但是增加了额外的约束要求实际类型不能是一种枚举类型。
    </p><p>     因此，当使用一种多态类型声明了多于一个参数位置，有效效果是只有实际参数类型的某些组合才被允许。例如，一个被声明为<code class="literal">equal(anyelement, anyelement)</code>的函数将要求任意两个输入值，只要它们是同一种数据类型。
    </p><p>     当一个函数的返回值被声明为多态类型时，必须至少有一个参数位置也是多态的，并且作为该参数提供的实际数据类型决定了该调用的实际结果类型。例如，如果还没有一种数组下标机制，我们可以定义一个函数来实现下标：<code class="literal">subscript(anyarray, integer) returns anyelement</code>。这个声明约束了实际的第一个参数是一种数组类型，并且允许解析器从实际的第一个参数类型推断正确的结果类型。另一个例子是一个被声明为<code class="literal">f(anyarray) returns anyenum</code>的函数将只接受枚举类型的数组。
    </p><p>     注意<code class="type">anynonarray</code>和<code class="type">anyenum</code>并不表示独立的类型变量，它们是和<code class="type">anyelement</code>相同的类型，只是有一个额外的约束。例如，将一个函数声明为<code class="literal">f(anyelement, anyenum)</code>等效于把它声明为<code class="literal">f(anyenum, anyenum)</code>：两种实际参数必须是相同的枚举类型。
    </p><p>     一个可变函数（可以有可变数量的参数，如<a class="xref" href="xfunc-sql.html#XFUNC-SQL-VARIADIC-FUNCTIONS" title="37.4.5. 带有可变数量参数的SQL函数">第 37.4.5 节</a>中所述）能够是多态的：这可以通过声明其最后一个参数为<code class="literal">VARIADIC</code> <code class="type">anyarray</code>来实现。为了匹配和决定实际结果类型的参数，这样一种函数的行为和写了合适数量的<code class="type">anynonarray</code>参数是一样的。
    </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="extend-how.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="extend.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="xfunc.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">37.1. 扩展性如何工作 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 37.3. 用户定义的函数</td></tr></table></div></body></html>
