<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>E.124. 版本 9.0.7</title><link rel="stylesheet" type="text/css" href="../../0/stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="release-9-0-8.html" title="E.123. 版本 9.0.8" /><link rel="next" href="release-9-0-6.html" title="E.125. 版本 9.0.6" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">E.124. 版本 9.0.7</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="release-9-0-8.html" title="E.123. 版本 9.0.8">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="release.html" title="附录 E. 版本说明">上一级</a></td><th width="60%" align="center">附录 E. 版本说明</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.1 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="release-9-0-6.html" title="E.125. 版本 9.0.6">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="RELEASE-9-0-7"><div class="titlepage"><div><div><h2 class="title" style="clear: both">E.124. 版本 9.0.7</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="release-9-0-7.html#idp75164080">E.124.1. 迁移到版本 9.0.7</a></span></dt><dt><span class="sect2"><a href="release-9-0-7.html#idp75165840">E.124.2. 修改列表</a></span></dt></dl></div><p><strong>发布日期：. </strong>2012-02-27</p><p>这个版本包含各种自9.0.6以来的修复。想要获得关于9.0主版本的新特性信息，
请参阅<a class="xref" href="release-9-0.html" title="E.131. 版本 9.0">第 E.131 节</a>。</p><div class="sect2" id="idp75164080"><div class="titlepage"><div><div><h3 class="title">E.124.1. 迁移到版本 9.0.7</h3></div></div></div><p>运行9.0.X的系统不需要转储/恢复。</p><p>另外，如果你是从一个早于9.0.6的版本升级而来，请参阅<a class="xref" href="release-9-0-6.html" title="E.125. 版本 9.0.6">第 E.125 节</a>。</p></div><div class="sect2" id="idp75165840"><div class="titlepage"><div><div><h3 class="title">E.124.2. 修改列表</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>需要在触发器函数<code class="command">CREATE TRIGGER</code>上的执行权限 (Robert Haas)</p><p>这个缺失的检查会允许另外一个用户通过在他自己的一个表上安装触发器来用伪造的输入数据执行触发器函数。
这只在触发器函数标记为<code class="literal">SECURITY DEFINER</code>时是有意义的，
因为否则触发器函数会作为表所有者运行。 (CVE-2012-0866)</p></li><li class="listitem"><p>删除SSL认证中通用名长度的任意限制 (Heikki Linnakangas)</p><p><span class="application">libpq</span>和服务器都缩短了从SSL认证中提取的通用名为32字节。
通常这没什么坏处，除了一个意外的认证失败，但是有一些相当那以置信的情况下，
它可能允许一个证书持有人冒充另一个。受害者必须有一个正好是32字节长度的通用名，
攻击者必须说服一个信任的CA发出一份证明书，证明该通用名有那个字符串作为前缀。
冒充一个服务器也需要一些额外的开发重定向客户端连接。</p></li><li class="listitem"><p>转换写入<span class="application">pg_dump</span>注释中的名字中的换行为空格 (Robert Haas)</p><p><span class="application">pg_dump</span>对于在它的输出脚本中的SQL注释中发出的汉化的对象名是不谨慎的。
一个包含换行的名字将至少使得脚本在语句构成上不正确。
恶意的对象名将在脚本重载时引入SQL注入风险。 (CVE-2012-0868)</p></li><li class="listitem"><p>修复插入的同时做清理时的btree索引损坏 (Tom Lane)</p><p>一个插入导致的索引页分裂有时会导致并发的运行<code class="command">VACUUM</code>，
导致丢失它应该删除的索引条目。在删除相应的表行之后，悬空的索引项会导致错误
（如<span class="quote">“<span class="quote">could not read block N in file ...</span>”</span>）或者更糟，
在不相关的行重新插入到表中行释放的位置时得到错误的查询结果。
这个bug自从版本8.2就已经存在了，但是因为很少重现，所以直到现在才诊断出来。
如果你怀疑在你的数据库中发生了这种情况，那么在受影响的索引上重建索引就可修复问题。</p></li><li class="listitem"><p>修复WAL重放期间共享缓冲区的瞬态归零 (Tom Lane)</p><p>重放逻辑会有时清空然后回填共享缓冲区，这样内容会在瞬间无效。
在热备模式，这会导致并行执行的查询看到垃圾数据。
从此会出现各种症状，但是最常见的一个是<span class="quote">“<span class="quote">invalid memory alloc request size</span>”</span>。</p></li><li class="listitem"><p>修复postmaster在热备崩溃后尝试重启 (Tom Lane)</p><p>如果在热备模式操作时任意后端进程崩溃，那么一个逻辑错误导致postmaster中止，而不是尝试重启集群。</p></li><li class="listitem"><p>修复<code class="command">CLUSTER</code>/<code class="command">VACUUM FULL</code>挂起最近更新的行拥有的toast值 (Tom Lane)</p><p>这个监督可能会导致在这些命令期间，在toast表的索引上报告
<span class="quote">“<span class="quote">duplicate key value violates unique constraint</span>”</span>错误。</p></li><li class="listitem"><p>在改变表的所有者时，更新每行的权限，而不只是更新每表的权限 (Tom Lane)</p><p>未能做到这一点意味着任意先前授权的行权限仍然显示为是通过旧的所有者授权的。
这意味着不管是新的所有者还是超级用户都不能撤销该现在无法追踪表的所有者的权限。</p></li><li class="listitem"><p>在<code class="command">REASSIGN OWNED</code>中支持外部数据封装和外部服务器 (Alvaro Herrera)</p><p>如果需要改变任意这样的对象的归属，那么这个命令会带有<span class="quote">“<span class="quote">unexpected classid</span>”</span>错误失败。</p></li><li class="listitem"><p>允许<code class="command">ALTER USER/DATABASE SET</code>中的一些设置是不存在的值 (Heikki Linnakangas)</p><p>允许<code class="varname">default_text_search_config</code>, <code class="varname">default_tablespace</code>, 和 <code class="varname">temp_tablespaces</code>
设置为不知道名字。这是因为他们可能在另外一个使用这个设置的数据库中知道，或者对于表空间来说，
因为表空间可能还未创建。相同的问题早已被<code class="varname">search_path</code>认识到，这些设置并不像那个一样动作。</p></li><li class="listitem"><p>避免在提交之后删除表文件有问题时的崩溃 (Tom Lane)</p><p>删除表会导致在事务提交之后删除底层磁盘文件。如果失败（例如，因为错误的文件权限），
那么该代码应该只是发出一个警告消息然后继续，因为退出该事务已经太晚了。
这个逻辑在版本8.4被打破，导致这样的情况引起一个PANIC和一个不可重新启动的数据库。</p></li><li class="listitem"><p>在<code class="command">DROP TABLESPACE</code>的WAL重放期间从错误事件中恢复 (Tom Lane)</p><p>重放将尝试删除表空间的目录，但是有各种会失败的原因（例如，在这些目录上的不正确的所有权或权限）。
以前，重放代码会引起恐慌，致使数据库不能重新启动除非手动介入。
似乎最好是记录该问题并记录，因为删除目录失败的唯一后果是浪费一些磁盘空间。</p></li><li class="listitem"><p>修复为热备记录AccessExclusiveLocks中的竞态条件 (Simon Riggs)</p><p>有时一个锁被记录为就像是被<span class="quote">“<span class="quote">transaction zero</span>”</span>持有一样。
这至少已知为在从属服务器上产生声明失败，或者可能造成更严重的问题。</p></li><li class="listitem"><p>在WAL重放期间甚至打包时正确的跟踪OID计数器 (Tom Lane)</p><p>以前，OID计数器保持停留在一个高值直到系统退出重放模式。实际的结果通常为零，
但是在备用服务器中，被提升到master的情况下，一旦值是必要的，
可能需要很长的一段时间促进OID计数器为一个合理的值。</p></li><li class="listitem"><p>在故障修复的开始阻止发出误导的<span class="quote">“<span class="quote">consistent recovery state reached</span>”</span>日志信息 (Heikki Linnakangas)</p></li><li class="listitem"><p>修复<code class="structname">pg_stat_replication</code>.<code class="structfield">replay_location</code>的初始值 (Fujii Masao)</p><p>之前，显示的值是错误的，直到至少一个WAL记录被重放。</p></li><li class="listitem"><p>修复附加<code class="literal">*</code>的正则表达式的逆向引用 (Tom Lane)</p><p>不是强制一个准确的字符串匹配，而是该代码实际上接受任意满足逆向引用符号引用的模式子表达式的字符串。</p><p>一个类似的问题仍然困扰着嵌入到一个较大的量化的表达式中的逆向引用，而不是量词的直接主体。
这将在将来的<span class="productname">PostgreSQL</span>版本中处理。</p></li><li class="listitem"><p>修复处理<code class="type">inet</code>/<code class="type">cidr</code>值的过程中最近引入的内存泄露 (Heikki Linnakangas)</p><p><span class="productname">PostgreSQL</span>的2011.12版本中的一个补丁导致在这些操作中的内存泄露，
在有些情况下可能是重要的，如在这样的字段上建立一个btree索引。</p></li><li class="listitem"><p>修复在一个SQL语言功能中<code class="command">CREATE TABLE AS</code>/<code class="command">SELECT INTO</code>之后的悬挂指针 (Tom Lane)</p><p>在大多数情况下，这只会在启用声明的建立中导致声明失败，但是有可能有更糟糕的后果。</p></li><li class="listitem"><p>避免在Windows上的syslogger中两次关闭文件句柄 (MauMau)</p><p>通常这种错误是不可见的，但是当运行在Windows的debug版本上时它会导致一个意外。</p></li><li class="listitem"><p>修复plpgsql中I/O转换相关的内存泄露 (Andres Freund, Jan Urbanski, Tom Lane)</p><p>某些操作会泄露内存，直到当前函数的结束。</p></li><li class="listitem"><p>改善<span class="application">pg_dump</span>的继承表字段的处理 (Tom Lane)</p><p>当子字段有一个与父字段不同的缺省表达式时，<span class="application">pg_dump</span>会错误的处理这种情况。
如果缺省和父字段的缺省文本上相同，但是实际上不同（例如，因为模式搜索路径不同），
将不会认为是不同，所以在转储和恢复之后，允许子字段继承父字段的缺省。
当它们的父字段不是也可以恢复巧妙的错误时，子字段为<code class="literal">NOT NULL</code>。</p></li><li class="listitem"><p>为INSERT-style表数据修复<span class="application">pg_restore</span>的direct-to-database模式 (Tom Lane)</p><p>当使用发布日期为2011年12月或9月的<span class="application">pg_restore</span>时，
Direct-to-database从带有<code class="option">--inserts</code>或<code class="option">--column-inserts</code>
选项制作的归档文件中恢复会失败，因为监督在另外一个问题的修复中。
该归档文件本身没有问题，文本模式输出也是可以的。</p></li><li class="listitem"><p>允许<span class="application">pg_upgrade</span>处理包含<code class="type">regclass</code>字段的表 (Bruce Momjian)</p><p>因为<span class="application">pg_upgrade</span>现在注意保存<code class="structname">pg_class</code> OID，不再有任何原因限制。</p></li><li class="listitem"><p>当查找一个SSL客户端证书文件时使<span class="application">libpq</span>忽略<code class="literal">ENOTDIR</code>错误 (Magnus Hagander)</p><p>这允许建立SSL连接，尽管不带有证书，甚至用户的根目录设置为类似<code class="literal">/dev/null</code>的东西。</p></li><li class="listitem"><p>修复<span class="application">ecpg</span>的SQLDA区域内一些更多的字段对齐问题 (Zoltan Boszormenyi)</p></li><li class="listitem"><p>在<span class="application">ecpg</span> <code class="literal">DEALLOCATE</code>语句中允许<code class="literal">AT</code>选项 (Michael Meskes)</p><p>支持这个的基础构造已经有一段时间了，但是通过一个监督，仍然有一个错误检查拒绝该情况。</p></li><li class="listitem"><p>在ecpg中定义一个varchar结构时不要使用变量名 (Michael Meskes)</p></li><li class="listitem"><p>修复<code class="filename">contrib/auto_explain</code>的JSON输出模式以产生有效的JSON (Andrew Dunstan)</p><p>输出在顶级使用方括号，在它原本应该使用花括号的地方。</p></li><li class="listitem"><p>修复<code class="filename">contrib/intarray</code>的<code class="literal">int[] &amp; int[]</code>操作符中的错误 (Guillaume Lelarge)</p><p>如果两个输入数组有相同的最小整数为1，并且两个数组中都有更小的值，
那么1将会不正确的从结果中漏掉。</p></li><li class="listitem"><p>修复<code class="filename">contrib/pgcrypto</code>的<code class="function">encrypt_iv()</code>和<code class="function">decrypt_iv()</code>
中的错误检测 (Marko Kreen)</p><p>这些函数未能报告无效输入错误的准确类型，并且对于不正确的输入会返回随机的垃圾值。</p></li><li class="listitem"><p>修复<code class="filename">contrib/test_parser</code>中的一字节缓冲区溢出 (Paul Guyot)</p><p>该代码将会试图比它应该读取的多读一个字节，这会导致极端情况下的崩溃。
因为<code class="filename">contrib/test_parser</code>只是示例代码，这对它本身来说不是一个安全问题，
但是不好的示例代码仍是坏的。</p></li><li class="listitem"><p>如果可用，在ARM上为自旋锁使用<code class="function">__sync_lock_test_and_set()</code> (Martin Pitt)</p><p>这个函数替代我们以前<code class="literal">SWPB</code>指令的使用，该指令已经弃用了并且在ARMv6和以后的版本中不能使用了。
报告显示，老旧代码不会在最近的ARM模块明显的失败，但是简单的不互锁并发访问，
导致在多进程操作中奇怪的失败。</p></li><li class="listitem"><p>当使用接受<code class="option">-fexcess-precision=standard</code>的gcc版本建立时使用该选项 (Andrew Dunstan)</p><p>这防止了混合情形下gcc的最近版本将产生创新结果。</p></li><li class="listitem"><p>允许在FreeBSD上使用线程的Python (Chris Rees)</p><p>以前我们的配置脚本相信这种组合不会运行；但是FreeBSD修复了这个问题，所以删除那个错误检查。</p></li></ul></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="release-9-0-8.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="release.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="release-9-0-6.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">E.123. 版本 9.0.8 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> E.125. 版本 9.0.6</td></tr></table></div></body></html>
