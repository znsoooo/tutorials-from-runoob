<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>9.25. 系统信息函数</title><link rel="stylesheet" type="text/css" href="../../0/stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="functions-srf.html" title="9.24. 集合返回函数" /><link rel="next" href="functions-admin.html" title="9.26. 系统管理函数" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">9.25. 系统信息函数</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="functions-srf.html" title="9.24. 集合返回函数">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="functions.html" title="第 9 章 函数和操作符">上一级</a></td><th width="60%" align="center">第 9 章 函数和操作符</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.1 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="functions-admin.html" title="9.26. 系统管理函数">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="FUNCTIONS-INFO"><div class="titlepage"><div><div><h2 class="title" style="clear: both">9.25. 系统信息函数</h2></div></div></div><p>   <a class="xref" href="functions-info.html#FUNCTIONS-INFO-SESSION-TABLE" title="表 9.60. 会话信息函数">表 9.60</a>展示了多个可以抽取会话和系统信息的函数。
  </p><p>   除了本节列出的函数，还有一些与统计系统相关的函数也提供系统信息。详见<a class="xref" href="monitoring-stats.html#MONITORING-STATS-VIEWS" title="28.2.2. 查看统计信息">第 28.2.2 节</a>。
  </p><div class="table" id="FUNCTIONS-INFO-SESSION-TABLE"><p class="title"><strong>表 9.60. 会话信息函数</strong></p><div class="table-contents"><table class="table" summary="会话信息函数" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>返回类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="literal"><code class="function">current_catalog</code></code></td><td><code class="type">name</code></td><td>当前数据库名（SQL 标准中称作<span class="quote">“<span class="quote">目录</span>”</span>）</td></tr><tr><td><code class="literal"><code class="function">current_database()</code></code></td><td><code class="type">name</code></td><td>当前数据库名</td></tr><tr><td><code class="literal"><code class="function">current_query()</code></code></td><td><code class="type">text</code></td><td>当前正在执行的查询的文本，和客户端提交的一样（可能包含多于一个语句）</td></tr><tr><td><code class="literal"><code class="function">current_role</code></code></td><td><code class="type">name</code></td><td>等效于<code class="function">current_user</code></td></tr><tr><td><code class="literal"><code class="function">current_schema</code>[()]</code></td><td><code class="type">name</code></td><td>当前模式名</td></tr><tr><td><code class="literal"><code class="function">current_schemas(<code class="type">boolean</code>)</code></code></td><td><code class="type">name[]</code></td><td>搜索路径中的模式名，可以选择是否包含隐式模式</td></tr><tr><td><code class="literal"><code class="function">current_user</code></code></td><td><code class="type">name</code></td><td>当前执行上下文的用户名</td></tr><tr><td><code class="literal"><code class="function">inet_client_addr()</code></code></td><td><code class="type">inet</code></td><td>远程的客户端连接地址</td></tr><tr><td><code class="literal"><code class="function">inet_client_port()</code></code></td><td><code class="type">int</code></td><td>远程的客户端连接端口</td></tr><tr><td><code class="literal"><code class="function">inet_server_addr()</code></code></td><td><code class="type">inet</code></td><td>本地的服务端连接地址</td></tr><tr><td><code class="literal"><code class="function">inet_server_port()</code></code></td><td><code class="type">int</code></td><td>本地的服务端连接端口</td></tr><tr><td><code class="literal"><code class="function">pg_backend_pid()</code></code></td><td><code class="type">int</code></td><td>        与当前会话关联的服务器进程的进程 ID
       </td></tr><tr><td><code class="literal"><code class="function">pg_blocking_pids(<code class="type">int</code>)</code></code></td><td><code class="type">int[]</code></td><td>正在阻止指定的服务器进程ID获取锁的进程ID</td></tr><tr><td><code class="literal"><code class="function">pg_conf_load_time()</code></code></td><td><code class="type">timestamp with time zone</code></td><td>配置载入时间</td></tr><tr><td><code class="literal"><code class="function">pg_current_logfile([<span class="optional"><code class="type">text</code></span>])</code></code></td><td><code class="type">text</code></td><td>主日志文件名称，或者登录日志采集器当前正在使用的请求格式的日志</td></tr><tr><td><code class="literal"><code class="function">pg_my_temp_schema()</code></code></td><td><code class="type">oid</code></td><td>会话的临时模式的 OID，如果没有则为 0</td></tr><tr><td><code class="literal"><code class="function">pg_is_other_temp_schema(<code class="type">oid</code>)</code></code></td><td><code class="type">boolean</code></td><td>模式是另一个会话的临时模式吗？</td></tr><tr><td><code class="literal"><code class="function">pg_listening_channels()</code></code></td><td><code class="type">setof text</code></td><td>会话当前正在监听的频道名称</td></tr><tr><td><code class="literal"><code class="function">pg_notification_queue_usage()</code></code></td><td><code class="type">double</code></td><td>异步通知队列当前被占用的分数（0-1）</td></tr><tr><td><code class="literal"><code class="function">pg_postmaster_start_time()</code></code></td><td><code class="type">timestamp with time zone</code></td><td>服务器启动时间</td></tr><tr><td><code class="literal"><code class="function">pg_safe_snapshot_blocking_pids(<code class="type">int</code>)</code></code></td><td><code class="type">int[]</code></td><td>阻止指定的服务器进程ID获取安全快照的进程ID</td></tr><tr><td><code class="literal"><code class="function">pg_trigger_depth()</code></code></td><td><code class="type">int</code></td><td><span class="productname">PostgreSQL</span>触发器的当前嵌套层次（如果没有调用则为 0，直接或间接，从一个触发器内部开始）</td></tr><tr><td><code class="literal"><code class="function">session_user</code></code></td><td><code class="type">name</code></td><td>会话用户名</td></tr><tr><td><code class="literal"><code class="function">user</code></code></td><td><code class="type">name</code></td><td>等价于<code class="function">current_user</code></td></tr><tr><td><code class="literal"><code class="function">version()</code></code></td><td><code class="type">text</code></td><td><span class="productname">PostgreSQL</span>版本信息。参阅<a class="xref" href="runtime-config-preset.html#GUC-SERVER-VERSION-NUM">server_version_num</a>获取机器可读版本。</td></tr></tbody></table></div></div><br class="table-break" /><div class="note"><h3 class="title">注意</h3><p>     <code class="function">current_catalog</code>、<code class="function">current_role</code>、<code class="function">current_schema</code>、<code class="function">current_user</code>、<code class="function">session_user</code>和<code class="function">user</code>在<acronym class="acronym">SQL</acronym>里有特殊的语意状态： 它们被调用时结尾不要跟着园括号（在 PostgreSQL 中，圆括号可以有选择性地被用于<code class="function">current_schema</code>，但是不能和其他的一起用）。
    </p></div><a id="idp14711824" class="indexterm"></a><a id="idp14712512" class="indexterm"></a><a id="idp14713200" class="indexterm"></a><a id="idp14713888" class="indexterm"></a><a id="idp14714576" class="indexterm"></a><a id="idp14715264" class="indexterm"></a><a id="idp14715952" class="indexterm"></a><a id="idp14716640" class="indexterm"></a><a id="idp14717328" class="indexterm"></a><a id="idp14718304" class="indexterm"></a><a id="idp14719280" class="indexterm"></a><a id="idp14719968" class="indexterm"></a><a id="idp14720944" class="indexterm"></a><p>    <code class="function">session_user</code>通常是发起当前数据库连接的用户，不过超级用户可以用<a class="xref" href="sql-set-session-authorization.html" title="SET SESSION AUTHORIZATION"><span class="refentrytitle">SET SESSION AUTHORIZATION</span></a>修改这个设置。<code class="function">current_user</code>是用于权限检查的用户标识。通常， 它总是等于会话用户，但是可以被<a class="xref" href="sql-set-role.html" title="SET ROLE"><span class="refentrytitle">SET ROLE</span></a>改变。它也会在函数执行的过程中随着属性<code class="literal">SECURITY DEFINER</code>的改变而改变。在 Unix 的说法里，那么会话用户是<span class="quote">“<span class="quote">真实用户</span>”</span>，而当前用户是<span class="quote">“<span class="quote">有效用户</span>”</span>。
	<code class="function">current_role</code>和<code class="function">user</code>是
    <code class="function">current_user</code>的同义词。(SQL标准区分
    <code class="function">current_role</code>和<code class="function">current_user</code>，
	但是<span class="productname">PostgreSQL</span>不区分，因为它将用户和角色统一为单一类型的实体。)
   </p><p>    <code class="function">current_schema</code>返回在搜索路径中的第一个模式名（如果搜索路径是空则返回空值）。 如果创建表或者其它命名对象时没有声明目标模式，那么它将是被用于这些对象的模式。<code class="function">current_schemas(boolean)</code>返回一个在搜索路径中出现的所有模式名的数组。布尔选项决定<code class="literal">pg_catalog</code>这样的隐式包含的系统模式是否包含在返回的搜索路径中。
   </p><div class="note"><h3 class="title">注意</h3><p>     搜索路径可以在运行时修改。命令是：
</p><pre class="programlisting">SET search_path TO <em class="replaceable"><code>schema</code></em> [<span class="optional">, <em class="replaceable"><code>schema</code></em>, ...</span>]</pre><p>
    </p></div><a id="idp14736256" class="indexterm"></a><a id="idp14736944" class="indexterm"></a><a id="idp14737632" class="indexterm"></a><a id="idp14738320" class="indexterm"></a><p>     <code class="function">inet_client_addr</code>返回当前客户端的 IP 地址，<code class="function">inet_client_port</code>返回它的端口号。 <code class="function">inet_server_addr</code>返回接受当前连接的服务器的 IP 地址，而<code class="function">inet_server_port</code>返回对应的端口号。如果连接是通过 Unix 域套接字进行的，那么所有这些函数都返回 NULL。
   </p><a id="idp14742320" class="indexterm"></a><p>    <code class="function">pg_blocking_pids</code>返回一个进程 ID 的数组，
    数组中的进程中的会话阻塞了指定进程 ID 所代表的服务器进程，
    如果指定的服务器进程不存在或者没有被阻塞则返回空数组。
    如果一个进程持有与另一个进程加锁请求冲突的锁（硬锁），
    或者前者正在等待一个与后者加锁请求冲突的锁并且前者在该锁的等待队列中
    位于后者的前面（软锁），则前者会阻塞后者。在使用并行查询时，
    这个函数的结果总是会列出客户端可见的进程 ID（即<code class="function">pg_backend_pid</code>
    的结果），即便实际的锁是由工作者进程所持有或者等待也是如此。
    这样造成的后果是，结果中可能会有很多重复的 PID。
    还要注意当一个预备事务持有一个冲突锁时，
    这个函数的结果中它将被表示为一个为零的进程 ID。
    对这个函数的频繁调用可能对数据库性能有一些影响，
    因为它需要短时间地独占访问锁管理器的共享状态。
   </p><a id="idp14746432" class="indexterm"></a><p>    <code class="function">pg_conf_load_time</code>返回服务器配置文件最近被载入的
    <code class="type">timestamp with time zone</code>（如果当前会话在那时就已经存在，
    这个值将是该会话自己重新读取配置文件的时间，
    因此在不同的会话中这个读数会有一点变化。如果不是这样，
    这个值就是 postmaster 进程重读配置文件的时间）。
   </p><a id="idp14748864" class="indexterm"></a><a id="idp14749552" class="indexterm"></a><a id="idp14750560" class="indexterm"></a><a id="idp14751568" class="indexterm"></a><p>    <code class="function">pg_current_logfile</code>以<code class="type">text</code>
	的形式返回日志采集器当前使用的日志文件的路径。路径包括
	<a class="xref" href="runtime-config-logging.html#GUC-LOG-DIRECTORY">log_directory</a>目录和日志文件名。
	必须启用日志收集或返回值为<code class="literal">NULL</code>。当存在多个日志文件时，
	每个格式都不同，调用时不带参数的<code class="function">pg_current_logfile</code>
	将返回具有在有序列表中找到的第一个格式的文件的路径：<span class="systemitem">stderr</span>、
	<span class="systemitem">csvlog</span>。当没有日志文件具有任何这些格式时，
	将返回<code class="literal">NULL</code>。要以<code class="type">text</code>的形式请求特定的文件格式，
	可以使用<span class="systemitem">csvlog</span>或<span class="systemitem">stderr</span>作为可选参数的值。
	当请求的日志格式不是配置的<a class="xref" href="runtime-config-logging.html#GUC-LOG-DESTINATION">log_destination</a>时，
	返回值是<code class="literal">NULL</code>。<code class="function">pg_current_logfiles</code>
	反映了<code class="filename">current_logfiles</code>文件的内容。
   </p><a id="idp14763776" class="indexterm"></a><a id="idp14764464" class="indexterm"></a><p>    <code class="function">pg_my_temp_schema</code>返回当前会话临时模式的 OID，如果没有使用临时模式（因为它没有创建任何临时表）则返回零。如果给定的 OID 是另一个会话的临时模式的 OID，则<code class="function">pg_is_other_temp_schema</code>返回真（这是有用的，例如，要将其他会话的临时表从一个目录显示中排除）。
   </p><a id="idp14767120" class="indexterm"></a><a id="idp14767808" class="indexterm"></a><p>    <code class="function">pg_listening_channels</code>
    返回当前会话正在监听的异步通知频道的名称的集合。
    <code class="function">pg_notification_queue_usage</code>
    返回等待处理的通知占可用的通知空间的比例，
    它是一个 0-1 范围内的<code class="type">double</code>值。详见
    <a class="xref" href="sql-listen.html" title="LISTEN"><span class="refentrytitle">LISTEN</span></a>和<a class="xref" href="sql-notify.html" title="NOTIFY"><span class="refentrytitle">NOTIFY</span></a>。
   </p><a id="idp14772640" class="indexterm"></a><p>    <code class="function">pg_postmaster_start_time</code>返回服务器启动时的<code class="type">timestamp with time zone</code>。
   </p><a id="idp14774816" class="indexterm"></a><p>    <code class="function">pg_safe_snapshot_blocking_pids</code>
	返回阻塞具有指定进程ID的服务器进程获取安全快照的会话的进程ID数组，
	或者如果没有这样的服务器进程或者它不是受阻，返回一个空数组。
	运行<code class="literal">SERIALIZABLE</code>事务的会话会阻止
	<code class="literal">SERIALIZABLE READ ONLY DEFERRABLE</code>事务获取快照，
	直到后者确定避免使用任何谓词锁定是安全的为止。
	有关可序列化和可延期事务的更多信息，请参阅<a class="xref" href="transaction-iso.html#XACT-SERIALIZABLE" title="13.2.3. 可序列化隔离级别">第 13.2.3 节</a>。
	频繁调用此函数可能会对数据库性能产生一些影响，
	因为它需要短时间访问谓词锁管理器的共享状态。
   </p><a id="idp14779520" class="indexterm"></a><p>    <code class="function">version</code>返回一个描述
    <span class="productname">PostgreSQL</span>服务器版本的字符串。
    你也可以从<a class="xref" href="runtime-config-preset.html#GUC-SERVER-VERSION">server_version</a>获取机器
    可读版本<a class="xref" href="runtime-config-preset.html#GUC-SERVER-VERSION-NUM">server_version_num</a>信息，
    软件开发者应该使用<code class="literal">server_version_num</code>
    (8.2可用)或者<a class="xref" href="libpq-status.html#LIBPQ-PQSERVERVERSION">      <code class="function">PQserverVersion</code>
      
     </a>解析文本版本。
   </p><a id="idp14785120" class="indexterm"></a><p>   <a class="xref" href="functions-info.html#FUNCTIONS-INFO-ACCESS-TABLE" title="表 9.61. 访问权限查询函数">表 9.61</a>列出那些允许用户编程查询对象访问权限的函数。参阅<a class="xref" href="ddl-priv.html" title="5.6. 权限">第 5.6 节</a>获取更多有关权限的信息。
  </p><div class="table" id="FUNCTIONS-INFO-ACCESS-TABLE"><p class="title"><strong>表 9.61. 访问权限查询函数</strong></p><div class="table-contents"><table class="table" summary="访问权限查询函数" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>返回类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="literal"><code class="function">has_any_column_privilege</code>(<em class="parameter"><code>user</code></em>,
                                  <em class="parameter"><code>table</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>用户有没有表中任意列上的权限</td></tr><tr><td><code class="literal"><code class="function">has_any_column_privilege</code>(<em class="parameter"><code>table</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>当前用户有没有表中任意列上的权限</td></tr><tr><td><code class="literal"><code class="function">has_column_privilege</code>(<em class="parameter"><code>user</code></em>,
                                  <em class="parameter"><code>table</code></em>,
                                  <em class="parameter"><code>column</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>用户有没有列的权限</td></tr><tr><td><code class="literal"><code class="function">has_column_privilege</code>(<em class="parameter"><code>table</code></em>,
                                  <em class="parameter"><code>column</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>当前用户有没有列的权限</td></tr><tr><td><code class="literal"><code class="function">has_database_privilege</code>(<em class="parameter"><code>user</code></em>,
                                  <em class="parameter"><code>database</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>用户有没有数据库的权限</td></tr><tr><td><code class="literal"><code class="function">has_database_privilege</code>(<em class="parameter"><code>database</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>当前用户有没有数据库的权限</td></tr><tr><td><code class="literal"><code class="function">has_foreign_data_wrapper_privilege</code>(<em class="parameter"><code>user</code></em>,
                                  <em class="parameter"><code>fdw</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>用户有没有外部数据包装器上的权限</td></tr><tr><td><code class="literal"><code class="function">has_foreign_data_wrapper_privilege</code>(<em class="parameter"><code>fdw</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>当前用户有没有外部数据包装器上的权限</td></tr><tr><td><code class="literal"><code class="function">has_function_privilege</code>(<em class="parameter"><code>user</code></em>,
                                  <em class="parameter"><code>function</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>用户有没有函数上的权限</td></tr><tr><td><code class="literal"><code class="function">has_function_privilege</code>(<em class="parameter"><code>function</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>当前用户有没有函数上的权限</td></tr><tr><td><code class="literal"><code class="function">has_language_privilege</code>(<em class="parameter"><code>user</code></em>,
                                  <em class="parameter"><code>language</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>用户有没有语言上的权限</td></tr><tr><td><code class="literal"><code class="function">has_language_privilege</code>(<em class="parameter"><code>language</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>当前用户有没有语言上的权限</td></tr><tr><td><code class="literal"><code class="function">has_schema_privilege</code>(<em class="parameter"><code>user</code></em>,
                                  <em class="parameter"><code>schema</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>用户有没有模式上的权限</td></tr><tr><td><code class="literal"><code class="function">has_schema_privilege</code>(<em class="parameter"><code>schema</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>当前用户有没有模式上的权限</td></tr><tr><td><code class="literal"><code class="function">has_sequence_privilege</code>(<em class="parameter"><code>user</code></em>,
                                  <em class="parameter"><code>sequence</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>用户有没有序列上的权限</td></tr><tr><td><code class="literal"><code class="function">has_sequence_privilege</code>(<em class="parameter"><code>sequence</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>当前用户有没有序列上的权限</td></tr><tr><td><code class="literal"><code class="function">has_server_privilege</code>(<em class="parameter"><code>user</code></em>,
                                  <em class="parameter"><code>server</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>用户有没有外部服务器上的权限</td></tr><tr><td><code class="literal"><code class="function">has_server_privilege</code>(<em class="parameter"><code>server</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>当前用户有没有外部服务器上的权限</td></tr><tr><td><code class="literal"><code class="function">has_table_privilege</code>(<em class="parameter"><code>user</code></em>,
                                  <em class="parameter"><code>table</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>用户有没有表上的权限</td></tr><tr><td><code class="literal"><code class="function">has_table_privilege</code>(<em class="parameter"><code>table</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>当前用户有没有表上的权限</td></tr><tr><td><code class="literal"><code class="function">has_tablespace_privilege</code>(<em class="parameter"><code>user</code></em>,
                                  <em class="parameter"><code>tablespace</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>用户有没有表空间上的权限</td></tr><tr><td><code class="literal"><code class="function">has_tablespace_privilege</code>(<em class="parameter"><code>tablespace</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>当前用户有没有表空间上的权限</td></tr><tr><td><code class="literal"><code class="function">has_type_privilege</code>(<em class="parameter"><code>user</code></em>,
                                  <em class="parameter"><code>type</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>用户有没有类型的特权</td></tr><tr><td><code class="literal"><code class="function">has_type_privilege</code>(<em class="parameter"><code>type</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>当前用户有没有类型的特权</td></tr><tr><td><code class="literal"><code class="function">pg_has_role</code>(<em class="parameter"><code>user</code></em>,
                                  <em class="parameter"><code>role</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>用户有没有角色上的权限</td></tr><tr><td><code class="literal"><code class="function">pg_has_role</code>(<em class="parameter"><code>role</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>当前用户有没有角色上的权限</td></tr><tr><td><code class="literal"><code class="function">row_security_active</code>(<em class="parameter"><code>table</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>当前用户有没有表上的行级安全性</td></tr></tbody></table></div></div><br class="table-break" /><a id="idp14898544" class="indexterm"></a><a id="idp14899248" class="indexterm"></a><a id="idp14899936" class="indexterm"></a><a id="idp14900624" class="indexterm"></a><a id="idp14901312" class="indexterm"></a><a id="idp14902016" class="indexterm"></a><a id="idp14902704" class="indexterm"></a><a id="idp14903392" class="indexterm"></a><a id="idp14904080" class="indexterm"></a><a id="idp14904768" class="indexterm"></a><a id="idp14905456" class="indexterm"></a><a id="idp14906160" class="indexterm"></a><a id="idp14906848" class="indexterm"></a><a id="idp14907536" class="indexterm"></a><p>    <code class="function">has_table_privilege</code>判断一个用户是否可以用某种特定的方式访问一个表。 该用户可以通过名字或者 OID （<code class="literal">pg_authid.oid</code>） 来指定，也可以用<code class="literal">public</code>表示 PUBLIC 伪角色。如果省略该参数，则使用<code class="function">current_user</code>。 该表可以通过名字或者 OID 指定（因此，实际上有六种 <code class="function">has_table_privilege</code>的变体，我们可以通过它们的参数数目和类型来区分它们） 。如果用名字指定，那么在必要时该名字可以是模式限定的。 所希望的权限类型是用一个文本串来指定的，它必须是下面的几个值之一： <code class="literal">SELECT</code>、<code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、<code class="literal">DELETE</code>、<code class="literal">TRUNCATE</code>、<code class="literal">REFERENCES</code>或<code class="literal">TRIGGER</code>。<code class="literal">WITH GRANT OPTION</code>可以被选择增加到一个权限类型来测试是否该权限是使用转授选项得到。另外，可以使用逗号分隔来列出多个权限类型，在这种情况下只要具有其中之一的权限则结果为<code class="literal">真</code>（权限字符串的大小写并不重要，可以在权限名称之间出现额外的空白，但是在权限名内部不能有空白）。一些例子：
</p><pre class="programlisting">SELECT has_table_privilege('myschema.mytable', 'select');
SELECT has_table_privilege('joe', 'mytable', 'INSERT, SELECT WITH GRANT OPTION');</pre><p>
   </p><p>    <code class="function">has_sequence_privilege</code>检查一个用户是否能以某种特定方式访问一个序列。它的参数可能性和<code class="function">has_table_privilege</code>相似。所希望测试的访问权限类型必须是下列之一：<code class="literal">USAGE</code>、<code class="literal">SELECT</code>或<code class="literal">UPDATE</code>。
   </p><p>    <code class="function">has_any_column_privilege</code>检查一个用户是否能以特定方式访问一个表的任意列。其参数可能性和<code class="function">has_table_privilege</code>类似，除了所希望的访问权限类型必须是下面值的某种组合：<code class="literal">SELECT</code>、<code class="literal">INSERT</code>、<code class="literal">UPDATE</code>或<code class="literal">REFERENCES</code>。注意在表层面上具有这些权限的任意一个都会隐式地把它授权给表中的每一列，因此如果<code class="function">has_table_privilege</code>对同样的参数返回真则<code class="function">has_any_column_privilege</code>将总是返回<code class="literal">真</code>。但是如果在至少一列上有一个该权限的列级授权，<code class="function">has_any_column_privilege</code>也会成功。
   </p><p>    <code class="function">has_column_privilege</code>检查一个用户是否能以特定方式访问一个列。它的参数可能性与<code class="function">has_table_privilege</code>类似，并且列还可以使用名字或者属性号来指定。希望的访问权限类型必须是下列值的某种组合：<code class="literal">SELECT</code>、<code class="literal">INSERT</code>、<code class="literal">UPDATE</code>或<code class="literal">REFERENCES</code>。注意在表级别上具有这些权限中的任意一种将会隐式地把它授予给表上的每一列。
   </p><p>    <code class="function">has_database_privilege</code>检查一个用户是否能以特定方式访问一个数据库。它的参数可能性类似 <code class="function">has_table_privilege</code>。希望的访问权限类型必须是以下值的某种组合：<code class="literal">CREATE</code>、<code class="literal">CONNECT</code>、<code class="literal">TEMPORARY</code>或<code class="literal">TEMP</code>（等价于<code class="literal">TEMPORARY</code>）。
   </p><p>    <code class="function">has_function_privilege</code>检查一个用户是否能以特定方式访问一个函数。其参数可能性类似<code class="function">has_table_privilege</code>。在用一个文本串而不是 OID 指定一个函数时，允许的输入和<code class="type">regprocedure</code>数据类型一样（参阅 <a class="xref" href="datatype-oid.html" title="8.18. 对象标识符类型">第 8.18 节</a>）。希望的访问权限类型必须是<code class="literal">EXECUTE</code>。一个例子：
</p><pre class="programlisting">SELECT has_function_privilege('joeuser', 'myfunc(int, text)', 'execute');</pre><p>
   </p><p>    <code class="function">has_foreign_data_wrapper_privilege</code>检查一个用户是否能以特定方式访问一个外部数据包装器。它的参数可能性类似于<code class="function">has_table_privilege</code>。希望的访问权限类型必须是<code class="literal">USAGE</code>。
   </p><p>    <code class="function">has_language_privilege</code>检查一个用户是否可以以某种特定的方式访问一个过程语言。 其参数可能性类似 <code class="function">has_table_privilege</code>。希望的访问权限类型必须是<code class="literal">USAGE</code>。
   </p><p>    <code class="function">has_schema_privilege</code>检查一个用户是否可以以某种特定的方式访问一个模式。 其参数可能性类似 <code class="function">has_table_privilege</code>。希望的访问权限类型必须是<code class="literal">CREATE</code>或<code class="literal">USAGE</code>。
   </p><p>    <code class="function">has_server_privilege</code>检查一个用户是否可以以某种特定的方式访问一个外部服务器。 其参数可能性类似 <code class="function">has_table_privilege</code>。希望的访问权限类型必须是<code class="literal">USAGE</code>。
   </p><p>    <code class="function">has_tablespace_privilege</code>检查一个用户是否可以以某种特定的方式访问一个表空间。其参数可能性类似 <code class="function">has_table_privilege</code>。希望的访问权限类型必须是<code class="literal">CREATE</code>。
   </p><p>    <code class="function">pg_has_role</code>检查一个用户是否可以以某种特定的方式访问一个角色。其参数可能性类似 <code class="function">has_table_privilege</code>，除了<code class="literal">public</code>不能被允许作为一个用户名。希望的访问权限类型必须是下列值的某种组合：<code class="literal">MEMBER</code>或<code class="literal">USAGE</code>。<code class="literal">MEMBER</code>表示该角色中的直接或间接成员关系（即使用<code class="command">SET ROLE</code>的权力），而<code class="literal">USAGE</code>表示不做<code class="command">SET ROLE</code>的情况下该角色的权限是否立即可用。
   </p><p>    <code class="function">row_security_active</code>检查行级安全是否对
    <code class="function">current_user</code>以及环境上下文中的指定表是活跃的。
    通过名称或者OID指定表。    
   </p><p>
    <code class="function">row_security_active</code>检查在<code class="function">current_user</code>
    的上下文和环境中是否为指定的表激活了行级安全性。表可以用名称或者 OID 指定。
   </p><p>   <a class="xref" href="functions-info.html#FUNCTIONS-INFO-SCHEMA-TABLE" title="表 9.62. 模式可见性查询函数">表 9.62</a>展示了决定是否一个特定对象在当前模式搜索路径中<em class="firstterm">可见</em>的函数。例如，如果一个表所在的模式在当前搜索路径中并且在它之前没有出现过相同的名字，这个表就被说是可见的。这等价于在语句中表可以被用名称引用但不加显式的模式限定。要列出所有可见表的名字：










</p><pre class="programlisting">SELECT relname FROM pg_class WHERE pg_table_is_visible(oid);</pre><p>
  </p><a id="idp14973360" class="indexterm"></a><div class="table" id="FUNCTIONS-INFO-SCHEMA-TABLE"><p class="title"><strong>表 9.62. 模式可见性查询函数</strong></p><div class="table-contents"><table class="table" summary="模式可见性查询函数" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>返回类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="literal"><code class="function">pg_collation_is_visible(<em class="parameter"><code>collation_oid</code></em>)</code></code>
       </td><td><code class="type">boolean</code></td><td>排序规则在搜索路径中可见吗？</td></tr><tr><td><code class="literal"><code class="function">pg_conversion_is_visible(<em class="parameter"><code>conversion_oid</code></em>)</code></code>
       </td><td><code class="type">boolean</code></td><td>转换在搜索路径中可见吗？</td></tr><tr><td><code class="literal"><code class="function">pg_function_is_visible(<em class="parameter"><code>function_oid</code></em>)</code></code>
       </td><td><code class="type">boolean</code></td><td>函数在搜索路径中可见吗？</td></tr><tr><td><code class="literal"><code class="function">pg_opclass_is_visible(<em class="parameter"><code>opclass_oid</code></em>)</code></code>
       </td><td><code class="type">boolean</code></td><td>操作符类在搜索路径中可见吗？</td></tr><tr><td><code class="literal"><code class="function">pg_operator_is_visible(<em class="parameter"><code>operator_oid</code></em>)</code></code>
       </td><td><code class="type">boolean</code></td><td>操作符在搜索路径中可见吗？</td></tr><tr><td><code class="literal"><code class="function">pg_opfamily_is_visible(<em class="parameter"><code>opclass_oid</code></em>)</code></code>
       </td><td><code class="type">boolean</code></td><td>操作符族在搜索路径中可见吗？</td></tr><tr><td><code class="literal"><code class="function">pg_statistics_obj_is_visible(<em class="parameter"><code>stat_oid</code></em>)</code></code>
       </td><td><code class="type">boolean</code></td><td>统计对象在搜索路径中是否可见</td></tr><tr><td><code class="literal"><code class="function">pg_table_is_visible(<em class="parameter"><code>table_oid</code></em>)</code></code>
       </td><td><code class="type">boolean</code></td><td>表在搜索路径中可见吗？</td></tr><tr><td><code class="literal"><code class="function">pg_ts_config_is_visible(<em class="parameter"><code>config_oid</code></em>)</code></code>
       </td><td><code class="type">boolean</code></td><td>文本搜索配置在搜索路径中可见吗？</td></tr><tr><td><code class="literal"><code class="function">pg_ts_dict_is_visible(<em class="parameter"><code>dict_oid</code></em>)</code></code>
       </td><td><code class="type">boolean</code></td><td>文本搜索字典在搜索路径中可见吗？</td></tr><tr><td><code class="literal"><code class="function">pg_ts_parser_is_visible(<em class="parameter"><code>parser_oid</code></em>)</code></code>
       </td><td><code class="type">boolean</code></td><td>文本搜索解析器在搜索路径中可见吗？</td></tr><tr><td><code class="literal"><code class="function">pg_ts_template_is_visible(<em class="parameter"><code>template_oid</code></em>)</code></code>
       </td><td><code class="type">boolean</code></td><td>文本搜索模板在搜索路径中可见吗？</td></tr><tr><td><code class="literal"><code class="function">pg_type_is_visible(<em class="parameter"><code>type_oid</code></em>)</code></code>
       </td><td><code class="type">boolean</code></td><td>类型（或域）在搜索路径中可见吗？</td></tr></tbody></table></div></div><br class="table-break" /><a id="idp15012752" class="indexterm"></a><a id="idp15013440" class="indexterm"></a><a id="idp15014144" class="indexterm"></a><a id="idp15014832" class="indexterm"></a><a id="idp15015520" class="indexterm"></a><a id="idp15016208" class="indexterm"></a><a id="idp15016896" class="indexterm"></a><a id="idp15017600" class="indexterm"></a><a id="idp15018288" class="indexterm"></a><a id="idp15018976" class="indexterm"></a><a id="idp15019664" class="indexterm"></a><a id="idp15020352" class="indexterm"></a><a id="idp15021056" class="indexterm"></a><p>    每一个函数对一种数据库对象执行可见性检查。
    注意<code class="function">pg_table_is_visible</code>也可被用于视图、索引和序列以及外表，
    <code class="function">pg_type_is_visible</code>也可以被用于域。对于函数和操作符，
    如果在路径中更早的地方没有出现具有相同名称<span class="emphasis"><em>和参数数据类型</em></span>的对象，
    该对象在搜索路径中是可见的。对于操作符类，名称和相关的索引访问方法都要考虑。
   </p><p>    所有这些函数都要求用对象 OID 来标识将被检查的对象。如果你想用名称来测试一个对象，使用 OID 别名类型（<code class="type">regclass</code>、<code class="type">regtype</code>、<code class="type">regprocedure</code>、<code class="type">regoperator</code>、<code class="type">regconfig</code>或<code class="type">regdictionary</code>）将会很方便。例如：
</p><pre class="programlisting">SELECT pg_type_is_visible('myschema.widget'::regtype);</pre><p>
    注意以这种方式测试一个非模式限定的类型名没什么意义 — 如果该名称完全能被识别，它必须是可见的。
   </p><a id="idp11391264" class="indexterm"></a><a id="idp15029504" class="indexterm"></a><a id="idp15030192" class="indexterm"></a><a id="idp15030880" class="indexterm"></a><a id="idp15031568" class="indexterm"></a><a id="idp15032272" class="indexterm"></a><a id="idp15032976" class="indexterm"></a><a id="idp15033664" class="indexterm"></a><a id="idp15034352" class="indexterm"></a><a id="idp15035040" class="indexterm"></a><a id="idp15035728" class="indexterm"></a><a id="idp15036416" class="indexterm"></a><a id="idp15037104" class="indexterm"></a><a id="idp15037792" class="indexterm"></a><a id="idp15038480" class="indexterm"></a><a id="idp15039168" class="indexterm"></a><a id="idp15039872" class="indexterm"></a><a id="idp15040560" class="indexterm"></a><a id="idp15041248" class="indexterm"></a><a id="idp15041936" class="indexterm"></a><a id="idp15042624" class="indexterm"></a><a id="idp15043312" class="indexterm"></a><a id="idp15044000" class="indexterm"></a><a id="idp15044688" class="indexterm"></a><a id="idp15045376" class="indexterm"></a><a id="idp15046064" class="indexterm"></a><a id="idp15046752" class="indexterm"></a><a id="idp15047440" class="indexterm"></a><a id="idp15048128" class="indexterm"></a><a id="idp15048816" class="indexterm"></a><a id="idp15049504" class="indexterm"></a><p>   <a class="xref" href="functions-info.html#FUNCTIONS-INFO-CATALOG-TABLE" title="表 9.63. 系统目录信息函数">表 9.63</a>列出了从系统目录抽取信息的函数。
  </p><div class="table" id="FUNCTIONS-INFO-CATALOG-TABLE"><p class="title"><strong>表 9.63. 系统目录信息函数</strong></p><div class="table-contents"><table class="table" summary="系统目录信息函数" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>返回类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="literal"><code class="function">format_type(<em class="parameter"><code>type_oid</code></em>, <em class="parameter"><code>typemod</code></em>)</code></code></td><td><code class="type">text</code></td><td>获得一个数据类型的 SQL 名字</td></tr><tr><td><code class="literal"><code class="function">pg_get_constraintdef(<em class="parameter"><code>constraint_oid</code></em>)</code></code></td><td><code class="type">text</code></td><td>获得一个约束的定义</td></tr><tr><td><code class="literal"><code class="function">pg_get_constraintdef(<em class="parameter"><code>constraint_oid</code></em>, <em class="parameter"><code>pretty_bool</code></em>)</code></code></td><td><code class="type">text</code></td><td>获得一个约束的定义</td></tr><tr><td><code class="literal"><code class="function">pg_get_expr(<em class="parameter"><code>pg_node_tree</code></em>, <em class="parameter"><code>relation_oid</code></em>)</code></code></td><td><code class="type">text</code></td><td>反编译一个表达式的内部形式，假定其中的任何 Var 指向由第二个参数指示的关系</td></tr><tr><td><code class="literal"><code class="function">pg_get_expr(<em class="parameter"><code>pg_node_tree</code></em>, <em class="parameter"><code>relation_oid</code></em>, <em class="parameter"><code>pretty_bool</code></em>)</code></code></td><td><code class="type">text</code></td><td>反编译一个表达式的内部形式，假定其中的任何 Var 指向由第二个参数指示的关系</td></tr><tr><td><code class="literal"><code class="function">pg_get_functiondef(<em class="parameter"><code>func_oid</code></em>)</code></code></td><td><code class="type">text</code></td><td>获得一个函数的定义</td></tr><tr><td><code class="literal"><code class="function">pg_get_function_arguments(<em class="parameter"><code>func_oid</code></em>)</code></code></td><td><code class="type">text</code></td><td>获得一个函数定义的参数列表（带有默认值）</td></tr><tr><td><code class="literal"><code class="function">pg_get_function_identity_arguments(<em class="parameter"><code>func_oid</code></em>)</code></code></td><td><code class="type">text</code></td><td>获得标识一个函数的参数列表（不带默认值）</td></tr><tr><td><code class="literal"><code class="function">pg_get_function_result(<em class="parameter"><code>func_oid</code></em>)</code></code></td><td><code class="type">text</code></td><td>获得函数的<code class="literal">RETURNS</code>子句</td></tr><tr><td><code class="literal"><code class="function">pg_get_indexdef(<em class="parameter"><code>index_oid</code></em>)</code></code></td><td><code class="type">text</code></td><td>获得索引的<code class="command">CREATE INDEX</code>命令</td></tr><tr><td><code class="literal"><code class="function">pg_get_indexdef(<em class="parameter"><code>index_oid</code></em>, <em class="parameter"><code>column_no</code></em>, <em class="parameter"><code>pretty_bool</code></em>)</code></code></td><td><code class="type">text</code></td><td>获得索引的<code class="command">CREATE INDEX</code>命令，或者当<em class="parameter"><code>column_no</code></em>为非零时只得到一个索引列的定义</td></tr><tr><td><code class="literal"><code class="function">pg_get_keywords()</code></code></td><td><code class="type">setof record</code></td><td>获得 SQL 关键字的列表及其分类</td></tr><tr><td><code class="literal"><code class="function">pg_get_ruledef(<em class="parameter"><code>rule_oid</code></em>)</code></code></td><td><code class="type">text</code></td><td>获得规则的<code class="command">CREATE RULE</code>命令</td></tr><tr><td><code class="literal"><code class="function">pg_get_ruledef(<em class="parameter"><code>rule_oid</code></em>, <em class="parameter"><code>pretty_bool</code></em>)</code></code></td><td><code class="type">text</code></td><td>获得规则的<code class="command">CREATE RULE</code>命令</td></tr><tr><td><code class="literal"><code class="function">pg_get_serial_sequence(<em class="parameter"><code>table_name</code></em>, <em class="parameter"><code>column_name</code></em>)</code></code></td><td><code class="type">text</code></td><td>获取序列或标识列使用的序列的名称</td></tr><tr><td><code class="literal"><code class="function">pg_get_statisticsobjdef(<em class="parameter"><code>statobj_oid</code></em>)</code></code></td><td><code class="type">text</code></td><td>获取扩展统计信息对象的<code class="command">CREATE STATISTICS</code>命令</td></tr><tr><td><code class="function">pg_get_triggerdef</code>(<em class="parameter"><code>trigger_oid</code></em>)</td><td><code class="type">text</code></td><td>获得触发器的<code class="command">CREATE [ CONSTRAINT ] TRIGGER</code>命令</td></tr><tr><td><code class="function">pg_get_triggerdef</code>(<em class="parameter"><code>trigger_oid</code></em>, <em class="parameter"><code>pretty_bool</code></em>)</td><td><code class="type">text</code></td><td>获得触发器的<code class="command">CREATE [ CONSTRAINT ] TRIGGER</code>命令</td></tr><tr><td><code class="literal"><code class="function">pg_get_userbyid(<em class="parameter"><code>role_oid</code></em>)</code></code></td><td><code class="type">name</code></td><td>获得给定 OID 指定的角色名</td></tr><tr><td><code class="literal"><code class="function">pg_get_viewdef(<em class="parameter"><code>view_name</code></em>)</code></code></td><td><code class="type">text</code></td><td>获得视图或物化视图的底层<code class="command">SELECT</code>命令（<span class="emphasis"><em>已废弃</em></span>）</td></tr><tr><td><code class="literal"><code class="function">pg_get_viewdef(<em class="parameter"><code>view_name</code></em>, <em class="parameter"><code>pretty_bool</code></em>)</code></code></td><td><code class="type">text</code></td><td>获得视图或物化视图的底层<code class="command">SELECT</code>命令（<span class="emphasis"><em>已废弃</em></span>）</td></tr><tr><td><code class="literal"><code class="function">pg_get_viewdef(<em class="parameter"><code>view_oid</code></em>)</code></code></td><td><code class="type">text</code></td><td>获得视图或物化视图的底层<code class="command">SELECT</code>命令</td></tr><tr><td><code class="literal"><code class="function">pg_get_viewdef(<em class="parameter"><code>view_oid</code></em>, <em class="parameter"><code>pretty_bool</code></em>)</code></code></td><td><code class="type">text</code></td><td>获得视图或物化视图的底层<code class="command">SELECT</code>命令</td></tr><tr><td><code class="literal"><code class="function">pg_get_viewdef(<em class="parameter"><code>view_oid</code></em>, <em class="parameter"><code>wrap_column_int</code></em>)</code></code></td><td><code class="type">text</code></td><td>获得视图或物化视图的底层<code class="command">SELECT</code>命令；带域的行被包装成指定的列数，并隐含了优质打印</td></tr><tr><td><code class="literal"><code class="function">pg_index_column_has_property(<em class="parameter"><code>index_oid</code></em>, <em class="parameter"><code>column_no</code></em>, <em class="parameter"><code>prop_name</code></em>)</code></code></td><td><code class="type">boolean</code></td><td>测试一个索引列是否有指定的性质</td></tr><tr><td><code class="literal"><code class="function">pg_index_has_property(<em class="parameter"><code>index_oid</code></em>, <em class="parameter"><code>prop_name</code></em>)</code></code></td><td><code class="type">boolean</code></td><td>测试一个索引是否有指定的性质</td></tr><tr><td><code class="literal"><code class="function">pg_indexam_has_property(<em class="parameter"><code>am_oid</code></em>, <em class="parameter"><code>prop_name</code></em>)</code></code></td><td><code class="type">boolean</code></td><td>测试一个索引访问方法是否有指定的性质</td></tr><tr><td><code class="literal"><code class="function">pg_options_to_table(<em class="parameter"><code>reloptions</code></em>)</code></code></td><td><code class="type">setof record</code></td><td>获得存储选项的名称/值对的集合</td></tr><tr><td><code class="literal"><code class="function">pg_tablespace_databases(<em class="parameter"><code>tablespace_oid</code></em>)</code></code></td><td><code class="type">setof oid</code></td><td>获得在该表空间中有对象的数据库的 OID 的集合</td></tr><tr><td><code class="literal"><code class="function">pg_tablespace_location(<em class="parameter"><code>tablespace_oid</code></em>)</code></code></td><td><code class="type">text</code></td><td>获得这个表空间所在的文件系统的路径</td></tr><tr><td><code class="literal"><code class="function">pg_typeof(<em class="parameter"><code>any</code></em>)</code></code></td><td><code class="type">regtype</code></td><td>获得任意值的数据类型</td></tr><tr><td><code class="literal"><code class="function">collation for (<em class="parameter"><code>any</code></em>)</code></code></td><td><code class="type">text</code></td><td>获得该参数的排序规则</td></tr><tr><td><code class="literal"><code class="function">to_regclass(<em class="parameter"><code>rel_name</code></em>)</code></code></td><td><code class="type">regclass</code></td><td>获得命名关系的OID</td></tr><tr><td><code class="literal"><code class="function">to_regproc(<em class="parameter"><code>func_name</code></em>)</code></code></td><td><code class="type">regproc</code></td><td>获得命名函数的OID</td></tr><tr><td><code class="literal"><code class="function">to_regprocedure(<em class="parameter"><code>func_name</code></em>)</code></code></td><td><code class="type">regprocedure</code></td><td>获得命名函数的OID</td></tr><tr><td><code class="literal"><code class="function">to_regoper(<em class="parameter"><code>operator_name</code></em>)</code></code></td><td><code class="type">regoper</code></td><td>获得命名操作符的OID</td></tr><tr><td><code class="literal"><code class="function">to_regoperator(<em class="parameter"><code>operator_name</code></em>)</code></code></td><td><code class="type">regoperator</code></td><td>获得命名操作符的OID</td></tr><tr><td><code class="literal"><code class="function">to_regtype(<em class="parameter"><code>type_name</code></em>)</code></code></td><td><code class="type">regtype</code></td><td>获得命名类型的OID</td></tr><tr><td><code class="literal"><code class="function">to_regnamespace(<em class="parameter"><code>schema_name</code></em>)</code></code></td><td><code class="type">regnamespace</code></td><td>获得命名模式的OID</td></tr><tr><td><code class="literal"><code class="function">to_regrole(<em class="parameter"><code>role_name</code></em>)</code></code></td><td><code class="type">regrole</code></td><td>获得命名角色的OID</td></tr></tbody></table></div></div><br class="table-break" /><p>   <code class="function">format_type</code>返回一个数据类型的 SQL 名称，它由它的类型 OID 标识并且可能是一个类型修饰符。如果不知道相关的修饰符，则为类型修饰符传递 NULL。
  </p><p>   <code class="function">pg_get_keywords</code>返回一组记录描述服务器识别的 SQL 关键字。<code class="structfield">word</code>列包含关键字。<code class="structfield">catcode</code>列包含一个分类码：<code class="literal">U</code>为未被预定，<code class="literal">C</code> 为列名，<code class="literal">T</code>类型或函数名，<code class="literal">R</code>为预留。<code class="structfield">catdesc</code>列包含一个可能本地化的描述分类的字符串。
  </p><p>   <code class="function">pg_get_constraintdef</code>、<code class="function">pg_get_indexdef</code>、<code class="function">pg_get_ruledef</code>、<code class="function">pg_get_statisticsobjdef</code>和<code class="function">pg_get_triggerdef</code>分别重建一个约束、索引、规则、扩展统计对象或触发器的创建命令（注意这是一个反编译的重构，而不是命令的原始文本）。<code class="function">pg_get_expr</code>反编译一个表达式的内部形式，例如一个列的默认值。在检查系统目录内容时有用。如果表达式可能包含 Var，在第二个参数中指定它们引用的关系的 OID；如果不会出现 Var，第二个参数设置为 0 即可。<code class="function">pg_get_viewdef</code>重构定义一个视图的<code class="command">SELECT</code>查询。这些函数的大部分都有两种变体，一种可以可选地<span class="quote">“<span class="quote">优质打印</span>”</span>结果。优质打印的格式可读性更强，但是默认格式更可能被未来版本的<span class="productname">PostgreSQL</span>以相同的方式解释。在转出目的中避免使用优质打印输出。为优质打印参数传递<code class="literal">假</code>将得到和不带该参数的变体相同的结果。
  </p><p>   <code class="function">pg_get_functiondef</code>为一个函数返回一个完整的<code class="command">CREATE OR REPLACE FUNCTION</code>语句。<code class="function">pg_get_function_arguments</code>返回一个函数的参数列表，形式按照它们出现在<code class="command">CREATE FUNCTION</code>中的那样。<code class="function">pg_get_function_result</code>类似地返回函数的合适的<code class="literal">RETURNS</code>子句。<code class="function">pg_get_function_identity_arguments</code>返回标识一个函数必要的参数列表，形式和它们出现在<code class="command">ALTER FUNCTION</code>中的一样。这种形式忽略默认值。
  </p><p>   <code class="function">pg_get_serial_sequence</code>返回与一个列相关联的序列的名称，如果与列相关联的序列则返回 NULL。
   如果列是标识列，则相关序列是为标识列内部创建的序列。
   对于使用其中一种串行类型（<code class="type">serial</code>、<code class="type">smallserial</code>、
   <code class="type">bigserial</code>）创建的列，它是为该串行列定义创建的序列。
   在后一种情况下，可以使用<code class="command">ALTER SEQUENCE OWNED BY</code>修改或删除该关联。
   （该函数可能应该被称为<code class="function">pg_get_owned_sequence</code>;；
   它的当前名称反映了它通常用于<code class="type">serial</code>或<code class="type">bigserial</code>列的事实。）
   第一个输入参数是一个带可选模式的表名，第二个参数是一个列名。因为第一个参数可能是一个模式和表，它不能按照一个双引号包围的标识符来对待，意味着它默认情况下是小写的。而第二个参数只是一个列名，将被当作一个双引号包围的来处理并且会保留其大小写。函数返回的值会被适当地格式化以便传递给序列函数（参见<a class="xref" href="functions-sequence.html" title="9.16. 序列操作函数">第 9.16 节</a>）。
   典型用途是读取标识或序列列的当前值，例如：
</p><pre class="programlisting">SELECT currval(pg_get_serial_sequence('sometable', 'id'));</pre><p>
  </p><p>   <code class="function">pg_get_userbyid</code>抽取给定 OID 的角色的名称。
  </p><p>   <code class="function">pg_index_column_has_property</code>、<code class="function">pg_index_has_property</code>
   和<code class="function">pg_indexam_has_property</code>返回指定的索引列、
   索引或者索引访问方法是否具有指定性质。如果性质的名称找不到或者不适用于特定的对象，
   亦或者 OID 或者列号不表示合法的对象，则返回<code class="literal">NULL</code>。
   列的性质可参见<a class="xref" href="functions-info.html#FUNCTIONS-INFO-INDEX-COLUMN-PROPS" title="表 9.64.  索引列属性">表 9.64</a>，
   索引的性质可参见<a class="xref" href="functions-info.html#FUNCTIONS-INFO-INDEX-PROPS" title="表 9.65. 索引性质">表 9.65</a>，
   访问方法的性质可参见<a class="xref" href="functions-info.html#FUNCTIONS-INFO-INDEXAM-PROPS" title="表 9.66. 索引访问方法性质">表 9.66</a>
   （注意扩展访问方法可以为其索引定义额外的性质）。 
  </p><div class="table" id="FUNCTIONS-INFO-INDEX-COLUMN-PROPS"><p class="title"><strong>表 9.64.  索引列属性</strong></p><div class="table-contents"><table class="table" summary=" 索引列属性" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td><code class="literal">asc</code></td><td>在向前扫描时列是按照升序排列吗？ 
      </td></tr><tr><td><code class="literal">desc</code></td><td>在向前扫描时列是按照降序排列吗？ 
      </td></tr><tr><td><code class="literal">nulls_first</code></td><td>在向前扫描时列排序会把空值排在前面吗？ 
      </td></tr><tr><td><code class="literal">nulls_last</code></td><td>在向前扫描时列排序会把空值排在最后吗？ 
      </td></tr><tr><td><code class="literal">orderable</code></td><td>列具有已定义的排序顺序吗？ 
      </td></tr><tr><td><code class="literal">distance_orderable</code></td><td>列能否通过一个<span class="quote">“<span class="quote">distance</span>”</span>操作符
      （例如<code class="literal">ORDER BY col &lt;-&gt; constant</code>）有序地扫描？
      </td></tr><tr><td><code class="literal">returnable</code></td><td>列值是否可以通过一次只用索引扫描返回？ 
      </td></tr><tr><td><code class="literal">search_array</code></td><td>列是否天然支持<code class="literal">col = ANY(array)</code>搜索？
      </td></tr><tr><td><code class="literal">search_nulls</code></td><td>列是否支持<code class="literal">IS NULL</code>和<code class="literal">IS NOT NULL</code>搜索？
      </td></tr></tbody></table></div></div><br class="table-break" /><div class="table" id="FUNCTIONS-INFO-INDEX-PROPS"><p class="title"><strong>表 9.65. 索引性质</strong></p><div class="table-contents"><table class="table" summary="索引性质" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td><code class="literal">clusterable</code></td><td>索引是否可以用于<code class="literal">CLUSTER</code>命令？
      </td></tr><tr><td><code class="literal">index_scan</code></td><td>索引是否支持普通扫描（非位图）？
      </td></tr><tr><td><code class="literal">bitmap_scan</code></td><td>索引是否支持位图扫描？ 
      </td></tr><tr><td><code class="literal">backward_scan</code></td><td>索引是否可以反向扫描？ 
      </td></tr></tbody></table></div></div><br class="table-break" /><div class="table" id="FUNCTIONS-INFO-INDEXAM-PROPS"><p class="title"><strong>表 9.66. 索引访问方法性质</strong></p><div class="table-contents"><table class="table" summary="索引访问方法性质" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td><code class="literal">can_order</code></td><td>访问方法是否支持<code class="literal">ASC</code>、<code class="literal">DESC</code>
      以及<code class="literal">CREATE INDEX</code>中的有关关键词？ 
      </td></tr><tr><td><code class="literal">can_unique</code></td><td>访问方法是否支持唯一索引？ 
      </td></tr><tr><td><code class="literal">can_multi_col</code></td><td>访问方法是否支持多列索引？ 
      </td></tr><tr><td><code class="literal">can_exclude</code></td><td>访问方法是否支持排除约束？ 
      </td></tr></tbody></table></div></div><br class="table-break" /><p>   当传入<code class="structname">pg_class</code>.<code class="structfield">reloptions</code>或<code class="structname">pg_attribute</code>.<code class="structfield">attoptions</code>时，<code class="function">pg_options_to_table</code>返回存储选项名称/值对（<code class="literal">option_name</code>/<code class="literal">option_value</code>）的集合。
  </p><p>   <code class="function">pg_tablespace_databases</code>允许一个表空间被检查。它返回一组数据库的 OID，这些数据库都有对象存储在该表空间中。如果这个函数返回任何行，则该表空间为非空并且不能被删除。为了显示该表空间中的指定对象，你将需要连接到<code class="function">pg_tablespace_databases</code>标识的数据库并且查询它们的<code class="structname">pg_class</code>目录。
  </p><p>   <code class="function">pg_typeof</code>返回传递给它的值的数据类型的 OID。这在检修或者动态构建 SQL 查询时有用。函数被声明为返回<code class="type">regtype</code>，它是一个 OID 别名类型（见<a class="xref" href="datatype-oid.html" title="8.18. 对象标识符类型">第 8.18 节</a>）；这表明它和一个用于比较目的的 OID 相同，但是作为一个类型名称显示。例如：
</p><pre class="programlisting">SELECT pg_typeof(33);

 pg_typeof 
-----------
 integer
(1 row) 

SELECT typlen FROM pg_type WHERE oid = pg_typeof(33);
 typlen 
--------
      4
(1 row)</pre><p>
  </p><p>   表达式<code class="literal">collation for</code>返回传递给它的值的排序规则。例子：
</p><pre class="programlisting">SELECT collation for (description) FROM pg_description LIMIT 1;
 pg_collation_for 
------------------
 "default"
(1 row)

SELECT collation for ('foo' COLLATE "de_DE");
 pg_collation_for 
------------------
 "de_DE"
(1 row)</pre><p>
  值可能被加上引号并且变成模式限定的。如果从参数表达式得不到排序规则，则返回一个空值。如果参数不是一个可排序的数据类型，则抛出一个错误。
  </p><p>   <code class="function">to_regclass</code>，<code class="function">to_regproc</code>，
   <code class="function">to_regprocedure</code>，<code class="function">to_regoper</code>，
   <code class="function">to_regoperator</code>，<code class="function">to_regtype</code>，
   <code class="function">to_regnamespace</code>以及<code class="function">to_regrole</code>
   函数各自转换关系，函数，操作符，类型，模式以及角色名称为
   <code class="type">regclass</code>，<code class="type">regproc</code>，<code class="type">regprocedure</code>，
   <code class="type">regoper</code>，<code class="type">regoperator</code>，<code class="type">regtype</code>，
   <code class="type">regnamespace</code>以及<code class="type">regrole</code>类型对象。
   这些函数不同于来自不接受数字OID的文本映射，并返回空而不是抛出一个错误。
   如果没有找到名称（或<code class="function">to_regproc</code>和<code class="function">to_regoper</code>，
   如果给定的名称匹配多个对象）。
  </p><a id="idp15272064" class="indexterm"></a><a id="idp15272752" class="indexterm"></a><a id="idp15273440" class="indexterm"></a><a id="idp15274144" class="indexterm"></a><p>   <a class="xref" href="functions-info.html#FUNCTIONS-INFO-OBJECT-TABLE" title="表 9.67. 对象信息和地址函数">表 9.67</a>列出与数据库对象标识和寻址有关的函数。
  </p><div class="table" id="FUNCTIONS-INFO-OBJECT-TABLE"><p class="title"><strong>表 9.67. 对象信息和地址函数</strong></p><div class="table-contents"><table class="table" summary="对象信息和地址函数" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>返回类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="literal"><code class="function">pg_describe_object(<em class="parameter"><code>catalog_id</code></em>, <em class="parameter"><code>object_id</code></em>, <em class="parameter"><code>object_sub_id</code></em>)</code></code></td><td><code class="type">text</code></td><td>获取数据库对象的描述</td></tr><tr><td><code class="literal"><code class="function">pg_identify_object(<em class="parameter"><code>catalog_id</code></em> <code class="type">oid</code>, <em class="parameter"><code>object_id</code></em> <code class="type">oid</code>, <em class="parameter"><code>object_sub_id</code></em> <code class="type">integer</code>)</code></code></td><td><em class="parameter"><code>type</code></em> <code class="type">text</code>, <em class="parameter"><code>schema</code></em> <code class="type">text</code>, <em class="parameter"><code>name</code></em> <code class="type">text</code>, <em class="parameter"><code>identity</code></em> <code class="type">text</code></td><td>获取数据库对象标识</td></tr><tr><td><code class="literal"><code class="function">pg_identify_object_as_address(<em class="parameter"><code>catalog_id</code></em> <code class="type">oid</code>, <em class="parameter"><code>object_id</code></em> <code class="type">oid</code>, <em class="parameter"><code>object_sub_id</code></em> <code class="type">integer</code>)</code></code></td><td><em class="parameter"><code>type</code></em> <code class="type">text</code>, <em class="parameter"><code>name</code></em> <code class="type">text[]</code>, <em class="parameter"><code>args</code></em> <code class="type">text[]</code></td><td>获取数据库对象地址的外部表征</td></tr><tr><td><code class="literal"><code class="function">pg_get_object_address(<em class="parameter"><code>type</code></em> <code class="type">text</code>, <em class="parameter"><code>name</code></em> <code class="type">text[]</code>, <em class="parameter"><code>args</code></em> <code class="type">text[]</code>)</code></code></td><td><em class="parameter"><code>catalog_id</code></em> <code class="type">oid</code>, <em class="parameter"><code>object_id</code></em> <code class="type">oid</code>, <em class="parameter"><code>object_sub_id</code></em> <code class="type">int32</code></td><td>从外部表征中获取数据库对象地址</td></tr></tbody></table></div></div><br class="table-break" /><p>   <code class="function">pg_describe_object</code>返回一个数据库对象的文本描述，
      该数据库对象由目录 OID、对象 OID 和一个（可能为零）子对象 ID 指定。
      这个描述会是人类可读的，并且可能是被翻译过的，具体情况取决于服务器配置。
      这在判断存储在<code class="structname">pg_depend</code>目录中的一个对象的身份有用。
  </p><p>   <code class="function">pg_identify_object</code>返回一行，
      其中包含足够的信息来唯一地标识数据库对象，
      该数据库对象由目录 OID、对象 OID 和一个（可能为零）子对象 ID 指定。
      这个信息是机器可读的，并且永远不会被翻译。<em class="parameter"><code>type</code></em>标识数据库对象的类型；
      <em class="parameter"><code>schema</code></em>是对象所属的模式的名称，
      如果对象类型不属于模式则为<code class="literal">NULL</code>；
      <em class="parameter"><code>name</code></em>是对象的名称，必要时要加上引号，
      只在能被用作对象的唯一标识符时出现（和模式名称一起，如果相关），
      否则为<code class="literal">NULL</code>；<em class="parameter"><code>identity</code></em>是完整的对象身份，
      确切格式取决于对象类型，并且格式中的每一部分都是模式限定的并且按照需要被加上了引号。
  </p><p>   <code class="function">pg_identify_object_as_address</code>返回一行，
   其中包含足够的信息来唯一地标识数据库对象，
   该数据库对象由目录 OID、对象 OID 和一个（可能为零）子对象 ID 指定。
   返回的信息是独立于当前服务器的，也就是说，
   它可以用于标识另一个服务器中同一个命名对象。
   <em class="parameter"><code>type</code></em>标识数据库对象的类型；
   <em class="parameter"><code>name</code></em>和<em class="parameter"><code>args</code></em>是形成对象引用的文本数组。 
   传递三列到<code class="function">pg_get_object_address</code>获取对象的外部地址。
   这个函数是<code class="function">pg_get_object_address</code>的逆函数。
  </p><p>   <code class="function">pg_get_object_address</code>返回行，
   包含足够信息来唯一地标识数据库对象，该数据库对象由类型和对象名称以及参数数组指定。
   返回值是在系统目录中使用的比如<code class="structname">pg_depend</code>，并且可以传递给其它系统函数
   比如<code class="function">pg_identify_object</code>或者<code class="function">pg_describe_object</code>。
   <em class="parameter"><code>catalog_id</code></em>是包含对象的系统目录OID； 
   <em class="parameter"><code>object_id</code></em>是对象本身的OID，<em class="parameter"><code>object_sub_id</code></em>是对象的子ID，
   如果没有则为零。这个函数是<code class="function">pg_identify_object_as_address</code>的逆函数。
  </p><a id="idp15326880" class="indexterm"></a><a id="idp15327568" class="indexterm"></a><a id="idp15328256" class="indexterm"></a><a id="idp15328944" class="indexterm"></a><p>    <a class="xref" href="functions-info.html#FUNCTIONS-INFO-COMMENT-TABLE" title="表 9.68. 注释信息函数">表 9.68</a>中展示的函数抽取注释，注释是由<a class="xref" href="sql-comment.html" title="COMMENT"><span class="refentrytitle">COMMENT</span></a>命令在以前存储的。如果对指定参数找不到注释，则返回空值。
   </p><div class="table" id="FUNCTIONS-INFO-COMMENT-TABLE"><p class="title"><strong>表 9.68. 注释信息函数</strong></p><div class="table-contents"><table class="table" summary="注释信息函数" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>返回类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="literal"><code class="function">col_description(<em class="parameter"><code>table_oid</code></em>, <em class="parameter"><code>column_number</code></em>)</code></code></td><td><code class="type">text</code></td><td>为一个表列获得注释</td></tr><tr><td><code class="literal"><code class="function">obj_description(<em class="parameter"><code>object_oid</code></em>, <em class="parameter"><code>catalog_name</code></em>)</code></code></td><td><code class="type">text</code></td><td>为一个数据库对象获得注释</td></tr><tr><td><code class="literal"><code class="function">obj_description(<em class="parameter"><code>object_oid</code></em>)</code></code></td><td><code class="type">text</code></td><td>为一个数据库对象获得注释（<span class="emphasis"><em>已被废弃</em></span>）</td></tr><tr><td><code class="literal"><code class="function">shobj_description(<em class="parameter"><code>object_oid</code></em>, <em class="parameter"><code>catalog_name</code></em>)</code></code></td><td><code class="type">text</code></td><td>为一个共享数据库对象获得注释</td></tr></tbody></table></div></div><br class="table-break" /><p>    <code class="function">col_description</code>为一个表列返回注释，该表列由所在表的 OID 和它的列号指定（<code class="function">obj_description</code>不能被用在表列，因为表列没有自己的 OID）。
   </p><p>    <code class="function">obj_description</code>的双参数形式返回一个由其 OID 和所在系统目录名称指定的数据库对象的注释。例如，<code class="literal">obj_description(123456,'pg_class')</code>将会检索出 OID 为123456的表的注释。<code class="function">obj_description</code>的单参数形式只要求对象 OID。它已经被废弃，因为无法保证 OID 在不同系统目录之间是唯一的；这样可能会返回错误的注释。
   </p><p>    <code class="function">shobj_description</code>用起来就像<code class="function">obj_description</code>，但是前者是用于检索共享对象上的注释。某些系统目录对于一个集簇中的所有数据库是全局的，并且其中的对象的描述也是全局存储的。
   </p><a id="idp15354080" class="indexterm"></a><a id="idp15354768" class="indexterm"></a><a id="idp15355472" class="indexterm"></a><a id="idp15356160" class="indexterm"></a><a id="idp15356848" class="indexterm"></a><a id="idp15357536" class="indexterm"></a><a id="idp15358224" class="indexterm"></a><a id="idp15358928" class="indexterm"></a><p>    <a class="xref" href="functions-info.html#FUNCTIONS-TXID-SNAPSHOT" title="表 9.69. 事务 ID 和快照">表 9.69</a>中展示的函数以一种可导出的形式提供了服务器事务信息。这些函数的主要用途是判断在两个快照之间哪些事务被提交。
   </p><div class="table" id="FUNCTIONS-TXID-SNAPSHOT"><p class="title"><strong>表 9.69. 事务 ID 和快照</strong></p><div class="table-contents"><table class="table" summary="事务 ID 和快照" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>返回类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="literal"><code class="function">txid_current()</code></code></td><td><code class="type">bigint</code></td><td>获得当前事务ID，如果当前事务没有则分配一个新的</td></tr><tr><td><code class="literal"><code class="function">txid_current_if_assigned()</code></code></td><td><code class="type">bigint</code></td><td>和<code class="function">txid_current()</code>相同，但如果没有分配一个新的事务ID，则返回null而不是分配新的事务ID</td></tr><tr><td><code class="literal"><code class="function">txid_current_snapshot()</code></code></td><td><code class="type">txid_snapshot</code></td><td>获得当前快照</td></tr><tr><td><code class="literal"><code class="function">txid_snapshot_xip(<em class="parameter"><code>txid_snapshot</code></em>)</code></code></td><td><code class="type">setof bigint</code></td><td>获得快照中正在进行的事务 ID</td></tr><tr><td><code class="literal"><code class="function">txid_snapshot_xmax(<em class="parameter"><code>txid_snapshot</code></em>)</code></code></td><td><code class="type">bigint</code></td><td>获得快照的<code class="literal">xmax</code></td></tr><tr><td><code class="literal"><code class="function">txid_snapshot_xmin(<em class="parameter"><code>txid_snapshot</code></em>)</code></code></td><td><code class="type">bigint</code></td><td>获得快照的<code class="literal">xmin</code></td></tr><tr><td><code class="literal"><code class="function">txid_visible_in_snapshot(<em class="parameter"><code>bigint</code></em>, <em class="parameter"><code>txid_snapshot</code></em>)</code></code></td><td><code class="type">boolean</code></td><td>事务 ID 在快照中可见吗？（不能用于子事务 ID）</td></tr><tr><td><code class="literal"><code class="function">txid_status(<em class="parameter"><code>bigint</code></em>)</code></code></td><td><code class="type">txid_status</code></td><td>报告给定事务的状态: <code class="literal">committed</code>、<code class="literal">aborted</code>、<code class="literal">in progress</code>
	   或者如果事务ID太老则是null</td></tr></tbody></table></div></div><br class="table-break" /><p>    内部事务 ID 类型（<code class="type">xid</code>）是 32 位宽并且每 40 亿个事务就会回卷。但是，这些函数导出一种 64 位格式，它被使用一个<span class="quote">“<span class="quote">世代</span>”</span>计数器，这样在一个安装的生命期内不会回卷。这些函数使用的数据类型<code class="type">txid_snapshot</code>存储了在一个特定时刻有关事务 ID 可见性的信息。它的成分在<a class="xref" href="functions-info.html#FUNCTIONS-TXID-SNAPSHOT-PARTS" title="表 9.70. 快照成分">表 9.70</a>中描述。
   </p><div class="table" id="FUNCTIONS-TXID-SNAPSHOT-PARTS"><p class="title"><strong>表 9.70. 快照成分</strong></p><div class="table-contents"><table class="table" summary="快照成分" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td><code class="type">xmin</code></td><td>         仍然活动的最早的事务 ID （txid）。所有更早的事务要么已经被提交并且可见，要么已经被回滚并且死亡。
       </td></tr><tr><td><code class="type">xmax</code></td><td>        第一个还未分配的 txid。所有大于等于它的 txid 在快照的时刻还没有开始，并且因此是不可见的。
       </td></tr><tr><td><code class="type">xip_list</code></td><td>        在快照时刻活动的 txid。这个列表只包括那些位于<code class="literal">xmin</code>和<code class="literal">xmax</code>之间的活动 txid；可能有活动的超过<code class="literal">xmax</code>的 txid。一个满足<code class="literal">xmin &lt;= txid &lt; xmax</code>并且不在这个列表中的 txid 在快照时刻已经结束，并且因此根据其提交状态要么可见要么死亡。该列表不包括子事务的 txid。
       </td></tr></tbody></table></div></div><br class="table-break" /><p>    <code class="type">txid_snapshot</code>的文本表示是<code class="literal"><em class="replaceable"><code>xmin</code></em>:<em class="replaceable"><code>xmax</code></em>:<em class="replaceable"><code>xip_list</code></em></code>。例如<code class="literal">10:20:10,14,15</code>表示<code class="literal">xmin=10, xmax=20, xip_list=10, 14, 15</code>。
   </p><p>    <code class="function">txid_status(bigint)</code>报告最近事务的提交状态。
	当<code class="literal">COMMIT</code>正在进行时，
	应用程序可以使用它来确定当应用程序和数据库服务器断开连接时事务是否提交或中止。
	事务的状态将被报告为<code class="literal">in progress</code>、<code class="literal">committed</code>或
	<code class="literal">aborted</code>，只要事务足够近，系统保留了该事务的提交状态。
	如果太老旧以至于在系统中不存在对该事务的引用，并且提交状态信息已被丢弃，
	则该函数将返回NULL。请注意，准备好的事务报告为<code class="literal">in progress</code>；
	如果他们需要确定txid是否为准备好的事务，则应用程序必须检查
	<a class="link" href="view-pg-prepared-xacts.html" title="51.77. pg_prepared_xacts"><code class="literal">pg_prepared_xacts</code></a>。
   </p><p>    在<a class="xref" href="functions-info.html#FUNCTIONS-COMMIT-TIMESTAMP" title="表 9.71. 已提交事务信息">表 9.71</a>中显示的函数
    提供了已提交事务的信息。这些函数主要提供关于事务提交的信息。
    当<a class="xref" href="runtime-config-replication.html#GUC-TRACK-COMMIT-TIMESTAMP">track_commit_timestamp</a>配置选项启用的时候，
    并且只有启用后提交的事务，它们只提供有用的数据。
   </p><div class="table" id="FUNCTIONS-COMMIT-TIMESTAMP"><p class="title"><strong>表 9.71. 已提交事务信息</strong></p><div class="table-contents"><table class="table" summary="已提交事务信息" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>返回类型</th><th>描述</th></tr></thead><tbody><tr><td>        <a id="idp15413696" class="indexterm"></a>
        <code class="literal"><code class="function">pg_xact_commit_timestamp(<em class="parameter"><code>xid</code></em>)</code></code>
       </td><td><code class="type">timestamp with time zone</code></td><td>事务提交的时间戳</td></tr><tr><td>        <a id="idp15417360" class="indexterm"></a>
        <code class="literal"><code class="function">pg_last_committed_xact()</code></code>
       </td><td><em class="parameter"><code>xid</code></em> <code class="type">xid</code>, <em class="parameter"><code>timestamp</code></em> <code class="type">timestamp with time zone</code></td><td>最近提交事务的事务ID以及提交时间戳</td></tr></tbody></table></div></div><br class="table-break" /><p>    <a class="xref" href="functions-info.html#FUNCTIONS-CONTROLDATA" title="表 9.72. Control Data Functions">表 9.72</a>中所展示的函数能打印<code class="command">initdb</code>
    期间初始化的信息，例如系统目录版本。
    它们也能显示有关预写式日志和检查点处理的信息。这些信息是集簇范围内的，
    不与任何特定的一个数据库相关。对于同一种来源，它们返回和
    <a class="xref" href="app-pgcontroldata.html" title="pg_controldata"><span class="refentrytitle"><span class="application">pg_controldata</span></span></a>大致相同的信息，不过其形式更适合于
    <acronym class="acronym">SQL</acronym>函数。 
   </p><div class="table" id="FUNCTIONS-CONTROLDATA"><p class="title"><strong>表 9.72. Control Data Functions</strong></p><div class="table-contents"><table class="table" summary="Control Data Functions" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>返回类型</th><th>描述</th></tr></thead><tbody><tr><td>        <a id="idp15428208" class="indexterm"></a>
        <code class="literal"><code class="function">pg_control_checkpoint()</code></code>
       </td><td><code class="type">record</code></td><td>        返回有关当前检查点状态的信息。
       </td></tr><tr><td>        <a id="idp15431312" class="indexterm"></a>
        <code class="literal"><code class="function">pg_control_system()</code></code>
       </td><td><code class="type">record</code></td><td>        返回有关当前控制文件状态的信息。
       </td></tr><tr><td>        <a id="idp15434416" class="indexterm"></a>
        <code class="literal"><code class="function">pg_control_init()</code></code>
       </td><td><code class="type">record</code></td><td>        返回有关集簇初始化状态的信息。 
       </td></tr><tr><td>        <a id="idp15437520" class="indexterm"></a>
        <code class="literal"><code class="function">pg_control_recovery()</code></code>
       </td><td><code class="type">record</code></td><td>        返回有关恢复状态的信息。
       </td></tr></tbody></table></div></div><br class="table-break" /><p>    <code class="function">pg_control_checkpoint</code>返回一个
    <a class="xref" href="functions-info.html#FUNCTIONS-PG-CONTROL-CHECKPOINT" title="表 9.73. pg_control_checkpoint 列">表 9.73</a>中所示的记录 。
   </p><div class="table" id="FUNCTIONS-PG-CONTROL-CHECKPOINT"><p class="title"><strong>表 9.73. <code class="function">pg_control_checkpoint</code> 列</strong></p><div class="table-contents"><table class="table" summary="pg_control_checkpoint 列" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>列名</th><th>数据类型</th></tr></thead><tbody><tr><td><code class="literal">checkpoint_lsn</code></td><td><code class="type">pg_lsn</code></td></tr><tr><td><code class="literal">prior_lsn</code></td><td><code class="type">pg_lsn</code></td></tr><tr><td><code class="literal">redo_lsn</code></td><td><code class="type">pg_lsn</code></td></tr><tr><td><code class="literal">redo_wal_file</code></td><td><code class="type">text</code></td></tr><tr><td><code class="literal">timeline_id</code></td><td><code class="type">integer</code></td></tr><tr><td><code class="literal">prev_timeline_id</code></td><td><code class="type">integer</code></td></tr><tr><td><code class="literal">full_page_writes</code></td><td><code class="type">boolean</code></td></tr><tr><td><code class="literal">next_xid</code></td><td><code class="type">text</code></td></tr><tr><td><code class="literal">next_oid</code></td><td><code class="type">oid</code></td></tr><tr><td><code class="literal">next_multixact_id</code></td><td><code class="type">xid</code></td></tr><tr><td><code class="literal">next_multi_offset</code></td><td><code class="type">xid</code></td></tr><tr><td><code class="literal">oldest_xid</code></td><td><code class="type">xid</code></td></tr><tr><td><code class="literal">oldest_xid_dbid</code></td><td><code class="type">oid</code></td></tr><tr><td><code class="literal">oldest_active_xid</code></td><td><code class="type">xid</code></td></tr><tr><td><code class="literal">oldest_multi_xid</code></td><td><code class="type">xid</code></td></tr><tr><td><code class="literal">oldest_multi_dbid</code></td><td><code class="type">oid</code></td></tr><tr><td><code class="literal">oldest_commit_ts_xid</code></td><td><code class="type">xid</code></td></tr><tr><td><code class="literal">newest_commit_ts_xid</code></td><td><code class="type">xid</code></td></tr><tr><td><code class="literal">checkpoint_time</code></td><td><code class="type">timestamp with time zone</code></td></tr></tbody></table></div></div><br class="table-break" /><p>    <code class="function">pg_control_system</code>返回一个
    <a class="xref" href="functions-info.html#FUNCTIONS-PG-CONTROL-SYSTEM" title="表 9.74. pg_control_system 列">表 9.74</a>中所示的记录。
   </p><div class="table" id="FUNCTIONS-PG-CONTROL-SYSTEM"><p class="title"><strong>表 9.74. <code class="function">pg_control_system</code> 列</strong></p><div class="table-contents"><table class="table" summary="pg_control_system 列" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>列名</th><th>数据类型</th></tr></thead><tbody><tr><td><code class="literal">pg_control_version</code></td><td><code class="type">integer</code></td></tr><tr><td><code class="literal">catalog_version_no</code></td><td><code class="type">integer</code></td></tr><tr><td><code class="literal">system_identifier</code></td><td><code class="type">bigint</code></td></tr><tr><td><code class="literal">pg_control_last_modified</code></td><td><code class="type">timestamp with time zone</code></td></tr></tbody></table></div></div><br class="table-break" /><p>    <code class="function">pg_control_init</code>返回一个
    <a class="xref" href="functions-info.html#FUNCTIONS-PG-CONTROL-INIT" title="表 9.75. pg_control_init 列">表 9.75</a>中所示的记录。
   </p><div class="table" id="FUNCTIONS-PG-CONTROL-INIT"><p class="title"><strong>表 9.75. <code class="function">pg_control_init</code> 列</strong></p><div class="table-contents"><table class="table" summary="pg_control_init 列" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>列名</th><th>数据类型</th></tr></thead><tbody><tr><td><code class="literal">max_data_alignment</code></td><td><code class="type">integer</code></td></tr><tr><td><code class="literal">database_block_size</code></td><td><code class="type">integer</code></td></tr><tr><td><code class="literal">blocks_per_segment</code></td><td><code class="type">integer</code></td></tr><tr><td><code class="literal">wal_block_size</code></td><td><code class="type">integer</code></td></tr><tr><td><code class="literal">bytes_per_wal_segment</code></td><td><code class="type">integer</code></td></tr><tr><td><code class="literal">max_identifier_length</code></td><td><code class="type">integer</code></td></tr><tr><td><code class="literal">max_index_columns</code></td><td><code class="type">integer</code></td></tr><tr><td><code class="literal">max_toast_chunk_size</code></td><td><code class="type">integer</code></td></tr><tr><td><code class="literal">large_object_chunk_size</code></td><td><code class="type">integer</code></td></tr><tr><td><code class="literal">float4_pass_by_value</code></td><td><code class="type">boolean</code></td></tr><tr><td><code class="literal">float8_pass_by_value</code></td><td><code class="type">boolean</code></td></tr><tr><td><code class="literal">data_page_checksum_version</code></td><td><code class="type">integer</code></td></tr></tbody></table></div></div><br class="table-break" /><p>    <code class="function">pg_control_recovery</code>返回一个
    <a class="xref" href="functions-info.html#FUNCTIONS-PG-CONTROL-RECOVERY" title="表 9.76. pg_control_recovery 列">表 9.76</a>中所示的记录。
   </p><div class="table" id="FUNCTIONS-PG-CONTROL-RECOVERY"><p class="title"><strong>表 9.76. <code class="function">pg_control_recovery</code> 列</strong></p><div class="table-contents"><table class="table" summary="pg_control_recovery 列" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>列名</th><th>数据类型</th></tr></thead><tbody><tr><td><code class="literal">min_recovery_end_lsn</code></td><td><code class="type">pg_lsn</code></td></tr><tr><td><code class="literal">min_recovery_end_timeline</code></td><td><code class="type">integer</code></td></tr><tr><td><code class="literal">backup_start_lsn</code></td><td><code class="type">pg_lsn</code></td></tr><tr><td><code class="literal">backup_end_lsn</code></td><td><code class="type">pg_lsn</code></td></tr><tr><td><code class="literal">end_of_backup_record_required</code></td><td><code class="type">boolean</code></td></tr></tbody></table></div></div><br class="table-break" /></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="functions-srf.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="functions.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="functions-admin.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">9.24. 集合返回函数 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 9.26. 系统管理函数</td></tr></table></div></body></html>
